"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0";
exports.ids = ["vendor-chunks/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0"];
exports.modules = {

/***/ "(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/api-719c8c15.node.react-server.esm.js":
/*!************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/api-719c8c15.node.react-server.esm.js ***!
  \************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   c: () => (/* binding */ component),\n/* harmony export */   i: () => (/* binding */ integer)\n/* harmony export */ });\n/* harmony import */ var _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-b0eee923.node.react-server.esm.js */ \"(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/index-b0eee923.node.react-server.esm.js\");\n/* harmony import */ var _empty_field_ui_5b08ee07_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./empty-field-ui-5b08ee07.node.react-server.esm.js */ \"(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/empty-field-ui-5b08ee07.node.react-server.esm.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(rsc)/../../node_modules/.pnpm/next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var emery__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! emery */ \"(rsc)/../../node_modules/.pnpm/emery@1.4.2/node_modules/emery/dist/emery.cjs.js\");\n/* harmony import */ var _sindresorhus_slugify__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sindresorhus/slugify */ \"(rsc)/../../node_modules/.pnpm/@sindresorhus+slugify@1.1.2/node_modules/@sindresorhus/slugify/index.js\");\n/* harmony import */ var _sindresorhus_slugify__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_sindresorhus_slugify__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _braintree_sanitize_url__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @braintree/sanitize-url */ \"(rsc)/../../node_modules/.pnpm/@braintree+sanitize-url@6.0.4/node_modules/@braintree/sanitize-url/dist/index.js\");\n\n\n\n\n\n\nfunction validateInteger(validation, value, label) {\n    if (value !== null && (typeof value !== \"number\" || !Number.isFinite(value))) {\n        return `${label} is not a valid whole number`;\n    }\n    if (validation !== null && validation !== void 0 && validation.isRequired && value === null) {\n        return `${label} is required`;\n    }\n    if (value !== null) {\n        if ((validation === null || validation === void 0 ? void 0 : validation.min) !== undefined && value < validation.min) {\n            return `${label} must be at least ${validation.min}`;\n        }\n        if ((validation === null || validation === void 0 ? void 0 : validation.max) !== undefined && value > validation.max) {\n            return `${label} must be at most ${validation.max}`;\n        }\n    }\n}\nfunction integer({ label, defaultValue, validation, description }) {\n    return (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__.L)({\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_empty_field_ui_5b08ee07_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.e, {\n                label: label,\n                description: description,\n                validation: validation,\n                ...props\n            });\n        },\n        defaultValue () {\n            return defaultValue !== null && defaultValue !== void 0 ? defaultValue : null;\n        },\n        parse (value) {\n            if (value === undefined) {\n                return null;\n            }\n            if (typeof value === \"number\") {\n                return value;\n            }\n            throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__.J(\"Must be a number\");\n        },\n        validate (value) {\n            const message = validateInteger(validation, value, label);\n            if (message !== undefined) {\n                throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__.J(message);\n            }\n            (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__.M)(value, validation, label);\n            return value;\n        },\n        serialize (value) {\n            return {\n                value: value === null ? undefined : value\n            };\n        }\n    });\n}\n// this is written like this rather than ArrayField<ComponentSchema> to avoid TypeScript erroring about circularity\nfunction component(options) {\n    return options;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BrZXlzdGF0aWMrY29yZUAwLjEuN19uZXh0QDEzLjUuNl9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQGtleXN0YXRpYy9jb3JlL2Rpc3QvYXBpLTcxOWM4YzE1Lm5vZGUucmVhY3Qtc2VydmVyLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQStJO0FBQ25EO0FBQ3BEO0FBQ3pCO0FBQ2dCO0FBQ0U7QUFFakMsU0FBU1MsZ0JBQWdCQyxVQUFVLEVBQUVDLEtBQUssRUFBRUMsS0FBSztJQUMvQyxJQUFJRCxVQUFVLFFBQVMsUUFBT0EsVUFBVSxZQUFZLENBQUNFLE9BQU9DLFFBQVEsQ0FBQ0gsTUFBSyxHQUFJO1FBQzVFLE9BQU8sQ0FBQyxFQUFFQyxNQUFNLDRCQUE0QixDQUFDO0lBQy9DO0lBQ0EsSUFBSUYsZUFBZSxRQUFRQSxlQUFlLEtBQUssS0FBS0EsV0FBV0ssVUFBVSxJQUFJSixVQUFVLE1BQU07UUFDM0YsT0FBTyxDQUFDLEVBQUVDLE1BQU0sWUFBWSxDQUFDO0lBQy9CO0lBQ0EsSUFBSUQsVUFBVSxNQUFNO1FBQ2xCLElBQUksQ0FBQ0QsZUFBZSxRQUFRQSxlQUFlLEtBQUssSUFBSSxLQUFLLElBQUlBLFdBQVdNLEdBQUcsTUFBTUMsYUFBYU4sUUFBUUQsV0FBV00sR0FBRyxFQUFFO1lBQ3BILE9BQU8sQ0FBQyxFQUFFSixNQUFNLGtCQUFrQixFQUFFRixXQUFXTSxHQUFHLENBQUMsQ0FBQztRQUN0RDtRQUNBLElBQUksQ0FBQ04sZUFBZSxRQUFRQSxlQUFlLEtBQUssSUFBSSxLQUFLLElBQUlBLFdBQVdRLEdBQUcsTUFBTUQsYUFBYU4sUUFBUUQsV0FBV1EsR0FBRyxFQUFFO1lBQ3BILE9BQU8sQ0FBQyxFQUFFTixNQUFNLGlCQUFpQixFQUFFRixXQUFXUSxHQUFHLENBQUMsQ0FBQztRQUNyRDtJQUNGO0FBQ0Y7QUFFQSxTQUFTQyxRQUFRLEVBQ2ZQLEtBQUssRUFDTFEsWUFBWSxFQUNaVixVQUFVLEVBQ1ZXLFdBQVcsRUFDWjtJQUNDLE9BQU9wQiwyRUFBbUNBLENBQUM7UUFDekNxQixPQUFNQyxLQUFLO1lBQ1QsT0FBTyxXQUFXLEdBQUVmLHNEQUFHQSxDQUFDRCxnRkFBaUJBLEVBQUU7Z0JBQ3pDSyxPQUFPQTtnQkFDUFMsYUFBYUE7Z0JBQ2JYLFlBQVlBO2dCQUNaLEdBQUdhLEtBQUs7WUFDVjtRQUNGO1FBQ0FIO1lBQ0UsT0FBT0EsaUJBQWlCLFFBQVFBLGlCQUFpQixLQUFLLElBQUlBLGVBQWU7UUFDM0U7UUFDQUksT0FBTWIsS0FBSztZQUNULElBQUlBLFVBQVVNLFdBQVc7Z0JBQ3ZCLE9BQU87WUFDVDtZQUNBLElBQUksT0FBT04sVUFBVSxVQUFVO2dCQUM3QixPQUFPQTtZQUNUO1lBQ0EsTUFBTSxJQUFJUix1RUFBY0EsQ0FBQztRQUMzQjtRQUNBc0IsVUFBU2QsS0FBSztZQUNaLE1BQU1lLFVBQVVqQixnQkFBZ0JDLFlBQVlDLE9BQU9DO1lBQ25ELElBQUljLFlBQVlULFdBQVc7Z0JBQ3pCLE1BQU0sSUFBSWQsdUVBQWNBLENBQUN1QjtZQUMzQjtZQUNBckIsMkVBQWNBLENBQUNNLE9BQU9ELFlBQVlFO1lBQ2xDLE9BQU9EO1FBQ1Q7UUFDQWdCLFdBQVVoQixLQUFLO1lBQ2IsT0FBTztnQkFDTEEsT0FBT0EsVUFBVSxPQUFPTSxZQUFZTjtZQUN0QztRQUNGO0lBQ0Y7QUFDRjtBQUVBLG1IQUFtSDtBQUNuSCxTQUFTaUIsVUFBVUMsT0FBTztJQUN4QixPQUFPQTtBQUNUO0FBRXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va2V5c3RhdGljLXN0YXJ0ZXIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BrZXlzdGF0aWMrY29yZUAwLjEuN19uZXh0QDEzLjUuNl9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQGtleXN0YXRpYy9jb3JlL2Rpc3QvYXBpLTcxOWM4YzE1Lm5vZGUucmVhY3Qtc2VydmVyLmVzbS5qcz81OGMxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEwgYXMgYmFzaWNGb3JtRmllbGRXaXRoU2ltcGxlUmVhZGVyUGFyc2UsIEogYXMgRmllbGREYXRhRXJyb3IsIE0gYXMgYXNzZXJ0UmVxdWlyZWQgfSBmcm9tICcuL2luZGV4LWIwZWVlOTIzLm5vZGUucmVhY3Qtc2VydmVyLmVzbS5qcyc7XG5pbXBvcnQgeyBlIGFzIEludGVnZXJGaWVsZElucHV0IH0gZnJvbSAnLi9lbXB0eS1maWVsZC11aS01YjA4ZWUwNy5ub2RlLnJlYWN0LXNlcnZlci5lc20uanMnO1xuaW1wb3J0IHsganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0ICdlbWVyeSc7XG5pbXBvcnQgJ0BzaW5kcmVzb3JodXMvc2x1Z2lmeSc7XG5pbXBvcnQgJ0BicmFpbnRyZWUvc2FuaXRpemUtdXJsJztcblxuZnVuY3Rpb24gdmFsaWRhdGVJbnRlZ2VyKHZhbGlkYXRpb24sIHZhbHVlLCBsYWJlbCkge1xuICBpZiAodmFsdWUgIT09IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpKSB7XG4gICAgcmV0dXJuIGAke2xhYmVsfSBpcyBub3QgYSB2YWxpZCB3aG9sZSBudW1iZXJgO1xuICB9XG4gIGlmICh2YWxpZGF0aW9uICE9PSBudWxsICYmIHZhbGlkYXRpb24gIT09IHZvaWQgMCAmJiB2YWxpZGF0aW9uLmlzUmVxdWlyZWQgJiYgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gYCR7bGFiZWx9IGlzIHJlcXVpcmVkYDtcbiAgfVxuICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICBpZiAoKHZhbGlkYXRpb24gPT09IG51bGwgfHwgdmFsaWRhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsaWRhdGlvbi5taW4pICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPCB2YWxpZGF0aW9uLm1pbikge1xuICAgICAgcmV0dXJuIGAke2xhYmVsfSBtdXN0IGJlIGF0IGxlYXN0ICR7dmFsaWRhdGlvbi5taW59YDtcbiAgICB9XG4gICAgaWYgKCh2YWxpZGF0aW9uID09PSBudWxsIHx8IHZhbGlkYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbGlkYXRpb24ubWF4KSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlID4gdmFsaWRhdGlvbi5tYXgpIHtcbiAgICAgIHJldHVybiBgJHtsYWJlbH0gbXVzdCBiZSBhdCBtb3N0ICR7dmFsaWRhdGlvbi5tYXh9YDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZWdlcih7XG4gIGxhYmVsLFxuICBkZWZhdWx0VmFsdWUsXG4gIHZhbGlkYXRpb24sXG4gIGRlc2NyaXB0aW9uXG59KSB7XG4gIHJldHVybiBiYXNpY0Zvcm1GaWVsZFdpdGhTaW1wbGVSZWFkZXJQYXJzZSh7XG4gICAgSW5wdXQocHJvcHMpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovanN4KEludGVnZXJGaWVsZElucHV0LCB7XG4gICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgICAgICB2YWxpZGF0aW9uOiB2YWxpZGF0aW9uLFxuICAgICAgICAuLi5wcm9wc1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlICE9PSBudWxsICYmIGRlZmF1bHRWYWx1ZSAhPT0gdm9pZCAwID8gZGVmYXVsdFZhbHVlIDogbnVsbDtcbiAgICB9LFxuICAgIHBhcnNlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBGaWVsZERhdGFFcnJvcignTXVzdCBiZSBhIG51bWJlcicpO1xuICAgIH0sXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSB2YWxpZGF0ZUludGVnZXIodmFsaWRhdGlvbiwgdmFsdWUsIGxhYmVsKTtcbiAgICAgIGlmIChtZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpZWxkRGF0YUVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0UmVxdWlyZWQodmFsdWUsIHZhbGlkYXRpb24sIGxhYmVsKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlID09PSBudWxsID8gdW5kZWZpbmVkIDogdmFsdWVcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn1cblxuLy8gdGhpcyBpcyB3cml0dGVuIGxpa2UgdGhpcyByYXRoZXIgdGhhbiBBcnJheUZpZWxkPENvbXBvbmVudFNjaGVtYT4gdG8gYXZvaWQgVHlwZVNjcmlwdCBlcnJvcmluZyBhYm91dCBjaXJjdWxhcml0eVxuZnVuY3Rpb24gY29tcG9uZW50KG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmV4cG9ydCB7IGNvbXBvbmVudCBhcyBjLCBpbnRlZ2VyIGFzIGkgfTtcbiJdLCJuYW1lcyI6WyJMIiwiYmFzaWNGb3JtRmllbGRXaXRoU2ltcGxlUmVhZGVyUGFyc2UiLCJKIiwiRmllbGREYXRhRXJyb3IiLCJNIiwiYXNzZXJ0UmVxdWlyZWQiLCJlIiwiSW50ZWdlckZpZWxkSW5wdXQiLCJqc3giLCJ2YWxpZGF0ZUludGVnZXIiLCJ2YWxpZGF0aW9uIiwidmFsdWUiLCJsYWJlbCIsIk51bWJlciIsImlzRmluaXRlIiwiaXNSZXF1aXJlZCIsIm1pbiIsInVuZGVmaW5lZCIsIm1heCIsImludGVnZXIiLCJkZWZhdWx0VmFsdWUiLCJkZXNjcmlwdGlvbiIsIklucHV0IiwicHJvcHMiLCJwYXJzZSIsInZhbGlkYXRlIiwibWVzc2FnZSIsInNlcmlhbGl6ZSIsImNvbXBvbmVudCIsIm9wdGlvbnMiLCJjIiwiaSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/api-719c8c15.node.react-server.esm.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/empty-field-ui-5b08ee07.node.react-server.esm.js":
/*!***********************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/empty-field-ui-5b08ee07.node.react-server.esm.js ***!
  \***********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   B: () => (/* binding */ BlocksFieldInput),\n/* harmony export */   C: () => (/* binding */ CheckboxFieldInput),\n/* harmony export */   D: () => (/* binding */ DocumentFieldInput),\n/* harmony export */   F: () => (/* binding */ FileFieldInput),\n/* harmony export */   I: () => (/* binding */ ImageFieldInput),\n/* harmony export */   M: () => (/* binding */ MultiselectFieldInput),\n/* harmony export */   P: () => (/* binding */ PathReferenceInput),\n/* harmony export */   R: () => (/* binding */ RelationshipInput),\n/* harmony export */   S: () => (/* binding */ SelectFieldInput),\n/* harmony export */   T: () => (/* binding */ TextFieldInput),\n/* harmony export */   U: () => (/* binding */ UrlFieldInput),\n/* harmony export */   a: () => (/* binding */ DateFieldInput),\n/* harmony export */   b: () => (/* binding */ DatetimeFieldInput),\n/* harmony export */   c: () => (/* binding */ SlugFieldInput),\n/* harmony export */   d: () => (/* binding */ CloudImageFieldInput),\n/* harmony export */   e: () => (/* binding */ IntegerFieldInput),\n/* harmony export */   f: () => (/* binding */ createEditorSchema),\n/* harmony export */   g: () => (/* binding */ getDefaultValue),\n/* harmony export */   p: () => (/* binding */ parseToEditorState),\n/* harmony export */   s: () => (/* binding */ serializeFromEditorState)\n/* harmony export */ });\n// this is used in react-server environments to avoid bundling UI when the reader API is used\n// if you added a new field and get an error that there's missing a missing export here,\n// you probably just need to add another empty export here\nfunction empty() {\n    throw new Error(\"unexpected call to function that shouldn't be called in React server component environment\");\n}\nlet SlugFieldInput = empty, TextFieldInput = empty, UrlFieldInput = empty, SelectFieldInput = empty, RelationshipInput = empty, PathReferenceInput = empty, MultiselectFieldInput = empty, IntegerFieldInput = empty, ImageFieldInput = empty, FileFieldInput = empty, DatetimeFieldInput = empty, DateFieldInput = empty, CloudImageFieldInput = empty, BlocksFieldInput = empty, DocumentFieldInput = empty, CheckboxFieldInput = empty, createEditorSchema = empty, getDefaultValue = empty, parseToEditorState = empty, serializeFromEditorState = empty;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BrZXlzdGF0aWMrY29yZUAwLjEuN19uZXh0QDEzLjUuNl9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQGtleXN0YXRpYy9jb3JlL2Rpc3QvZW1wdHktZmllbGQtdWktNWIwOGVlMDcubm9kZS5yZWFjdC1zZXJ2ZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNkZBQTZGO0FBQzdGLHdGQUF3RjtBQUN4RiwwREFBMEQ7QUFFMUQsU0FBU0E7SUFDUCxNQUFNLElBQUlDLE1BQU07QUFDbEI7QUFDQSxJQUFJQyxpQkFBaUJGLE9BQ25CRyxpQkFBaUJILE9BQ2pCSSxnQkFBZ0JKLE9BQ2hCSyxtQkFBbUJMLE9BQ25CTSxvQkFBb0JOLE9BQ3BCTyxxQkFBcUJQLE9BQ3JCUSx3QkFBd0JSLE9BQ3hCUyxvQkFBb0JULE9BQ3BCVSxrQkFBa0JWLE9BQ2xCVyxpQkFBaUJYLE9BQ2pCWSxxQkFBcUJaLE9BQ3JCYSxpQkFBaUJiLE9BQ2pCYyx1QkFBdUJkLE9BQ3ZCZSxtQkFBbUJmLE9BQ25CZ0IscUJBQXFCaEIsT0FDckJpQixxQkFBcUJqQixPQUNyQmtCLHFCQUFxQmxCLE9BQ3JCbUIsa0JBQWtCbkIsT0FDbEJvQixxQkFBcUJwQixPQUNyQnFCLDJCQUEyQnJCO0FBRTJjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va2V5c3RhdGljLXN0YXJ0ZXIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BrZXlzdGF0aWMrY29yZUAwLjEuN19uZXh0QDEzLjUuNl9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQGtleXN0YXRpYy9jb3JlL2Rpc3QvZW1wdHktZmllbGQtdWktNWIwOGVlMDcubm9kZS5yZWFjdC1zZXJ2ZXIuZXNtLmpzPzA5ZjciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdGhpcyBpcyB1c2VkIGluIHJlYWN0LXNlcnZlciBlbnZpcm9ubWVudHMgdG8gYXZvaWQgYnVuZGxpbmcgVUkgd2hlbiB0aGUgcmVhZGVyIEFQSSBpcyB1c2VkXG4vLyBpZiB5b3UgYWRkZWQgYSBuZXcgZmllbGQgYW5kIGdldCBhbiBlcnJvciB0aGF0IHRoZXJlJ3MgbWlzc2luZyBhIG1pc3NpbmcgZXhwb3J0IGhlcmUsXG4vLyB5b3UgcHJvYmFibHkganVzdCBuZWVkIHRvIGFkZCBhbm90aGVyIGVtcHR5IGV4cG9ydCBoZXJlXG5cbmZ1bmN0aW9uIGVtcHR5KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIGNhbGwgdG8gZnVuY3Rpb24gdGhhdCBzaG91bGRuJ3QgYmUgY2FsbGVkIGluIFJlYWN0IHNlcnZlciBjb21wb25lbnQgZW52aXJvbm1lbnRcIik7XG59XG5sZXQgU2x1Z0ZpZWxkSW5wdXQgPSBlbXB0eSxcbiAgVGV4dEZpZWxkSW5wdXQgPSBlbXB0eSxcbiAgVXJsRmllbGRJbnB1dCA9IGVtcHR5LFxuICBTZWxlY3RGaWVsZElucHV0ID0gZW1wdHksXG4gIFJlbGF0aW9uc2hpcElucHV0ID0gZW1wdHksXG4gIFBhdGhSZWZlcmVuY2VJbnB1dCA9IGVtcHR5LFxuICBNdWx0aXNlbGVjdEZpZWxkSW5wdXQgPSBlbXB0eSxcbiAgSW50ZWdlckZpZWxkSW5wdXQgPSBlbXB0eSxcbiAgSW1hZ2VGaWVsZElucHV0ID0gZW1wdHksXG4gIEZpbGVGaWVsZElucHV0ID0gZW1wdHksXG4gIERhdGV0aW1lRmllbGRJbnB1dCA9IGVtcHR5LFxuICBEYXRlRmllbGRJbnB1dCA9IGVtcHR5LFxuICBDbG91ZEltYWdlRmllbGRJbnB1dCA9IGVtcHR5LFxuICBCbG9ja3NGaWVsZElucHV0ID0gZW1wdHksXG4gIERvY3VtZW50RmllbGRJbnB1dCA9IGVtcHR5LFxuICBDaGVja2JveEZpZWxkSW5wdXQgPSBlbXB0eSxcbiAgY3JlYXRlRWRpdG9yU2NoZW1hID0gZW1wdHksXG4gIGdldERlZmF1bHRWYWx1ZSA9IGVtcHR5LFxuICBwYXJzZVRvRWRpdG9yU3RhdGUgPSBlbXB0eSxcbiAgc2VyaWFsaXplRnJvbUVkaXRvclN0YXRlID0gZW1wdHk7XG5cbmV4cG9ydCB7IEJsb2Nrc0ZpZWxkSW5wdXQgYXMgQiwgQ2hlY2tib3hGaWVsZElucHV0IGFzIEMsIERvY3VtZW50RmllbGRJbnB1dCBhcyBELCBGaWxlRmllbGRJbnB1dCBhcyBGLCBJbWFnZUZpZWxkSW5wdXQgYXMgSSwgTXVsdGlzZWxlY3RGaWVsZElucHV0IGFzIE0sIFBhdGhSZWZlcmVuY2VJbnB1dCBhcyBQLCBSZWxhdGlvbnNoaXBJbnB1dCBhcyBSLCBTZWxlY3RGaWVsZElucHV0IGFzIFMsIFRleHRGaWVsZElucHV0IGFzIFQsIFVybEZpZWxkSW5wdXQgYXMgVSwgRGF0ZUZpZWxkSW5wdXQgYXMgYSwgRGF0ZXRpbWVGaWVsZElucHV0IGFzIGIsIFNsdWdGaWVsZElucHV0IGFzIGMsIENsb3VkSW1hZ2VGaWVsZElucHV0IGFzIGQsIEludGVnZXJGaWVsZElucHV0IGFzIGUsIGNyZWF0ZUVkaXRvclNjaGVtYSBhcyBmLCBnZXREZWZhdWx0VmFsdWUgYXMgZywgcGFyc2VUb0VkaXRvclN0YXRlIGFzIHAsIHNlcmlhbGl6ZUZyb21FZGl0b3JTdGF0ZSBhcyBzIH07XG4iXSwibmFtZXMiOlsiZW1wdHkiLCJFcnJvciIsIlNsdWdGaWVsZElucHV0IiwiVGV4dEZpZWxkSW5wdXQiLCJVcmxGaWVsZElucHV0IiwiU2VsZWN0RmllbGRJbnB1dCIsIlJlbGF0aW9uc2hpcElucHV0IiwiUGF0aFJlZmVyZW5jZUlucHV0IiwiTXVsdGlzZWxlY3RGaWVsZElucHV0IiwiSW50ZWdlckZpZWxkSW5wdXQiLCJJbWFnZUZpZWxkSW5wdXQiLCJGaWxlRmllbGRJbnB1dCIsIkRhdGV0aW1lRmllbGRJbnB1dCIsIkRhdGVGaWVsZElucHV0IiwiQ2xvdWRJbWFnZUZpZWxkSW5wdXQiLCJCbG9ja3NGaWVsZElucHV0IiwiRG9jdW1lbnRGaWVsZElucHV0IiwiQ2hlY2tib3hGaWVsZElucHV0IiwiY3JlYXRlRWRpdG9yU2NoZW1hIiwiZ2V0RGVmYXVsdFZhbHVlIiwicGFyc2VUb0VkaXRvclN0YXRlIiwic2VyaWFsaXplRnJvbUVkaXRvclN0YXRlIiwiQiIsIkMiLCJEIiwiRiIsIkkiLCJNIiwiUCIsIlIiLCJTIiwiVCIsIlUiLCJhIiwiYiIsImMiLCJkIiwiZSIsImYiLCJnIiwicCIsInMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/empty-field-ui-5b08ee07.node.react-server.esm.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/generic-ddb9bd13.node.react-server.esm.js":
/*!****************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/generic-ddb9bd13.node.react-server.esm.js ***!
  \****************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ cache),\n/* harmony export */   c: () => (/* binding */ collectionReader),\n/* harmony export */   s: () => (/* binding */ singletonReader)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(rsc)/../../node_modules/.pnpm/next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-b0eee923.node.react-server.esm.js */ \"(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/index-b0eee923.node.react-server.esm.js\");\n/* harmony import */ var _sindresorhus_slugify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sindresorhus/slugify */ \"(rsc)/../../node_modules/.pnpm/@sindresorhus+slugify@1.1.2/node_modules/@sindresorhus/slugify/index.js\");\n/* harmony import */ var _sindresorhus_slugify__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_sindresorhus_slugify__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _braintree_sanitize_url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @braintree/sanitize-url */ \"(rsc)/../../node_modules/.pnpm/@braintree+sanitize-url@6.0.4/node_modules/@braintree/sanitize-url/dist/index.js\");\n/* harmony import */ var _required_files_58b1ab35_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./required-files-58b1ab35.node.react-server.esm.js */ \"(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/required-files-58b1ab35.node.react-server.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ \"(rsc)/../../node_modules/.pnpm/next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_5__);\n\n\n\n\n\n\nfunction cache$1(func) {\n    return func;\n}\n// we conditionally using it since it's not actually in stable react releases yet\n// (though it should be unnecessary since this file is only imported in react-server environments anyway)\n// it's a function because some tools try to be smart with accessing things on namespace imports\n// and error at build time if you try to read an export that doesn't exist on a namespace object\nfunction getCache(react) {\n    var _react$cache;\n    return (_react$cache = react.cache) !== null && _react$cache !== void 0 ? _react$cache : cache$1;\n}\nconst cache = getCache(react__WEBPACK_IMPORTED_MODULE_5__);\nasync function getAllEntries(parent, fsReader) {\n    return (await Promise.all((await fsReader.readdir(parent)).map(async (dirent)=>{\n        const name = `${parent}${dirent.name}`;\n        const entry = {\n            entry: dirent,\n            name\n        };\n        if (dirent.kind === \"directory\") {\n            return [\n                entry,\n                ...await getAllEntries(`${name}/`, fsReader)\n            ];\n        }\n        return entry;\n    }))).flat();\n}\nconst listCollection = cache(async function listCollection(collectionPath, glob, formatInfo, extension, fsReader) {\n    const entries = glob === \"*\" ? (await fsReader.readdir(collectionPath)).map((entry)=>({\n            entry,\n            name: entry.name\n        })) : (await getAllEntries(`${collectionPath}/`, fsReader)).map((x)=>({\n            entry: x.entry,\n            name: x.name.slice(collectionPath.length + 1)\n        }));\n    return (await Promise.all(entries.map(async (x)=>{\n        if (formatInfo.dataLocation === \"index\") {\n            if (x.entry.kind !== \"directory\") return [];\n            if (!await fsReader.fileExists((0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.o)(`${collectionPath}/${x.name}`, formatInfo))) {\n                return [];\n            }\n            return [\n                x.name\n            ];\n        } else {\n            if (x.entry.kind !== \"file\" || !x.name.endsWith(extension)) {\n                return [];\n            }\n            return [\n                x.name.slice(0, -extension.length)\n            ];\n        }\n    }))).flat();\n});\nfunction collectionReader(collection, config, fsReader) {\n    const formatInfo = (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.B)(config, collection);\n    const collectionPath = (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.h)(config, collection);\n    const collectionConfig = config.collections[collection];\n    const schema = (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.q)(collectionConfig.schema);\n    const glob = (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.A)(config, collection);\n    const extension = (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.D)(formatInfo);\n    const read = (slug, ...args)=>{\n        var _args$;\n        return readItem(schema, formatInfo, (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.C)(config, collection, slug), (_args$ = args[0]) === null || _args$ === void 0 ? void 0 : _args$.resolveLinkedFiles, `\"${slug}\" in collection \"${collection}\"`, fsReader, slug, collectionConfig.slugField, glob);\n    };\n    const list = ()=>listCollection(collectionPath, glob, formatInfo, extension, fsReader);\n    return {\n        read,\n        readOrThrow: async (...args)=>{\n            const entry = await read(...args);\n            if (entry === null) {\n                throw new Error(`Entry \"${args[0]}\" not found in collection \"${collection}\"`);\n            }\n            return entry;\n        },\n        // TODO: this could drop the fs.stat call that list does for each item\n        // since we just immediately read it\n        all: async (...args)=>{\n            const slugs = await list();\n            return (await Promise.all(slugs.map(async (slug)=>{\n                const entry = await read(slug, args[0]);\n                if (entry === null) return [];\n                return [\n                    {\n                        slug,\n                        entry\n                    }\n                ];\n            }))).flat();\n        },\n        list\n    };\n}\nconst readItem = cache(async function readItem(rootSchema, formatInfo, itemDir, resolveLinkedFiles, debugReference, fsReader, ...slugInfo) {\n    const dataFile = await fsReader.readFile((0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.o)(itemDir, formatInfo));\n    if (dataFile === null) return null;\n    const { loaded, extraFakeFile } = (0,_required_files_58b1ab35_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_4__.l)(dataFile, formatInfo);\n    const contentFieldPathsToEagerlyResolve = resolveLinkedFiles ? [] : undefined;\n    let validated;\n    try {\n        validated = (0,_required_files_58b1ab35_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_4__.p)(rootSchema, loaded, [], [], (schema, value, path, pathWithArrayFieldSlugs)=>{\n            if (schema.formKind === \"asset\") {\n                return schema.reader.parse(value);\n            }\n            if (schema.formKind === \"content\") {\n                contentFieldPathsToEagerlyResolve === null || contentFieldPathsToEagerlyResolve === void 0 || contentFieldPathsToEagerlyResolve.push(path);\n                return async ()=>{\n                    let content;\n                    const filename = pathWithArrayFieldSlugs.join(\"/\") + schema.contentExtension;\n                    if (filename === (extraFakeFile === null || extraFakeFile === void 0 ? void 0 : extraFakeFile.path)) {\n                        content = extraFakeFile.contents;\n                    } else {\n                        var _await$fsReader$readF;\n                        content = (_await$fsReader$readF = await fsReader.readFile(`${itemDir}/${filename}`)) !== null && _await$fsReader$readF !== void 0 ? _await$fsReader$readF : undefined;\n                    }\n                    return schema.reader.parse(value, {\n                        content\n                    });\n                };\n            }\n            if (path.length === 1 && slugInfo[0] !== undefined) {\n                const [slug, slugField, glob] = slugInfo;\n                if (path[0] === slugField) {\n                    if (schema.formKind !== \"slug\") {\n                        throw new Error(`Slug field ${slugInfo[1]} is not a slug field`);\n                    }\n                    return schema.reader.parseWithSlug(value, {\n                        slug,\n                        glob\n                    });\n                }\n            }\n            return schema.reader.parse(value);\n        }, true);\n        if (contentFieldPathsToEagerlyResolve !== null && contentFieldPathsToEagerlyResolve !== void 0 && contentFieldPathsToEagerlyResolve.length) {\n            await Promise.all(contentFieldPathsToEagerlyResolve.map(async (path)=>{\n                const parentValue = (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.T)(validated, path.slice(0, -1));\n                const keyOnParent = path[path.length - 1];\n                const originalValue = parentValue[keyOnParent];\n                parentValue[keyOnParent] = await originalValue();\n            }));\n        }\n    } catch (err) {\n        const formatted = (0,_required_files_58b1ab35_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_4__.f)(err);\n        throw new Error(`Invalid data for ${debugReference}:\\n${formatted}`);\n    }\n    return validated;\n});\nfunction singletonReader(singleton, config, fsReader) {\n    const formatInfo = (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.I)(config, singleton);\n    const singletonPath = (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(config, singleton);\n    const schema = (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.q)(config.singletons[singleton].schema);\n    const read = (...args)=>{\n        var _args$2;\n        return readItem(schema, formatInfo, singletonPath, (_args$2 = args[0]) === null || _args$2 === void 0 ? void 0 : _args$2.resolveLinkedFiles, `singleton \"${singleton}\"`, fsReader, undefined);\n    };\n    return {\n        read,\n        readOrThrow: async (...opts)=>{\n            const entry = await read(...opts);\n            if (entry === null) {\n                throw new Error(`Singleton \"${singleton}\" not found`);\n            }\n            return entry;\n        }\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BrZXlzdGF0aWMrY29yZUAwLjEuN19uZXh0QDEzLjUuNl9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQGtleXN0YXRpYy9jb3JlL2Rpc3QvZ2VuZXJpYy1kZGI5YmQxMy5ub2RlLnJlYWN0LXNlcnZlci5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQTJCO0FBQ3lSO0FBQ3JSO0FBQ0U7QUFDaUc7QUFDbkc7QUFFL0IsU0FBUzJCLFFBQVFDLElBQUk7SUFDbkIsT0FBT0E7QUFDVDtBQUVBLGlGQUFpRjtBQUNqRix5R0FBeUc7QUFDekcsZ0dBQWdHO0FBQ2hHLGdHQUFnRztBQUNoRyxTQUFTQyxTQUFTQyxLQUFLO0lBQ3JCLElBQUlDO0lBQ0osT0FBTyxDQUFDQSxlQUFlRCxNQUFNRSxLQUFLLE1BQU0sUUFBUUQsaUJBQWlCLEtBQUssSUFBSUEsZUFBZUo7QUFDM0Y7QUFDQSxNQUFNSyxRQUFRSCxTQUFTSCxrQ0FBS0E7QUFFNUIsZUFBZU8sY0FBY0MsTUFBTSxFQUFFQyxRQUFRO0lBQzNDLE9BQU8sQ0FBQyxNQUFNQyxRQUFRQyxHQUFHLENBQUMsQ0FBQyxNQUFNRixTQUFTRyxPQUFPLENBQUNKLE9BQU0sRUFBR0ssR0FBRyxDQUFDLE9BQU1DO1FBQ25FLE1BQU1DLE9BQU8sQ0FBQyxFQUFFUCxPQUFPLEVBQUVNLE9BQU9DLElBQUksQ0FBQyxDQUFDO1FBQ3RDLE1BQU1DLFFBQVE7WUFDWkEsT0FBT0Y7WUFDUEM7UUFDRjtRQUNBLElBQUlELE9BQU9HLElBQUksS0FBSyxhQUFhO1lBQy9CLE9BQU87Z0JBQUNEO21CQUFXLE1BQU1ULGNBQWMsQ0FBQyxFQUFFUSxLQUFLLENBQUMsQ0FBQyxFQUFFTjthQUFXO1FBQ2hFO1FBQ0EsT0FBT087SUFDVCxHQUFFLEVBQUdFLElBQUk7QUFDWDtBQUNBLE1BQU1DLGlCQUFpQmIsTUFBTSxlQUFlYSxlQUFlQyxjQUFj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RSIsInNvdXJjZXMiOlsid2VicGFjazovL2tleXN0YXRpYy1zdGFydGVyLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Aa2V5c3RhdGljK2NvcmVAMC4xLjdfbmV4dEAxMy41LjZfcmVhY3QtZG9tQDE4LjIuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL0BrZXlzdGF0aWMvY29yZS9kaXN0L2dlbmVyaWMtZGRiOWJkMTMubm9kZS5yZWFjdC1zZXJ2ZXIuZXNtLmpzP2E1ZTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgeyBvIGFzIGdldEVudHJ5RGF0YUZpbGVwYXRoLCBUIGFzIGdldFZhbHVlQXRQcm9wUGF0aCwgQiBhcyBnZXRDb2xsZWN0aW9uRm9ybWF0LCBoIGFzIGdldENvbGxlY3Rpb25QYXRoLCBxIGFzIG9iamVjdCwgQSBhcyBnZXRTbHVnR2xvYkZvckNvbGxlY3Rpb24sIEQgYXMgZ2V0RGF0YUZpbGVFeHRlbnNpb24sIEkgYXMgZ2V0U2luZ2xldG9uRm9ybWF0LCBjIGFzIGdldFNpbmdsZXRvblBhdGgsIEMgYXMgZ2V0Q29sbGVjdGlvbkl0ZW1QYXRoIH0gZnJvbSAnLi9pbmRleC1iMGVlZTkyMy5ub2RlLnJlYWN0LXNlcnZlci5lc20uanMnO1xuaW1wb3J0ICdAc2luZHJlc29yaHVzL3NsdWdpZnknO1xuaW1wb3J0ICdAYnJhaW50cmVlL3Nhbml0aXplLXVybCc7XG5pbXBvcnQgeyBsIGFzIGxvYWREYXRhRmlsZSwgcCBhcyBwYXJzZVByb3BzLCBmIGFzIGZvcm1hdEZvcm1EYXRhRXJyb3IgfSBmcm9tICcuL3JlcXVpcmVkLWZpbGVzLTU4YjFhYjM1Lm5vZGUucmVhY3Qtc2VydmVyLmVzbS5qcyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmZ1bmN0aW9uIGNhY2hlJDEoZnVuYykge1xuICByZXR1cm4gZnVuYztcbn1cblxuLy8gd2UgY29uZGl0aW9uYWxseSB1c2luZyBpdCBzaW5jZSBpdCdzIG5vdCBhY3R1YWxseSBpbiBzdGFibGUgcmVhY3QgcmVsZWFzZXMgeWV0XG4vLyAodGhvdWdoIGl0IHNob3VsZCBiZSB1bm5lY2Vzc2FyeSBzaW5jZSB0aGlzIGZpbGUgaXMgb25seSBpbXBvcnRlZCBpbiByZWFjdC1zZXJ2ZXIgZW52aXJvbm1lbnRzIGFueXdheSlcbi8vIGl0J3MgYSBmdW5jdGlvbiBiZWNhdXNlIHNvbWUgdG9vbHMgdHJ5IHRvIGJlIHNtYXJ0IHdpdGggYWNjZXNzaW5nIHRoaW5ncyBvbiBuYW1lc3BhY2UgaW1wb3J0c1xuLy8gYW5kIGVycm9yIGF0IGJ1aWxkIHRpbWUgaWYgeW91IHRyeSB0byByZWFkIGFuIGV4cG9ydCB0aGF0IGRvZXNuJ3QgZXhpc3Qgb24gYSBuYW1lc3BhY2Ugb2JqZWN0XG5mdW5jdGlvbiBnZXRDYWNoZShyZWFjdCkge1xuICB2YXIgX3JlYWN0JGNhY2hlO1xuICByZXR1cm4gKF9yZWFjdCRjYWNoZSA9IHJlYWN0LmNhY2hlKSAhPT0gbnVsbCAmJiBfcmVhY3QkY2FjaGUgIT09IHZvaWQgMCA/IF9yZWFjdCRjYWNoZSA6IGNhY2hlJDE7XG59XG5jb25zdCBjYWNoZSA9IGdldENhY2hlKFJlYWN0KTtcblxuYXN5bmMgZnVuY3Rpb24gZ2V0QWxsRW50cmllcyhwYXJlbnQsIGZzUmVhZGVyKSB7XG4gIHJldHVybiAoYXdhaXQgUHJvbWlzZS5hbGwoKGF3YWl0IGZzUmVhZGVyLnJlYWRkaXIocGFyZW50KSkubWFwKGFzeW5jIGRpcmVudCA9PiB7XG4gICAgY29uc3QgbmFtZSA9IGAke3BhcmVudH0ke2RpcmVudC5uYW1lfWA7XG4gICAgY29uc3QgZW50cnkgPSB7XG4gICAgICBlbnRyeTogZGlyZW50LFxuICAgICAgbmFtZVxuICAgIH07XG4gICAgaWYgKGRpcmVudC5raW5kID09PSAnZGlyZWN0b3J5Jykge1xuICAgICAgcmV0dXJuIFtlbnRyeSwgLi4uKGF3YWl0IGdldEFsbEVudHJpZXMoYCR7bmFtZX0vYCwgZnNSZWFkZXIpKV07XG4gICAgfVxuICAgIHJldHVybiBlbnRyeTtcbiAgfSkpKS5mbGF0KCk7XG59XG5jb25zdCBsaXN0Q29sbGVjdGlvbiA9IGNhY2hlKGFzeW5jIGZ1bmN0aW9uIGxpc3RDb2xsZWN0aW9uKGNvbGxlY3Rpb25QYXRoLCBnbG9iLCBmb3JtYXRJbmZvLCBleHRlbnNpb24sIGZzUmVhZGVyKSB7XG4gIGNvbnN0IGVudHJpZXMgPSBnbG9iID09PSAnKicgPyAoYXdhaXQgZnNSZWFkZXIucmVhZGRpcihjb2xsZWN0aW9uUGF0aCkpLm1hcChlbnRyeSA9PiAoe1xuICAgIGVudHJ5LFxuICAgIG5hbWU6IGVudHJ5Lm5hbWVcbiAgfSkpIDogKGF3YWl0IGdldEFsbEVudHJpZXMoYCR7Y29sbGVjdGlvblBhdGh9L2AsIGZzUmVhZGVyKSkubWFwKHggPT4gKHtcbiAgICBlbnRyeTogeC5lbnRyeSxcbiAgICBuYW1lOiB4Lm5hbWUuc2xpY2UoY29sbGVjdGlvblBhdGgubGVuZ3RoICsgMSlcbiAgfSkpO1xuICByZXR1cm4gKGF3YWl0IFByb21pc2UuYWxsKGVudHJpZXMubWFwKGFzeW5jIHggPT4ge1xuICAgIGlmIChmb3JtYXRJbmZvLmRhdGFMb2NhdGlvbiA9PT0gJ2luZGV4Jykge1xuICAgICAgaWYgKHguZW50cnkua2luZCAhPT0gJ2RpcmVjdG9yeScpIHJldHVybiBbXTtcbiAgICAgIGlmICghKGF3YWl0IGZzUmVhZGVyLmZpbGVFeGlzdHMoZ2V0RW50cnlEYXRhRmlsZXBhdGgoYCR7Y29sbGVjdGlvblBhdGh9LyR7eC5uYW1lfWAsIGZvcm1hdEluZm8pKSkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt4Lm5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoeC5lbnRyeS5raW5kICE9PSAnZmlsZScgfHwgIXgubmFtZS5lbmRzV2l0aChleHRlbnNpb24pKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbeC5uYW1lLnNsaWNlKDAsIC1leHRlbnNpb24ubGVuZ3RoKV07XG4gICAgfVxuICB9KSkpLmZsYXQoKTtcbn0pO1xuZnVuY3Rpb24gY29sbGVjdGlvblJlYWRlcihjb2xsZWN0aW9uLCBjb25maWcsIGZzUmVhZGVyKSB7XG4gIGNvbnN0IGZvcm1hdEluZm8gPSBnZXRDb2xsZWN0aW9uRm9ybWF0KGNvbmZpZywgY29sbGVjdGlvbik7XG4gIGNvbnN0IGNvbGxlY3Rpb25QYXRoID0gZ2V0Q29sbGVjdGlvblBhdGgoY29uZmlnLCBjb2xsZWN0aW9uKTtcbiAgY29uc3QgY29sbGVjdGlvbkNvbmZpZyA9IGNvbmZpZy5jb2xsZWN0aW9uc1tjb2xsZWN0aW9uXTtcbiAgY29uc3Qgc2NoZW1hID0gb2JqZWN0KGNvbGxlY3Rpb25Db25maWcuc2NoZW1hKTtcbiAgY29uc3QgZ2xvYiA9IGdldFNsdWdHbG9iRm9yQ29sbGVjdGlvbihjb25maWcsIGNvbGxlY3Rpb24pO1xuICBjb25zdCBleHRlbnNpb24gPSBnZXREYXRhRmlsZUV4dGVuc2lvbihmb3JtYXRJbmZvKTtcbiAgY29uc3QgcmVhZCA9IChzbHVnLCAuLi5hcmdzKSA9PiB7XG4gICAgdmFyIF9hcmdzJDtcbiAgICByZXR1cm4gcmVhZEl0ZW0oc2NoZW1hLCBmb3JtYXRJbmZvLCBnZXRDb2xsZWN0aW9uSXRlbVBhdGgoY29uZmlnLCBjb2xsZWN0aW9uLCBzbHVnKSwgKF9hcmdzJCA9IGFyZ3NbMF0pID09PSBudWxsIHx8IF9hcmdzJCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FyZ3MkLnJlc29sdmVMaW5rZWRGaWxlcywgYFwiJHtzbHVnfVwiIGluIGNvbGxlY3Rpb24gXCIke2NvbGxlY3Rpb259XCJgLCBmc1JlYWRlciwgc2x1ZywgY29sbGVjdGlvbkNvbmZpZy5zbHVnRmllbGQsIGdsb2IpO1xuICB9O1xuICBjb25zdCBsaXN0ID0gKCkgPT4gbGlzdENvbGxlY3Rpb24oY29sbGVjdGlvblBhdGgsIGdsb2IsIGZvcm1hdEluZm8sIGV4dGVuc2lvbiwgZnNSZWFkZXIpO1xuICByZXR1cm4ge1xuICAgIHJlYWQsXG4gICAgcmVhZE9yVGhyb3c6IGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBlbnRyeSA9IGF3YWl0IHJlYWQoLi4uYXJncyk7XG4gICAgICBpZiAoZW50cnkgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbnRyeSBcIiR7YXJnc1swXX1cIiBub3QgZm91bmQgaW4gY29sbGVjdGlvbiBcIiR7Y29sbGVjdGlvbn1cImApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH0sXG4gICAgLy8gVE9ETzogdGhpcyBjb3VsZCBkcm9wIHRoZSBmcy5zdGF0IGNhbGwgdGhhdCBsaXN0IGRvZXMgZm9yIGVhY2ggaXRlbVxuICAgIC8vIHNpbmNlIHdlIGp1c3QgaW1tZWRpYXRlbHkgcmVhZCBpdFxuICAgIGFsbDogYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IHNsdWdzID0gYXdhaXQgbGlzdCgpO1xuICAgICAgcmV0dXJuIChhd2FpdCBQcm9taXNlLmFsbChzbHVncy5tYXAoYXN5bmMgc2x1ZyA9PiB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gYXdhaXQgcmVhZChzbHVnLCBhcmdzWzBdKTtcbiAgICAgICAgaWYgKGVudHJ5ID09PSBudWxsKSByZXR1cm4gW107XG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgIHNsdWcsXG4gICAgICAgICAgZW50cnlcbiAgICAgICAgfV07XG4gICAgICB9KSkpLmZsYXQoKTtcbiAgICB9LFxuICAgIGxpc3RcbiAgfTtcbn1cbmNvbnN0IHJlYWRJdGVtID0gY2FjaGUoYXN5bmMgZnVuY3Rpb24gcmVhZEl0ZW0ocm9vdFNjaGVtYSwgZm9ybWF0SW5mbywgaXRlbURpciwgcmVzb2x2ZUxpbmtlZEZpbGVzLCBkZWJ1Z1JlZmVyZW5jZSwgZnNSZWFkZXIsIC4uLnNsdWdJbmZvKSB7XG4gIGNvbnN0IGRhdGFGaWxlID0gYXdhaXQgZnNSZWFkZXIucmVhZEZpbGUoZ2V0RW50cnlEYXRhRmlsZXBhdGgoaXRlbURpciwgZm9ybWF0SW5mbykpO1xuICBpZiAoZGF0YUZpbGUgPT09IG51bGwpIHJldHVybiBudWxsO1xuICBjb25zdCB7XG4gICAgbG9hZGVkLFxuICAgIGV4dHJhRmFrZUZpbGVcbiAgfSA9IGxvYWREYXRhRmlsZShkYXRhRmlsZSwgZm9ybWF0SW5mbyk7XG4gIGNvbnN0IGNvbnRlbnRGaWVsZFBhdGhzVG9FYWdlcmx5UmVzb2x2ZSA9IHJlc29sdmVMaW5rZWRGaWxlcyA/IFtdIDogdW5kZWZpbmVkO1xuICBsZXQgdmFsaWRhdGVkO1xuICB0cnkge1xuICAgIHZhbGlkYXRlZCA9IHBhcnNlUHJvcHMocm9vdFNjaGVtYSwgbG9hZGVkLCBbXSwgW10sIChzY2hlbWEsIHZhbHVlLCBwYXRoLCBwYXRoV2l0aEFycmF5RmllbGRTbHVncykgPT4ge1xuICAgICAgaWYgKHNjaGVtYS5mb3JtS2luZCA9PT0gJ2Fzc2V0Jykge1xuICAgICAgICByZXR1cm4gc2NoZW1hLnJlYWRlci5wYXJzZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc2NoZW1hLmZvcm1LaW5kID09PSAnY29udGVudCcpIHtcbiAgICAgICAgY29udGVudEZpZWxkUGF0aHNUb0VhZ2VybHlSZXNvbHZlID09PSBudWxsIHx8IGNvbnRlbnRGaWVsZFBhdGhzVG9FYWdlcmx5UmVzb2x2ZSA9PT0gdm9pZCAwIHx8IGNvbnRlbnRGaWVsZFBhdGhzVG9FYWdlcmx5UmVzb2x2ZS5wdXNoKHBhdGgpO1xuICAgICAgICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGxldCBjb250ZW50O1xuICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gcGF0aFdpdGhBcnJheUZpZWxkU2x1Z3Muam9pbignLycpICsgc2NoZW1hLmNvbnRlbnRFeHRlbnNpb247XG4gICAgICAgICAgaWYgKGZpbGVuYW1lID09PSAoZXh0cmFGYWtlRmlsZSA9PT0gbnVsbCB8fCBleHRyYUZha2VGaWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleHRyYUZha2VGaWxlLnBhdGgpKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gZXh0cmFGYWtlRmlsZS5jb250ZW50cztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIF9hd2FpdCRmc1JlYWRlciRyZWFkRjtcbiAgICAgICAgICAgIGNvbnRlbnQgPSAoX2F3YWl0JGZzUmVhZGVyJHJlYWRGID0gYXdhaXQgZnNSZWFkZXIucmVhZEZpbGUoYCR7aXRlbURpcn0vJHtmaWxlbmFtZX1gKSkgIT09IG51bGwgJiYgX2F3YWl0JGZzUmVhZGVyJHJlYWRGICE9PSB2b2lkIDAgPyBfYXdhaXQkZnNSZWFkZXIkcmVhZEYgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzY2hlbWEucmVhZGVyLnBhcnNlKHZhbHVlLCB7XG4gICAgICAgICAgICBjb250ZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEgJiYgc2x1Z0luZm9bMF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBbc2x1Zywgc2x1Z0ZpZWxkLCBnbG9iXSA9IHNsdWdJbmZvO1xuICAgICAgICBpZiAocGF0aFswXSA9PT0gc2x1Z0ZpZWxkKSB7XG4gICAgICAgICAgaWYgKHNjaGVtYS5mb3JtS2luZCAhPT0gJ3NsdWcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNsdWcgZmllbGQgJHtzbHVnSW5mb1sxXX0gaXMgbm90IGEgc2x1ZyBmaWVsZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2NoZW1hLnJlYWRlci5wYXJzZVdpdGhTbHVnKHZhbHVlLCB7XG4gICAgICAgICAgICBzbHVnLFxuICAgICAgICAgICAgZ2xvYlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NoZW1hLnJlYWRlci5wYXJzZSh2YWx1ZSk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgaWYgKGNvbnRlbnRGaWVsZFBhdGhzVG9FYWdlcmx5UmVzb2x2ZSAhPT0gbnVsbCAmJiBjb250ZW50RmllbGRQYXRoc1RvRWFnZXJseVJlc29sdmUgIT09IHZvaWQgMCAmJiBjb250ZW50RmllbGRQYXRoc1RvRWFnZXJseVJlc29sdmUubGVuZ3RoKSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChjb250ZW50RmllbGRQYXRoc1RvRWFnZXJseVJlc29sdmUubWFwKGFzeW5jIHBhdGggPT4ge1xuICAgICAgICBjb25zdCBwYXJlbnRWYWx1ZSA9IGdldFZhbHVlQXRQcm9wUGF0aCh2YWxpZGF0ZWQsIHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICAgICAgY29uc3Qga2V5T25QYXJlbnQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsVmFsdWUgPSBwYXJlbnRWYWx1ZVtrZXlPblBhcmVudF07XG4gICAgICAgIHBhcmVudFZhbHVlW2tleU9uUGFyZW50XSA9IGF3YWl0IG9yaWdpbmFsVmFsdWUoKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnN0IGZvcm1hdHRlZCA9IGZvcm1hdEZvcm1EYXRhRXJyb3IoZXJyKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGF0YSBmb3IgJHtkZWJ1Z1JlZmVyZW5jZX06XFxuJHtmb3JtYXR0ZWR9YCk7XG4gIH1cbiAgcmV0dXJuIHZhbGlkYXRlZDtcbn0pO1xuZnVuY3Rpb24gc2luZ2xldG9uUmVhZGVyKHNpbmdsZXRvbiwgY29uZmlnLCBmc1JlYWRlcikge1xuICBjb25zdCBmb3JtYXRJbmZvID0gZ2V0U2luZ2xldG9uRm9ybWF0KGNvbmZpZywgc2luZ2xldG9uKTtcbiAgY29uc3Qgc2luZ2xldG9uUGF0aCA9IGdldFNpbmdsZXRvblBhdGgoY29uZmlnLCBzaW5nbGV0b24pO1xuICBjb25zdCBzY2hlbWEgPSBvYmplY3QoY29uZmlnLnNpbmdsZXRvbnNbc2luZ2xldG9uXS5zY2hlbWEpO1xuICBjb25zdCByZWFkID0gKC4uLmFyZ3MpID0+IHtcbiAgICB2YXIgX2FyZ3MkMjtcbiAgICByZXR1cm4gcmVhZEl0ZW0oc2NoZW1hLCBmb3JtYXRJbmZvLCBzaW5nbGV0b25QYXRoLCAoX2FyZ3MkMiA9IGFyZ3NbMF0pID09PSBudWxsIHx8IF9hcmdzJDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hcmdzJDIucmVzb2x2ZUxpbmtlZEZpbGVzLCBgc2luZ2xldG9uIFwiJHtzaW5nbGV0b259XCJgLCBmc1JlYWRlciwgdW5kZWZpbmVkKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICByZWFkLFxuICAgIHJlYWRPclRocm93OiBhc3luYyAoLi4ub3B0cykgPT4ge1xuICAgICAgY29uc3QgZW50cnkgPSBhd2FpdCByZWFkKC4uLm9wdHMpO1xuICAgICAgaWYgKGVudHJ5ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2luZ2xldG9uIFwiJHtzaW5nbGV0b259XCIgbm90IGZvdW5kYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgeyBjYWNoZSBhcyBhLCBjb2xsZWN0aW9uUmVhZGVyIGFzIGMsIHNpbmdsZXRvblJlYWRlciBhcyBzIH07XG4iXSwibmFtZXMiOlsibyIsImdldEVudHJ5RGF0YUZpbGVwYXRoIiwiVCIsImdldFZhbHVlQXRQcm9wUGF0aCIsIkIiLCJnZXRDb2xsZWN0aW9uRm9ybWF0IiwiaCIsImdldENvbGxlY3Rpb25QYXRoIiwicSIsIm9iamVjdCIsIkEiLCJnZXRTbHVnR2xvYkZvckNvbGxlY3Rpb24iLCJEIiwiZ2V0RGF0YUZpbGVFeHRlbnNpb24iLCJJIiwiZ2V0U2luZ2xldG9uRm9ybWF0IiwiYyIsImdldFNpbmdsZXRvblBhdGgiLCJDIiwiZ2V0Q29sbGVjdGlvbkl0ZW1QYXRoIiwibCIsImxvYWREYXRhRmlsZSIsInAiLCJwYXJzZVByb3BzIiwiZiIsImZvcm1hdEZvcm1EYXRhRXJyb3IiLCJSZWFjdCIsImNhY2hlJDEiLCJmdW5jIiwiZ2V0Q2FjaGUiLCJyZWFjdCIsIl9yZWFjdCRjYWNoZSIsImNhY2hlIiwiZ2V0QWxsRW50cmllcyIsInBhcmVudCIsImZzUmVhZGVyIiwiUHJvbWlzZSIsImFsbCIsInJlYWRkaXIiLCJtYXAiLCJkaXJlbnQiLCJuYW1lIiwiZW50cnkiLCJraW5kIiwiZmxhdCIsImxpc3RDb2xsZWN0aW9uIiwiY29sbGVjdGlvblBhdGgiLCJnbG9iIiwiZm9ybWF0SW5mbyIsImV4dGVuc2lvbiIsImVudHJpZXMiLCJ4Iiwic2xpY2UiLCJsZW5ndGgiLCJkYXRhTG9jYXRpb24iLCJmaWxlRXhpc3RzIiwiZW5kc1dpdGgiLCJjb2xsZWN0aW9uUmVhZGVyIiwiY29sbGVjdGlvbiIsImNvbmZpZyIsImNvbGxlY3Rpb25Db25maWciLCJjb2xsZWN0aW9ucyIsInNjaGVtYSIsInJlYWQiLCJzbHVnIiwiYXJncyIsIl9hcmdzJCIsInJlYWRJdGVtIiwicmVzb2x2ZUxpbmtlZEZpbGVzIiwic2x1Z0ZpZWxkIiwibGlzdCIsInJlYWRPclRocm93IiwiRXJyb3IiLCJzbHVncyIsInJvb3RTY2hlbWEiLCJpdGVtRGlyIiwiZGVidWdSZWZlcmVuY2UiLCJzbHVnSW5mbyIsImRhdGFGaWxlIiwicmVhZEZpbGUiLCJsb2FkZWQiLCJleHRyYUZha2VGaWxlIiwiY29udGVudEZpZWxkUGF0aHNUb0VhZ2VybHlSZXNvbHZlIiwidW5kZWZpbmVkIiwidmFsaWRhdGVkIiwidmFsdWUiLCJwYXRoIiwicGF0aFdpdGhBcnJheUZpZWxkU2x1Z3MiLCJmb3JtS2luZCIsInJlYWRlciIsInBhcnNlIiwicHVzaCIsImNvbnRlbnQiLCJmaWxlbmFtZSIsImpvaW4iLCJjb250ZW50RXh0ZW5zaW9uIiwiY29udGVudHMiLCJfYXdhaXQkZnNSZWFkZXIkcmVhZEYiLCJwYXJzZVdpdGhTbHVnIiwicGFyZW50VmFsdWUiLCJrZXlPblBhcmVudCIsIm9yaWdpbmFsVmFsdWUiLCJlcnIiLCJmb3JtYXR0ZWQiLCJzaW5nbGV0b25SZWFkZXIiLCJzaW5nbGV0b24iLCJzaW5nbGV0b25QYXRoIiwic2luZ2xldG9ucyIsIl9hcmdzJDIiLCJvcHRzIiwiYSIsInMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/generic-ddb9bd13.node.react-server.esm.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/index-b0eee923.node.react-server.esm.js":
/*!**************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/index-b0eee923.node.react-server.esm.js ***!
  \**************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ getSlugGlobForCollection),\n/* harmony export */   B: () => (/* binding */ getCollectionFormat),\n/* harmony export */   C: () => (/* binding */ getCollectionItemPath),\n/* harmony export */   D: () => (/* binding */ getDataFileExtension),\n/* harmony export */   E: () => (/* binding */ getRepoUrl),\n/* harmony export */   F: () => (/* binding */ keyedEntries),\n/* harmony export */   G: () => (/* binding */ nodeTypeMatcher),\n/* harmony export */   H: () => (/* binding */ getSplitCloudProject),\n/* harmony export */   I: () => (/* binding */ getSingletonFormat),\n/* harmony export */   J: () => (/* binding */ FieldDataError),\n/* harmony export */   K: () => (/* binding */ KEYSTATIC_CLOUD_API_URL),\n/* harmony export */   L: () => (/* binding */ basicFormFieldWithSimpleReaderParse),\n/* harmony export */   M: () => (/* binding */ assertRequired),\n/* harmony export */   N: () => (/* binding */ getSrcPrefix),\n/* harmony export */   O: () => (/* binding */ fixPath),\n/* harmony export */   P: () => (/* binding */ validateText),\n/* harmony export */   Q: () => (/* binding */ text),\n/* harmony export */   R: () => (/* binding */ document$1),\n/* harmony export */   S: () => (/* binding */ sha1),\n/* harmony export */   T: () => (/* binding */ getValueAtPropPath),\n/* harmony export */   a: () => (/* binding */ KEYSTATIC_CLOUD_HEADERS),\n/* harmony export */   b: () => (/* binding */ getEntriesInCollectionWithTreeKey),\n/* harmony export */   c: () => (/* binding */ getSingletonPath),\n/* harmony export */   d: () => (/* binding */ getTreeNodeAtPath),\n/* harmony export */   e: () => (/* binding */ treeSha),\n/* harmony export */   f: () => (/* binding */ isCloudConfig),\n/* harmony export */   g: () => (/* binding */ getPathPrefix),\n/* harmony export */   h: () => (/* binding */ getCollectionPath),\n/* harmony export */   i: () => (/* binding */ isGitHubConfig),\n/* harmony export */   j: () => (/* binding */ isLocalConfig),\n/* harmony export */   k: () => (/* binding */ getKeysForArrayValue),\n/* harmony export */   l: () => (/* binding */ getSlugFromState),\n/* harmony export */   m: () => (/* binding */ getBranchPrefix),\n/* harmony export */   n: () => (/* binding */ getInitialPropsValue),\n/* harmony export */   o: () => (/* binding */ getEntryDataFilepath),\n/* harmony export */   p: () => (/* binding */ pluralize),\n/* harmony export */   q: () => (/* binding */ object),\n/* harmony export */   r: () => (/* binding */ redirectToCloudAuth),\n/* harmony export */   s: () => (/* binding */ setKeysForArrayValue),\n/* harmony export */   t: () => (/* binding */ treeEntriesToTreeNodes),\n/* harmony export */   u: () => (/* binding */ updateValue),\n/* harmony export */   v: () => (/* binding */ getDirectoriesForTreeKey),\n/* harmony export */   w: () => (/* binding */ getTreeKey),\n/* harmony export */   x: () => (/* binding */ blobSha),\n/* harmony export */   y: () => (/* binding */ updateTreeWithChanges),\n/* harmony export */   z: () => (/* binding */ serializeProps)\n/* harmony export */ });\n/* harmony import */ var _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @markdoc/markdoc */ \"(rsc)/../../node_modules/.pnpm/@markdoc+markdoc@0.3.4_@types+react@18.2.8_react@18.2.0/node_modules/@markdoc/markdoc/dist/index.js\");\n/* harmony import */ var _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! slate */ \"(rsc)/../../node_modules/.pnpm/slate@0.91.4/node_modules/slate/dist/index.js\");\n/* harmony import */ var emery_assertions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! emery/assertions */ \"(rsc)/../../node_modules/.pnpm/emery@1.4.2/node_modules/emery/assertions/dist/emery-assertions.cjs.js\");\n/* harmony import */ var emery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! emery */ \"(rsc)/../../node_modules/.pnpm/emery@1.4.2/node_modules/emery/dist/emery.cjs.js\");\n/* harmony import */ var js_base64__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! js-base64 */ \"(rsc)/../../node_modules/.pnpm/js-base64@3.7.5/node_modules/js-base64/base64.mjs\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _empty_field_ui_5b08ee07_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./empty-field-ui-5b08ee07.node.react-server.esm.js */ \"(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/empty-field-ui-5b08ee07.node.react-server.esm.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ \"(rsc)/../../node_modules/.pnpm/next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _emotion_weak_memoize__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @emotion/weak-memoize */ \"(rsc)/../../node_modules/.pnpm/@emotion+weak-memoize@0.3.1/node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js\");\n\n\n\n\n\n\n\n\n\nfunction fixPath(path) {\n    return path.replace(/^\\.?\\/+/, \"\").replace(/\\/*$/, \"\");\n}\nconst collectionPath = /\\/\\*\\*?(?:$|\\/)/;\nfunction getConfiguredCollectionPath(config, collection) {\n    var _collectionConfig$pat;\n    const collectionConfig = config.collections[collection];\n    const path = (_collectionConfig$pat = collectionConfig.path) !== null && _collectionConfig$pat !== void 0 ? _collectionConfig$pat : `${collection}/*/`;\n    if (!collectionPath.test(path)) {\n        throw new Error(`Collection path must end with /* or /** or include /*/ or /**/ but ${collection} has ${path}`);\n    }\n    return path;\n}\nfunction getCollectionPath(config, collection) {\n    const configuredPath = getConfiguredCollectionPath(config, collection);\n    const path = fixPath(configuredPath.replace(/\\*\\*?.*$/, \"\"));\n    return path;\n}\nfunction getCollectionFormat(config, collection) {\n    var _collectionConfig$for;\n    const collectionConfig = config.collections[collection];\n    return getFormatInfo((_collectionConfig$for = collectionConfig.format) !== null && _collectionConfig$for !== void 0 ? _collectionConfig$for : \"yaml\", collectionConfig.schema, getConfiguredCollectionPath(config, collection));\n}\nfunction getSingletonFormat(config, singleton) {\n    var _singletonConfig$form, _singletonConfig$path;\n    const singletonConfig = config.singletons[singleton];\n    return getFormatInfo((_singletonConfig$form = singletonConfig.format) !== null && _singletonConfig$form !== void 0 ? _singletonConfig$form : \"yaml\", singletonConfig.schema, (_singletonConfig$path = singletonConfig.path) !== null && _singletonConfig$path !== void 0 ? _singletonConfig$path : `${singleton}/`);\n}\nfunction getCollectionItemPath(config, collection, slug) {\n    const basePath = getCollectionPath(config, collection);\n    const suffix = getCollectionItemSlugSuffix(config, collection);\n    return `${basePath}/${slug}${suffix}`;\n}\nfunction getEntryDataFilepath(dir, formatInfo) {\n    return `${dir}${formatInfo.dataLocation === \"index\" ? \"/index\" : \"\"}${getDataFileExtension(formatInfo)}`;\n}\nfunction getSlugGlobForCollection(config, collection) {\n    const collectionPath = getConfiguredCollectionPath(config, collection);\n    return collectionPath.includes(\"**\") ? \"**\" : \"*\";\n}\nfunction getCollectionItemSlugSuffix(config, collection) {\n    const configuredPath = getConfiguredCollectionPath(config, collection);\n    const path = fixPath(configuredPath.replace(/^[^*]+\\*\\*?/, \"\"));\n    return path ? `/${path}` : \"\";\n}\nfunction getSingletonPath(config, singleton) {\n    var _singleton$path, _singleton$path2;\n    if ((_singleton$path = config.singletons[singleton].path) !== null && _singleton$path !== void 0 && _singleton$path.includes(\"*\")) {\n        throw new Error(`Singleton paths cannot include * but ${singleton} has ${config.singletons[singleton].path}`);\n    }\n    return fixPath((_singleton$path2 = config.singletons[singleton].path) !== null && _singleton$path2 !== void 0 ? _singleton$path2 : singleton);\n}\nfunction getDataFileExtension(formatInfo) {\n    return formatInfo.contentField ? formatInfo.contentField.config.contentExtension : \".\" + formatInfo.data;\n}\nfunction getFormatInfo(format, schema, path) {\n    var _format$data;\n    const dataLocation = path.endsWith(\"/\") ? \"index\" : \"outer\";\n    if (typeof format === \"string\") {\n        return {\n            dataLocation,\n            contentField: undefined,\n            data: format\n        };\n    }\n    let contentField;\n    if (format.contentField) {\n        const field = schema[format.contentField];\n        (0,emery__WEBPACK_IMPORTED_MODULE_1__.assert)((field === null || field === void 0 ? void 0 : field.kind) === \"form\", `${format.contentField} is not a form field`);\n        (0,emery__WEBPACK_IMPORTED_MODULE_1__.assert)(field.formKind === \"content\", `${format.contentField} is not a content field`);\n        contentField = {\n            key: format.contentField,\n            config: field\n        };\n    }\n    return {\n        data: (_format$data = format.data) !== null && _format$data !== void 0 ? _format$data : \"yaml\",\n        contentField,\n        dataLocation\n    };\n}\nfunction getPathPrefix(storage) {\n    if (storage.kind === \"local\" || !storage.pathPrefix) {\n        return undefined;\n    }\n    return fixPath(storage.pathPrefix) + \"/\";\n}\nasync function sha1(content) {\n    return (0,crypto__WEBPACK_IMPORTED_MODULE_2__.createHash)(\"sha1\").update(content).digest(\"hex\");\n}\nconst textEncoder$2 = new TextEncoder();\nfunction blobSha(contents) {\n    const blobPrefix = textEncoder$2.encode(\"blob \" + contents.length + \"\\x00\");\n    const array = new Uint8Array(blobPrefix.byteLength + contents.byteLength);\n    array.set(blobPrefix, 0);\n    array.set(contents, blobPrefix.byteLength);\n    return sha1(array);\n}\nfunction getTreeNodeAtPath(root, path) {\n    const parts = path.split(\"/\");\n    let node = root.get(parts[0]);\n    for (const part of parts.slice(1)){\n        if (!node) return undefined;\n        if (!node.children) return undefined;\n        node = node.children.get(part);\n    }\n    return node;\n}\nfunction getNodeAtPath(tree, path) {\n    let node = tree;\n    for (const part of path.split(\"/\")){\n        if (!node.has(part)) {\n            node.set(part, new Map());\n        }\n        const innerNode = node.get(part);\n        (0,emery__WEBPACK_IMPORTED_MODULE_1__.assert)(innerNode instanceof Map, \"expected tree\");\n        node = innerNode;\n    }\n    return node;\n}\nfunction getFilename(path) {\n    return path.replace(/.*\\//, \"\");\n}\nfunction getDirname(path) {\n    return path.replace(/\\/[^/]+$/, \"\");\n}\nfunction toTreeChanges(changes) {\n    const changesRoot = new Map();\n    for (const deletion of changes.deletions){\n        const parentTree = getNodeAtPath(changesRoot, getDirname(deletion));\n        parentTree.set(getFilename(deletion), \"delete\");\n    }\n    for (const addition of changes.additions){\n        const parentTree = getNodeAtPath(changesRoot, getDirname(addition.path));\n        parentTree.set(getFilename(addition.path), addition.contents);\n    }\n    return changesRoot;\n}\nconst SPACE_CHAR_CODE = 32;\nconst space = new Uint8Array([\n    SPACE_CHAR_CODE\n]);\nconst nullchar = new Uint8Array([\n    0\n]);\nconst tree = textEncoder$2.encode(\"tree \");\n// based on https://github.com/isomorphic-git/isomorphic-git/blob/c09dfa20ffe0ab9e6602e0fa172d72ba8994e443/src/models/GitTree.js#L108-L122\nfunction treeSha(children) {\n    const entries = [\n        ...children\n    ].map(([name, node])=>({\n            name,\n            sha: node.entry.sha,\n            mode: node.entry.mode\n        }));\n    entries.sort((a, b)=>{\n        const aName = a.mode === \"040000\" ? a.name + \"/\" : a.name;\n        const bName = b.mode === \"040000\" ? b.name + \"/\" : b.name;\n        return aName === bName ? 0 : aName < bName ? -1 : 1;\n    });\n    const treeObject = entries.flatMap((entry)=>{\n        const mode = textEncoder$2.encode(entry.mode.replace(/^0/, \"\"));\n        const name = textEncoder$2.encode(entry.name);\n        const sha = hexToBytes(entry.sha);\n        return [\n            mode,\n            space,\n            name,\n            nullchar,\n            sha\n        ];\n    });\n    return sha1(concatBytes([\n        tree,\n        textEncoder$2.encode(treeObject.reduce((sum, val)=>sum + val.byteLength, 0).toString()),\n        nullchar,\n        ...treeObject\n    ]));\n}\nfunction concatBytes(byteArrays) {\n    const totalLength = byteArrays.reduce((sum, arr)=>sum + arr.byteLength, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const arr of byteArrays){\n        result.set(arr, offset);\n        offset += arr.byteLength;\n    }\n    return result;\n}\nfunction hexToBytes(str) {\n    const bytes = new Uint8Array(str.length / 2);\n    for(var i = 0; i < bytes.byteLength; i += 1){\n        const start = i * 2;\n        bytes[i] = parseInt(str.slice(start, start + 2), 16);\n    }\n    return bytes;\n}\nasync function createTreeNodeEntry(path, children) {\n    const sha = await treeSha(children);\n    return {\n        path,\n        mode: \"040000\",\n        type: \"tree\",\n        sha\n    };\n}\nasync function createBlobNodeEntry(path, contents) {\n    const sha = \"sha\" in contents ? contents.sha : await blobSha(contents);\n    return {\n        path,\n        mode: \"100644\",\n        type: \"blob\",\n        sha,\n        size: contents.byteLength\n    };\n}\nasync function updateTreeWithChanges(tree, changes) {\n    var _await$updateTree;\n    const newTree = (_await$updateTree = await updateTree(tree, toTreeChanges(changes), [])) !== null && _await$updateTree !== void 0 ? _await$updateTree : new Map();\n    return {\n        entries: treeToEntries(newTree),\n        sha: await treeSha(newTree !== null && newTree !== void 0 ? newTree : new Map())\n    };\n}\nfunction treeToEntries(tree) {\n    return [\n        ...tree.values()\n    ].flatMap((x)=>x.children ? [\n            x.entry,\n            ...treeToEntries(x.children)\n        ] : [\n            x.entry\n        ]);\n}\nasync function updateTree(tree, changedTree, path) {\n    const newTree = new Map(tree);\n    for (const [key, value] of changedTree){\n        if (value === \"delete\") {\n            newTree.delete(key);\n        }\n        if (value instanceof Map) {\n            var _newTree$get$children, _newTree$get;\n            const existingChildren = (_newTree$get$children = (_newTree$get = newTree.get(key)) === null || _newTree$get === void 0 ? void 0 : _newTree$get.children) !== null && _newTree$get$children !== void 0 ? _newTree$get$children : new Map();\n            const children = await updateTree(existingChildren, value, path.concat(key));\n            if (children === undefined) {\n                newTree.delete(key);\n                continue;\n            }\n            const entry = await createTreeNodeEntry(path.concat(key).join(\"/\"), children);\n            newTree.set(key, {\n                entry,\n                children\n            });\n        }\n        if (value instanceof Uint8Array || typeof value === \"object\" && \"sha\" in value) {\n            const entry = await createBlobNodeEntry(path.concat(key).join(\"/\"), value);\n            newTree.set(key, {\n                entry\n            });\n        }\n    }\n    if (newTree.size === 0) {\n        return undefined;\n    }\n    return newTree;\n}\nfunction treeEntriesToTreeNodes(entries) {\n    const root = new Map();\n    const getChildrenAtPath = (parts)=>{\n        var _node;\n        if (parts.length === 0) {\n            return root;\n        }\n        let node = root.get(parts[0]);\n        for (const part of parts.slice(1)){\n            if (!node) return undefined;\n            if (!node.children) return undefined;\n            node = node.children.get(part);\n        }\n        return (_node = node) === null || _node === void 0 ? void 0 : _node.children;\n    };\n    for (const entry of entries){\n        const split = entry.path.split(\"/\");\n        const children = getChildrenAtPath(split.slice(0, -1));\n        if (children) {\n            children.set(split[split.length - 1], {\n                entry,\n                children: entry.type === \"tree\" ? new Map() : undefined\n            });\n        }\n    }\n    return root;\n}\nfunction collectDirectoriesUsedInSchemaInner(schema, directories, seenSchemas) {\n    if (seenSchemas.has(schema)) {\n        return;\n    }\n    seenSchemas.add(schema);\n    if (schema.kind === \"array\") {\n        return collectDirectoriesUsedInSchemaInner(schema.element, directories, seenSchemas);\n    }\n    if (schema.kind === \"child\") {\n        return;\n    }\n    if (schema.kind === \"form\") {\n        if (schema.formKind === \"asset\" && schema.directory !== undefined) {\n            directories.add(fixPath(schema.directory));\n        }\n        if (schema.formKind === \"content\" && schema.directories !== undefined) {\n            for (const directory of schema.directories){\n                directories.add(fixPath(directory));\n            }\n        }\n        return;\n    }\n    if (schema.kind === \"object\") {\n        for (const field of Object.values(schema.fields)){\n            collectDirectoriesUsedInSchemaInner(field, directories, seenSchemas);\n        }\n        return;\n    }\n    if (schema.kind === \"conditional\") {\n        for (const innerSchema of Object.values(schema.values)){\n            collectDirectoriesUsedInSchemaInner(innerSchema, directories, seenSchemas);\n        }\n        return;\n    }\n    (0,emery__WEBPACK_IMPORTED_MODULE_1__.assertNever)(schema);\n}\nfunction collectDirectoriesUsedInSchema(schema) {\n    const directories = new Set();\n    collectDirectoriesUsedInSchemaInner(schema, directories, new Set());\n    return directories;\n}\nfunction getDirectoriesForTreeKey(schema, directory, slug, format) {\n    const directories = [\n        fixPath(directory)\n    ];\n    if (format.dataLocation === \"outer\") {\n        directories.push(fixPath(directory) + getDataFileExtension(format));\n    }\n    const toAdd = slug === undefined ? \"\" : `/${slug}`;\n    for (const directory of collectDirectoriesUsedInSchema(schema)){\n        directories.push(directory + toAdd);\n    }\n    return directories;\n}\nfunction getTreeKey(directories, tree) {\n    return directories.map((d)=>{\n        var _getTreeNodeAtPath;\n        return (_getTreeNodeAtPath = getTreeNodeAtPath(tree, d)) === null || _getTreeNodeAtPath === void 0 ? void 0 : _getTreeNodeAtPath.entry.sha;\n    }).join(\"-\");\n}\nvar pkgJson = {\n    name: \"@keystatic/core\",\n    version: \"0.1.7\",\n    license: \"MIT\",\n    repository: {\n        type: \"git\",\n        url: \"https://github.com/Thinkmill/keystatic/\",\n        directory: \"packages/keystatic\"\n    },\n    exports: {\n        \"./ui\": {\n            types: \"./ui/dist/keystatic-core-ui.cjs.js\",\n            node: {\n                \"react-server\": {\n                    module: \"./ui/dist/keystatic-core-ui.node.react-server.esm.js\",\n                    \"default\": \"./ui/dist/keystatic-core-ui.node.react-server.cjs.js\"\n                },\n                module: \"./ui/dist/keystatic-core-ui.node.esm.js\",\n                \"default\": \"./ui/dist/keystatic-core-ui.node.cjs.js\"\n            },\n            \"react-server\": {\n                module: \"./ui/dist/keystatic-core-ui.react-server.esm.js\",\n                \"default\": \"./ui/dist/keystatic-core-ui.react-server.cjs.js\"\n            },\n            module: \"./ui/dist/keystatic-core-ui.esm.js\",\n            \"default\": \"./ui/dist/keystatic-core-ui.cjs.js\"\n        },\n        \".\": {\n            types: \"./dist/keystatic-core.cjs.js\",\n            node: {\n                \"react-server\": {\n                    module: \"./dist/keystatic-core.node.react-server.esm.js\",\n                    \"default\": \"./dist/keystatic-core.node.react-server.cjs.js\"\n                },\n                module: \"./dist/keystatic-core.node.esm.js\",\n                \"default\": \"./dist/keystatic-core.node.cjs.js\"\n            },\n            \"react-server\": {\n                module: \"./dist/keystatic-core.react-server.esm.js\",\n                \"default\": \"./dist/keystatic-core.react-server.cjs.js\"\n            },\n            module: \"./dist/keystatic-core.esm.js\",\n            \"default\": \"./dist/keystatic-core.cjs.js\"\n        },\n        \"./api/utils\": {\n            types: \"./api/utils/dist/keystatic-core-api-utils.cjs.js\",\n            node: {\n                \"react-server\": {\n                    module: \"./api/utils/dist/keystatic-core-api-utils.node.react-server.esm.js\",\n                    \"default\": \"./api/utils/dist/keystatic-core-api-utils.node.react-server.cjs.js\"\n                },\n                module: \"./api/utils/dist/keystatic-core-api-utils.node.esm.js\",\n                \"default\": \"./api/utils/dist/keystatic-core-api-utils.node.cjs.js\"\n            },\n            \"react-server\": {\n                module: \"./api/utils/dist/keystatic-core-api-utils.react-server.esm.js\",\n                \"default\": \"./api/utils/dist/keystatic-core-api-utils.react-server.cjs.js\"\n            },\n            module: \"./api/utils/dist/keystatic-core-api-utils.esm.js\",\n            \"default\": \"./api/utils/dist/keystatic-core-api-utils.cjs.js\"\n        },\n        \"./renderer\": {\n            types: \"./renderer/dist/keystatic-core-renderer.cjs.js\",\n            node: {\n                \"react-server\": {\n                    module: \"./renderer/dist/keystatic-core-renderer.node.react-server.esm.js\",\n                    \"default\": \"./renderer/dist/keystatic-core-renderer.node.react-server.cjs.js\"\n                },\n                module: \"./renderer/dist/keystatic-core-renderer.node.esm.js\",\n                \"default\": \"./renderer/dist/keystatic-core-renderer.node.cjs.js\"\n            },\n            \"react-server\": {\n                module: \"./renderer/dist/keystatic-core-renderer.react-server.esm.js\",\n                \"default\": \"./renderer/dist/keystatic-core-renderer.react-server.cjs.js\"\n            },\n            module: \"./renderer/dist/keystatic-core-renderer.esm.js\",\n            \"default\": \"./renderer/dist/keystatic-core-renderer.cjs.js\"\n        },\n        \"./api/generic\": {\n            types: \"./api/generic/dist/keystatic-core-api-generic.cjs.js\",\n            node: {\n                \"react-server\": {\n                    module: \"./api/generic/dist/keystatic-core-api-generic.node.react-server.esm.js\",\n                    \"default\": \"./api/generic/dist/keystatic-core-api-generic.node.react-server.cjs.js\"\n                },\n                module: \"./api/generic/dist/keystatic-core-api-generic.node.esm.js\",\n                \"default\": \"./api/generic/dist/keystatic-core-api-generic.node.cjs.js\"\n            },\n            \"react-server\": {\n                module: \"./api/generic/dist/keystatic-core-api-generic.react-server.esm.js\",\n                \"default\": \"./api/generic/dist/keystatic-core-api-generic.react-server.cjs.js\"\n            },\n            module: \"./api/generic/dist/keystatic-core-api-generic.esm.js\",\n            \"default\": \"./api/generic/dist/keystatic-core-api-generic.cjs.js\"\n        },\n        \"./reader\": {\n            types: \"./reader/dist/keystatic-core-reader.cjs.js\",\n            node: {\n                \"react-server\": {\n                    module: \"./reader/dist/keystatic-core-reader.node.react-server.esm.js\",\n                    \"default\": \"./reader/dist/keystatic-core-reader.node.react-server.cjs.js\"\n                },\n                module: \"./reader/dist/keystatic-core-reader.node.esm.js\",\n                \"default\": \"./reader/dist/keystatic-core-reader.node.cjs.js\"\n            },\n            \"react-server\": {\n                module: \"./reader/dist/keystatic-core-reader.react-server.esm.js\",\n                \"default\": \"./reader/dist/keystatic-core-reader.react-server.cjs.js\"\n            },\n            module: \"./reader/dist/keystatic-core-reader.esm.js\",\n            \"default\": \"./reader/dist/keystatic-core-reader.cjs.js\"\n        },\n        \"./reader/github\": {\n            types: \"./reader/github/dist/keystatic-core-reader-github.cjs.js\",\n            node: {\n                \"react-server\": {\n                    module: \"./reader/github/dist/keystatic-core-reader-github.node.react-server.esm.js\",\n                    \"default\": \"./reader/github/dist/keystatic-core-reader-github.node.react-server.cjs.js\"\n                },\n                module: \"./reader/github/dist/keystatic-core-reader-github.node.esm.js\",\n                \"default\": \"./reader/github/dist/keystatic-core-reader-github.node.cjs.js\"\n            },\n            \"react-server\": {\n                module: \"./reader/github/dist/keystatic-core-reader-github.react-server.esm.js\",\n                \"default\": \"./reader/github/dist/keystatic-core-reader-github.react-server.cjs.js\"\n            },\n            module: \"./reader/github/dist/keystatic-core-reader-github.esm.js\",\n            \"default\": \"./reader/github/dist/keystatic-core-reader-github.cjs.js\"\n        },\n        \"./component-blocks\": {\n            types: \"./component-blocks/dist/keystatic-core-component-blocks.cjs.js\",\n            node: {\n                \"react-server\": {\n                    module: \"./component-blocks/dist/keystatic-core-component-blocks.node.react-server.esm.js\",\n                    \"default\": \"./component-blocks/dist/keystatic-core-component-blocks.node.react-server.cjs.js\"\n                },\n                module: \"./component-blocks/dist/keystatic-core-component-blocks.node.esm.js\",\n                \"default\": \"./component-blocks/dist/keystatic-core-component-blocks.node.cjs.js\"\n            },\n            \"react-server\": {\n                module: \"./component-blocks/dist/keystatic-core-component-blocks.react-server.esm.js\",\n                \"default\": \"./component-blocks/dist/keystatic-core-component-blocks.react-server.cjs.js\"\n            },\n            module: \"./component-blocks/dist/keystatic-core-component-blocks.esm.js\",\n            \"default\": \"./component-blocks/dist/keystatic-core-component-blocks.cjs.js\"\n        },\n        \"./form/fields/markdoc\": {\n            types: \"./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.cjs.js\",\n            node: {\n                \"react-server\": {\n                    module: \"./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.node.react-server.esm.js\",\n                    \"default\": \"./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.node.react-server.cjs.js\"\n                },\n                module: \"./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.node.esm.js\",\n                \"default\": \"./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.node.cjs.js\"\n            },\n            \"react-server\": {\n                module: \"./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.react-server.esm.js\",\n                \"default\": \"./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.react-server.cjs.js\"\n            },\n            module: \"./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.esm.js\",\n            \"default\": \"./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.cjs.js\"\n        },\n        \"./package.json\": \"./package.json\"\n    },\n    main: \"dist/keystatic-core.cjs.js\",\n    module: \"dist/keystatic-core.esm.js\",\n    files: [\n        \"dist\",\n        \"api\",\n        \"reader\",\n        \"renderer\",\n        \"ui\",\n        \"form\",\n        \"component-blocks\"\n    ],\n    scripts: {\n        setup: \"ts-gql build && tsx scripts/l10n.ts && tsx scripts/build-prism.ts\",\n        build: \"pnpm run setup && next build\",\n        dev: \"next dev\",\n        start: \"next start\"\n    },\n    dependencies: {\n        \"@babel/runtime\": \"^7.18.3\",\n        \"@braintree/sanitize-url\": \"^6.0.2\",\n        \"@emotion/css\": \"^11.9.0\",\n        \"@emotion/weak-memoize\": \"^0.3.0\",\n        \"@floating-ui/react\": \"^0.24.0\",\n        \"@internationalized/string\": \"^3.1.1\",\n        \"@keystar/ui\": \"^0.3.3\",\n        \"@markdoc/markdoc\": \"^0.3.0\",\n        \"@react-aria/focus\": \"^3.14.2\",\n        \"@react-aria/i18n\": \"^3.8.0\",\n        \"@react-aria/interactions\": \"^3.19.0\",\n        \"@react-aria/overlays\": \"^3.15.0\",\n        \"@react-aria/selection\": \"^3.16.0\",\n        \"@react-aria/utils\": \"^3.21.0\",\n        \"@react-aria/visually-hidden\": \"^3.8.5\",\n        \"@react-stately/collections\": \"^3.10.2\",\n        \"@react-stately/list\": \"^3.9.0\",\n        \"@react-stately/overlays\": \"^3.6.0\",\n        \"@react-stately/utils\": \"^3.7.0\",\n        \"@react-types/shared\": \"^3.21.0\",\n        \"@sindresorhus/slugify\": \"^1.1.2\",\n        \"@ts-gql/tag\": \"^0.7.0\",\n        \"@types/node\": \"16.11.13\",\n        \"@types/react\": \"^18.2.8\",\n        \"@types/react-dom\": \"^18.0.11\",\n        \"@urql/core\": \"^4.1.3\",\n        \"@urql/exchange-auth\": \"^2.1.6\",\n        \"@urql/exchange-graphcache\": \"^6.3.3\",\n        \"@urql/exchange-persisted\": \"^4.1.0\",\n        cookie: \"^0.5.0\",\n        emery: \"^1.4.1\",\n        \"escape-string-regexp\": \"^4.0.0\",\n        \"fast-deep-equal\": \"^3.1.3\",\n        graphql: \"^16.6.0\",\n        \"idb-keyval\": \"^6.2.1\",\n        ignore: \"^5.2.4\",\n        \"iron-webcrypto\": \"^0.10.1\",\n        \"is-hotkey\": \"^0.2.0\",\n        \"js-base64\": \"^3.7.5\",\n        \"js-yaml\": \"^4.1.0\",\n        \"lru-cache\": \"^7.14.1\",\n        \"match-sorter\": \"^6.3.1\",\n        \"mdast-util-from-markdown\": \"^0.8.5\",\n        \"mdast-util-gfm-autolink-literal\": \"^0.1.3\",\n        \"mdast-util-gfm-strikethrough\": \"^0.2.3\",\n        \"micromark-extension-gfm-autolink-literal\": \"0.5.7\",\n        \"micromark-extension-gfm-strikethrough\": \"0.6.5\",\n        minimatch: \"^7.1.0\",\n        \"prosemirror-commands\": \"^1.5.1\",\n        \"prosemirror-history\": \"^1.3.0\",\n        \"prosemirror-keymap\": \"^1.2.1\",\n        \"prosemirror-model\": \"^1.19.0\",\n        \"prosemirror-state\": \"^1.4.2\",\n        \"prosemirror-transform\": \"^1.7.1\",\n        \"prosemirror-view\": \"^1.30.2\",\n        \"scroll-into-view-if-needed\": \"^3.0.3\",\n        slate: \"^0.91.4\",\n        \"slate-history\": \"^0.86.0\",\n        \"slate-react\": \"^0.91.9\",\n        urql: \"^4.0.0\",\n        zod: \"^3.20.2\"\n    },\n    devDependencies: {\n        \"@testing-library/user-event\": \"^14.4.3\",\n        \"@ts-gql/compiler\": \"^0.16.1\",\n        \"@ts-gql/eslint-plugin\": \"^0.8.5\",\n        \"@ts-gql/next\": \"^17.0.0\",\n        \"@types/cookie\": \"^0.5.1\",\n        \"@types/is-hotkey\": \"^0.1.7\",\n        \"@types/js-yaml\": \"^4.0.5\",\n        \"@types/prismjs\": \"^1.26.0\",\n        \"@types/signal-exit\": \"^3.0.1\",\n        eslint: \"^8.18.0\",\n        \"fast-glob\": \"^3.2.12\",\n        \"jest-diff\": \"^29.0.1\",\n        outdent: \"^0.8.0\",\n        \"pretty-format\": \"^29.0.1\",\n        prismjs: \"^1.29.0\",\n        react: \"^18.2.0\",\n        \"react-dom\": \"^18.2.0\",\n        \"react-element-to-jsx-string\": \"^15.0.0\",\n        \"resize-observer-polyfill\": \"^1.5.1\",\n        \"signal-exit\": \"^3.0.7\",\n        \"slate-hyperscript\": \"^0.77.0\",\n        tsx: \"^3.8.0\",\n        typescript: \"^5.2.2\"\n    },\n    peerDependencies: {\n        react: \"^18.2.0\",\n        \"react-dom\": \"^18.2.0\"\n    },\n    preconstruct: {\n        entrypoints: [\n            \"index.ts\",\n            \"api/generic.ts\",\n            \"api/utils.ts\",\n            \"reader/index.ts\",\n            \"reader/github.ts\",\n            \"renderer.tsx\",\n            \"ui.tsx\",\n            \"form/fields/markdoc/index.tsx\",\n            \"component-blocks/index.tsx\"\n        ]\n    },\n    \"ts-gql\": {\n        schema: \"./github.graphql\",\n        mode: \"no-transform\",\n        addTypename: false,\n        scalars: {\n            GitObjectID: \"string\"\n        }\n    },\n    imports: {\n        \"#react-cache-in-react-server\": {\n            \"react-server\": \"./src/reader/react-server-cache.ts\",\n            \"default\": \"./src/reader/noop-cache.ts\"\n        },\n        \"#sha1\": {\n            node: \"./src/sha1/node.ts\",\n            \"default\": \"./src/sha1/webcrypto.ts\"\n        },\n        \"#webcrypto\": {\n            node: \"./src/api/webcrypto/node.ts\",\n            \"default\": \"./src/api/webcrypto/default.ts\"\n        },\n        \"#api-handler\": {\n            node: \"./src/api/api-node.ts\",\n            \"default\": \"./src/api/api-noop.ts\"\n        },\n        \"#field-ui/*\": {\n            \"react-server\": \"./src/form/fields/empty-field-ui.tsx\",\n            \"default\": \"./src/form/fields/*/ui.tsx\"\n        },\n        \"#component-block-primitives\": {\n            \"react-server\": \"./src/form/fields/document/DocumentEditor/primitives/blank-for-react-server.tsx\",\n            \"default\": \"./src/form/fields/document/DocumentEditor/primitives/index.tsx\"\n        },\n        \"#cloud-image-preview\": {\n            \"react-server\": \"./src/component-blocks/blank-for-react-server.tsx\",\n            \"default\": \"./src/component-blocks/cloud-image-preview.tsx\"\n        }\n    }\n};\nfunction object(fields, opts) {\n    return {\n        ...opts,\n        kind: \"object\",\n        fields\n    };\n}\nfunction pluralize(count, options) {\n    const { singular, plural = singular + \"s\", inclusive = true } = options;\n    const variant = count === 1 ? singular : plural;\n    return inclusive ? `${count} ${variant}` : variant;\n}\nfunction getBranchPrefix(config) {\n    return config.storage.kind !== \"local\" ? config.storage.branchPrefix : undefined;\n}\nfunction keyedEntries(obj) {\n    return Object.entries(obj).map(([key, value])=>({\n            key,\n            ...value\n        }));\n}\nfunction isGitHubConfig(config) {\n    return config.storage.kind === \"github\";\n}\nfunction isLocalConfig(config) {\n    return config.storage.kind === \"local\";\n}\nfunction isCloudConfig(config) {\n    var _config$cloud;\n    if (config.storage.kind !== \"cloud\") return false;\n    if (!((_config$cloud = config.cloud) !== null && _config$cloud !== void 0 && _config$cloud.project) || !config.cloud.project.includes(\"/\")) {\n        throw new Error(`Keystatic is set to \\`storage: { kind: 'cloud' }\\` but \\`cloud.project\\` isn't set.\nconfig({\n  storage: { kind: 'cloud' },\n  cloud: { project: 'team/project' },\n})`);\n    }\n    return true;\n}\nfunction getSplitCloudProject(config) {\n    var _config$cloud2;\n    if (!((_config$cloud2 = config.cloud) !== null && _config$cloud2 !== void 0 && _config$cloud2.project)) return undefined;\n    const [team, project] = config.cloud.project.split(\"/\");\n    return {\n        team,\n        project\n    };\n}\nfunction getRepoPath(config) {\n    return `${config.mainOwner}/${config.mainRepo}`;\n}\nfunction getRepoUrl(config) {\n    return `https://github.com/${getRepoPath(config)}`;\n}\nfunction getSlugFromState(collectionConfig, state) {\n    const value = state[collectionConfig.slugField];\n    const field = collectionConfig.schema[collectionConfig.slugField];\n    if (field.kind !== \"form\" || field.formKind !== \"slug\") {\n        throw new Error(`slugField is not a slug field`);\n    }\n    return field.serializeWithSlug(value).slug;\n}\nfunction getEntriesInCollectionWithTreeKey(config, collection, rootTree) {\n    var _getTreeNodeAtPath$ch, _getTreeNodeAtPath;\n    const collectionConfig = config.collections[collection];\n    const schema = object(collectionConfig.schema);\n    const formatInfo = getCollectionFormat(config, collection);\n    const extension = getDataFileExtension(formatInfo);\n    const glob = getSlugGlobForCollection(config, collection);\n    const collectionPath = getCollectionPath(config, collection);\n    const directory = (_getTreeNodeAtPath$ch = (_getTreeNodeAtPath = getTreeNodeAtPath(rootTree, collectionPath)) === null || _getTreeNodeAtPath === void 0 ? void 0 : _getTreeNodeAtPath.children) !== null && _getTreeNodeAtPath$ch !== void 0 ? _getTreeNodeAtPath$ch : new Map();\n    const entries = [];\n    const directoriesUsedInSchema = [\n        ...collectDirectoriesUsedInSchema(schema)\n    ];\n    const suffix = getCollectionItemSlugSuffix(config, collection);\n    const possibleEntries = new Map(directory);\n    if (glob === \"**\") {\n        const handleDirectory = (dir, prefix)=>{\n            for (const [key, entry] of dir){\n                if (entry.children) {\n                    possibleEntries.set(`${prefix}${key}`, entry);\n                    handleDirectory(entry.children, `${prefix}${key}/`);\n                } else {\n                    possibleEntries.set(`${prefix}${key}`, entry);\n                }\n            }\n        };\n        handleDirectory(directory, \"\");\n    }\n    for (const [key, entry] of possibleEntries){\n        if (formatInfo.dataLocation === \"index\") {\n            var _actualEntry$children;\n            const actualEntry = getTreeNodeAtPath(rootTree, getCollectionItemPath(config, collection, key));\n            if (!(actualEntry !== null && actualEntry !== void 0 && (_actualEntry$children = actualEntry.children) !== null && _actualEntry$children !== void 0 && _actualEntry$children.has(\"index\" + extension))) continue;\n            entries.push({\n                key: getTreeKey([\n                    actualEntry.entry.path,\n                    ...directoriesUsedInSchema.map((x)=>`${x}/${key}`)\n                ], rootTree),\n                slug: key\n            });\n        } else {\n            if (suffix) {\n                const newEntry = getTreeNodeAtPath(rootTree, getCollectionItemPath(config, collection, key) + extension);\n                if (!newEntry || newEntry.children) continue;\n                entries.push({\n                    key: getTreeKey([\n                        entry.entry.path,\n                        getCollectionItemPath(config, collection, key),\n                        ...directoriesUsedInSchema.map((x)=>`${x}/${key}`)\n                    ], rootTree),\n                    slug: key\n                });\n            }\n            if (entry.children || !key.endsWith(extension)) continue;\n            const slug = key.slice(0, -extension.length);\n            entries.push({\n                key: getTreeKey([\n                    entry.entry.path,\n                    getCollectionItemPath(config, collection, slug),\n                    ...directoriesUsedInSchema.map((x)=>`${x}/${slug}`)\n                ], rootTree),\n                slug\n            });\n        }\n    }\n    return entries;\n}\nconst KEYSTATIC_CLOUD_API_URL = \"https://api.keystatic.cloud\";\nconst KEYSTATIC_CLOUD_HEADERS = {\n    \"x-keystatic-version\": pkgJson.version\n};\nconst textEncoder$1 = new TextEncoder();\nasync function redirectToCloudAuth(from, config) {\n    var _config$cloud3;\n    if (!((_config$cloud3 = config.cloud) !== null && _config$cloud3 !== void 0 && _config$cloud3.project)) {\n        throw new Error(\"Not a cloud config\");\n    }\n    const code_verifier = (0,js_base64__WEBPACK_IMPORTED_MODULE_6__.fromUint8Array)(crypto.getRandomValues(new Uint8Array(32)), true);\n    const code_challenge = (0,js_base64__WEBPACK_IMPORTED_MODULE_6__.fromUint8Array)(new Uint8Array(await crypto.subtle.digest(\"SHA-256\", textEncoder$1.encode(code_verifier))), true);\n    const state = (0,js_base64__WEBPACK_IMPORTED_MODULE_6__.fromUint8Array)(crypto.getRandomValues(new Uint8Array(32)), true);\n    localStorage.setItem(\"keystatic-cloud-state\", JSON.stringify({\n        state,\n        from,\n        code_verifier\n    }));\n    const url = new URL(`${KEYSTATIC_CLOUD_API_URL}/oauth/authorize`);\n    url.searchParams.set(\"state\", state);\n    url.searchParams.set(\"client_id\", config.cloud.project);\n    url.searchParams.set(\"redirect_uri\", `${window.location.origin}/keystatic/cloud/oauth/callback`);\n    url.searchParams.set(\"response_type\", \"code\");\n    url.searchParams.set(\"code_challenge_method\", \"S256\");\n    url.searchParams.set(\"code_challenge\", code_challenge);\n    url.searchParams.set(\"keystatic_version\", pkgJson.version);\n    window.location.href = url.toString();\n}\nclass FieldDataError extends Error {\n    constructor(message){\n        super(message);\n        this.name = \"FieldDataError\";\n    }\n}\nfunction assertRequired(value, validation, label) {\n    if (value === null && validation !== null && validation !== void 0 && validation.isRequired) {\n        throw new FieldDataError(`${label} is required`);\n    }\n}\nfunction basicFormFieldWithSimpleReaderParse(config) {\n    return {\n        kind: \"form\",\n        Input: config.Input,\n        defaultValue: config.defaultValue,\n        parse: config.parse,\n        serialize: config.serialize,\n        validate: config.validate,\n        reader: {\n            parse (value) {\n                return config.validate(config.parse(value));\n            }\n        }\n    };\n}\nconst arrayValuesToElementKeys = new WeakMap();\nlet counter = 0;\nfunction getKeysForArrayValue(value) {\n    if (!arrayValuesToElementKeys.has(value)) {\n        arrayValuesToElementKeys.set(value, Array.from({\n            length: value.length\n        }, getNewArrayElementKey));\n    }\n    return arrayValuesToElementKeys.get(value);\n}\nfunction setKeysForArrayValue(value, elementIds) {\n    arrayValuesToElementKeys.set(value, elementIds);\n}\nfunction getNewArrayElementKey() {\n    return (counter++).toString();\n}\nconst getInitialPropsValue = _getInitialPropsValue;\nfunction _getInitialPropsValue(schema) {\n    switch(schema.kind){\n        case \"form\":\n            return schema.defaultValue();\n        case \"child\":\n            return null;\n        case \"conditional\":\n            {\n                const defaultValue = schema.discriminant.defaultValue();\n                return {\n                    discriminant: defaultValue,\n                    value: getInitialPropsValue(schema.values[defaultValue.toString()])\n                };\n            }\n        case \"object\":\n            {\n                const obj = {};\n                for (const key of Object.keys(schema.fields)){\n                    obj[key] = getInitialPropsValue(schema.fields[key]);\n                }\n                return obj;\n            }\n        case \"array\":\n            {\n                return [];\n            }\n    }\n    (0,emery__WEBPACK_IMPORTED_MODULE_1__.assertNever)(schema);\n}\nfunction getInitialPropsValueFromInitializer(schema, initializer) {\n    switch(schema.kind){\n        case \"form\":\n            return initializer === undefined ? schema.defaultValue() : initializer;\n        case \"child\":\n            return null;\n        case \"conditional\":\n            {\n                const defaultValue = initializer === undefined ? schema.discriminant.defaultValue() : initializer.discriminant;\n                return {\n                    discriminant: defaultValue,\n                    value: getInitialPropsValueFromInitializer(schema.values[defaultValue.toString()], initializer === undefined ? undefined : initializer.value)\n                };\n            }\n        case \"object\":\n            {\n                const obj = {};\n                for (const key of Object.keys(schema.fields)){\n                    obj[key] = getInitialPropsValueFromInitializer(schema.fields[key], initializer === undefined ? undefined : initializer[key]);\n                }\n                return obj;\n            }\n        case \"array\":\n            {\n                return (initializer !== null && initializer !== void 0 ? initializer : []).map((x)=>getInitialPropsValueFromInitializer(schema.element, x.value));\n            }\n    }\n    (0,emery__WEBPACK_IMPORTED_MODULE_1__.assertNever)(schema);\n}\nfunction updateValue(schema, currentValue, updater) {\n    if (updater === undefined) return currentValue;\n    switch(schema.kind){\n        case \"form\":\n            return updater;\n        case \"child\":\n            return null;\n        case \"conditional\":\n            {\n                return {\n                    discriminant: updater.discriminant,\n                    value: updater.discriminant === currentValue.discriminant ? updateValue(schema.values[updater.discriminant.toString()], currentValue.value, updater.value) : getInitialPropsValueFromInitializer(schema.values[updater.discriminant.toString()], updater.value)\n                };\n            }\n        case \"object\":\n            {\n                const obj = {};\n                for (const key of Object.keys(schema.fields)){\n                    obj[key] = updateValue(schema.fields[key], currentValue[key], updater[key]);\n                }\n                return obj;\n            }\n        case \"array\":\n            {\n                const currentArrVal = currentValue;\n                const newVal = updater;\n                const uniqueKeys = new Set();\n                for (const x of newVal){\n                    if (x.key !== undefined) {\n                        if (uniqueKeys.has(x.key)) {\n                            throw new Error(\"Array elements must have unique keys\");\n                        }\n                        uniqueKeys.add(x.key);\n                    }\n                }\n                const keys = newVal.map((x)=>{\n                    if (x.key !== undefined) return x.key;\n                    let elementKey = getNewArrayElementKey();\n                    // just in case someone gives a key that is above our counter\n                    while(uniqueKeys.has(elementKey)){\n                        elementKey = getNewArrayElementKey();\n                    }\n                    uniqueKeys.add(elementKey);\n                    return elementKey;\n                });\n                const prevKeys = getKeysForArrayValue(currentArrVal);\n                const prevValuesByKey = new Map(currentArrVal.map((value, i)=>{\n                    return [\n                        prevKeys[i],\n                        value\n                    ];\n                }));\n                const val = newVal.map((x, i)=>{\n                    const id = keys[i];\n                    if (prevValuesByKey.has(id)) {\n                        return updateValue(schema.element, prevValuesByKey.get(id), x.value);\n                    }\n                    return getInitialPropsValueFromInitializer(schema.element, x.value);\n                });\n                setKeysForArrayValue(val, keys);\n                return val;\n            }\n    }\n    (0,emery__WEBPACK_IMPORTED_MODULE_1__.assertNever)(schema);\n}\nfunction getValueAtPropPath(value, inputPath) {\n    const path = [\n        ...inputPath\n    ];\n    while(path.length){\n        const key = path.shift();\n        value = value[key];\n    }\n    return value;\n}\nfunction traverseProps(schema, value, visitor, path = []) {\n    if (schema.kind === \"form\" || schema.kind === \"child\") {\n        visitor(schema, value, path);\n        return;\n    }\n    if (schema.kind === \"object\") {\n        for (const [key, childProp] of Object.entries(schema.fields)){\n            traverseProps(childProp, value[key], visitor, [\n                ...path,\n                key\n            ]);\n        }\n        visitor(schema, value, path);\n        return;\n    }\n    if (schema.kind === \"array\") {\n        for (const [idx, val] of value.entries()){\n            traverseProps(schema.element, val, visitor, path.concat(idx));\n        }\n        return visitor(schema, value, path);\n    }\n    if (schema.kind === \"conditional\") {\n        const discriminant = value.discriminant;\n        visitor(schema, discriminant, path.concat(\"discriminant\"));\n        traverseProps(schema.values[discriminant.toString()], value.value, visitor, path.concat(\"value\"));\n        visitor(schema, value, path);\n        return;\n    }\n    (0,emery_assertions__WEBPACK_IMPORTED_MODULE_0__.assertNever)(schema);\n}\nfunction transformProps(schema, value, visitors, path = []) {\n    if (schema.kind === \"form\" || schema.kind === \"child\") {\n        if (visitors[schema.kind]) {\n            return visitors[schema.kind](schema, value, path);\n        }\n        return value;\n    }\n    if (schema.kind === \"object\") {\n        const val = Object.fromEntries(Object.entries(schema.fields).map(([key, val])=>{\n            return [\n                key,\n                transformProps(val, value[key], visitors, [\n                    ...path,\n                    key\n                ])\n            ];\n        }));\n        if (visitors.object) {\n            return visitors[schema.kind](schema, val, path);\n        }\n        return val;\n    }\n    if (schema.kind === \"array\") {\n        const val = value.map((val, idx)=>transformProps(schema.element, val, visitors, path.concat(idx)));\n        if (visitors.array) {\n            return visitors[schema.kind](schema, val, path);\n        }\n        return val;\n    }\n    if (schema.kind === \"conditional\") {\n        const discriminant = transformProps(schema.discriminant, value.discriminant, visitors, path.concat(\"discriminant\"));\n        const conditionalVal = transformProps(schema.values[discriminant.toString()], value.value, visitors, path.concat(\"value\"));\n        const val = {\n            discriminant,\n            value: conditionalVal\n        };\n        if (visitors.conditional) {\n            return visitors[schema.kind](schema, val, path);\n        }\n        return val;\n    }\n    (0,emery_assertions__WEBPACK_IMPORTED_MODULE_0__.assertNever)(schema);\n}\nfunction replaceValueAtPropPath(schema, value, newValue, path) {\n    if (path.length === 0) {\n        return newValue;\n    }\n    const [key, ...newPath] = path;\n    if (schema.kind === \"object\") {\n        return {\n            ...value,\n            [key]: replaceValueAtPropPath(schema.fields[key], value[key], newValue, newPath)\n        };\n    }\n    if (schema.kind === \"conditional\") {\n        const conditionalValue = value;\n        // replaceValueAtPropPath should not be used to only update the discriminant of a conditional field\n        // if you want to update the discriminant of a conditional field, replace the value of the whole conditional field\n        (0,emery_assertions__WEBPACK_IMPORTED_MODULE_0__.assert)(key === \"value\");\n        return {\n            discriminant: conditionalValue.discriminant,\n            value: replaceValueAtPropPath(schema.values[key], conditionalValue.value, newValue, newPath)\n        };\n    }\n    if (schema.kind === \"array\") {\n        const prevVal = value;\n        const newVal = [\n            ...prevVal\n        ];\n        setKeysForArrayValue(newVal, getKeysForArrayValue(prevVal));\n        newVal[key] = replaceValueAtPropPath(schema.element, newVal[key], newValue, newPath);\n        return newVal;\n    }\n    // we should never reach here since form or child fields don't contain other fields\n    // so the only thing that can happen to them is to be replaced which happens at the start of this function when path.length === 0\n    (0,emery_assertions__WEBPACK_IMPORTED_MODULE_0__.assert)(schema.kind !== \"form\" && schema.kind !== \"child\");\n    (0,emery_assertions__WEBPACK_IMPORTED_MODULE_0__.assertNever)(schema);\n}\n// a v important note\n// marks in the markdown ast/html are represented quite differently to how they are in slate\n// if you had the markdown **something https://keystonejs.com something**\n// the bold node is the parent of the link node\n// but in slate, marks are only represented on text nodes\nconst currentlyActiveMarks = new Set();\nconst currentlyDisabledMarks = new Set();\nlet currentLink = null;\nfunction addMarkToChildren(mark, cb) {\n    const wasPreviouslyActive = currentlyActiveMarks.has(mark);\n    currentlyActiveMarks.add(mark);\n    try {\n        return cb();\n    } finally{\n        if (!wasPreviouslyActive) {\n            currentlyActiveMarks.delete(mark);\n        }\n    }\n}\nfunction setLinkForChildren(href, cb) {\n    // we'll only use the outer link\n    if (currentLink !== null) {\n        return cb();\n    }\n    currentLink = href;\n    try {\n        return cb();\n    } finally{\n        currentLink = null;\n    }\n}\n/**\n * This type is more strict than `Element & { type: 'link'; }` because `children`\n * is constrained to only contain Text nodes. This can't be assumed generally around the editor\n * (because of potentially future inline components or nested links(which are normalized away but the editor needs to not break if it happens))\n * but where this type is used, we're only going to allow links to contain Text and that's important\n * so that we know a block will never be inside an inline because Slate gets unhappy when that happens\n * (really the link inline should probably be a mark rather than an inline,\n * non-void inlines are probably always bad but that would imply changing the document\n * structure which would be such unnecessary breakage)\n */ function getInlineNodes(text) {\n    const node = {\n        text\n    };\n    for (const mark of currentlyActiveMarks){\n        if (!currentlyDisabledMarks.has(mark)) {\n            node[mark] = true;\n        }\n    }\n    if (currentLink !== null) {\n        return [\n            {\n                text: \"\"\n            },\n            {\n                type: \"link\",\n                href: currentLink,\n                children: [\n                    node\n                ]\n            },\n            {\n                text: \"\"\n            }\n        ];\n    }\n    return [\n        node\n    ];\n}\nclass VariableChildFields extends Error {\n    constructor(){\n        super(\"There are a variable number of child fields\");\n    }\n}\nfunction findSingleChildField(schema) {\n    try {\n        const result = _findConstantChildFields(schema, [], new Set());\n        if (result.length === 1) {\n            return result[0];\n        }\n        return;\n    } catch (err) {\n        if (err instanceof VariableChildFields) {\n            return;\n        }\n        throw err;\n    }\n}\nfunction _findConstantChildFields(schema, path, seenSchemas) {\n    if (seenSchemas.has(schema)) {\n        return [];\n    }\n    seenSchemas.add(schema);\n    switch(schema.kind){\n        case \"form\":\n            return [];\n        case \"child\":\n            return [\n                {\n                    relativePath: path,\n                    options: schema.options,\n                    kind: \"child\"\n                }\n            ];\n        case \"conditional\":\n            {\n                if (couldContainChildField(schema)) {\n                    throw new VariableChildFields();\n                }\n                return [];\n            }\n        case \"array\":\n            {\n                if (schema.asChildTag) {\n                    const child = _findConstantChildFields(schema.element, [], seenSchemas);\n                    if (child.length > 1) {\n                        return [];\n                    }\n                    return [\n                        {\n                            kind: \"array\",\n                            asChildTag: schema.asChildTag,\n                            field: schema,\n                            relativePath: path,\n                            child: child[0]\n                        }\n                    ];\n                }\n                if (couldContainChildField(schema)) {\n                    throw new VariableChildFields();\n                }\n                return [];\n            }\n        case \"object\":\n            {\n                const paths = [];\n                for (const [key, value] of Object.entries(schema.fields)){\n                    paths.push(..._findConstantChildFields(value, path.concat(key), seenSchemas));\n                }\n                return paths;\n            }\n    }\n}\nfunction couldContainChildField(schema, seen = new Set()) {\n    if (seen.has(schema)) {\n        return false;\n    }\n    seen.add(schema);\n    switch(schema.kind){\n        case \"form\":\n            return false;\n        case \"child\":\n            return true;\n        case \"conditional\":\n            return Object.values(schema.values).some((value)=>couldContainChildField(value, seen));\n        case \"object\":\n            return Object.keys(schema.fields).some((key)=>couldContainChildField(schema.fields[key], seen));\n        case \"array\":\n            return couldContainChildField(schema.element, seen);\n    }\n}\nfunction inlineNodeFromMarkdoc(node) {\n    if (node.type === \"inline\") {\n        return inlineChildrenFromMarkdoc(node.children);\n    }\n    if (node.type === \"link\") {\n        return setLinkForChildren(node.attributes.href, ()=>inlineChildrenFromMarkdoc(node.children));\n    }\n    if (node.type === \"text\") {\n        return getInlineNodes(node.attributes.content);\n    }\n    if (node.type === \"strong\") {\n        return addMarkToChildren(\"bold\", ()=>inlineChildrenFromMarkdoc(node.children));\n    }\n    if (node.type === \"code\") {\n        return addMarkToChildren(\"code\", ()=>[\n                {\n                    text: node.attributes.content,\n                    code: true\n                }\n            ]);\n    }\n    if (node.type === \"em\") {\n        return addMarkToChildren(\"italic\", ()=>inlineChildrenFromMarkdoc(node.children));\n    }\n    if (node.type === \"s\") {\n        return addMarkToChildren(\"strikethrough\", ()=>inlineChildrenFromMarkdoc(node.children));\n    }\n    if (node.type === \"tag\") {\n        if (node.tag === \"u\") {\n            return addMarkToChildren(\"underline\", ()=>inlineChildrenFromMarkdoc(node.children));\n        }\n        if (node.tag === \"kbd\") {\n            return addMarkToChildren(\"keyboard\", ()=>inlineChildrenFromMarkdoc(node.children));\n        }\n        if (node.tag === \"sub\") {\n            return addMarkToChildren(\"subscript\", ()=>inlineChildrenFromMarkdoc(node.children));\n        }\n        if (node.tag === \"sup\") {\n            return addMarkToChildren(\"superscript\", ()=>inlineChildrenFromMarkdoc(node.children));\n        }\n    }\n    if (node.type === \"softbreak\") {\n        return getInlineNodes(\" \");\n    }\n    if (node.type === \"hardbreak\") {\n        return getInlineNodes(\"\\n\");\n    }\n    if (node.tag === \"component-inline-prop\" && Array.isArray(node.attributes.propPath) && node.attributes.propPath.every((x)=>typeof x === \"string\" || typeof x === \"number\")) {\n        return {\n            type: \"component-inline-prop\",\n            children: inlineFromMarkdoc(node.children),\n            propPath: node.attributes.propPath\n        };\n    }\n    throw new Error(`Unknown inline node type: ${node.type}`);\n}\nfunction inlineChildrenFromMarkdoc(nodes) {\n    return nodes.flatMap(inlineNodeFromMarkdoc);\n}\nfunction inlineFromMarkdoc(nodes) {\n    const transformedNodes = nodes.flatMap(inlineNodeFromMarkdoc);\n    const nextNodes = [];\n    let lastNode;\n    for (const [idx, node] of transformedNodes.entries()){\n        var _lastNode;\n        if (node.type === undefined && node.text === \"\" && ((_lastNode = lastNode) === null || _lastNode === void 0 ? void 0 : _lastNode.type) === undefined && idx !== transformedNodes.length - 1) {\n            continue;\n        }\n        nextNodes.push(node);\n        lastNode = node;\n    }\n    if (!nextNodes.length) {\n        nextNodes.push({\n            text: \"\"\n        });\n    }\n    return nextNodes;\n}\nfunction fromMarkdoc(node, componentBlocks) {\n    const nodes = node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks));\n    if (nodes.length === 0) {\n        return [\n            {\n                type: \"paragraph\",\n                children: [\n                    {\n                        text: \"\"\n                    }\n                ]\n            }\n        ];\n    }\n    if (nodes[nodes.length - 1].type !== \"paragraph\") {\n        nodes.push({\n            type: \"paragraph\",\n            children: [\n                {\n                    text: \"\"\n                }\n            ]\n        });\n    }\n    return nodes;\n}\nfunction fromMarkdocNode(node, componentBlocks) {\n    if (node.type === \"blockquote\") {\n        return {\n            type: \"blockquote\",\n            children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n        };\n    }\n    if (node.type === \"fence\") {\n        const { language, content, ...rest } = node.attributes;\n        return {\n            type: \"code\",\n            children: [\n                {\n                    text: content.replace(/\\n$/, \"\")\n                }\n            ],\n            ...typeof language === \"string\" ? {\n                language\n            } : {},\n            ...rest\n        };\n    }\n    if (node.type === \"heading\") {\n        return {\n            ...node.attributes,\n            level: node.attributes.level,\n            type: \"heading\",\n            children: inlineFromMarkdoc(node.children)\n        };\n    }\n    if (node.type === \"list\") {\n        return {\n            type: node.attributes.ordered ? \"ordered-list\" : \"unordered-list\",\n            children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n        };\n    }\n    if (node.type === \"item\") {\n        var _node$children$;\n        const children = [\n            {\n                type: \"list-item-content\",\n                children: node.children.length ? inlineFromMarkdoc([\n                    node.children[0]\n                ]) : [\n                    {\n                        text: \"\"\n                    }\n                ]\n            }\n        ];\n        if (((_node$children$ = node.children[1]) === null || _node$children$ === void 0 ? void 0 : _node$children$.type) === \"list\") {\n            const list = node.children[1];\n            children.push({\n                type: list.attributes.ordered ? \"ordered-list\" : \"unordered-list\",\n                children: list.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n            });\n        }\n        return {\n            type: \"list-item\",\n            children\n        };\n    }\n    if (node.type === \"paragraph\") {\n        if (node.children.length === 1 && node.children[0].type === \"inline\" && node.children[0].children.length === 1 && node.children[0].children[0].type === \"image\") {\n            var _image$attributes$tit;\n            const image = node.children[0].children[0];\n            return {\n                type: \"image\",\n                src: decodeURI(image.attributes.src),\n                alt: image.attributes.alt,\n                title: (_image$attributes$tit = image.attributes.title) !== null && _image$attributes$tit !== void 0 ? _image$attributes$tit : \"\",\n                children: [\n                    {\n                        text: \"\"\n                    }\n                ]\n            };\n        }\n        const children = inlineFromMarkdoc(node.children);\n        if (children.length === 1 && children[0].type === \"component-inline-prop\") {\n            return children[0];\n        }\n        return {\n            type: \"paragraph\",\n            children,\n            textAlign: node.attributes.textAlign\n        };\n    }\n    if (node.type === \"hr\") {\n        return {\n            type: \"divider\",\n            children: [\n                {\n                    text: \"\"\n                }\n            ]\n        };\n    }\n    if (node.type === \"table\") {\n        return {\n            type: \"table\",\n            children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n        };\n    }\n    if (node.type === \"tbody\") {\n        return {\n            type: \"table-body\",\n            children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n        };\n    }\n    if (node.type === \"thead\") {\n        if (!node.children.length) return [];\n        return {\n            type: \"table-head\",\n            children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n        };\n    }\n    if (node.type === \"tr\") {\n        return {\n            type: \"table-row\",\n            children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n        };\n    }\n    if (node.type === \"td\") {\n        return {\n            type: \"table-cell\",\n            children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n        };\n    }\n    if (node.type === \"th\") {\n        return {\n            type: \"table-cell\",\n            header: true,\n            children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n        };\n    }\n    if (node.type === \"tag\") {\n        if (node.tag === \"table\") {\n            return fromMarkdocNode(node.children[0], componentBlocks);\n        }\n        if (node.tag === \"layout\") {\n            return {\n                type: \"layout\",\n                layout: node.attributes.layout,\n                children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n            };\n        }\n        if (node.tag === \"layout-area\") {\n            return {\n                type: \"layout-area\",\n                children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n            };\n        }\n        if (node.tag === \"component-block\") {\n            return {\n                type: \"component-block\",\n                component: node.attributes.component,\n                props: node.attributes.props,\n                children: node.children.length === 0 ? [\n                    {\n                        type: \"component-inline-prop\",\n                        children: [\n                            {\n                                text: \"\"\n                            }\n                        ]\n                    }\n                ] : node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n            };\n        }\n        if (node.tag === \"component-block-prop\" && Array.isArray(node.attributes.propPath) && node.attributes.propPath.every((x)=>typeof x === \"string\" || typeof x === \"number\")) {\n            return {\n                type: \"component-block-prop\",\n                children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks)),\n                propPath: node.attributes.propPath\n            };\n        }\n        if (node.tag) {\n            const componentBlock = componentBlocks[node.tag];\n            if (componentBlock) {\n                const singleChildField = findSingleChildField({\n                    kind: \"object\",\n                    fields: componentBlock.schema\n                });\n                if (singleChildField) {\n                    const newAttributes = JSON.parse(JSON.stringify(node.attributes));\n                    const children = [];\n                    toChildrenAndProps$1(node.children, children, newAttributes, singleChildField, [], componentBlocks);\n                    return {\n                        type: \"component-block\",\n                        component: node.tag,\n                        props: newAttributes,\n                        children\n                    };\n                }\n                return {\n                    type: \"component-block\",\n                    component: node.tag,\n                    props: node.attributes,\n                    children: node.children.length === 0 ? [\n                        {\n                            type: \"component-inline-prop\",\n                            children: [\n                                {\n                                    text: \"\"\n                                }\n                            ]\n                        }\n                    ] : node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))\n                };\n            }\n        }\n        throw new Error(`Unknown tag: ${node.tag}`);\n    }\n    return inlineNodeFromMarkdoc(node);\n}\nfunction toChildrenAndProps$1(fromMarkdoc, resultingChildren, value, singleChildField, parentPropPath, componentBlocks) {\n    if (singleChildField.kind === \"child\") {\n        const children = fromMarkdoc.flatMap((x)=>fromMarkdocNode(x, componentBlocks));\n        resultingChildren.push({\n            type: `component-${singleChildField.options.kind}-prop`,\n            propPath: [\n                ...parentPropPath,\n                ...singleChildField.relativePath\n            ],\n            children\n        });\n    }\n    if (singleChildField.kind === \"array\") {\n        const arr = [];\n        for (let [idx, child] of fromMarkdoc.entries()){\n            if (child.type === \"paragraph\") {\n                child = child.children[0].children[0];\n            }\n            if (child.type !== \"tag\") {\n                throw new Error(`expected tag ${singleChildField.asChildTag}, found type: ${child.type}`);\n            }\n            if (child.tag !== singleChildField.asChildTag) {\n                throw new Error(`expected tag ${singleChildField.asChildTag}, found tag: ${child.tag}`);\n            }\n            const attributes = JSON.parse(JSON.stringify(child.attributes));\n            if (singleChildField.child) {\n                toChildrenAndProps$1(child.children, resultingChildren, attributes, singleChildField.child, [\n                    ...parentPropPath,\n                    ...singleChildField.relativePath,\n                    idx\n                ], componentBlocks);\n            }\n            arr.push(attributes);\n        }\n        const key = singleChildField.relativePath[singleChildField.relativePath.length - 1];\n        const parent = getValueAtPropPath(value, singleChildField.relativePath.slice(0, -1));\n        parent[key] = arr;\n    }\n}\nfunction areArraysEqual(a, b) {\n    return a.length === b.length && a.every((x, i)=>x === b[i]);\n}\nfunction normalizeTextBasedOnInlineMarksAndSoftBreaks([node, path], editor, inlineMarks, softBreaks) {\n    const marksToRemove = Object.keys(node).filter((x)=>x !== \"text\" && x !== \"insertMenu\" && inlineMarks[x] !== true);\n    if (marksToRemove.length) {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.unsetNodes(editor, marksToRemove, {\n            at: path\n        });\n        return true;\n    }\n    if (!softBreaks) {\n        const hasSoftBreaks = node.text.includes(\"\\n\");\n        if (hasSoftBreaks) {\n            const [parentNode] = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.parent(editor, path);\n            if (parentNode.type !== \"code\") {\n                for (const position of slate__WEBPACK_IMPORTED_MODULE_7__.Editor.positions(editor, {\n                    at: path\n                })){\n                    const character = slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(editor, position.path).text[position.offset];\n                    if (character === \"\\n\") {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.delete(editor, {\n                            at: position\n                        });\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\nfunction normalizeInlineBasedOnLinks([node, path], editor, links) {\n    if (node.type === \"link\" && !links) {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.insertText(editor, ` (${node.href})`, {\n            at: slate__WEBPACK_IMPORTED_MODULE_7__.Editor.end(editor, path)\n        });\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.unwrapNodes(editor, {\n            at: path\n        });\n        return true;\n    }\n    return false;\n}\nfunction normalizeElementBasedOnDocumentFeatures([node, path], editor, { formatting, dividers, layouts, links, images, tables }) {\n    if (node.type === \"heading\" && (!formatting.headings.levels.length || !formatting.headings.levels.includes(node.level)) || node.type === \"ordered-list\" && !formatting.listTypes.ordered || node.type === \"unordered-list\" && !formatting.listTypes.unordered || node.type === \"code\" && !formatting.blockTypes.code || node.type === \"blockquote\" && !formatting.blockTypes.blockquote || node.type === \"image\" && !images || node.type === \"table\" && !tables || node.type === \"layout\" && (layouts.length === 0 || !layouts.some((layout)=>areArraysEqual(layout, node.layout)))) {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.unwrapNodes(editor, {\n            at: path\n        });\n        return true;\n    }\n    if ((node.type === \"paragraph\" || node.type === \"heading\") && (!formatting.alignment.center && node.textAlign === \"center\" || !formatting.alignment.end && node.textAlign === \"end\" || \"textAlign\" in node && node.textAlign !== \"center\" && node.textAlign !== \"end\")) {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.unsetNodes(editor, \"textAlign\", {\n            at: path\n        });\n        return true;\n    }\n    if (node.type === \"divider\" && !dividers) {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.removeNodes(editor, {\n            at: path\n        });\n        return true;\n    }\n    return normalizeInlineBasedOnLinks([\n        node,\n        path\n    ], editor, links);\n}\nfunction withDocumentFeaturesNormalization(documentFeatures, editor) {\n    const { normalizeNode } = editor;\n    editor.normalizeNode = ([node, path])=>{\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText(node)) {\n            normalizeTextBasedOnInlineMarksAndSoftBreaks([\n                node,\n                path\n            ], editor, documentFeatures.formatting.inlineMarks, documentFeatures.formatting.softBreaks);\n        } else if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node)) {\n            normalizeElementBasedOnDocumentFeatures([\n                node,\n                path\n            ], editor, documentFeatures);\n        }\n        normalizeNode([\n            node,\n            path\n        ]);\n    };\n    return editor;\n}\nfunction getSrcPrefix(publicPath, slug) {\n    return typeof publicPath === \"string\" ? `${publicPath.replace(/\\/*$/, \"\")}/${slug === undefined ? \"\" : slug + \"/\"}` : \"\";\n}\nfunction deserializeFiles(nodes, componentBlocks, files, otherFiles, mode, documentFeatures, slug) {\n    return nodes.map((node)=>{\n        if (node.type === \"component-block\") {\n            const componentBlock = componentBlocks[node.component];\n            if (!componentBlock) return node;\n            const schema = object(componentBlock.schema);\n            return {\n                ...node,\n                props: deserializeProps(schema, node.props, files, otherFiles, mode, slug)\n            };\n        }\n        if (node.type === \"image\" && typeof node.src === \"string\" && mode === \"edit\") {\n            var _ref;\n            const prefix = getSrcPrefixForImageBlock(documentFeatures, slug);\n            const filename = node.src.slice(prefix.length);\n            const content = (_ref = typeof documentFeatures.images === \"object\" && typeof documentFeatures.images.directory === \"string\" ? otherFiles.get(fixPath(documentFeatures.images.directory)) : files) === null || _ref === void 0 ? void 0 : _ref.get(filename);\n            if (!content) {\n                return {\n                    type: \"paragraph\",\n                    children: [\n                        {\n                            text: `Missing image ${filename}`\n                        }\n                    ]\n                };\n            }\n            return {\n                type: \"image\",\n                src: {\n                    filename,\n                    content\n                },\n                alt: node.alt,\n                title: node.title,\n                children: [\n                    {\n                        text: \"\"\n                    }\n                ]\n            };\n        }\n        if (typeof node.type === \"string\") {\n            const children = deserializeFiles(node.children, componentBlocks, files, otherFiles, mode, documentFeatures, slug);\n            return {\n                ...node,\n                children\n            };\n        }\n        return node;\n    });\n}\nfunction deserializeProps(schema, value, files, otherFiles, mode, slug) {\n    return transformProps(schema, value, {\n        form: (schema, value)=>{\n            if (schema.formKind === \"asset\") {\n                var _otherFiles$get;\n                if (mode === \"read\") {\n                    return schema.reader.parse(value);\n                }\n                const filename = schema.filename(value, {\n                    slug,\n                    suggestedFilenamePrefix: undefined\n                });\n                return schema.parse(value, {\n                    asset: filename ? schema.directory ? (_otherFiles$get = otherFiles.get(schema.directory)) === null || _otherFiles$get === void 0 ? void 0 : _otherFiles$get.get(filename) : files.get(filename) : undefined,\n                    slug\n                });\n            }\n            if (schema.formKind === \"content\") {\n                throw new Error(\"Not implemented\");\n            }\n            if (mode === \"read\") {\n                return schema.reader.parse(value);\n            }\n            return schema.parse(value, undefined);\n        }\n    });\n}\nfunction getSrcPrefixForImageBlock(documentFeatures, slug) {\n    return getSrcPrefix(typeof documentFeatures.images === \"object\" ? documentFeatures.images.publicPath : undefined, slug);\n}\nfunction serializeProps(rootValue, rootSchema, // note you might have a slug without a slug field when serializing props inside a component block or etc. in the editor\nslugField, slug, shouldSuggestFilenamePrefix) {\n    const extraFiles = [];\n    return {\n        value: transformProps(rootSchema, rootValue, {\n            form (schema, value, propPath) {\n                if (propPath.length === 1 && slugField === propPath[0]) {\n                    if (schema.formKind !== \"slug\") {\n                        throw new Error(\"slugField is a not a slug field\");\n                    }\n                    return schema.serializeWithSlug(value).value;\n                }\n                if (schema.formKind === \"asset\") {\n                    const { asset, value: forYaml } = schema.serialize(value, {\n                        suggestedFilenamePrefix: shouldSuggestFilenamePrefix ? getPropPathPortion(propPath, rootSchema, rootValue) : undefined,\n                        slug\n                    });\n                    if (asset) {\n                        extraFiles.push({\n                            path: asset.filename,\n                            contents: asset.content,\n                            parent: schema.directory\n                        });\n                    }\n                    return forYaml;\n                }\n                if (schema.formKind === \"content\") {\n                    const { other, external, content, value: forYaml } = schema.serialize(value, {\n                        slug\n                    });\n                    if (content) {\n                        extraFiles.push({\n                            path: getPropPathPortion(propPath, rootSchema, rootValue) + schema.contentExtension,\n                            contents: content,\n                            parent: undefined\n                        });\n                    }\n                    for (const [key, contents] of other){\n                        extraFiles.push({\n                            path: getPropPathPortion(propPath, rootSchema, rootValue) + \"/\" + key,\n                            contents,\n                            parent: undefined\n                        });\n                    }\n                    const allowedDirectories = new Set(schema.directories);\n                    for (const [directory, contents] of external){\n                        if (!allowedDirectories.has(directory)) {\n                            throw new Error(`Invalid directory ${directory} in content field serialization`);\n                        }\n                        for (const [filename, fileContents] of contents){\n                            extraFiles.push({\n                                path: filename,\n                                contents: fileContents,\n                                parent: directory\n                            });\n                        }\n                    }\n                    return forYaml;\n                }\n                return schema.serialize(value).value;\n            },\n            object (_schema, value) {\n                return Object.fromEntries(Object.entries(value).filter(([_, val])=>val !== undefined));\n            },\n            array (_schema, value) {\n                return value.map((val)=>val === undefined ? null : val);\n            },\n            child () {\n                return undefined;\n            }\n        }),\n        extraFiles\n    };\n}\nfunction getPropPathPortion(path, schema, value) {\n    const end = [];\n    for (const portion of path){\n        if (schema.kind === \"array\") {\n            value = value[portion];\n            if (schema.slugField && schema.element.kind === \"object\") {\n                const slug = getSlugFromState({\n                    schema: schema.element.fields,\n                    slugField: schema.slugField\n                }, value);\n                end.push(slug);\n            } else {\n                end.push(portion);\n            }\n            schema = schema.element;\n            continue;\n        }\n        end.push(portion);\n        if (schema.kind === \"object\") {\n            value = value[portion];\n            schema = schema.fields[portion];\n            continue;\n        }\n        if (schema.kind === \"conditional\") {\n            if (portion === \"discriminant\") {\n                schema = schema.discriminant;\n            } else if (portion === \"value\") {\n                schema = schema.values[value.discriminant];\n            }\n            value = value[portion];\n            continue;\n        }\n        throw new Error(`unexpected ${schema.kind}`);\n    }\n    return end.join(\"/\");\n}\nfunction toInline(nodes) {\n    return new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"inline\", {}, nodes.flatMap(toMarkdocInline));\n}\nconst markToMarkdoc = {\n    bold: {\n        type: \"strong\"\n    },\n    code: {\n        type: \"code\"\n    },\n    italic: {\n        type: \"em\"\n    },\n    underline: {\n        type: \"tag\",\n        tag: \"u\"\n    },\n    keyboard: {\n        type: \"tag\",\n        tag: \"kbd\"\n    },\n    strikethrough: {\n        type: \"s\"\n    },\n    subscript: {\n        type: \"tag\",\n        tag: \"sub\"\n    },\n    superscript: {\n        type: \"tag\",\n        tag: \"sup\"\n    }\n};\nfunction toMarkdocInline(node) {\n    if (node.type === \"link\") {\n        return new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"link\", {\n            href: node.href\n        }, node.children.flatMap(toMarkdocInline));\n    }\n    if (node.type !== undefined) {\n        throw new Error(`unexpected inline node type: ${node.type}`);\n    }\n    if (node.code) {\n        return new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"code\", {\n            content: node.text\n        }, []);\n    }\n    const marks = Object.keys(node).filter((mark)=>mark !== \"text\").sort();\n    let markdocNode = new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"text\", {\n        content: node.text\n    });\n    for (const mark of marks){\n        const config = markToMarkdoc[mark];\n        if (config) {\n            markdocNode = new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(config.type, {}, [\n                markdocNode\n            ], config.tag);\n        }\n    }\n    return markdocNode;\n}\nfunction toMarkdocDocument(nodes, _config) {\n    const extraFiles = [];\n    const config = {\n        ..._config,\n        extraFiles\n    };\n    const node = new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"document\", {}, nodes.flatMap((x)=>toMarkdoc(x, config)));\n    return {\n        node,\n        extraFiles\n    };\n}\nfunction toChildrenAndProps(childrenAsMarkdoc, resultingChildren, value, singleChildField) {\n    if (singleChildField.kind === \"child\") {\n        const child = childrenAsMarkdoc.find((x)=>areArraysEqual(x.propPath, singleChildField.relativePath));\n        if (child) {\n            resultingChildren.push(...child.children);\n        }\n        return;\n    }\n    if (singleChildField.kind === \"array\") {\n        const key = singleChildField.relativePath[singleChildField.relativePath.length - 1];\n        const parent = getValueAtPropPath(value, singleChildField.relativePath.slice(0, -1));\n        const valueAtPropPath = parent[key];\n        delete parent[key];\n        const childNodes = new Map();\n        for (const child of childrenAsMarkdoc){\n            const innerPropPath = child.propPath.slice(singleChildField.relativePath.length + 1);\n            const num = child.propPath[singleChildField.relativePath.length];\n            if (childNodes.get(num) === undefined) {\n                childNodes.set(num, []);\n            }\n            childNodes.get(num).push({\n                children: child.children,\n                propPath: innerPropPath\n            });\n        }\n        resultingChildren.push(...valueAtPropPath.map((x, i)=>{\n            var _childNodes$get;\n            const newChildrenAsMarkdoc = (_childNodes$get = childNodes.get(i)) !== null && _childNodes$get !== void 0 ? _childNodes$get : [];\n            const children = [];\n            toChildrenAndProps(newChildrenAsMarkdoc, children, x, singleChildField.child);\n            return new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"tag\", x, children, singleChildField.asChildTag);\n        }));\n    }\n}\nfunction toMarkdoc(node, config) {\n    if (node.type === \"paragraph\") {\n        const markdocNode = new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"paragraph\", node.textAlign ? {\n            textAlign: node.textAlign\n        } : {}, [\n            toInline(node.children)\n        ]);\n        if (node.textAlign) {\n            markdocNode.annotations.push({\n                name: \"textAlign\",\n                value: node.textAlign,\n                type: \"attribute\"\n            });\n        }\n        return markdocNode;\n    }\n    if (node.type === \"image\") {\n        config.extraFiles.push({\n            contents: node.src.content,\n            path: node.src.filename,\n            parent: typeof config.documentFeatures.images === \"object\" && typeof config.documentFeatures.images.directory === \"string\" ? fixPath(config.documentFeatures.images.directory) : undefined\n        });\n        return new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"paragraph\", {}, [\n            new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"inline\", {}, [\n                new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"image\", {\n                    src: encodeURI(`${getSrcPrefixForImageBlock(config.documentFeatures, config.slug)}${node.src.filename}`),\n                    alt: node.alt,\n                    title: node.title\n                })\n            ])\n        ]);\n    }\n    if (node.type === \"code\") {\n        const extraAttributes = {};\n        const { children, language, type, ...rest } = node;\n        const schema = typeof config.documentFeatures.formatting.blockTypes.code === \"object\" ? config.documentFeatures.formatting.blockTypes.code.schema : undefined;\n        if (schema && Object.keys(schema.fields).length > 0) {\n            const serialized = serializeProps(getInitialPropsValueFromInitializer(schema, rest), schema, undefined, config.slug, false);\n            Object.assign(extraAttributes, serialized.value);\n            config.extraFiles.push(...serialized.extraFiles);\n        }\n        let content = children[0].text + \"\\n\";\n        const markdocNode = new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"fence\", {\n            content,\n            language,\n            ...extraAttributes\n        }, [\n            new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"text\", {\n                content\n            })\n        ]);\n        for (const [key, value] of Object.entries(extraAttributes)){\n            markdocNode.annotations.push({\n                name: key,\n                value,\n                type: \"attribute\"\n            });\n        }\n        return markdocNode;\n    }\n    const _toMarkdoc = (node)=>toMarkdoc(node, config);\n    if (node.type === \"blockquote\") {\n        return new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"blockquote\", {}, node.children.map(_toMarkdoc));\n    }\n    if (node.type === \"divider\") {\n        return new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"hr\");\n    }\n    if (node.type === \"table\") {\n        const head = node.children.find((x)=>x.type === \"table-head\");\n        return new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"tag\", {}, [\n            new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"table\", {}, [\n                new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"thead\", {}, head ? head.children.map(_toMarkdoc) : []),\n                _toMarkdoc(node.children.find((x)=>x.type === \"table-body\"))\n            ])\n        ], \"table\");\n    }\n    if (node.type === \"table-body\") {\n        return new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"tbody\", {}, node.children.map(_toMarkdoc));\n    }\n    if (node.type === \"table-row\") {\n        return new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"tr\", {}, node.children.map(_toMarkdoc));\n    }\n    if (node.type === \"table-cell\") {\n        return new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(node.header ? \"th\" : \"td\", {}, node.children.map(_toMarkdoc));\n    }\n    if (node.type === \"heading\") {\n        const extraAttributes = {};\n        if (node.textAlign) {\n            extraAttributes.textAlign = node.textAlign;\n        }\n        const { children, level, textAlign, type, ...rest } = node;\n        const schema = config.documentFeatures.formatting.headings.schema;\n        if (Object.keys(schema.fields).length > 0) {\n            Object.assign(extraAttributes, serializeProps(getInitialPropsValueFromInitializer(schema, rest), schema, undefined, config.slug, false).value);\n        }\n        const markdocNode = new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"heading\", {\n            level: node.level,\n            ...extraAttributes\n        }, [\n            toInline(node.children)\n        ]);\n        for (const [key, value] of Object.entries(extraAttributes)){\n            markdocNode.annotations.push({\n                name: key,\n                value,\n                type: \"attribute\"\n            });\n        }\n        return markdocNode;\n    }\n    if (node.type === \"ordered-list\") {\n        return new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"list\", {\n            ordered: true\n        }, node.children.map(_toMarkdoc));\n    }\n    if (node.type === \"unordered-list\") {\n        return new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"list\", {\n            ordered: false\n        }, node.children.map(_toMarkdoc));\n    }\n    if (node.type === \"layout\") {\n        return new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"tag\", {\n            layout: node.layout\n        }, node.children.map(_toMarkdoc), \"layout\");\n    }\n    if (node.type === \"layout-area\") {\n        return new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"tag\", {}, node.children.flatMap(_toMarkdoc), \"layout-area\");\n    }\n    if (node.type === \"component-block\") {\n        const isVoid = node.children.length === 1 && node.children[0].type === \"component-inline-prop\" && node.children[0].propPath === undefined;\n        const componentBlock = config.componentBlocks[node.component];\n        const childrenAsMarkdoc = [];\n        for (const child of node.children){\n            if ((child.type === \"component-block-prop\" || child.type === \"component-inline-prop\") && child.propPath !== undefined) {\n                childrenAsMarkdoc.push({\n                    type: child.type,\n                    propPath: child.propPath,\n                    children: child.type === \"component-block-prop\" ? child.children.flatMap(_toMarkdoc) : [\n                        toInline(child.children)\n                    ]\n                });\n            }\n        }\n        let attributes = node.props;\n        if (componentBlock) {\n            const serialized = serializeProps(node.props, {\n                kind: \"object\",\n                fields: componentBlock.schema\n            }, undefined, config.slug, false);\n            attributes = serialized.value;\n            config.extraFiles.push(...serialized.extraFiles);\n            const singleChildField = findSingleChildField({\n                kind: \"object\",\n                fields: componentBlock.schema\n            });\n            if (singleChildField) {\n                const children = [];\n                toChildrenAndProps(childrenAsMarkdoc, children, attributes, singleChildField);\n                return new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"tag\", attributes, children, node.component);\n            }\n        }\n        const children = isVoid ? [] : childrenAsMarkdoc.map((x)=>new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"tag\", {\n                propPath: x.propPath\n            }, x.children, x.type));\n        return new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"tag\", attributes, children, node.component);\n    }\n    if (node.type === \"component-block-prop\" || node.type === \"component-inline-prop\") {\n        return new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"tag\", {\n            propPath: node.propPath\n        }, node.type === \"component-inline-prop\" ? [\n            toInline(node.children)\n        ] : node.children.flatMap(_toMarkdoc), node.type);\n    }\n    if (node.type === \"list-item\") {\n        const listItemContent = node.children[0];\n        if (listItemContent.type !== \"list-item-content\") {\n            throw new Error(\"list item content must contain a list-item-content\");\n        }\n        const inline = toInline(listItemContent.children);\n        const children = [\n            inline\n        ];\n        const nestedList = node.children[1];\n        if (nestedList) {\n            children.push(toMarkdoc(nestedList, config));\n        }\n        return new _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8__.Ast.Node(\"item\", {}, children);\n    }\n    if (node.type === \"list-item-content\") {\n        throw new Error(\"list-item-content in unexpected position\");\n    }\n    debugger;\n    throw new Error(`unexpected node type: ${node.type}`);\n}\nfunction validateText(val, min, max, fieldLabel, slugInfo) {\n    if (val.length < min) {\n        if (min === 1) {\n            return `${fieldLabel} must not be empty`;\n        } else {\n            return `${fieldLabel} must be at least ${min} characters long`;\n        }\n    }\n    if (val.length > max) {\n        return `${fieldLabel} must be no longer than ${max} characters`;\n    }\n    if (slugInfo) {\n        if (val === \"\") {\n            return `${fieldLabel} must not be empty`;\n        }\n        if (val === \"..\") {\n            return `${fieldLabel} must not be ..`;\n        }\n        if (val === \".\") {\n            return `${fieldLabel} must not be .`;\n        }\n        if (slugInfo.glob === \"**\") {\n            const split = val.split(\"/\");\n            if (split.some((s)=>s === \"..\")) {\n                return `${fieldLabel} must not contain ..`;\n            }\n            if (split.some((s)=>s === \".\")) {\n                return `${fieldLabel} must not be .`;\n            }\n        }\n        if ((slugInfo.glob === \"*\" ? /[\\\\/]/ : /[\\\\]/).test(val)) {\n            return `${fieldLabel} must not contain slashes`;\n        }\n        if (/^\\s|\\s$/.test(val)) {\n            return `${fieldLabel} must not start or end with spaces`;\n        }\n        if (slugInfo.slugs.has(val)) {\n            return `${fieldLabel} must be unique`;\n        }\n    }\n}\nfunction parseAsNormalField(value) {\n    if (value === undefined) {\n        return \"\";\n    }\n    if (typeof value !== \"string\") {\n        throw new FieldDataError(\"Must be a string\");\n    }\n    return value;\n}\nconst emptySet = new Set();\nfunction text({ label, defaultValue = \"\", validation: { length: { max = Infinity, min = 0 } = {} } = {}, description, multiline = false }) {\n    function validate(value, slugField) {\n        const message = validateText(value, min, max, label, slugField);\n        if (message !== undefined) {\n            throw new FieldDataError(message);\n        }\n        return value;\n    }\n    return {\n        kind: \"form\",\n        formKind: \"slug\",\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_empty_field_ui_5b08ee07_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_3__.T, {\n                label: label,\n                description: description,\n                min: min,\n                max: max,\n                multiline: multiline,\n                ...props\n            });\n        },\n        defaultValue () {\n            return typeof defaultValue === \"string\" ? defaultValue : defaultValue();\n        },\n        parse (value, args) {\n            if ((args === null || args === void 0 ? void 0 : args.slug) !== undefined) {\n                return args.slug;\n            }\n            return parseAsNormalField(value);\n        },\n        serialize (value) {\n            return {\n                value: value === \"\" ? undefined : value\n            };\n        },\n        serializeWithSlug (value) {\n            return {\n                slug: value,\n                value: undefined\n            };\n        },\n        reader: {\n            parse (value) {\n                const parsed = parseAsNormalField(value);\n                return validate(parsed, undefined);\n            },\n            parseWithSlug (_value, args) {\n                validate(parseAsNormalField(args.slug), {\n                    glob: args.glob,\n                    slugs: emptySet\n                });\n                return null;\n            }\n        },\n        validate (value, args) {\n            return validate(value, args === null || args === void 0 ? void 0 : args.slugField);\n        }\n    };\n}\nconst tableCellChildren = [\n    \"paragraph\",\n    \"code\",\n    \"heading\",\n    \"ordered-list\",\n    \"unordered-list\",\n    \"divider\",\n    \"image\"\n];\nconst blockquoteChildren = [\n    ...tableCellChildren,\n    \"table\"\n];\nconst paragraphLike = [\n    ...blockquoteChildren,\n    \"blockquote\"\n];\nconst insideOfLayouts = [\n    ...paragraphLike,\n    \"component-block\"\n];\nfunction blockContainer(args) {\n    return {\n        kind: \"blocks\",\n        allowedChildren: new Set(args.allowedChildren),\n        blockToWrapInlinesIn: args.allowedChildren[0],\n        invalidPositionHandleMode: args.invalidPositionHandleMode\n    };\n}\nfunction inlineContainer(args) {\n    return {\n        kind: \"inlines\",\n        invalidPositionHandleMode: args.invalidPositionHandleMode\n    };\n}\n// a user land version of https://github.com/microsoft/TypeScript/issues/47920\nfunction satisfies() {\n    return function(value) {\n        return value;\n    };\n}\nconst editorSchema = satisfies()({\n    editor: blockContainer({\n        allowedChildren: [\n            ...insideOfLayouts,\n            \"layout\"\n        ],\n        invalidPositionHandleMode: \"move\"\n    }),\n    layout: blockContainer({\n        allowedChildren: [\n            \"layout-area\"\n        ],\n        invalidPositionHandleMode: \"move\"\n    }),\n    \"layout-area\": blockContainer({\n        allowedChildren: insideOfLayouts,\n        invalidPositionHandleMode: \"unwrap\"\n    }),\n    blockquote: blockContainer({\n        allowedChildren: blockquoteChildren,\n        invalidPositionHandleMode: \"move\"\n    }),\n    paragraph: inlineContainer({\n        invalidPositionHandleMode: \"unwrap\"\n    }),\n    code: inlineContainer({\n        invalidPositionHandleMode: \"move\"\n    }),\n    divider: inlineContainer({\n        invalidPositionHandleMode: \"move\"\n    }),\n    heading: inlineContainer({\n        invalidPositionHandleMode: \"unwrap\"\n    }),\n    \"component-block\": blockContainer({\n        allowedChildren: [\n            \"component-block-prop\",\n            \"component-inline-prop\"\n        ],\n        invalidPositionHandleMode: \"move\"\n    }),\n    \"component-inline-prop\": inlineContainer({\n        invalidPositionHandleMode: \"unwrap\"\n    }),\n    \"component-block-prop\": blockContainer({\n        allowedChildren: [\n            ...paragraphLike,\n            \"component-block\"\n        ],\n        invalidPositionHandleMode: \"unwrap\"\n    }),\n    \"ordered-list\": blockContainer({\n        allowedChildren: [\n            \"list-item\"\n        ],\n        invalidPositionHandleMode: \"move\"\n    }),\n    \"unordered-list\": blockContainer({\n        allowedChildren: [\n            \"list-item\"\n        ],\n        invalidPositionHandleMode: \"move\"\n    }),\n    \"list-item\": blockContainer({\n        allowedChildren: [\n            \"list-item-content\",\n            \"ordered-list\",\n            \"unordered-list\"\n        ],\n        invalidPositionHandleMode: \"unwrap\"\n    }),\n    \"list-item-content\": inlineContainer({\n        invalidPositionHandleMode: \"unwrap\"\n    }),\n    image: inlineContainer({\n        invalidPositionHandleMode: \"move\"\n    }),\n    table: blockContainer({\n        invalidPositionHandleMode: \"move\",\n        allowedChildren: [\n            \"table-head\",\n            \"table-body\"\n        ]\n    }),\n    \"table-body\": blockContainer({\n        invalidPositionHandleMode: \"move\",\n        allowedChildren: [\n            \"table-row\"\n        ]\n    }),\n    \"table-row\": blockContainer({\n        invalidPositionHandleMode: \"move\",\n        allowedChildren: [\n            \"table-cell\"\n        ]\n    }),\n    \"table-cell\": blockContainer({\n        invalidPositionHandleMode: \"move\",\n        allowedChildren: tableCellChildren\n    }),\n    \"table-head\": blockContainer({\n        invalidPositionHandleMode: \"move\",\n        allowedChildren: [\n            \"table-row\"\n        ]\n    })\n});\nconst inlineContainerTypes = new Set(Object.entries(editorSchema).filter(([, value])=>value.kind === \"inlines\").map(([type])=>type));\nfunction isInlineContainer(node) {\n    return node.type !== undefined && inlineContainerTypes.has(node.type);\n}\nconst blockTypes = new Set(Object.keys(editorSchema).filter((x)=>x !== \"editor\"));\nfunction isBlock(node) {\n    return blockTypes.has(node.type);\n}\n// to print the editor schema in Graphviz if you want to visualize it\n// function printEditorSchema(editorSchema: EditorSchema) {\n//   return `digraph G {\n//   concentrate=true;\n//   ${Object.keys(editorSchema)\n//     .map(key => {\n//       let val = editorSchema[key];\n//       if (val.kind === 'inlines') {\n//         return `\"${key}\" -> inlines`;\n//       }\n//       if (val.kind === 'blocks') {\n//         return `\"${key}\" -> {${[...val.allowedChildren].map(x => JSON.stringify(x)).join(' ')}}`;\n//       }\n//     })\n//     .join('\\n  ')}\n// }`;\n// }\nfunction getDocumentFeaturesForChildField(editorDocumentFeatures, options) {\n    var _options$formatting, _options$formatting3, _options$formatting4, _options$formatting5, _options$formatting6, _options$formatting7;\n    // an important note for this: normalization based on document features\n    // is done based on the document features returned here\n    // and the editor document features\n    // so the result for any given child prop will be the things that are\n    // allowed by both these document features\n    // AND the editor document features\n    const inlineMarksFromOptions = (_options$formatting = options.formatting) === null || _options$formatting === void 0 ? void 0 : _options$formatting.inlineMarks;\n    const inlineMarks = inlineMarksFromOptions === \"inherit\" ? \"inherit\" : Object.fromEntries(Object.keys(editorDocumentFeatures.formatting.inlineMarks).map((mark)=>{\n        return [\n            mark,\n            !!(inlineMarksFromOptions || {})[mark]\n        ];\n    }));\n    if (options.kind === \"inline\") {\n        var _options$formatting2;\n        return {\n            kind: \"inline\",\n            inlineMarks,\n            documentFeatures: {\n                links: options.links === \"inherit\"\n            },\n            softBreaks: ((_options$formatting2 = options.formatting) === null || _options$formatting2 === void 0 ? void 0 : _options$formatting2.softBreaks) === \"inherit\"\n        };\n    }\n    const headingLevels = (_options$formatting3 = options.formatting) === null || _options$formatting3 === void 0 ? void 0 : _options$formatting3.headingLevels;\n    return {\n        kind: \"block\",\n        inlineMarks,\n        softBreaks: ((_options$formatting4 = options.formatting) === null || _options$formatting4 === void 0 ? void 0 : _options$formatting4.softBreaks) === \"inherit\",\n        documentFeatures: {\n            layouts: [],\n            dividers: options.dividers === \"inherit\" ? editorDocumentFeatures.dividers : false,\n            formatting: {\n                alignment: ((_options$formatting5 = options.formatting) === null || _options$formatting5 === void 0 ? void 0 : _options$formatting5.alignment) === \"inherit\" ? editorDocumentFeatures.formatting.alignment : {\n                    center: false,\n                    end: false\n                },\n                blockTypes: ((_options$formatting6 = options.formatting) === null || _options$formatting6 === void 0 ? void 0 : _options$formatting6.blockTypes) === \"inherit\" ? editorDocumentFeatures.formatting.blockTypes : {\n                    blockquote: false,\n                    code: false\n                },\n                headings: headingLevels === \"inherit\" ? editorDocumentFeatures.formatting.headings : {\n                    levels: headingLevels ? editorDocumentFeatures.formatting.headings.levels.filter((level)=>headingLevels.includes(level)) : [],\n                    schema: editorDocumentFeatures.formatting.headings.schema\n                },\n                listTypes: ((_options$formatting7 = options.formatting) === null || _options$formatting7 === void 0 ? void 0 : _options$formatting7.listTypes) === \"inherit\" ? editorDocumentFeatures.formatting.listTypes : {\n                    ordered: false,\n                    unordered: false\n                }\n            },\n            links: options.links === \"inherit\",\n            images: options.images === \"inherit\" ? editorDocumentFeatures.images : false,\n            tables: options.tables === \"inherit\"\n        },\n        componentBlocks: options.componentBlocks === \"inherit\"\n    };\n}\nfunction getSchemaAtPropPathInner(path, value, schema) {\n    // because we're checking the length here\n    // the non-null asserts on shift below are fine\n    if (path.length === 0) {\n        return schema;\n    }\n    if (schema.kind === \"child\" || schema.kind === \"form\") {\n        return;\n    }\n    if (schema.kind === \"conditional\") {\n        const key = path.shift();\n        if (key === \"discriminant\") {\n            return getSchemaAtPropPathInner(path, value.discriminant, schema.discriminant);\n        }\n        if (key === \"value\") {\n            const propVal = schema.values[value.discriminant];\n            return getSchemaAtPropPathInner(path, value.value, propVal);\n        }\n        return;\n    }\n    if (schema.kind === \"object\") {\n        const key = path.shift();\n        return getSchemaAtPropPathInner(path, value[key], schema.fields[key]);\n    }\n    if (schema.kind === \"array\") {\n        const index = path.shift();\n        return getSchemaAtPropPathInner(path, value[index], schema.element);\n    }\n    (0,emery__WEBPACK_IMPORTED_MODULE_1__.assertNever)(schema);\n}\nfunction getSchemaAtPropPath(path, value, props) {\n    return getSchemaAtPropPathInner([\n        ...path\n    ], value, {\n        kind: \"object\",\n        fields: props\n    });\n}\nfunction getAncestorSchemas(rootSchema, path, value) {\n    const ancestors = [];\n    const currentPath = [\n        ...path\n    ];\n    let currentProp = rootSchema;\n    let currentValue = value;\n    while(currentPath.length){\n        ancestors.push(currentProp);\n        const key = currentPath.shift(); // this code only runs when path.length is truthy so this non-null assertion is fine\n        if (currentProp.kind === \"array\") {\n            currentProp = currentProp.element;\n            currentValue = currentValue[key];\n        } else if (currentProp.kind === \"conditional\") {\n            currentProp = currentProp.values[value.discriminant];\n            currentValue = currentValue.value;\n        } else if (currentProp.kind === \"object\") {\n            currentValue = currentValue[key];\n            currentProp = currentProp.fields[key];\n        } else if (currentProp.kind === \"child\" || currentProp.kind === \"form\") {\n            throw new Error(`unexpected prop \"${key}\"`);\n        } else {\n            (0,emery__WEBPACK_IMPORTED_MODULE_1__.assertNever)(currentProp);\n        }\n    }\n    return ancestors;\n}\nfunction moveChildren(editor, parent, to, shouldMoveNode = ()=>true) {\n    const parentPath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.isPath(parent) ? parent : parent[1];\n    const parentNode = slate__WEBPACK_IMPORTED_MODULE_7__.Path.isPath(parent) ? slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(editor, parentPath) : parent[0];\n    if (!isBlock(parentNode)) return;\n    for(let i = parentNode.children.length - 1; i >= 0; i--){\n        if (shouldMoveNode(parentNode.children[i], i)) {\n            const childPath = [\n                ...parentPath,\n                i\n            ];\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.moveNodes(editor, {\n                at: childPath,\n                to\n            });\n        }\n    }\n}\n/**\n * This is equivalent to Editor.after except that it ignores points that have no content\n * like the point in a void text node, an empty text node and the last point in a text node\n */ // TODO: this would probably break if you were trying to get the last point in the editor?\nfunction EditorAfterButIgnoringingPointsWithNoContent(editor, at, { distance = 1 } = {}) {\n    const anchor = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.point(editor, at, {\n        edge: \"end\"\n    });\n    const focus = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.end(editor, []);\n    const range = {\n        anchor,\n        focus\n    };\n    let d = 0;\n    let target;\n    for (const p of slate__WEBPACK_IMPORTED_MODULE_7__.Editor.positions(editor, {\n        at: range\n    })){\n        if (d > distance) {\n            break;\n        }\n        // this is the important change\n        const node = slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(editor, p.path);\n        if (node.text.length === p.offset) {\n            continue;\n        }\n        if (d !== 0) {\n            target = p;\n        }\n        d++;\n    }\n    return target;\n}\nfunction nodeTypeMatcher(...args) {\n    if (args.length === 1) {\n        const type = args[0];\n        return (node)=>node.type === type;\n    }\n    const set = new Set(args);\n    return (node)=>typeof node.type === \"string\" && set.has(node.type);\n}\nfunction getAncestorComponentChildFieldDocumentFeatures(editor, editorDocumentFeatures, componentBlocks) {\n    const ancestorComponentProp = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n        match: nodeTypeMatcher(\"component-block-prop\", \"component-inline-prop\")\n    });\n    if (ancestorComponentProp) {\n        const propPath = ancestorComponentProp[0].propPath;\n        const ancestorComponent = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.parent(editor, ancestorComponentProp[1]);\n        if (ancestorComponent[0].type === \"component-block\") {\n            const component = ancestorComponent[0].component;\n            const componentBlock = componentBlocks[component];\n            if (componentBlock && propPath) {\n                const childField = getSchemaAtPropPath(propPath, ancestorComponent[0].props, componentBlock.schema);\n                if ((childField === null || childField === void 0 ? void 0 : childField.kind) === \"child\") {\n                    return getDocumentFeaturesForChildField(editorDocumentFeatures, childField.options);\n                }\n            }\n        }\n    }\n}\n/* eslint-disable */ globalThis.Prism = {\n    manual: true\n};\n/* **********************************************\n     Begin prism-core.js\n********************************************** */ /// <reference lib=\"WebWorker\"/>\nvar _self = globalThis;\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n *\n * @license MIT <https://opensource.org/licenses/MIT>\n * @author Lea Verou <https://lea.verou.me>\n * @namespace\n * @public\n */ var Prism = function(_self) {\n    // Private helper vars\n    var lang = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i;\n    var uniqueId = 0;\n    // The grammar object for plaintext\n    var plainTextGrammar = {};\n    var _ = {\n        /**\n     * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the\n     * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load\n     * additional languages or plugins yourself.\n     *\n     * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.\n     *\n     * You obviously have to change this value before the automatic highlighting started. To do this, you can add an\n     * empty Prism object into the global scope before loading the Prism script like this:\n     *\n     * ```js\n     * window.Prism = window.Prism || {};\n     * Prism.manual = true;\n     * // add a new <script> to load Prism's script\n     * ```\n     *\n     * @default false\n     * @type {boolean}\n     * @memberof Prism\n     * @public\n     */ manual: _self.Prism && _self.Prism.manual,\n        /**\n     * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses\n     * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your\n     * own worker, you don't want it to do this.\n     *\n     * By setting this value to `true`, Prism will not add its own listeners to the worker.\n     *\n     * You obviously have to change this value before Prism executes. To do this, you can add an\n     * empty Prism object into the global scope before loading the Prism script like this:\n     *\n     * ```js\n     * window.Prism = window.Prism || {};\n     * Prism.disableWorkerMessageHandler = true;\n     * // Load Prism's script\n     * ```\n     *\n     * @default false\n     * @type {boolean}\n     * @memberof Prism\n     * @public\n     */ disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,\n        /**\n     * A namespace for utility methods.\n     *\n     * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\n     * change or disappear at any time.\n     *\n     * @namespace\n     * @memberof Prism\n     */ util: {\n            encode: function encode(tokens) {\n                if (tokens instanceof Token) {\n                    return new Token(tokens.type, encode(tokens.content), tokens.alias);\n                } else if (Array.isArray(tokens)) {\n                    return tokens.map(encode);\n                } else {\n                    return tokens.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/\\u00a0/g, \" \");\n                }\n            },\n            /**\n       * Returns the name of the type of the given value.\n       *\n       * @param {any} o\n       * @returns {string}\n       * @example\n       * type(null)      === 'Null'\n       * type(undefined) === 'Undefined'\n       * type(123)       === 'Number'\n       * type('foo')     === 'String'\n       * type(true)      === 'Boolean'\n       * type([1, 2])    === 'Array'\n       * type({})        === 'Object'\n       * type(String)    === 'Function'\n       * type(/abc+/)    === 'RegExp'\n       */ type: function(o) {\n                return Object.prototype.toString.call(o).slice(8, -1);\n            },\n            /**\n       * Returns a unique number for the given object. Later calls will still return the same number.\n       *\n       * @param {Object} obj\n       * @returns {number}\n       */ objId: function(obj) {\n                if (!obj[\"__id\"]) {\n                    Object.defineProperty(obj, \"__id\", {\n                        value: ++uniqueId\n                    });\n                }\n                return obj[\"__id\"];\n            },\n            /**\n       * Creates a deep clone of the given object.\n       *\n       * The main intended use of this function is to clone language definitions.\n       *\n       * @param {T} o\n       * @param {Record<number, any>} [visited]\n       * @returns {T}\n       * @template T\n       */ clone: function deepClone(o, visited) {\n                visited = visited || {};\n                var clone;\n                var id;\n                switch(_.util.type(o)){\n                    case \"Object\":\n                        id = _.util.objId(o);\n                        if (visited[id]) {\n                            return visited[id];\n                        }\n                        clone = /** @type {Record<string, any>} */ {};\n                        visited[id] = clone;\n                        for(var key in o){\n                            if (o.hasOwnProperty(key)) {\n                                clone[key] = deepClone(o[key], visited);\n                            }\n                        }\n                        return /** @type {any} */ clone;\n                    case \"Array\":\n                        id = _.util.objId(o);\n                        if (visited[id]) {\n                            return visited[id];\n                        }\n                        clone = [];\n                        visited[id] = clone;\n                        /** @type {Array} */ /** @type {any} */ o.forEach(function(v, i) {\n                            clone[i] = deepClone(v, visited);\n                        });\n                        return /** @type {any} */ clone;\n                    default:\n                        return o;\n                }\n            },\n            /**\n       * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.\n       *\n       * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.\n       *\n       * @param {Element} element\n       * @returns {string}\n       */ getLanguage: function(element) {\n                while(element){\n                    var m = lang.exec(element.className);\n                    if (m) {\n                        return m[1].toLowerCase();\n                    }\n                    element = element.parentElement;\n                }\n                return \"none\";\n            },\n            /**\n       * Sets the Prism `language-xxxx` class of the given element.\n       *\n       * @param {Element} element\n       * @param {string} language\n       * @returns {void}\n       */ setLanguage: function(element, language) {\n                // remove all `language-xxxx` classes\n                // (this might leave behind a leading space)\n                element.className = element.className.replace(RegExp(lang, \"gi\"), \"\");\n                // add the new `language-xxxx` class\n                // (using `classList` will automatically clean up spaces for us)\n                element.classList.add(\"language-\" + language);\n            },\n            /**\n       * Returns the script element that is currently executing.\n       *\n       * This does __not__ work for line script element.\n       *\n       * @returns {HTMLScriptElement | null}\n       */ currentScript: function() {\n                if (typeof document === \"undefined\") {\n                    return null;\n                }\n                if (\"currentScript\" in document && 1 < 2 /* hack to trip TS' flow analysis */ ) {\n                    return /** @type {any} */ document.currentScript;\n                }\n                // IE11 workaround\n                // we'll get the src of the current script by parsing IE11's error stack trace\n                // this will not work for inline scripts\n                try {\n                    throw new Error();\n                } catch (err) {\n                    // Get file src url from stack. Specifically works with the format of stack traces in IE.\n                    // A stack will look like this:\n                    //\n                    // Error\n                    //    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)\n                    //    at Global code (http://localhost/components/prism-core.js:606:1)\n                    var src = (/at [^(\\r\\n]*\\((.*):[^:]+:[^:]+\\)$/i.exec(err.stack) || [])[1];\n                    if (src) {\n                        var scripts = document.getElementsByTagName(\"script\");\n                        for(var i in scripts){\n                            if (scripts[i].src == src) {\n                                return scripts[i];\n                            }\n                        }\n                    }\n                    return null;\n                }\n            },\n            /**\n       * Returns whether a given class is active for `element`.\n       *\n       * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated\n       * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the\n       * given class is just the given class with a `no-` prefix.\n       *\n       * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is\n       * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its\n       * ancestors have the given class or the negated version of it, then the default activation will be returned.\n       *\n       * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated\n       * version of it, the class is considered active.\n       *\n       * @param {Element} element\n       * @param {string} className\n       * @param {boolean} [defaultActivation=false]\n       * @returns {boolean}\n       */ isActive: function(element, className, defaultActivation) {\n                var no = \"no-\" + className;\n                while(element){\n                    var classList = element.classList;\n                    if (classList.contains(className)) {\n                        return true;\n                    }\n                    if (classList.contains(no)) {\n                        return false;\n                    }\n                    element = element.parentElement;\n                }\n                return !!defaultActivation;\n            }\n        },\n        /**\n     * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\n     *\n     * @namespace\n     * @memberof Prism\n     * @public\n     */ languages: {\n            /**\n       * The grammar for plain, unformatted text.\n       */ plain: plainTextGrammar,\n            plaintext: plainTextGrammar,\n            text: plainTextGrammar,\n            txt: plainTextGrammar,\n            /**\n       * Creates a deep copy of the language with the given id and appends the given tokens.\n       *\n       * If a token in `redef` also appears in the copied language, then the existing token in the copied language\n       * will be overwritten at its original position.\n       *\n       * ## Best practices\n       *\n       * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\n       * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n       * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n       *\n       * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n       * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n       *\n       * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\n       * @param {Grammar} redef The new tokens to append.\n       * @returns {Grammar} The new language created.\n       * @public\n       * @example\n       * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n       *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n       *     // at its original position\n       *     'comment': { ... },\n       *     // CSS doesn't have a 'color' token, so this token will be appended\n       *     'color': /\\b(?:red|green|blue)\\b/\n       * });\n       */ extend: function(id, redef) {\n                var lang = _.util.clone(_.languages[id]);\n                for(var key in redef){\n                    lang[key] = redef[key];\n                }\n                return lang;\n            },\n            /**\n       * Inserts tokens _before_ another token in a language definition or any other grammar.\n       *\n       * ## Usage\n       *\n       * This helper method makes it easy to modify existing languages. For example, the CSS language definition\n       * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n       * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n       * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n       * this:\n       *\n       * ```js\n       * Prism.languages.markup.style = {\n       *     // token\n       * };\n       * ```\n       *\n       * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n       * before existing tokens. For the CSS example above, you would use it like this:\n       *\n       * ```js\n       * Prism.languages.insertBefore('markup', 'cdata', {\n       *     'style': {\n       *         // token\n       *     }\n       * });\n       * ```\n       *\n       * ## Special cases\n       *\n       * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\n       * will be ignored.\n       *\n       * This behavior can be used to insert tokens after `before`:\n       *\n       * ```js\n       * Prism.languages.insertBefore('markup', 'comment', {\n       *     'comment': Prism.languages.markup.comment,\n       *     // tokens after 'comment'\n       * });\n       * ```\n       *\n       * ## Limitations\n       *\n       * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\n       * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\n       * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\n       * deleting properties which is necessary to insert at arbitrary positions.\n       *\n       * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\n       * Instead, it will create a new object and replace all references to the target object with the new one. This\n       * can be done without temporarily deleting properties, so the iteration order is well-defined.\n       *\n       * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\n       * you hold the target object in a variable, then the value of the variable will not change.\n       *\n       * ```js\n       * var oldMarkup = Prism.languages.markup;\n       * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\n       *\n       * assert(oldMarkup !== Prism.languages.markup);\n       * assert(newMarkup === Prism.languages.markup);\n       * ```\n       *\n       * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\n       * object to be modified.\n       * @param {string} before The key to insert before.\n       * @param {Grammar} insert An object containing the key-value pairs to be inserted.\n       * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\n       * object to be modified.\n       *\n       * Defaults to `Prism.languages`.\n       * @returns {Grammar} The new grammar object.\n       * @public\n       */ insertBefore: function(inside, before, insert, root) {\n                root = root || /** @type {any} */ _.languages;\n                var grammar = root[inside];\n                /** @type {Grammar} */ var ret = {};\n                for(var token in grammar){\n                    if (grammar.hasOwnProperty(token)) {\n                        if (token == before) {\n                            for(var newToken in insert){\n                                if (insert.hasOwnProperty(newToken)) {\n                                    ret[newToken] = insert[newToken];\n                                }\n                            }\n                        }\n                        // Do not insert token which also occur in insert. See #1525\n                        if (!insert.hasOwnProperty(token)) {\n                            ret[token] = grammar[token];\n                        }\n                    }\n                }\n                var old = root[inside];\n                root[inside] = ret;\n                // Update references in other language definitions\n                _.languages.DFS(_.languages, function(key, value) {\n                    if (value === old && key != inside) {\n                        this[key] = ret;\n                    }\n                });\n                return ret;\n            },\n            // Traverse a language definition with Depth First Search\n            DFS: function DFS(o, callback, type, visited) {\n                visited = visited || {};\n                var objId = _.util.objId;\n                for(var i in o){\n                    if (o.hasOwnProperty(i)) {\n                        callback.call(o, i, o[i], type || i);\n                        var property = o[i];\n                        var propertyType = _.util.type(property);\n                        if (propertyType === \"Object\" && !visited[objId(property)]) {\n                            visited[objId(property)] = true;\n                            DFS(property, callback, null, visited);\n                        } else if (propertyType === \"Array\" && !visited[objId(property)]) {\n                            visited[objId(property)] = true;\n                            DFS(property, callback, i, visited);\n                        }\n                    }\n                }\n            }\n        },\n        plugins: {},\n        /**\n     * This is the most high-level function in Prisms API.\n     * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on\n     * each one of them.\n     *\n     * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.\n     *\n     * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.\n     * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.\n     * @memberof Prism\n     * @public\n     */ highlightAll: function(async, callback) {\n            _.highlightAllUnder(document, async, callback);\n        },\n        /**\n     * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls\n     * {@link Prism.highlightElement} on each one of them.\n     *\n     * The following hooks will be run:\n     * 1. `before-highlightall`\n     * 2. `before-all-elements-highlight`\n     * 3. All hooks of {@link Prism.highlightElement} for each element.\n     *\n     * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.\n     * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.\n     * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.\n     * @memberof Prism\n     * @public\n     */ highlightAllUnder: function(container, async, callback) {\n            var env = {\n                callback: callback,\n                container: container,\n                selector: 'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'\n            };\n            _.hooks.run(\"before-highlightall\", env);\n            env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));\n            _.hooks.run(\"before-all-elements-highlight\", env);\n            for(var i = 0, element; element = env.elements[i++];){\n                _.highlightElement(element, async === true, env.callback);\n            }\n        },\n        /**\n     * Highlights the code inside a single element.\n     *\n     * The following hooks will be run:\n     * 1. `before-sanity-check`\n     * 2. `before-highlight`\n     * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.\n     * 4. `before-insert`\n     * 5. `after-highlight`\n     * 6. `complete`\n     *\n     * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for\n     * the element's language.\n     *\n     * @param {Element} element The element containing the code.\n     * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.\n     * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers\n     * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is\n     * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).\n     *\n     * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for\n     * asynchronous highlighting to work. You can build your own bundle on the\n     * [Download page](https://prismjs.com/download.html).\n     * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.\n     * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.\n     * @memberof Prism\n     * @public\n     */ highlightElement: function(element, async, callback) {\n            // Find language\n            var language = _.util.getLanguage(element);\n            var grammar = _.languages[language];\n            // Set language on the element, if not present\n            _.util.setLanguage(element, language);\n            // Set language on the parent, for styling\n            var parent = element.parentElement;\n            if (parent && parent.nodeName.toLowerCase() === \"pre\") {\n                _.util.setLanguage(parent, language);\n            }\n            var code = element.textContent;\n            var env = {\n                element: element,\n                language: language,\n                grammar: grammar,\n                code: code\n            };\n            function insertHighlightedCode(highlightedCode) {\n                env.highlightedCode = highlightedCode;\n                _.hooks.run(\"before-insert\", env);\n                env.element.innerHTML = env.highlightedCode;\n                _.hooks.run(\"after-highlight\", env);\n                _.hooks.run(\"complete\", env);\n                callback && callback.call(env.element);\n            }\n            _.hooks.run(\"before-sanity-check\", env);\n            // plugins may change/add the parent/element\n            parent = env.element.parentElement;\n            if (parent && parent.nodeName.toLowerCase() === \"pre\" && !parent.hasAttribute(\"tabindex\")) {\n                parent.setAttribute(\"tabindex\", \"0\");\n            }\n            if (!env.code) {\n                _.hooks.run(\"complete\", env);\n                callback && callback.call(env.element);\n                return;\n            }\n            _.hooks.run(\"before-highlight\", env);\n            if (!env.grammar) {\n                insertHighlightedCode(_.util.encode(env.code));\n                return;\n            }\n            if (async && _self.Worker) {\n                var worker = new Worker(_.filename);\n                worker.onmessage = function(evt) {\n                    insertHighlightedCode(evt.data);\n                };\n                worker.postMessage(JSON.stringify({\n                    language: env.language,\n                    code: env.code,\n                    immediateClose: true\n                }));\n            } else {\n                insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));\n            }\n        },\n        /**\n     * Low-level function, only use if you know what youre doing. It accepts a string of text as input\n     * and the language definitions to use, and returns a string with the HTML produced.\n     *\n     * The following hooks will be run:\n     * 1. `before-tokenize`\n     * 2. `after-tokenize`\n     * 3. `wrap`: On each {@link Token}.\n     *\n     * @param {string} text A string with the code to be highlighted.\n     * @param {Grammar} grammar An object containing the tokens to use.\n     *\n     * Usually a language definition like `Prism.languages.markup`.\n     * @param {string} language The name of the language definition passed to `grammar`.\n     * @returns {string} The highlighted HTML.\n     * @memberof Prism\n     * @public\n     * @example\n     * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\n     */ highlight: function(text, grammar, language) {\n            var env = {\n                code: text,\n                grammar: grammar,\n                language: language\n            };\n            _.hooks.run(\"before-tokenize\", env);\n            if (!env.grammar) {\n                throw new Error('The language \"' + env.language + '\" has no grammar.');\n            }\n            env.tokens = _.tokenize(env.code, env.grammar);\n            _.hooks.run(\"after-tokenize\", env);\n            return Token.stringify(_.util.encode(env.tokens), env.language);\n        },\n        /**\n     * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n     * and the language definitions to use, and returns an array with the tokenized code.\n     *\n     * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n     *\n     * This method could be useful in other contexts as well, as a very crude parser.\n     *\n     * @param {string} text A string with the code to be highlighted.\n     * @param {Grammar} grammar An object containing the tokens to use.\n     *\n     * Usually a language definition like `Prism.languages.markup`.\n     * @returns {TokenStream} An array of strings and tokens, a token stream.\n     * @memberof Prism\n     * @public\n     * @example\n     * let code = `var foo = 0;`;\n     * let tokens = Prism.tokenize(code, Prism.languages.javascript);\n     * tokens.forEach(token => {\n     *     if (token instanceof Prism.Token && token.type === 'number') {\n     *         console.log(`Found numeric literal: ${token.content}`);\n     *     }\n     * });\n     */ tokenize: function(text, grammar) {\n            var rest = grammar.rest;\n            if (rest) {\n                for(var token in rest){\n                    grammar[token] = rest[token];\n                }\n                delete grammar.rest;\n            }\n            var tokenList = new LinkedList();\n            addAfter(tokenList, tokenList.head, text);\n            matchGrammar(text, tokenList, grammar, tokenList.head, 0);\n            return toArray(tokenList);\n        },\n        /**\n     * @namespace\n     * @memberof Prism\n     * @public\n     */ hooks: {\n            all: {},\n            /**\n       * Adds the given callback to the list of callbacks for the given hook.\n       *\n       * The callback will be invoked when the hook it is registered for is run.\n       * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n       *\n       * One callback function can be registered to multiple hooks and the same hook multiple times.\n       *\n       * @param {string} name The name of the hook.\n       * @param {HookCallback} callback The callback function which is given environment variables.\n       * @public\n       */ add: function(name, callback) {\n                var hooks = _.hooks.all;\n                hooks[name] = hooks[name] || [];\n                hooks[name].push(callback);\n            },\n            /**\n       * Runs a hook invoking all registered callbacks with the given environment variables.\n       *\n       * Callbacks will be invoked synchronously and in the order in which they were registered.\n       *\n       * @param {string} name The name of the hook.\n       * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n       * @public\n       */ run: function(name, env) {\n                var callbacks = _.hooks.all[name];\n                if (!callbacks || !callbacks.length) {\n                    return;\n                }\n                for(var i = 0, callback; callback = callbacks[i++];){\n                    callback(env);\n                }\n            }\n        },\n        Token: Token\n    };\n    _self.Prism = _;\n    // Typescript note:\n    // The following can be used to import the Token type in JSDoc:\n    //\n    //   @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n    /**\n   * Creates a new token.\n   *\n   * @param {string} type See {@link Token#type type}\n   * @param {string | TokenStream} content See {@link Token#content content}\n   * @param {string|string[]} [alias] The alias(es) of the token.\n   * @param {string} [matchedStr=\"\"] A copy of the full string this token was created from.\n   * @class\n   * @global\n   * @public\n   */ function Token(type, content, alias, matchedStr) {\n        /**\n     * The type of the token.\n     *\n     * This is usually the key of a pattern in a {@link Grammar}.\n     *\n     * @type {string}\n     * @see GrammarToken\n     * @public\n     */ this.type = type;\n        /**\n     * The strings or tokens contained by this token.\n     *\n     * This will be a token stream if the pattern matched also defined an `inside` grammar.\n     *\n     * @type {string | TokenStream}\n     * @public\n     */ this.content = content;\n        /**\n     * The alias(es) of the token.\n     *\n     * @type {string|string[]}\n     * @see GrammarToken\n     * @public\n     */ this.alias = alias;\n        // Copy of the full string this token was created from\n        this.length = (matchedStr || \"\").length | 0;\n    }\n    /**\n   * A token stream is an array of strings and {@link Token Token} objects.\n   *\n   * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\n   * them.\n   *\n   * 1. No adjacent strings.\n   * 2. No empty strings.\n   *\n   *    The only exception here is the token stream that only contains the empty string and nothing else.\n   *\n   * @typedef {Array<string | Token>} TokenStream\n   * @global\n   * @public\n   */ /**\n   * Converts the given token or token stream to an HTML representation.\n   *\n   * The following hooks will be run:\n   * 1. `wrap`: On each {@link Token}.\n   *\n   * @param {string | Token | TokenStream} o The token or token stream to be converted.\n   * @param {string} language The name of current language.\n   * @returns {string} The HTML representation of the token or token stream.\n   * @memberof Token\n   * @static\n   */ Token.stringify = function stringify(o, language) {\n        if (typeof o == \"string\") {\n            return o;\n        }\n        if (Array.isArray(o)) {\n            var s = \"\";\n            o.forEach(function(e) {\n                s += stringify(e, language);\n            });\n            return s;\n        }\n        var env = {\n            type: o.type,\n            content: stringify(o.content, language),\n            tag: \"span\",\n            classes: [\n                \"token\",\n                o.type\n            ],\n            attributes: {},\n            language: language\n        };\n        var aliases = o.alias;\n        if (aliases) {\n            if (Array.isArray(aliases)) {\n                Array.prototype.push.apply(env.classes, aliases);\n            } else {\n                env.classes.push(aliases);\n            }\n        }\n        _.hooks.run(\"wrap\", env);\n        var attributes = \"\";\n        for(var name in env.attributes){\n            attributes += \" \" + name + '=\"' + (env.attributes[name] || \"\").replace(/\"/g, \"&quot;\") + '\"';\n        }\n        return \"<\" + env.tag + ' class=\"' + env.classes.join(\" \") + '\"' + attributes + \">\" + env.content + \"</\" + env.tag + \">\";\n    };\n    /**\n   * @param {RegExp} pattern\n   * @param {number} pos\n   * @param {string} text\n   * @param {boolean} lookbehind\n   * @returns {RegExpExecArray | null}\n   */ function matchPattern(pattern, pos, text, lookbehind) {\n        pattern.lastIndex = pos;\n        var match = pattern.exec(text);\n        if (match && lookbehind && match[1]) {\n            // change the match to remove the text matched by the Prism lookbehind group\n            var lookbehindLength = match[1].length;\n            match.index += lookbehindLength;\n            match[0] = match[0].slice(lookbehindLength);\n        }\n        return match;\n    }\n    /**\n   * @param {string} text\n   * @param {LinkedList<string | Token>} tokenList\n   * @param {any} grammar\n   * @param {LinkedListNode<string | Token>} startNode\n   * @param {number} startPos\n   * @param {RematchOptions} [rematch]\n   * @returns {void}\n   * @private\n   *\n   * @typedef RematchOptions\n   * @property {string} cause\n   * @property {number} reach\n   */ function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\n        for(var token in grammar){\n            if (!grammar.hasOwnProperty(token) || !grammar[token]) {\n                continue;\n            }\n            var patterns = grammar[token];\n            patterns = Array.isArray(patterns) ? patterns : [\n                patterns\n            ];\n            for(var j = 0; j < patterns.length; ++j){\n                if (rematch && rematch.cause == token + \",\" + j) {\n                    return;\n                }\n                var patternObj = patterns[j];\n                var inside = patternObj.inside;\n                var lookbehind = !!patternObj.lookbehind;\n                var greedy = !!patternObj.greedy;\n                var alias = patternObj.alias;\n                if (greedy && !patternObj.pattern.global) {\n                    // Without the global flag, lastIndex won't work\n                    var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];\n                    patternObj.pattern = RegExp(patternObj.pattern.source, flags + \"g\");\n                }\n                /** @type {RegExp} */ var pattern = patternObj.pattern || patternObj;\n                for(// iterate the token list and keep track of the current token/string position\n                var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next){\n                    if (rematch && pos >= rematch.reach) {\n                        break;\n                    }\n                    var str = currentNode.value;\n                    if (tokenList.length > text.length) {\n                        // Something went terribly wrong, ABORT, ABORT!\n                        return;\n                    }\n                    if (str instanceof Token) {\n                        continue;\n                    }\n                    var removeCount = 1; // this is the to parameter of removeBetween\n                    var match;\n                    if (greedy) {\n                        match = matchPattern(pattern, pos, text, lookbehind);\n                        if (!match || match.index >= text.length) {\n                            break;\n                        }\n                        var from = match.index;\n                        var to = match.index + match[0].length;\n                        var p = pos;\n                        // find the node that contains the match\n                        p += currentNode.value.length;\n                        while(from >= p){\n                            currentNode = currentNode.next;\n                            p += currentNode.value.length;\n                        }\n                        // adjust pos (and p)\n                        p -= currentNode.value.length;\n                        pos = p;\n                        // the current node is a Token, then the match starts inside another Token, which is invalid\n                        if (currentNode.value instanceof Token) {\n                            continue;\n                        }\n                        // find the last node which is affected by this match\n                        for(var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === \"string\"); k = k.next){\n                            removeCount++;\n                            p += k.value.length;\n                        }\n                        removeCount--;\n                        // replace with the new match\n                        str = text.slice(pos, p);\n                        match.index -= pos;\n                    } else {\n                        match = matchPattern(pattern, 0, str, lookbehind);\n                        if (!match) {\n                            continue;\n                        }\n                    }\n                    // eslint-disable-next-line no-redeclare\n                    var from = match.index;\n                    var matchStr = match[0];\n                    var before = str.slice(0, from);\n                    var after = str.slice(from + matchStr.length);\n                    var reach = pos + str.length;\n                    if (rematch && reach > rematch.reach) {\n                        rematch.reach = reach;\n                    }\n                    var removeFrom = currentNode.prev;\n                    if (before) {\n                        removeFrom = addAfter(tokenList, removeFrom, before);\n                        pos += before.length;\n                    }\n                    removeRange(tokenList, removeFrom, removeCount);\n                    var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);\n                    currentNode = addAfter(tokenList, removeFrom, wrapped);\n                    if (after) {\n                        addAfter(tokenList, currentNode, after);\n                    }\n                    if (removeCount > 1) {\n                        // at least one Token object was removed, so we have to do some rematching\n                        // this can only happen if the current pattern is greedy\n                        /** @type {RematchOptions} */ var nestedRematch = {\n                            cause: token + \",\" + j,\n                            reach: reach\n                        };\n                        matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);\n                        // the reach might have been extended because of the rematching\n                        if (rematch && nestedRematch.reach > rematch.reach) {\n                            rematch.reach = nestedRematch.reach;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n   * @typedef LinkedListNode\n   * @property {T} value\n   * @property {LinkedListNode<T> | null} prev The previous node.\n   * @property {LinkedListNode<T> | null} next The next node.\n   * @template T\n   * @private\n   */ /**\n   * @template T\n   * @private\n   */ function LinkedList() {\n        /** @type {LinkedListNode<T>} */ var head = {\n            value: null,\n            prev: null,\n            next: null\n        };\n        /** @type {LinkedListNode<T>} */ var tail = {\n            value: null,\n            prev: head,\n            next: null\n        };\n        head.next = tail;\n        /** @type {LinkedListNode<T>} */ this.head = head;\n        /** @type {LinkedListNode<T>} */ this.tail = tail;\n        this.length = 0;\n    }\n    /**\n   * Adds a new node with the given value to the list.\n   *\n   * @param {LinkedList<T>} list\n   * @param {LinkedListNode<T>} node\n   * @param {T} value\n   * @returns {LinkedListNode<T>} The added node.\n   * @template T\n   */ function addAfter(list, node, value) {\n        // assumes that node != list.tail && values.length >= 0\n        var next = node.next;\n        var newNode = {\n            value: value,\n            prev: node,\n            next: next\n        };\n        node.next = newNode;\n        next.prev = newNode;\n        list.length++;\n        return newNode;\n    }\n    /**\n   * Removes `count` nodes after the given node. The given node will not be removed.\n   *\n   * @param {LinkedList<T>} list\n   * @param {LinkedListNode<T>} node\n   * @param {number} count\n   * @template T\n   */ function removeRange(list, node, count) {\n        var next = node.next;\n        for(var i = 0; i < count && next !== list.tail; i++){\n            next = next.next;\n        }\n        node.next = next;\n        next.prev = node;\n        list.length -= i;\n    }\n    /**\n   * @param {LinkedList<T>} list\n   * @returns {T[]}\n   * @template T\n   */ function toArray(list) {\n        var array = [];\n        var node = list.head.next;\n        while(node !== list.tail){\n            array.push(node.value);\n            node = node.next;\n        }\n        return array;\n    }\n    if (!_self.document) {\n        if (!_self.addEventListener) {\n            // in Node.js\n            return _;\n        }\n        if (!_.disableWorkerMessageHandler) {\n            // In worker\n            _self.addEventListener(\"message\", function(evt) {\n                var message = JSON.parse(evt.data);\n                var lang = message.language;\n                var code = message.code;\n                var immediateClose = message.immediateClose;\n                _self.postMessage(_.highlight(code, _.languages[lang], lang));\n                if (immediateClose) {\n                    _self.close();\n                }\n            }, false);\n        }\n        return _;\n    }\n    // Get current script and highlight\n    var script = _.util.currentScript();\n    if (script) {\n        _.filename = script.src;\n        if (script.hasAttribute(\"data-manual\")) {\n            _.manual = true;\n        }\n    }\n    function highlightAutomaticallyCallback() {\n        if (!_.manual) {\n            _.highlightAll();\n        }\n    }\n    if (!_.manual) {\n        // If the document state is \"loading\", then we'll use DOMContentLoaded.\n        // If the document state is \"interactive\" and the prism.js script is deferred, then we'll also use the\n        // DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they\n        // might take longer one animation frame to execute which can create a race condition where only some plugins have\n        // been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.\n        // See https://github.com/PrismJS/prism/issues/2102\n        var readyState = document.readyState;\n        if (readyState === \"loading\" || readyState === \"interactive\" && script && script.defer) {\n            document.addEventListener(\"DOMContentLoaded\", highlightAutomaticallyCallback);\n        } else {\n            if (window.requestAnimationFrame) {\n                window.requestAnimationFrame(highlightAutomaticallyCallback);\n            } else {\n                window.setTimeout(highlightAutomaticallyCallback, 16);\n            }\n        }\n    }\n    return _;\n}(_self);\n// some additional documentation/types\n/**\n * The expansion of a simple `RegExp` literal to support additional properties.\n *\n * @typedef GrammarToken\n * @property {RegExp} pattern The regular expression of the token.\n * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)\n * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.\n * @property {boolean} [greedy=false] Whether the token is greedy.\n * @property {string|string[]} [alias] An optional alias or list of aliases.\n * @property {Grammar} [inside] The nested grammar of this token.\n *\n * The `inside` grammar will be used to tokenize the text value of each token of this kind.\n *\n * This can be used to make nested and even recursive language definitions.\n *\n * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into\n * each another.\n * @global\n * @public\n */ /**\n * @typedef Grammar\n * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}\n * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.\n * @global\n * @public\n */ /**\n * A function which will invoked after an element was successfully highlighted.\n *\n * @callback HighlightCallback\n * @param {Element} element The element successfully highlighted.\n * @returns {void}\n * @global\n * @public\n */ /**\n * @callback HookCallback\n * @param {Object<string, any>} env The environment variables of the hook.\n * @returns {void}\n * @global\n * @public\n */ /* **********************************************\n     Begin prism-markup.js\n********************************************** */ Prism.languages.markup = {\n    \"comment\": {\n        pattern: /<!--(?:(?!<!--)[\\s\\S])*?-->/,\n        greedy: true\n    },\n    \"prolog\": {\n        pattern: /<\\?[\\s\\S]+?\\?>/,\n        greedy: true\n    },\n    \"doctype\": {\n        // https://www.w3.org/TR/xml/#NT-doctypedecl\n        pattern: /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\\]\\s*)?>/i,\n        greedy: true,\n        inside: {\n            \"internal-subset\": {\n                pattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n                lookbehind: true,\n                greedy: true,\n                inside: null // see below\n            },\n            \"string\": {\n                pattern: /\"[^\"]*\"|'[^']*'/,\n                greedy: true\n            },\n            \"punctuation\": /^<!|>$|[[\\]]/,\n            \"doctype-tag\": /^DOCTYPE/i,\n            \"name\": /[^\\s<>'\"]+/\n        }\n    },\n    \"cdata\": {\n        pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n        greedy: true\n    },\n    \"tag\": {\n        pattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n        greedy: true,\n        inside: {\n            \"tag\": {\n                pattern: /^<\\/?[^\\s>\\/]+/,\n                inside: {\n                    \"punctuation\": /^<\\/?/,\n                    \"namespace\": /^[^\\s>\\/:]+:/\n                }\n            },\n            \"special-attr\": [],\n            \"attr-value\": {\n                pattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n                inside: {\n                    \"punctuation\": [\n                        {\n                            pattern: /^=/,\n                            alias: \"attr-equals\"\n                        },\n                        {\n                            pattern: /^(\\s*)[\"']|[\"']$/,\n                            lookbehind: true\n                        }\n                    ]\n                }\n            },\n            \"punctuation\": /\\/?>/,\n            \"attr-name\": {\n                pattern: /[^\\s>\\/]+/,\n                inside: {\n                    \"namespace\": /^[^\\s>\\/:]+:/\n                }\n            }\n        }\n    },\n    \"entity\": [\n        {\n            pattern: /&[\\da-z]{1,8};/i,\n            alias: \"named-entity\"\n        },\n        /&#x?[\\da-f]{1,8};/i\n    ]\n};\nPrism.languages.markup[\"tag\"].inside[\"attr-value\"].inside[\"entity\"] = Prism.languages.markup[\"entity\"];\nPrism.languages.markup[\"doctype\"].inside[\"internal-subset\"].inside = Prism.languages.markup;\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add(\"wrap\", function(env) {\n    if (env.type === \"entity\") {\n        env.attributes[\"title\"] = env.content.replace(/&amp;/, \"&\");\n    }\n});\nObject.defineProperty(Prism.languages.markup.tag, \"addInlined\", {\n    /**\n   * Adds an inlined language to markup.\n   *\n   * An example of an inlined language is CSS with `<style>` tags.\n   *\n   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n   * case insensitive.\n   * @param {string} lang The language key.\n   * @example\n   * addInlined('style', 'css');\n   */ value: function addInlined(tagName, lang) {\n        var includedCdataInside = {};\n        includedCdataInside[\"language-\" + lang] = {\n            pattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n            lookbehind: true,\n            inside: Prism.languages[lang]\n        };\n        includedCdataInside[\"cdata\"] = /^<!\\[CDATA\\[|\\]\\]>$/i;\n        var inside = {\n            \"included-cdata\": {\n                pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n                inside: includedCdataInside\n            }\n        };\n        inside[\"language-\" + lang] = {\n            pattern: /[\\s\\S]+/,\n            inside: Prism.languages[lang]\n        };\n        var def = {};\n        def[tagName] = {\n            pattern: RegExp(/(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(/__/g, function() {\n                return tagName;\n            }), \"i\"),\n            lookbehind: true,\n            greedy: true,\n            inside: inside\n        };\n        Prism.languages.insertBefore(\"markup\", \"cdata\", def);\n    }\n});\nObject.defineProperty(Prism.languages.markup.tag, \"addAttribute\", {\n    /**\n   * Adds an pattern to highlight languages embedded in HTML attributes.\n   *\n   * An example of an inlined language is CSS with `style` attributes.\n   *\n   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n   * case insensitive.\n   * @param {string} lang The language key.\n   * @example\n   * addAttribute('style', 'css');\n   */ value: function(attrName, lang) {\n        Prism.languages.markup.tag.inside[\"special-attr\"].push({\n            pattern: RegExp(/(^|[\"'\\s])/.source + \"(?:\" + attrName + \")\" + /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source, \"i\"),\n            lookbehind: true,\n            inside: {\n                \"attr-name\": /^[^\\s=]+/,\n                \"attr-value\": {\n                    pattern: /=[\\s\\S]+/,\n                    inside: {\n                        \"value\": {\n                            pattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n                            lookbehind: true,\n                            alias: [\n                                lang,\n                                \"language-\" + lang\n                            ],\n                            inside: Prism.languages[lang]\n                        },\n                        \"punctuation\": [\n                            {\n                                pattern: /^=/,\n                                alias: \"attr-equals\"\n                            },\n                            /\"|'/\n                        ]\n                    }\n                }\n            }\n        });\n    }\n});\nPrism.languages.html = Prism.languages.markup;\nPrism.languages.mathml = Prism.languages.markup;\nPrism.languages.svg = Prism.languages.markup;\nPrism.languages.xml = Prism.languages.extend(\"markup\", {});\nPrism.languages.ssml = Prism.languages.xml;\nPrism.languages.atom = Prism.languages.xml;\nPrism.languages.rss = Prism.languages.xml;\n/* **********************************************\n     Begin prism-css.js\n********************************************** */ (function(Prism) {\n    var string = /(?:\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;\n    Prism.languages.css = {\n        \"comment\": /\\/\\*[\\s\\S]*?\\*\\//,\n        \"atrule\": {\n            pattern: RegExp(\"@[\\\\w-](?:\" + /[^;{\\s\"']|\\s+(?!\\s)/.source + \"|\" + string.source + \")*?\" + /(?:;|(?=\\s*\\{))/.source),\n            inside: {\n                \"rule\": /^@[\\w-]+/,\n                \"selector-function-argument\": {\n                    pattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n                    lookbehind: true,\n                    alias: \"selector\"\n                },\n                \"keyword\": {\n                    pattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n                    lookbehind: true\n                }\n            }\n        },\n        \"url\": {\n            // https://drafts.csswg.org/css-values-3/#urls\n            pattern: RegExp(\"\\\\burl\\\\((?:\" + string.source + \"|\" + /(?:[^\\\\\\r\\n()\"']|\\\\[\\s\\S])*/.source + \")\\\\)\", \"i\"),\n            greedy: true,\n            inside: {\n                \"function\": /^url/i,\n                \"punctuation\": /^\\(|\\)$/,\n                \"string\": {\n                    pattern: RegExp(\"^\" + string.source + \"$\"),\n                    alias: \"url\"\n                }\n            }\n        },\n        \"selector\": {\n            pattern: RegExp(\"(^|[{}\\\\s])[^{}\\\\s](?:[^{};\\\"'\\\\s]|\\\\s+(?![\\\\s{])|\" + string.source + \")*(?=\\\\s*\\\\{)\"),\n            lookbehind: true\n        },\n        \"string\": {\n            pattern: string,\n            greedy: true\n        },\n        \"property\": {\n            pattern: /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n            lookbehind: true\n        },\n        \"important\": /!important\\b/i,\n        \"function\": {\n            pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n            lookbehind: true\n        },\n        \"punctuation\": /[(){};:,]/\n    };\n    Prism.languages.css[\"atrule\"].inside.rest = Prism.languages.css;\n    var markup = Prism.languages.markup;\n    if (markup) {\n        markup.tag.addInlined(\"style\", \"css\");\n        markup.tag.addAttribute(\"style\", \"css\");\n    }\n})(Prism);\n/* **********************************************\n     Begin prism-clike.js\n********************************************** */ Prism.languages.clike = {\n    \"comment\": [\n        {\n            pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n            lookbehind: true,\n            greedy: true\n        },\n        {\n            pattern: /(^|[^\\\\:])\\/\\/.*/,\n            lookbehind: true,\n            greedy: true\n        }\n    ],\n    \"string\": {\n        pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n        greedy: true\n    },\n    \"class-name\": {\n        pattern: /(\\b(?:class|extends|implements|instanceof|interface|new|trait)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n        lookbehind: true,\n        inside: {\n            \"punctuation\": /[.\\\\]/\n        }\n    },\n    \"keyword\": /\\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\\b/,\n    \"boolean\": /\\b(?:false|true)\\b/,\n    \"function\": /\\b\\w+(?=\\()/,\n    \"number\": /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n    \"operator\": /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n    \"punctuation\": /[{}[\\];(),.:]/\n};\n/* **********************************************\n     Begin prism-javascript.js\n********************************************** */ Prism.languages.javascript = Prism.languages.extend(\"clike\", {\n    \"class-name\": [\n        Prism.languages.clike[\"class-name\"],\n        {\n            pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:constructor|prototype))/,\n            lookbehind: true\n        }\n    ],\n    \"keyword\": [\n        {\n            pattern: /((?:^|\\})\\s*)catch\\b/,\n            lookbehind: true\n        },\n        {\n            pattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['\"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n            lookbehind: true\n        }\n    ],\n    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n    \"function\": /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n    \"number\": {\n        pattern: RegExp(/(^|[^\\w$])/.source + \"(?:\" + // constant\n        (/NaN|Infinity/.source + \"|\" + // binary integer\n        /0[bB][01]+(?:_[01]+)*n?/.source + \"|\" + // octal integer\n        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + \"|\" + // hexadecimal integer\n        /0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?/.source + \"|\" + // decimal bigint\n        /\\d+(?:_\\d+)*n/.source + \"|\" + // decimal number (integer or float) but no bigint\n        /(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?/.source) + \")\" + /(?![\\w$])/.source),\n        lookbehind: true\n    },\n    \"operator\": /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n});\nPrism.languages.javascript[\"class-name\"][0].pattern = /(\\b(?:class|extends|implements|instanceof|interface|new)\\s+)[\\w.\\\\]+/;\nPrism.languages.insertBefore(\"javascript\", \"keyword\", {\n    \"regex\": {\n        pattern: RegExp(// lookbehind\n        // eslint-disable-next-line regexp/no-dupe-characters-character-class\n        /((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)/.source + // Regex pattern:\n        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character\n        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible\n        // with the only syntax, so we have to define 2 different regex patterns.\n        /\\//.source + \"(?:\" + /(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}/.source + \"|\" + // `v` flag syntax. This supports 3 levels of nested character classes.\n        /(?:\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.)*\\])*\\])*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + \")\" + // lookahead\n        /(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/.source),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n            \"regex-source\": {\n                pattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n                lookbehind: true,\n                alias: \"language-regex\",\n                inside: Prism.languages.regex\n            },\n            \"regex-delimiter\": /^\\/|\\/$/,\n            \"regex-flags\": /^[a-z]+$/\n        }\n    },\n    // This must be declared before keyword because we use \"function\" inside the look-forward\n    \"function-variable\": {\n        pattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n        alias: \"function\"\n    },\n    \"parameter\": [\n        {\n            pattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n            lookbehind: true,\n            inside: Prism.languages.javascript\n        },\n        {\n            pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n            lookbehind: true,\n            inside: Prism.languages.javascript\n        },\n        {\n            pattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n            lookbehind: true,\n            inside: Prism.languages.javascript\n        },\n        {\n            pattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n            lookbehind: true,\n            inside: Prism.languages.javascript\n        }\n    ],\n    \"constant\": /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n});\nPrism.languages.insertBefore(\"javascript\", \"string\", {\n    \"hashbang\": {\n        pattern: /^#!.*/,\n        greedy: true,\n        alias: \"comment\"\n    },\n    \"template-string\": {\n        pattern: /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n        greedy: true,\n        inside: {\n            \"template-punctuation\": {\n                pattern: /^`|`$/,\n                alias: \"string\"\n            },\n            \"interpolation\": {\n                pattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n                lookbehind: true,\n                inside: {\n                    \"interpolation-punctuation\": {\n                        pattern: /^\\$\\{|\\}$/,\n                        alias: \"punctuation\"\n                    },\n                    rest: Prism.languages.javascript\n                }\n            },\n            \"string\": /[\\s\\S]+/\n        }\n    },\n    \"string-property\": {\n        pattern: /((?:^|[,{])[ \\t]*)([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2(?=\\s*:)/m,\n        lookbehind: true,\n        greedy: true,\n        alias: \"property\"\n    }\n});\nPrism.languages.insertBefore(\"javascript\", \"operator\", {\n    \"literal-property\": {\n        pattern: /((?:^|[,{])[ \\t]*)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/m,\n        lookbehind: true,\n        alias: \"property\"\n    }\n});\nif (Prism.languages.markup) {\n    Prism.languages.markup.tag.addInlined(\"script\", \"javascript\");\n    // add attribute support for all DOM events.\n    // https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events\n    Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, \"javascript\");\n}\nPrism.languages.js = Prism.languages.javascript;\n/* **********************************************\n     Begin prism-file-highlight.js\n********************************************** */ (function() {\n    if (typeof Prism === \"undefined\" || typeof document === \"undefined\") {\n        return;\n    }\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill\n    if (!Element.prototype.matches) {\n        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n    }\n    var LOADING_MESSAGE = \"Loading\";\n    var FAILURE_MESSAGE = function(status, message) {\n        return \" Error \" + status + \" while fetching file: \" + message;\n    };\n    var FAILURE_EMPTY_MESSAGE = \" Error: File does not exist or is empty\";\n    var EXTENSIONS = {\n        \"js\": \"javascript\",\n        \"py\": \"python\",\n        \"rb\": \"ruby\",\n        \"ps1\": \"powershell\",\n        \"psm1\": \"powershell\",\n        \"sh\": \"bash\",\n        \"bat\": \"batch\",\n        \"h\": \"c\",\n        \"tex\": \"latex\"\n    };\n    var STATUS_ATTR = \"data-src-status\";\n    var STATUS_LOADING = \"loading\";\n    var STATUS_LOADED = \"loaded\";\n    var STATUS_FAILED = \"failed\";\n    var SELECTOR = \"pre[data-src]:not([\" + STATUS_ATTR + '=\"' + STATUS_LOADED + '\"])' + \":not([\" + STATUS_ATTR + '=\"' + STATUS_LOADING + '\"])';\n    /**\n   * Loads the given file.\n   *\n   * @param {string} src The URL or path of the source file to load.\n   * @param {(result: string) => void} success\n   * @param {(reason: string) => void} error\n   */ function loadFile(src, success, error) {\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", src, true);\n        xhr.onreadystatechange = function() {\n            if (xhr.readyState == 4) {\n                if (xhr.status < 400 && xhr.responseText) {\n                    success(xhr.responseText);\n                } else {\n                    if (xhr.status >= 400) {\n                        error(FAILURE_MESSAGE(xhr.status, xhr.statusText));\n                    } else {\n                        error(FAILURE_EMPTY_MESSAGE);\n                    }\n                }\n            }\n        };\n        xhr.send(null);\n    }\n    /**\n   * Parses the given range.\n   *\n   * This returns a range with inclusive ends.\n   *\n   * @param {string | null | undefined} range\n   * @returns {[number, number | undefined] | undefined}\n   */ function parseRange(range) {\n        var m = /^\\s*(\\d+)\\s*(?:(,)\\s*(?:(\\d+)\\s*)?)?$/.exec(range || \"\");\n        if (m) {\n            var start = Number(m[1]);\n            var comma = m[2];\n            var end = m[3];\n            if (!comma) {\n                return [\n                    start,\n                    start\n                ];\n            }\n            if (!end) {\n                return [\n                    start,\n                    undefined\n                ];\n            }\n            return [\n                start,\n                Number(end)\n            ];\n        }\n        return undefined;\n    }\n    Prism.hooks.add(\"before-highlightall\", function(env) {\n        env.selector += \", \" + SELECTOR;\n    });\n    Prism.hooks.add(\"before-sanity-check\", function(env) {\n        var pre = /** @type {HTMLPreElement} */ env.element;\n        if (pre.matches(SELECTOR)) {\n            env.code = \"\"; // fast-path the whole thing and go to complete\n            pre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading\n            // add code element with loading message\n            var code = pre.appendChild(document.createElement(\"CODE\"));\n            code.textContent = LOADING_MESSAGE;\n            var src = pre.getAttribute(\"data-src\");\n            var language = env.language;\n            if (language === \"none\") {\n                // the language might be 'none' because there is no language set;\n                // in this case, we want to use the extension as the language\n                var extension = (/\\.(\\w+)$/.exec(src) || [\n                    ,\n                    \"none\"\n                ])[1];\n                language = EXTENSIONS[extension] || extension;\n            }\n            // set language classes\n            Prism.util.setLanguage(code, language);\n            Prism.util.setLanguage(pre, language);\n            // preload the language\n            var autoloader = Prism.plugins.autoloader;\n            if (autoloader) {\n                autoloader.loadLanguages(language);\n            }\n            // load file\n            loadFile(src, function(text) {\n                // mark as loaded\n                pre.setAttribute(STATUS_ATTR, STATUS_LOADED);\n                // handle data-range\n                var range = parseRange(pre.getAttribute(\"data-range\"));\n                if (range) {\n                    var lines = text.split(/\\r\\n?|\\n/g);\n                    // the range is one-based and inclusive on both ends\n                    var start = range[0];\n                    var end = range[1] == null ? lines.length : range[1];\n                    if (start < 0) {\n                        start += lines.length;\n                    }\n                    start = Math.max(0, Math.min(start - 1, lines.length));\n                    if (end < 0) {\n                        end += lines.length;\n                    }\n                    end = Math.max(0, Math.min(end, lines.length));\n                    text = lines.slice(start, end).join(\"\\n\");\n                    // add data-start for line numbers\n                    if (!pre.hasAttribute(\"data-start\")) {\n                        pre.setAttribute(\"data-start\", String(start + 1));\n                    }\n                }\n                // highlight code\n                code.textContent = text;\n                Prism.highlightElement(code);\n            }, function(error) {\n                // mark as failed\n                pre.setAttribute(STATUS_ATTR, STATUS_FAILED);\n                code.textContent = error;\n            });\n        }\n    });\n    Prism.plugins.fileHighlight = {\n        /**\n     * Executes the File Highlight plugin for all matching `pre` elements under the given container.\n     *\n     * Note: Elements which are already loaded or currently loading will not be touched by this method.\n     *\n     * @param {ParentNode} [container=document]\n     */ highlight: function highlight(container) {\n            var elements = (container || document).querySelectorAll(SELECTOR);\n            for(var i = 0, element; element = elements[i++];){\n                Prism.highlightElement(element);\n            }\n        }\n    };\n    var logged = false;\n    /** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */ Prism.fileHighlight = function() {\n        if (!logged) {\n            console.warn(\"Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.\");\n            logged = true;\n        }\n        Prism.plugins.fileHighlight.highlight.apply(this, arguments);\n    };\n})();\nPrism.languages.clike = {\n    \"comment\": [\n        {\n            pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n            lookbehind: true,\n            greedy: true\n        },\n        {\n            pattern: /(^|[^\\\\:])\\/\\/.*/,\n            lookbehind: true,\n            greedy: true\n        }\n    ],\n    \"string\": {\n        pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n        greedy: true\n    },\n    \"class-name\": {\n        pattern: /(\\b(?:class|extends|implements|instanceof|interface|new|trait)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n        lookbehind: true,\n        inside: {\n            \"punctuation\": /[.\\\\]/\n        }\n    },\n    \"keyword\": /\\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\\b/,\n    \"boolean\": /\\b(?:false|true)\\b/,\n    \"function\": /\\b\\w+(?=\\()/,\n    \"number\": /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n    \"operator\": /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n    \"punctuation\": /[{}[\\];(),.:]/\n};\nPrism.languages.c = Prism.languages.extend(\"clike\", {\n    \"comment\": {\n        pattern: /\\/\\/(?:[^\\r\\n\\\\]|\\\\(?:\\r\\n?|\\n|(?![\\r\\n])))*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n        greedy: true\n    },\n    \"string\": {\n        // https://en.cppreference.com/w/c/language/string_literal\n        pattern: /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"/,\n        greedy: true\n    },\n    \"class-name\": {\n        pattern: /(\\b(?:enum|struct)\\s+(?:__attribute__\\s*\\(\\([\\s\\S]*?\\)\\)\\s*)?)\\w+|\\b[a-z]\\w*_t\\b/,\n        lookbehind: true\n    },\n    \"keyword\": /\\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\\b/,\n    \"function\": /\\b[a-z_]\\w*(?=\\s*\\()/i,\n    \"number\": /(?:\\b0x(?:[\\da-f]+(?:\\.[\\da-f]*)?|\\.[\\da-f]+)(?:p[+-]?\\d+)?|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)[ful]{0,4}/i,\n    \"operator\": />>=?|<<=?|->|([-+&|:])\\1|[?:~]|[-+*/%&|^!=<>]=?/\n});\nPrism.languages.insertBefore(\"c\", \"string\", {\n    \"char\": {\n        // https://en.cppreference.com/w/c/language/character_constant\n        pattern: /'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n]){0,32}'/,\n        greedy: true\n    }\n});\nPrism.languages.insertBefore(\"c\", \"string\", {\n    \"macro\": {\n        // allow for multiline macro definitions\n        // spaces after the # character compile fine with gcc\n        pattern: /(^[\\t ]*)#\\s*[a-z](?:[^\\r\\n\\\\/]|\\/(?!\\*)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|\\\\(?:\\r\\n|[\\s\\S]))*/im,\n        lookbehind: true,\n        greedy: true,\n        alias: \"property\",\n        inside: {\n            \"string\": [\n                {\n                    // highlight the path of the include statement as a string\n                    pattern: /^(#\\s*include\\s*)<[^>]+>/,\n                    lookbehind: true\n                },\n                Prism.languages.c[\"string\"]\n            ],\n            \"char\": Prism.languages.c[\"char\"],\n            \"comment\": Prism.languages.c[\"comment\"],\n            \"macro-name\": [\n                {\n                    pattern: /(^#\\s*define\\s+)\\w+\\b(?!\\()/i,\n                    lookbehind: true\n                },\n                {\n                    pattern: /(^#\\s*define\\s+)\\w+\\b(?=\\()/i,\n                    lookbehind: true,\n                    alias: \"function\"\n                }\n            ],\n            // highlight macro directives as keywords\n            \"directive\": {\n                pattern: /^(#\\s*)[a-z]+/,\n                lookbehind: true,\n                alias: \"keyword\"\n            },\n            \"directive-hash\": /^#/,\n            \"punctuation\": /##|\\\\(?=[\\r\\n])/,\n            \"expression\": {\n                pattern: /\\S[\\s\\S]*/,\n                inside: Prism.languages.c\n            }\n        }\n    }\n});\nPrism.languages.insertBefore(\"c\", \"function\", {\n    // highlight predefined macros as constants\n    \"constant\": /\\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\\b/\n});\ndelete Prism.languages.c[\"boolean\"];\n(function(Prism) {\n    var keyword = /\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/;\n    var modName = /\\b(?!<keyword>)\\w+(?:\\s*\\.\\s*\\w+)*\\b/.source.replace(/<keyword>/g, function() {\n        return keyword.source;\n    });\n    Prism.languages.cpp = Prism.languages.extend(\"c\", {\n        \"class-name\": [\n            {\n                pattern: RegExp(/(\\b(?:class|concept|enum|struct|typename)\\s+)(?!<keyword>)\\w+/.source.replace(/<keyword>/g, function() {\n                    return keyword.source;\n                })),\n                lookbehind: true\n            },\n            // This is intended to capture the class name of method implementations like:\n            //   void foo::bar() const {}\n            // However! The `foo` in the above example could also be a namespace, so we only capture the class name if\n            // it starts with an uppercase letter. This approximation should give decent results.\n            /\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/,\n            // This will capture the class name before destructors like:\n            //   Foo::~Foo() {}\n            /\\b[A-Z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i,\n            // This also intends to capture the class name of method implementations but here the class has template\n            // parameters, so it can't be a namespace (until C++ adds generic namespaces).\n            /\\b\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/\n        ],\n        \"keyword\": keyword,\n        \"number\": {\n            pattern: /(?:\\b0b[01']+|\\b0x(?:[\\da-f']+(?:\\.[\\da-f']*)?|\\.[\\da-f']+)(?:p[+-]?[\\d']+)?|(?:\\b[\\d']+(?:\\.[\\d']*)?|\\B\\.[\\d']+)(?:e[+-]?[\\d']+)?)[ful]{0,4}/i,\n            greedy: true\n        },\n        \"operator\": />>=?|<<=?|->|--|\\+\\+|&&|\\|\\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/,\n        \"boolean\": /\\b(?:false|true)\\b/\n    });\n    Prism.languages.insertBefore(\"cpp\", \"string\", {\n        \"module\": {\n            // https://en.cppreference.com/w/cpp/language/modules\n            pattern: RegExp(/(\\b(?:import|module)\\s+)/.source + \"(?:\" + // header-name\n            /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|<[^<>\\r\\n]*>/.source + \"|\" + // module name or partition or both\n            /<mod-name>(?:\\s*:\\s*<mod-name>)?|:\\s*<mod-name>/.source.replace(/<mod-name>/g, function() {\n                return modName;\n            }) + \")\"),\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"string\": /^[<\"][\\s\\S]+/,\n                \"operator\": /:/,\n                \"punctuation\": /\\./\n            }\n        },\n        \"raw-string\": {\n            pattern: /R\"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1\"/,\n            alias: \"string\",\n            greedy: true\n        }\n    });\n    Prism.languages.insertBefore(\"cpp\", \"keyword\", {\n        \"generic-function\": {\n            pattern: /\\b(?!operator\\b)[a-z_]\\w*\\s*<(?:[^<>]|<[^<>]*>)*>(?=\\s*\\()/i,\n            inside: {\n                \"function\": /^\\w+/,\n                \"generic\": {\n                    pattern: /<[\\s\\S]+/,\n                    alias: \"class-name\",\n                    inside: Prism.languages.cpp\n                }\n            }\n        }\n    });\n    Prism.languages.insertBefore(\"cpp\", \"operator\", {\n        \"double-colon\": {\n            pattern: /::/,\n            alias: \"punctuation\"\n        }\n    });\n    Prism.languages.insertBefore(\"cpp\", \"class-name\", {\n        // the base clause is an optional list of parent classes\n        // https://en.cppreference.com/w/cpp/language/class\n        \"base-clause\": {\n            pattern: /(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)[^;{}\"'\\s]+(?:\\s+[^;{}\"'\\s]+)*(?=\\s*[;{])/,\n            lookbehind: true,\n            greedy: true,\n            inside: Prism.languages.extend(\"cpp\", {})\n        }\n    });\n    Prism.languages.insertBefore(\"inside\", \"double-colon\", {\n        // All untokenized words that are not namespaces should be class names\n        \"class-name\": /\\b[a-z_]\\w*\\b(?!\\s*::)/i\n    }, Prism.languages.cpp[\"base-clause\"]);\n})(Prism);\nPrism.languages.arduino = Prism.languages.extend(\"cpp\", {\n    \"keyword\": /\\b(?:String|array|bool|boolean|break|byte|case|catch|continue|default|do|double|else|finally|for|function|goto|if|in|instanceof|int|integer|long|loop|new|null|return|setup|string|switch|throw|try|void|while|word)\\b/,\n    \"constant\": /\\b(?:ANALOG_MESSAGE|DEFAULT|DIGITAL_MESSAGE|EXTERNAL|FIRMATA_STRING|HIGH|INPUT|INPUT_PULLUP|INTERNAL|INTERNAL1V1|INTERNAL2V56|LED_BUILTIN|LOW|OUTPUT|REPORT_ANALOG|REPORT_DIGITAL|SET_PIN_MODE|SYSEX_START|SYSTEM_RESET)\\b/,\n    \"builtin\": /\\b(?:Audio|BSSID|Bridge|Client|Console|EEPROM|Esplora|EsploraTFT|Ethernet|EthernetClient|EthernetServer|EthernetUDP|File|FileIO|FileSystem|Firmata|GPRS|GSM|GSMBand|GSMClient|GSMModem|GSMPIN|GSMScanner|GSMServer|GSMVoiceCall|GSM_SMS|HttpClient|IPAddress|IRread|Keyboard|KeyboardController|LiquidCrystal|LiquidCrystal_I2C|Mailbox|Mouse|MouseController|PImage|Process|RSSI|RobotControl|RobotMotor|SD|SPI|SSID|Scheduler|Serial|Server|Servo|SoftwareSerial|Stepper|Stream|TFT|Task|USBHost|WiFi|WiFiClient|WiFiServer|WiFiUDP|Wire|YunClient|YunServer|abs|addParameter|analogRead|analogReadResolution|analogReference|analogWrite|analogWriteResolution|answerCall|attach|attachGPRS|attachInterrupt|attached|autoscroll|available|background|beep|begin|beginPacket|beginSD|beginSMS|beginSpeaker|beginTFT|beginTransmission|beginWrite|bit|bitClear|bitRead|bitSet|bitWrite|blink|blinkVersion|buffer|changePIN|checkPIN|checkPUK|checkReg|circle|cityNameRead|cityNameWrite|clear|clearScreen|click|close|compassRead|config|connect|connected|constrain|cos|countryNameRead|countryNameWrite|createChar|cursor|debugPrint|delay|delayMicroseconds|detach|detachInterrupt|digitalRead|digitalWrite|disconnect|display|displayLogos|drawBMP|drawCompass|encryptionType|end|endPacket|endSMS|endTransmission|endWrite|exists|exitValue|fill|find|findUntil|flush|gatewayIP|get|getAsynchronously|getBand|getButton|getCurrentCarrier|getIMEI|getKey|getModifiers|getOemKey|getPINUsed|getResult|getSignalStrength|getSocket|getVoiceCallStatus|getXChange|getYChange|hangCall|height|highByte|home|image|interrupts|isActionDone|isDirectory|isListening|isPIN|isPressed|isValid|keyPressed|keyReleased|keyboardRead|knobRead|leftToRight|line|lineFollowConfig|listen|listenOnLocalhost|loadImage|localIP|lowByte|macAddress|maintain|map|max|messageAvailable|micros|millis|min|mkdir|motorsStop|motorsWrite|mouseDragged|mouseMoved|mousePressed|mouseReleased|move|noAutoscroll|noBlink|noBuffer|noCursor|noDisplay|noFill|noInterrupts|noListenOnLocalhost|noStroke|noTone|onReceive|onRequest|open|openNextFile|overflow|parseCommand|parseFloat|parseInt|parsePacket|pauseMode|peek|pinMode|playFile|playMelody|point|pointTo|position|pow|prepare|press|print|printFirmwareVersion|printVersion|println|process|processInput|pulseIn|put|random|randomSeed|read|readAccelerometer|readBlue|readButton|readBytes|readBytesUntil|readGreen|readJoystickButton|readJoystickSwitch|readJoystickX|readJoystickY|readLightSensor|readMessage|readMicrophone|readNetworks|readRed|readSlider|readString|readStringUntil|readTemperature|ready|rect|release|releaseAll|remoteIP|remoteNumber|remotePort|remove|requestFrom|retrieveCallingNumber|rewindDirectory|rightToLeft|rmdir|robotNameRead|robotNameWrite|run|runAsynchronously|runShellCommand|runShellCommandAsynchronously|running|scanNetworks|scrollDisplayLeft|scrollDisplayRight|seek|sendAnalog|sendDigitalPortPair|sendDigitalPorts|sendString|sendSysex|serialEvent|setBand|setBitOrder|setClockDivider|setCursor|setDNS|setDataMode|setFirmwareVersion|setMode|setPINUsed|setSpeed|setTextSize|setTimeout|shiftIn|shiftOut|shutdown|sin|size|sqrt|startLoop|step|stop|stroke|subnetMask|switchPIN|tan|tempoWrite|text|tone|transfer|tuneWrite|turn|updateIR|userNameRead|userNameWrite|voiceCall|waitContinue|width|write|writeBlue|writeGreen|writeJSON|writeMessage|writeMicroseconds|writeRGB|writeRed|yield)\\b/\n});\nPrism.languages.ino = Prism.languages.arduino;\n(function(Prism) {\n    // $ set | grep '^[A-Z][^[:space:]]*=' | cut -d= -f1 | tr '\\n' '|'\n    // + LC_ALL, RANDOM, REPLY, SECONDS.\n    // + make sure PS1..4 are here as they are not always set,\n    // - some useless things.\n    var envVars = \"\\\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\\\b\";\n    var commandAfterHeredoc = {\n        pattern: /(^([\"']?)\\w+\\2)[ \\t]+\\S.*/,\n        lookbehind: true,\n        alias: \"punctuation\",\n        // this looks reasonably well in all themes\n        inside: null // see below\n    };\n    var insideString = {\n        \"bash\": commandAfterHeredoc,\n        \"environment\": {\n            pattern: RegExp(\"\\\\$\" + envVars),\n            alias: \"constant\"\n        },\n        \"variable\": [\n            // [0]: Arithmetic Environment\n            {\n                pattern: /\\$?\\(\\([\\s\\S]+?\\)\\)/,\n                greedy: true,\n                inside: {\n                    // If there is a $ sign at the beginning highlight $(( and )) as variable\n                    \"variable\": [\n                        {\n                            pattern: /(^\\$\\(\\([\\s\\S]+)\\)\\)/,\n                            lookbehind: true\n                        },\n                        /^\\$\\(\\(/\n                    ],\n                    \"number\": /\\b0x[\\dA-Fa-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[Ee]-?\\d+)?/,\n                    // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic\n                    \"operator\": /--|\\+\\+|\\*\\*=?|<<=?|>>=?|&&|\\|\\||[=!+\\-*/%<>^&|]=?|[?~:]/,\n                    // If there is no $ sign at the beginning highlight (( and )) as punctuation\n                    \"punctuation\": /\\(\\(?|\\)\\)?|,|;/\n                }\n            },\n            // [1]: Command Substitution\n            {\n                pattern: /\\$\\((?:\\([^)]+\\)|[^()])+\\)|`[^`]+`/,\n                greedy: true,\n                inside: {\n                    \"variable\": /^\\$\\(|^`|\\)$|`$/\n                }\n            },\n            // [2]: Brace expansion\n            {\n                pattern: /\\$\\{[^}]+\\}/,\n                greedy: true,\n                inside: {\n                    \"operator\": /:[-=?+]?|[!\\/]|##?|%%?|\\^\\^?|,,?/,\n                    \"punctuation\": /[\\[\\]]/,\n                    \"environment\": {\n                        pattern: RegExp(\"(\\\\{)\" + envVars),\n                        lookbehind: true,\n                        alias: \"constant\"\n                    }\n                }\n            },\n            /\\$(?:\\w+|[#?*!@$])/\n        ],\n        // Escape sequences from echo and printf's manuals, and escaped quotes.\n        \"entity\": /\\\\(?:[abceEfnrtv\\\\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/\n    };\n    Prism.languages.bash = {\n        \"shebang\": {\n            pattern: /^#!\\s*\\/.*/,\n            alias: \"important\"\n        },\n        \"comment\": {\n            pattern: /(^|[^\"{\\\\$])#.*/,\n            lookbehind: true\n        },\n        \"function-name\": [\n            // a) function foo {\n            // b) foo() {\n            // c) function foo() {\n            // but not foo {\n            {\n                // a) and c)\n                pattern: /(\\bfunction\\s+)[\\w-]+(?=(?:\\s*\\(?:\\s*\\))?\\s*\\{)/,\n                lookbehind: true,\n                alias: \"function\"\n            },\n            {\n                // b)\n                pattern: /\\b[\\w-]+(?=\\s*\\(\\s*\\)\\s*\\{)/,\n                alias: \"function\"\n            }\n        ],\n        // Highlight variable names as variables in for and select beginnings.\n        \"for-or-select\": {\n            pattern: /(\\b(?:for|select)\\s+)\\w+(?=\\s+in\\s)/,\n            alias: \"variable\",\n            lookbehind: true\n        },\n        // Highlight variable names as variables in the left-hand part\n        // of assignments (= and +=).\n        \"assign-left\": {\n            pattern: /(^|[\\s;|&]|[<>]\\()\\w+(?:\\.\\w+)*(?=\\+?=)/,\n            inside: {\n                \"environment\": {\n                    pattern: RegExp(\"(^|[\\\\s;|&]|[<>]\\\\()\" + envVars),\n                    lookbehind: true,\n                    alias: \"constant\"\n                }\n            },\n            alias: \"variable\",\n            lookbehind: true\n        },\n        // Highlight parameter names as variables\n        \"parameter\": {\n            pattern: /(^|\\s)-{1,2}(?:\\w+:[+-]?)?\\w+(?:\\.\\w+)*(?=[=\\s]|$)/,\n            alias: \"variable\",\n            lookbehind: true\n        },\n        \"string\": [\n            // Support for Here-documents https://en.wikipedia.org/wiki/Here_document\n            {\n                pattern: /((?:^|[^<])<<-?\\s*)(\\w+)\\s[\\s\\S]*?(?:\\r?\\n|\\r)\\2/,\n                lookbehind: true,\n                greedy: true,\n                inside: insideString\n            },\n            // Here-document with quotes around the tag\n            //  No expansion (so no inside).\n            {\n                pattern: /((?:^|[^<])<<-?\\s*)([\"'])(\\w+)\\2\\s[\\s\\S]*?(?:\\r?\\n|\\r)\\3/,\n                lookbehind: true,\n                greedy: true,\n                inside: {\n                    \"bash\": commandAfterHeredoc\n                }\n            },\n            // Normal string\n            {\n                // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html\n                pattern: /(^|[^\\\\](?:\\\\\\\\)*)\"(?:\\\\[\\s\\S]|\\$\\([^)]+\\)|\\$(?!\\()|`[^`]+`|[^\"\\\\`$])*\"/,\n                lookbehind: true,\n                greedy: true,\n                inside: insideString\n            },\n            {\n                // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html\n                pattern: /(^|[^$\\\\])'[^']*'/,\n                lookbehind: true,\n                greedy: true\n            },\n            {\n                // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html\n                pattern: /\\$'(?:[^'\\\\]|\\\\[\\s\\S])*'/,\n                greedy: true,\n                inside: {\n                    \"entity\": insideString.entity\n                }\n            }\n        ],\n        \"environment\": {\n            pattern: RegExp(\"\\\\$?\" + envVars),\n            alias: \"constant\"\n        },\n        \"variable\": insideString.variable,\n        \"function\": {\n            pattern: /(^|[\\s;|&]|[<>]\\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\\s;|&])/,\n            lookbehind: true\n        },\n        \"keyword\": {\n            pattern: /(^|[\\s;|&]|[<>]\\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\\s;|&])/,\n            lookbehind: true\n        },\n        // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html\n        \"builtin\": {\n            pattern: /(^|[\\s;|&]|[<>]\\()(?:\\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\\s;|&])/,\n            lookbehind: true,\n            // Alias added to make those easier to distinguish from strings.\n            alias: \"class-name\"\n        },\n        \"boolean\": {\n            pattern: /(^|[\\s;|&]|[<>]\\()(?:false|true)(?=$|[)\\s;|&])/,\n            lookbehind: true\n        },\n        \"file-descriptor\": {\n            pattern: /\\B&\\d\\b/,\n            alias: \"important\"\n        },\n        \"operator\": {\n            // Lots of redirections here, but not just that.\n            pattern: /\\d?<>|>\\||\\+=|=[=~]?|!=?|<<[<-]?|[&\\d]?>>|\\d[<>]&?|[<>][&=]?|&[>&]?|\\|[&|]?/,\n            inside: {\n                \"file-descriptor\": {\n                    pattern: /^\\d/,\n                    alias: \"important\"\n                }\n            }\n        },\n        \"punctuation\": /\\$?\\(\\(?|\\)\\)?|\\.\\.|[{}[\\];\\\\]/,\n        \"number\": {\n            pattern: /(^|\\s)(?:[1-9]\\d*|0)(?:[.,]\\d+)?\\b/,\n            lookbehind: true\n        }\n    };\n    commandAfterHeredoc.inside = Prism.languages.bash;\n    /* Patterns in command substitution. */ var toBeCopied = [\n        \"comment\",\n        \"function-name\",\n        \"for-or-select\",\n        \"assign-left\",\n        \"parameter\",\n        \"string\",\n        \"environment\",\n        \"function\",\n        \"keyword\",\n        \"builtin\",\n        \"boolean\",\n        \"file-descriptor\",\n        \"operator\",\n        \"punctuation\",\n        \"number\"\n    ];\n    var inside = insideString.variable[1].inside;\n    for(var i = 0; i < toBeCopied.length; i++){\n        inside[toBeCopied[i]] = Prism.languages.bash[toBeCopied[i]];\n    }\n    Prism.languages.sh = Prism.languages.bash;\n    Prism.languages.shell = Prism.languages.bash;\n})(Prism);\n(function(Prism) {\n    /**\n   * Replaces all placeholders \"<<n>>\" of given pattern with the n-th replacement (zero based).\n   *\n   * Note: This is a simple text based replacement. Be careful when using backreferences!\n   *\n   * @param {string} pattern the given pattern.\n   * @param {string[]} replacements a list of replacement which can be inserted into the given pattern.\n   * @returns {string} the pattern with all placeholders replaced with their corresponding replacements.\n   * @example replace(/a<<0>>a/.source, [/b+/.source]) === /a(?:b+)a/.source\n   */ function replace(pattern, replacements) {\n        return pattern.replace(/<<(\\d+)>>/g, function(m, index) {\n            return \"(?:\" + replacements[+index] + \")\";\n        });\n    }\n    /**\n   * @param {string} pattern\n   * @param {string[]} replacements\n   * @param {string} [flags]\n   * @returns {RegExp}\n   */ function re(pattern, replacements, flags) {\n        return RegExp(replace(pattern, replacements), flags || \"\");\n    }\n    /**\n   * Creates a nested pattern where all occurrences of the string `<<self>>` are replaced with the pattern itself.\n   *\n   * @param {string} pattern\n   * @param {number} depthLog2\n   * @returns {string}\n   */ function nested(pattern, depthLog2) {\n        for(var i = 0; i < depthLog2; i++){\n            pattern = pattern.replace(/<<self>>/g, function() {\n                return \"(?:\" + pattern + \")\";\n            });\n        }\n        return pattern.replace(/<<self>>/g, \"[^\\\\s\\\\S]\");\n    }\n    // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/\n    var keywordKinds = {\n        // keywords which represent a return or variable type\n        type: \"bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void\",\n        // keywords which are used to declare a type\n        typeDeclaration: \"class enum interface record struct\",\n        // contextual keywords\n        // (\"var\" and \"dynamic\" are missing because they are used like types)\n        contextual: \"add alias and ascending async await by descending from(?=\\\\s*(?:\\\\w|$)) get global group into init(?=\\\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\\\s*{)\",\n        // all other keywords\n        other: \"abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield\"\n    };\n    // keywords\n    function keywordsToPattern(words) {\n        return \"\\\\b(?:\" + words.trim().replace(/ /g, \"|\") + \")\\\\b\";\n    }\n    var typeDeclarationKeywords = keywordsToPattern(keywordKinds.typeDeclaration);\n    var keywords = RegExp(keywordsToPattern(keywordKinds.type + \" \" + keywordKinds.typeDeclaration + \" \" + keywordKinds.contextual + \" \" + keywordKinds.other));\n    var nonTypeKeywords = keywordsToPattern(keywordKinds.typeDeclaration + \" \" + keywordKinds.contextual + \" \" + keywordKinds.other);\n    var nonContextualKeywords = keywordsToPattern(keywordKinds.type + \" \" + keywordKinds.typeDeclaration + \" \" + keywordKinds.other);\n    // types\n    var generic = nested(/<(?:[^<>;=+\\-*/%&|^]|<<self>>)*>/.source, 2); // the idea behind the other forbidden characters is to prevent false positives. Same for tupleElement.\n    var nestedRound = nested(/\\((?:[^()]|<<self>>)*\\)/.source, 2);\n    var name = /@?\\b[A-Za-z_]\\w*\\b/.source;\n    var genericName = replace(/<<0>>(?:\\s*<<1>>)?/.source, [\n        name,\n        generic\n    ]);\n    var identifier = replace(/(?!<<0>>)<<1>>(?:\\s*\\.\\s*<<1>>)*/.source, [\n        nonTypeKeywords,\n        genericName\n    ]);\n    var array = /\\[\\s*(?:,\\s*)*\\]/.source;\n    var typeExpressionWithoutTuple = replace(/<<0>>(?:\\s*(?:\\?\\s*)?<<1>>)*(?:\\s*\\?)?/.source, [\n        identifier,\n        array\n    ]);\n    var tupleElement = replace(/[^,()<>[\\];=+\\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [\n        generic,\n        nestedRound,\n        array\n    ]);\n    var tuple = replace(/\\(<<0>>+(?:,<<0>>+)+\\)/.source, [\n        tupleElement\n    ]);\n    var typeExpression = replace(/(?:<<0>>|<<1>>)(?:\\s*(?:\\?\\s*)?<<2>>)*(?:\\s*\\?)?/.source, [\n        tuple,\n        identifier,\n        array\n    ]);\n    var typeInside = {\n        \"keyword\": keywords,\n        \"punctuation\": /[<>()?,.:[\\]]/\n    };\n    // strings & characters\n    // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#character-literals\n    // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#string-literals\n    var character = /'(?:[^\\r\\n'\\\\]|\\\\.|\\\\[Uux][\\da-fA-F]{1,8})'/.source; // simplified pattern\n    var regularString = /\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/.source;\n    var verbatimString = /@\"(?:\"\"|\\\\[\\s\\S]|[^\\\\\"])*\"(?!\")/.source;\n    Prism.languages.csharp = Prism.languages.extend(\"clike\", {\n        \"string\": [\n            {\n                pattern: re(/(^|[^$\\\\])<<0>>/.source, [\n                    verbatimString\n                ]),\n                lookbehind: true,\n                greedy: true\n            },\n            {\n                pattern: re(/(^|[^@$\\\\])<<0>>/.source, [\n                    regularString\n                ]),\n                lookbehind: true,\n                greedy: true\n            }\n        ],\n        \"class-name\": [\n            {\n                // Using static\n                // using static System.Math;\n                pattern: re(/(\\busing\\s+static\\s+)<<0>>(?=\\s*;)/.source, [\n                    identifier\n                ]),\n                lookbehind: true,\n                inside: typeInside\n            },\n            {\n                // Using alias (type)\n                // using Project = PC.MyCompany.Project;\n                pattern: re(/(\\busing\\s+<<0>>\\s*=\\s*)<<1>>(?=\\s*;)/.source, [\n                    name,\n                    typeExpression\n                ]),\n                lookbehind: true,\n                inside: typeInside\n            },\n            {\n                // Using alias (alias)\n                // using Project = PC.MyCompany.Project;\n                pattern: re(/(\\busing\\s+)<<0>>(?=\\s*=)/.source, [\n                    name\n                ]),\n                lookbehind: true\n            },\n            {\n                // Type declarations\n                // class Foo<A, B>\n                // interface Foo<out A, B>\n                pattern: re(/(\\b<<0>>\\s+)<<1>>/.source, [\n                    typeDeclarationKeywords,\n                    genericName\n                ]),\n                lookbehind: true,\n                inside: typeInside\n            },\n            {\n                // Single catch exception declaration\n                // catch(Foo)\n                // (things like catch(Foo e) is covered by variable declaration)\n                pattern: re(/(\\bcatch\\s*\\(\\s*)<<0>>/.source, [\n                    identifier\n                ]),\n                lookbehind: true,\n                inside: typeInside\n            },\n            {\n                // Name of the type parameter of generic constraints\n                // where Foo : class\n                pattern: re(/(\\bwhere\\s+)<<0>>/.source, [\n                    name\n                ]),\n                lookbehind: true\n            },\n            {\n                // Casts and checks via as and is.\n                // as Foo<A>, is Bar<B>\n                // (things like if(a is Foo b) is covered by variable declaration)\n                pattern: re(/(\\b(?:is(?:\\s+not)?|as)\\s+)<<0>>/.source, [\n                    typeExpressionWithoutTuple\n                ]),\n                lookbehind: true,\n                inside: typeInside\n            },\n            {\n                // Variable, field and parameter declaration\n                // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)\n                pattern: re(/\\b<<0>>(?=\\s+(?!<<1>>|with\\s*\\{)<<2>>(?:\\s*[=,;:{)\\]]|\\s+(?:in|when)\\b))/.source, [\n                    typeExpression,\n                    nonContextualKeywords,\n                    name\n                ]),\n                inside: typeInside\n            }\n        ],\n        \"keyword\": keywords,\n        // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals\n        \"number\": /(?:\\b0(?:x[\\da-f_]*[\\da-f]|b[01_]*[01])|(?:\\B\\.\\d+(?:_+\\d+)*|\\b\\d+(?:_+\\d+)*(?:\\.\\d+(?:_+\\d+)*)?)(?:e[-+]?\\d+(?:_+\\d+)*)?)(?:[dflmu]|lu|ul)?\\b/i,\n        \"operator\": />>=?|<<=?|[-=]>|([-+&|])\\1|~|\\?\\?=?|[-+*/%&|^!=<>]=?/,\n        \"punctuation\": /\\?\\.?|::|[{}[\\];(),.:]/\n    });\n    Prism.languages.insertBefore(\"csharp\", \"number\", {\n        \"range\": {\n            pattern: /\\.\\./,\n            alias: \"operator\"\n        }\n    });\n    Prism.languages.insertBefore(\"csharp\", \"punctuation\", {\n        \"named-parameter\": {\n            pattern: re(/([(,]\\s*)<<0>>(?=\\s*:)/.source, [\n                name\n            ]),\n            lookbehind: true,\n            alias: \"punctuation\"\n        }\n    });\n    Prism.languages.insertBefore(\"csharp\", \"class-name\", {\n        \"namespace\": {\n            // namespace Foo.Bar {}\n            // using Foo.Bar;\n            pattern: re(/(\\b(?:namespace|using)\\s+)<<0>>(?:\\s*\\.\\s*<<0>>)*(?=\\s*[;{])/.source, [\n                name\n            ]),\n            lookbehind: true,\n            inside: {\n                \"punctuation\": /\\./\n            }\n        },\n        \"type-expression\": {\n            // default(Foo), typeof(Foo<Bar>), sizeof(int)\n            pattern: re(/(\\b(?:default|sizeof|typeof)\\s*\\(\\s*(?!\\s))(?:[^()\\s]|\\s(?!\\s)|<<0>>)*(?=\\s*\\))/.source, [\n                nestedRound\n            ]),\n            lookbehind: true,\n            alias: \"class-name\",\n            inside: typeInside\n        },\n        \"return-type\": {\n            // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0\n            // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];\n            // int Foo => 0; int Foo { get; set } = 0;\n            pattern: re(/<<0>>(?=\\s+(?:<<1>>\\s*(?:=>|[({]|\\.\\s*this\\s*\\[)|this\\s*\\[))/.source, [\n                typeExpression,\n                identifier\n            ]),\n            inside: typeInside,\n            alias: \"class-name\"\n        },\n        \"constructor-invocation\": {\n            // new List<Foo<Bar[]>> { }\n            pattern: re(/(\\bnew\\s+)<<0>>(?=\\s*[[({])/.source, [\n                typeExpression\n            ]),\n            lookbehind: true,\n            inside: typeInside,\n            alias: \"class-name\"\n        },\n        /*'explicit-implementation': {\n    \t// int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();\n    \tpattern: replace(/\\b<<0>>(?=\\.<<1>>)/, className, methodOrPropertyDeclaration),\n    \tinside: classNameInside,\n    \talias: 'class-name'\n    },*/ \"generic-method\": {\n            // foo<Bar>()\n            pattern: re(/<<0>>\\s*<<1>>(?=\\s*\\()/.source, [\n                name,\n                generic\n            ]),\n            inside: {\n                \"function\": re(/^<<0>>/.source, [\n                    name\n                ]),\n                \"generic\": {\n                    pattern: RegExp(generic),\n                    alias: \"class-name\",\n                    inside: typeInside\n                }\n            }\n        },\n        \"type-list\": {\n            // The list of types inherited or of generic constraints\n            // class Foo<F> : Bar, IList<FooBar>\n            // where F : Bar, IList<int>\n            pattern: re(/\\b((?:<<0>>\\s+<<1>>|record\\s+<<1>>\\s*<<5>>|where\\s+<<2>>)\\s*:\\s*)(?:<<3>>|<<4>>|<<1>>\\s*<<5>>|<<6>>)(?:\\s*,\\s*(?:<<3>>|<<4>>|<<6>>))*(?=\\s*(?:where|[{;]|=>|$))/.source, [\n                typeDeclarationKeywords,\n                genericName,\n                name,\n                typeExpression,\n                keywords.source,\n                nestedRound,\n                /\\bnew\\s*\\(\\s*\\)/.source\n            ]),\n            lookbehind: true,\n            inside: {\n                \"record-arguments\": {\n                    pattern: re(/(^(?!new\\s*\\()<<0>>\\s*)<<1>>/.source, [\n                        genericName,\n                        nestedRound\n                    ]),\n                    lookbehind: true,\n                    greedy: true,\n                    inside: Prism.languages.csharp\n                },\n                \"keyword\": keywords,\n                \"class-name\": {\n                    pattern: RegExp(typeExpression),\n                    greedy: true,\n                    inside: typeInside\n                },\n                \"punctuation\": /[,()]/\n            }\n        },\n        \"preprocessor\": {\n            pattern: /(^[\\t ]*)#.*/m,\n            lookbehind: true,\n            alias: \"property\",\n            inside: {\n                // highlight preprocessor directives as keywords\n                \"directive\": {\n                    pattern: /(#)\\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\\b/,\n                    lookbehind: true,\n                    alias: \"keyword\"\n                }\n            }\n        }\n    });\n    // attributes\n    var regularStringOrCharacter = regularString + \"|\" + character;\n    var regularStringCharacterOrComment = replace(/\\/(?![*/])|\\/\\/[^\\r\\n]*[\\r\\n]|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|<<0>>/.source, [\n        regularStringOrCharacter\n    ]);\n    var roundExpression = nested(replace(/[^\"'/()]|<<0>>|\\(<<self>>*\\)/.source, [\n        regularStringCharacterOrComment\n    ]), 2);\n    // https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/#attribute-targets\n    var attrTarget = /\\b(?:assembly|event|field|method|module|param|property|return|type)\\b/.source;\n    var attr = replace(/<<0>>(?:\\s*\\(<<1>>*\\))?/.source, [\n        identifier,\n        roundExpression\n    ]);\n    Prism.languages.insertBefore(\"csharp\", \"class-name\", {\n        \"attribute\": {\n            // Attributes\n            // [Foo], [Foo(1), Bar(2, Prop = \"foo\")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]\n            pattern: re(/((?:^|[^\\s\\w>)?])\\s*\\[\\s*)(?:<<0>>\\s*:\\s*)?<<1>>(?:\\s*,\\s*<<1>>)*(?=\\s*\\])/.source, [\n                attrTarget,\n                attr\n            ]),\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"target\": {\n                    pattern: re(/^<<0>>(?=\\s*:)/.source, [\n                        attrTarget\n                    ]),\n                    alias: \"keyword\"\n                },\n                \"attribute-arguments\": {\n                    pattern: re(/\\(<<0>>*\\)/.source, [\n                        roundExpression\n                    ]),\n                    inside: Prism.languages.csharp\n                },\n                \"class-name\": {\n                    pattern: RegExp(identifier),\n                    inside: {\n                        \"punctuation\": /\\./\n                    }\n                },\n                \"punctuation\": /[:,]/\n            }\n        }\n    });\n    // string interpolation\n    var formatString = /:[^}\\r\\n]+/.source;\n    // multi line\n    var mInterpolationRound = nested(replace(/[^\"'/()]|<<0>>|\\(<<self>>*\\)/.source, [\n        regularStringCharacterOrComment\n    ]), 2);\n    var mInterpolation = replace(/\\{(?!\\{)(?:(?![}:])<<0>>)*<<1>>?\\}/.source, [\n        mInterpolationRound,\n        formatString\n    ]);\n    // single line\n    var sInterpolationRound = nested(replace(/[^\"'/()]|\\/(?!\\*)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|<<0>>|\\(<<self>>*\\)/.source, [\n        regularStringOrCharacter\n    ]), 2);\n    var sInterpolation = replace(/\\{(?!\\{)(?:(?![}:])<<0>>)*<<1>>?\\}/.source, [\n        sInterpolationRound,\n        formatString\n    ]);\n    function createInterpolationInside(interpolation, interpolationRound) {\n        return {\n            \"interpolation\": {\n                pattern: re(/((?:^|[^{])(?:\\{\\{)*)<<0>>/.source, [\n                    interpolation\n                ]),\n                lookbehind: true,\n                inside: {\n                    \"format-string\": {\n                        pattern: re(/(^\\{(?:(?![}:])<<0>>)*)<<1>>(?=\\}$)/.source, [\n                            interpolationRound,\n                            formatString\n                        ]),\n                        lookbehind: true,\n                        inside: {\n                            \"punctuation\": /^:/\n                        }\n                    },\n                    \"punctuation\": /^\\{|\\}$/,\n                    \"expression\": {\n                        pattern: /[\\s\\S]+/,\n                        alias: \"language-csharp\",\n                        inside: Prism.languages.csharp\n                    }\n                }\n            },\n            \"string\": /[\\s\\S]+/\n        };\n    }\n    Prism.languages.insertBefore(\"csharp\", \"string\", {\n        \"interpolation-string\": [\n            {\n                pattern: re(/(^|[^\\\\])(?:\\$@|@\\$)\"(?:\"\"|\\\\[\\s\\S]|\\{\\{|<<0>>|[^\\\\{\"])*\"/.source, [\n                    mInterpolation\n                ]),\n                lookbehind: true,\n                greedy: true,\n                inside: createInterpolationInside(mInterpolation, mInterpolationRound)\n            },\n            {\n                pattern: re(/(^|[^@\\\\])\\$\"(?:\\\\.|\\{\\{|<<0>>|[^\\\\\"{])*\"/.source, [\n                    sInterpolation\n                ]),\n                lookbehind: true,\n                greedy: true,\n                inside: createInterpolationInside(sInterpolation, sInterpolationRound)\n            }\n        ],\n        \"char\": {\n            pattern: RegExp(character),\n            greedy: true\n        }\n    });\n    Prism.languages.dotnet = Prism.languages.cs = Prism.languages.csharp;\n})(Prism);\nPrism.languages.markup = {\n    \"comment\": {\n        pattern: /<!--(?:(?!<!--)[\\s\\S])*?-->/,\n        greedy: true\n    },\n    \"prolog\": {\n        pattern: /<\\?[\\s\\S]+?\\?>/,\n        greedy: true\n    },\n    \"doctype\": {\n        // https://www.w3.org/TR/xml/#NT-doctypedecl\n        pattern: /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\\]\\s*)?>/i,\n        greedy: true,\n        inside: {\n            \"internal-subset\": {\n                pattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n                lookbehind: true,\n                greedy: true,\n                inside: null // see below\n            },\n            \"string\": {\n                pattern: /\"[^\"]*\"|'[^']*'/,\n                greedy: true\n            },\n            \"punctuation\": /^<!|>$|[[\\]]/,\n            \"doctype-tag\": /^DOCTYPE/i,\n            \"name\": /[^\\s<>'\"]+/\n        }\n    },\n    \"cdata\": {\n        pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n        greedy: true\n    },\n    \"tag\": {\n        pattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n        greedy: true,\n        inside: {\n            \"tag\": {\n                pattern: /^<\\/?[^\\s>\\/]+/,\n                inside: {\n                    \"punctuation\": /^<\\/?/,\n                    \"namespace\": /^[^\\s>\\/:]+:/\n                }\n            },\n            \"special-attr\": [],\n            \"attr-value\": {\n                pattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n                inside: {\n                    \"punctuation\": [\n                        {\n                            pattern: /^=/,\n                            alias: \"attr-equals\"\n                        },\n                        {\n                            pattern: /^(\\s*)[\"']|[\"']$/,\n                            lookbehind: true\n                        }\n                    ]\n                }\n            },\n            \"punctuation\": /\\/?>/,\n            \"attr-name\": {\n                pattern: /[^\\s>\\/]+/,\n                inside: {\n                    \"namespace\": /^[^\\s>\\/:]+:/\n                }\n            }\n        }\n    },\n    \"entity\": [\n        {\n            pattern: /&[\\da-z]{1,8};/i,\n            alias: \"named-entity\"\n        },\n        /&#x?[\\da-f]{1,8};/i\n    ]\n};\nPrism.languages.markup[\"tag\"].inside[\"attr-value\"].inside[\"entity\"] = Prism.languages.markup[\"entity\"];\nPrism.languages.markup[\"doctype\"].inside[\"internal-subset\"].inside = Prism.languages.markup;\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add(\"wrap\", function(env) {\n    if (env.type === \"entity\") {\n        env.attributes[\"title\"] = env.content.replace(/&amp;/, \"&\");\n    }\n});\nObject.defineProperty(Prism.languages.markup.tag, \"addInlined\", {\n    /**\n   * Adds an inlined language to markup.\n   *\n   * An example of an inlined language is CSS with `<style>` tags.\n   *\n   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n   * case insensitive.\n   * @param {string} lang The language key.\n   * @example\n   * addInlined('style', 'css');\n   */ value: function addInlined(tagName, lang) {\n        var includedCdataInside = {};\n        includedCdataInside[\"language-\" + lang] = {\n            pattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n            lookbehind: true,\n            inside: Prism.languages[lang]\n        };\n        includedCdataInside[\"cdata\"] = /^<!\\[CDATA\\[|\\]\\]>$/i;\n        var inside = {\n            \"included-cdata\": {\n                pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n                inside: includedCdataInside\n            }\n        };\n        inside[\"language-\" + lang] = {\n            pattern: /[\\s\\S]+/,\n            inside: Prism.languages[lang]\n        };\n        var def = {};\n        def[tagName] = {\n            pattern: RegExp(/(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(/__/g, function() {\n                return tagName;\n            }), \"i\"),\n            lookbehind: true,\n            greedy: true,\n            inside: inside\n        };\n        Prism.languages.insertBefore(\"markup\", \"cdata\", def);\n    }\n});\nObject.defineProperty(Prism.languages.markup.tag, \"addAttribute\", {\n    /**\n   * Adds an pattern to highlight languages embedded in HTML attributes.\n   *\n   * An example of an inlined language is CSS with `style` attributes.\n   *\n   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n   * case insensitive.\n   * @param {string} lang The language key.\n   * @example\n   * addAttribute('style', 'css');\n   */ value: function(attrName, lang) {\n        Prism.languages.markup.tag.inside[\"special-attr\"].push({\n            pattern: RegExp(/(^|[\"'\\s])/.source + \"(?:\" + attrName + \")\" + /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source, \"i\"),\n            lookbehind: true,\n            inside: {\n                \"attr-name\": /^[^\\s=]+/,\n                \"attr-value\": {\n                    pattern: /=[\\s\\S]+/,\n                    inside: {\n                        \"value\": {\n                            pattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n                            lookbehind: true,\n                            alias: [\n                                lang,\n                                \"language-\" + lang\n                            ],\n                            inside: Prism.languages[lang]\n                        },\n                        \"punctuation\": [\n                            {\n                                pattern: /^=/,\n                                alias: \"attr-equals\"\n                            },\n                            /\"|'/\n                        ]\n                    }\n                }\n            }\n        });\n    }\n});\nPrism.languages.html = Prism.languages.markup;\nPrism.languages.mathml = Prism.languages.markup;\nPrism.languages.svg = Prism.languages.markup;\nPrism.languages.xml = Prism.languages.extend(\"markup\", {});\nPrism.languages.ssml = Prism.languages.xml;\nPrism.languages.atom = Prism.languages.xml;\nPrism.languages.rss = Prism.languages.xml;\n(function(Prism) {\n    var string = /(?:\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;\n    Prism.languages.css = {\n        \"comment\": /\\/\\*[\\s\\S]*?\\*\\//,\n        \"atrule\": {\n            pattern: RegExp(\"@[\\\\w-](?:\" + /[^;{\\s\"']|\\s+(?!\\s)/.source + \"|\" + string.source + \")*?\" + /(?:;|(?=\\s*\\{))/.source),\n            inside: {\n                \"rule\": /^@[\\w-]+/,\n                \"selector-function-argument\": {\n                    pattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n                    lookbehind: true,\n                    alias: \"selector\"\n                },\n                \"keyword\": {\n                    pattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n                    lookbehind: true\n                }\n            }\n        },\n        \"url\": {\n            // https://drafts.csswg.org/css-values-3/#urls\n            pattern: RegExp(\"\\\\burl\\\\((?:\" + string.source + \"|\" + /(?:[^\\\\\\r\\n()\"']|\\\\[\\s\\S])*/.source + \")\\\\)\", \"i\"),\n            greedy: true,\n            inside: {\n                \"function\": /^url/i,\n                \"punctuation\": /^\\(|\\)$/,\n                \"string\": {\n                    pattern: RegExp(\"^\" + string.source + \"$\"),\n                    alias: \"url\"\n                }\n            }\n        },\n        \"selector\": {\n            pattern: RegExp(\"(^|[{}\\\\s])[^{}\\\\s](?:[^{};\\\"'\\\\s]|\\\\s+(?![\\\\s{])|\" + string.source + \")*(?=\\\\s*\\\\{)\"),\n            lookbehind: true\n        },\n        \"string\": {\n            pattern: string,\n            greedy: true\n        },\n        \"property\": {\n            pattern: /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n            lookbehind: true\n        },\n        \"important\": /!important\\b/i,\n        \"function\": {\n            pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n            lookbehind: true\n        },\n        \"punctuation\": /[(){};:,]/\n    };\n    Prism.languages.css[\"atrule\"].inside.rest = Prism.languages.css;\n    var markup = Prism.languages.markup;\n    if (markup) {\n        markup.tag.addInlined(\"style\", \"css\");\n        markup.tag.addAttribute(\"style\", \"css\");\n    }\n})(Prism);\n(function(Prism) {\n    Prism.languages.diff = {\n        \"coord\": [\n            // Match all kinds of coord lines (prefixed by \"+++\", \"---\" or \"***\").\n            /^(?:\\*{3}|-{3}|\\+{3}).*$/m,\n            // Match \"@@ ... @@\" coord lines in unified diff.\n            /^@@.*@@$/m,\n            // Match coord lines in normal diff (starts with a number).\n            /^\\d.*$/m\n        ]\n    };\n    /**\n   * A map from the name of a block to its line prefix.\n   *\n   * @type {Object<string, string>}\n   */ var PREFIXES = {\n        \"deleted-sign\": \"-\",\n        \"deleted-arrow\": \"<\",\n        \"inserted-sign\": \"+\",\n        \"inserted-arrow\": \">\",\n        \"unchanged\": \" \",\n        \"diff\": \"!\"\n    };\n    // add a token for each prefix\n    Object.keys(PREFIXES).forEach(function(name) {\n        var prefix = PREFIXES[name];\n        var alias = [];\n        if (!/^\\w+$/.test(name)) {\n            // \"deleted-sign\" -> \"deleted\"\n            alias.push(/\\w+/.exec(name)[0]);\n        }\n        if (name === \"diff\") {\n            alias.push(\"bold\");\n        }\n        Prism.languages.diff[name] = {\n            pattern: RegExp(\"^(?:[\" + prefix + \"].*(?:\\r\\n?|\\n|(?![\\\\s\\\\S])))+\", \"m\"),\n            alias: alias,\n            inside: {\n                \"line\": {\n                    pattern: /(.)(?=[\\s\\S]).*(?:\\r\\n?|\\n)?/,\n                    lookbehind: true\n                },\n                \"prefix\": {\n                    pattern: /[\\s\\S]/,\n                    alias: /\\w+/.exec(name)[0]\n                }\n            }\n        };\n    });\n    // make prefixes available to Diff plugin\n    Object.defineProperty(Prism.languages.diff, \"PREFIXES\", {\n        value: PREFIXES\n    });\n})(Prism);\nPrism.languages.go = Prism.languages.extend(\"clike\", {\n    \"string\": {\n        pattern: /(^|[^\\\\])\"(?:\\\\.|[^\"\\\\\\r\\n])*\"|`[^`]*`/,\n        lookbehind: true,\n        greedy: true\n    },\n    \"keyword\": /\\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\\b/,\n    \"boolean\": /\\b(?:_|false|iota|nil|true)\\b/,\n    \"number\": [\n        // binary and octal integers\n        /\\b0(?:b[01_]+|o[0-7_]+)i?\\b/i,\n        // hexadecimal integers and floats\n        /\\b0x(?:[a-f\\d_]+(?:\\.[a-f\\d_]*)?|\\.[a-f\\d_]+)(?:p[+-]?\\d+(?:_\\d+)*)?i?(?!\\w)/i,\n        // decimal integers and floats\n        /(?:\\b\\d[\\d_]*(?:\\.[\\d_]*)?|\\B\\.\\d[\\d_]*)(?:e[+-]?[\\d_]+)?i?(?!\\w)/i\n    ],\n    \"operator\": /[*\\/%^!=]=?|\\+[=+]?|-[=-]?|\\|[=|]?|&(?:=|&|\\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\\.\\.\\./,\n    \"builtin\": /\\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\\b/\n});\nPrism.languages.insertBefore(\"go\", \"string\", {\n    \"char\": {\n        pattern: /'(?:\\\\.|[^'\\\\\\r\\n]){0,10}'/,\n        greedy: true\n    }\n});\ndelete Prism.languages.go[\"class-name\"];\nPrism.languages.ini = {\n    /**\n   * The component mimics the behavior of the Win32 API parser.\n   *\n   * @see {@link https://github.com/PrismJS/prism/issues/2775#issuecomment-787477723}\n   */ \"comment\": {\n        pattern: /(^[ \\f\\t\\v]*)[#;][^\\n\\r]*/m,\n        lookbehind: true\n    },\n    \"section\": {\n        pattern: /(^[ \\f\\t\\v]*)\\[[^\\n\\r\\]]*\\]?/m,\n        lookbehind: true,\n        inside: {\n            \"section-name\": {\n                pattern: /(^\\[[ \\f\\t\\v]*)[^ \\f\\t\\v\\]]+(?:[ \\f\\t\\v]+[^ \\f\\t\\v\\]]+)*/,\n                lookbehind: true,\n                alias: \"selector\"\n            },\n            \"punctuation\": /\\[|\\]/\n        }\n    },\n    \"key\": {\n        pattern: /(^[ \\f\\t\\v]*)[^ \\f\\n\\r\\t\\v=]+(?:[ \\f\\t\\v]+[^ \\f\\n\\r\\t\\v=]+)*(?=[ \\f\\t\\v]*=)/m,\n        lookbehind: true,\n        alias: \"attr-name\"\n    },\n    \"value\": {\n        pattern: /(=[ \\f\\t\\v]*)[^ \\f\\n\\r\\t\\v]+(?:[ \\f\\t\\v]+[^ \\f\\n\\r\\t\\v]+)*/,\n        lookbehind: true,\n        alias: \"attr-value\",\n        inside: {\n            \"inner-value\": {\n                pattern: /^(\"|').+(?=\\1$)/,\n                lookbehind: true\n            }\n        }\n    },\n    \"punctuation\": /=/\n};\n(function(Prism) {\n    var keywords = /\\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\\s*[(){}[\\]<>=%~.:,;?+\\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\\b/;\n    // full package (optional) + parent classes (optional)\n    var classNamePrefix = /(?:[a-z]\\w*\\s*\\.\\s*)*(?:[A-Z]\\w*\\s*\\.\\s*)*/.source;\n    // based on the java naming conventions\n    var className = {\n        pattern: RegExp(/(^|[^\\w.])/.source + classNamePrefix + /[A-Z](?:[\\d_A-Z]*[a-z]\\w*)?\\b/.source),\n        lookbehind: true,\n        inside: {\n            \"namespace\": {\n                pattern: /^[a-z]\\w*(?:\\s*\\.\\s*[a-z]\\w*)*(?:\\s*\\.)?/,\n                inside: {\n                    \"punctuation\": /\\./\n                }\n            },\n            \"punctuation\": /\\./\n        }\n    };\n    Prism.languages.java = Prism.languages.extend(\"clike\", {\n        \"string\": {\n            pattern: /(^|[^\\\\])\"(?:\\\\.|[^\"\\\\\\r\\n])*\"/,\n            lookbehind: true,\n            greedy: true\n        },\n        \"class-name\": [\n            className,\n            {\n                // variables, parameters, and constructor references\n                // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)\n                pattern: RegExp(/(^|[^\\w.])/.source + classNamePrefix + /[A-Z]\\w*(?=\\s+\\w+\\s*[;,=()]|\\s*(?:\\[[\\s,]*\\]\\s*)?::\\s*new\\b)/.source),\n                lookbehind: true,\n                inside: className.inside\n            },\n            {\n                // class names based on keyword\n                // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)\n                pattern: RegExp(/(\\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\\s+)/.source + classNamePrefix + /[A-Z]\\w*\\b/.source),\n                lookbehind: true,\n                inside: className.inside\n            }\n        ],\n        \"keyword\": keywords,\n        \"function\": [\n            Prism.languages.clike.function,\n            {\n                pattern: /(::\\s*)[a-z_]\\w*/,\n                lookbehind: true\n            }\n        ],\n        \"number\": /\\b0b[01][01_]*L?\\b|\\b0x(?:\\.[\\da-f_p+-]+|[\\da-f_]+(?:\\.[\\da-f_p+-]+)?)\\b|(?:\\b\\d[\\d_]*(?:\\.[\\d_]*)?|\\B\\.\\d[\\d_]*)(?:e[+-]?\\d[\\d_]*)?[dfl]?/i,\n        \"operator\": {\n            pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\\+\\+|&&|\\|\\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,\n            lookbehind: true\n        },\n        \"constant\": /\\b[A-Z][A-Z_\\d]+\\b/\n    });\n    Prism.languages.insertBefore(\"java\", \"string\", {\n        \"triple-quoted-string\": {\n            // http://openjdk.java.net/jeps/355#Description\n            pattern: /\"\"\"[ \\t]*[\\r\\n](?:(?:\"|\"\")?(?:\\\\.|[^\"\\\\]))*\"\"\"/,\n            greedy: true,\n            alias: \"string\"\n        },\n        \"char\": {\n            pattern: /'(?:\\\\.|[^'\\\\\\r\\n]){1,6}'/,\n            greedy: true\n        }\n    });\n    Prism.languages.insertBefore(\"java\", \"class-name\", {\n        \"annotation\": {\n            pattern: /(^|[^.])@\\w+(?:\\s*\\.\\s*\\w+)*/,\n            lookbehind: true,\n            alias: \"punctuation\"\n        },\n        \"generics\": {\n            pattern: /<(?:[\\w\\s,.?]|&(?!&)|<(?:[\\w\\s,.?]|&(?!&)|<(?:[\\w\\s,.?]|&(?!&)|<(?:[\\w\\s,.?]|&(?!&))*>)*>)*>)*>/,\n            inside: {\n                \"class-name\": className,\n                \"keyword\": keywords,\n                \"punctuation\": /[<>(),.:]/,\n                \"operator\": /[?&|]/\n            }\n        },\n        \"import\": [\n            {\n                pattern: RegExp(/(\\bimport\\s+)/.source + classNamePrefix + /(?:[A-Z]\\w*|\\*)(?=\\s*;)/.source),\n                lookbehind: true,\n                inside: {\n                    \"namespace\": className.inside.namespace,\n                    \"punctuation\": /\\./,\n                    \"operator\": /\\*/,\n                    \"class-name\": /\\w+/\n                }\n            },\n            {\n                pattern: RegExp(/(\\bimport\\s+static\\s+)/.source + classNamePrefix + /(?:\\w+|\\*)(?=\\s*;)/.source),\n                lookbehind: true,\n                alias: \"static\",\n                inside: {\n                    \"namespace\": className.inside.namespace,\n                    \"static\": /\\b\\w+$/,\n                    \"punctuation\": /\\./,\n                    \"operator\": /\\*/,\n                    \"class-name\": /\\w+/\n                }\n            }\n        ],\n        \"namespace\": {\n            pattern: RegExp(/(\\b(?:exports|import(?:\\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\\s+)(?!<keyword>)[a-z]\\w*(?:\\.[a-z]\\w*)*\\.?/.source.replace(/<keyword>/g, function() {\n                return keywords.source;\n            })),\n            lookbehind: true,\n            inside: {\n                \"punctuation\": /\\./\n            }\n        }\n    });\n})(Prism);\n(function(Prism) {\n    var specialEscape = {\n        pattern: /\\\\[\\\\(){}[\\]^$+*?|.]/,\n        alias: \"escape\"\n    };\n    var escape = /\\\\(?:x[\\da-fA-F]{2}|u[\\da-fA-F]{4}|u\\{[\\da-fA-F]+\\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/;\n    var charSet = {\n        pattern: /\\.|\\\\[wsd]|\\\\p\\{[^{}]+\\}/i,\n        alias: \"class-name\"\n    };\n    var charSetWithoutDot = {\n        pattern: /\\\\[wsd]|\\\\p\\{[^{}]+\\}/i,\n        alias: \"class-name\"\n    };\n    var rangeChar = \"(?:[^\\\\\\\\-]|\" + escape.source + \")\";\n    var range = RegExp(rangeChar + \"-\" + rangeChar);\n    // the name of a capturing group\n    var groupName = {\n        pattern: /(<|')[^<>']+(?=[>']$)/,\n        lookbehind: true,\n        alias: \"variable\"\n    };\n    Prism.languages.regex = {\n        \"char-class\": {\n            pattern: /((?:^|[^\\\\])(?:\\\\\\\\)*)\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/,\n            lookbehind: true,\n            inside: {\n                \"char-class-negation\": {\n                    pattern: /(^\\[)\\^/,\n                    lookbehind: true,\n                    alias: \"operator\"\n                },\n                \"char-class-punctuation\": {\n                    pattern: /^\\[|\\]$/,\n                    alias: \"punctuation\"\n                },\n                \"range\": {\n                    pattern: range,\n                    inside: {\n                        \"escape\": escape,\n                        \"range-punctuation\": {\n                            pattern: /-/,\n                            alias: \"operator\"\n                        }\n                    }\n                },\n                \"special-escape\": specialEscape,\n                \"char-set\": charSetWithoutDot,\n                \"escape\": escape\n            }\n        },\n        \"special-escape\": specialEscape,\n        \"char-set\": charSet,\n        \"backreference\": [\n            {\n                // a backreference which is not an octal escape\n                pattern: /\\\\(?![123][0-7]{2})[1-9]/,\n                alias: \"keyword\"\n            },\n            {\n                pattern: /\\\\k<[^<>']+>/,\n                alias: \"keyword\",\n                inside: {\n                    \"group-name\": groupName\n                }\n            }\n        ],\n        \"anchor\": {\n            pattern: /[$^]|\\\\[ABbGZz]/,\n            alias: \"function\"\n        },\n        \"escape\": escape,\n        \"group\": [\n            {\n                // https://docs.oracle.com/javase/10/docs/api/java/util/regex/Pattern.html\n                // https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference?view=netframework-4.7.2#grouping-constructs\n                // (), (?<name>), (?'name'), (?>), (?:), (?=), (?!), (?<=), (?<!), (?is-m), (?i-m:)\n                pattern: /\\((?:\\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/,\n                alias: \"punctuation\",\n                inside: {\n                    \"group-name\": groupName\n                }\n            },\n            {\n                pattern: /\\)/,\n                alias: \"punctuation\"\n            }\n        ],\n        \"quantifier\": {\n            pattern: /(?:[+*?]|\\{\\d+(?:,\\d*)?\\})[?+]?/,\n            alias: \"number\"\n        },\n        \"alternation\": {\n            pattern: /\\|/,\n            alias: \"keyword\"\n        }\n    };\n})(Prism);\nPrism.languages.javascript = Prism.languages.extend(\"clike\", {\n    \"class-name\": [\n        Prism.languages.clike[\"class-name\"],\n        {\n            pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:constructor|prototype))/,\n            lookbehind: true\n        }\n    ],\n    \"keyword\": [\n        {\n            pattern: /((?:^|\\})\\s*)catch\\b/,\n            lookbehind: true\n        },\n        {\n            pattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['\"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n            lookbehind: true\n        }\n    ],\n    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n    \"function\": /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n    \"number\": {\n        pattern: RegExp(/(^|[^\\w$])/.source + \"(?:\" + // constant\n        (/NaN|Infinity/.source + \"|\" + // binary integer\n        /0[bB][01]+(?:_[01]+)*n?/.source + \"|\" + // octal integer\n        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + \"|\" + // hexadecimal integer\n        /0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?/.source + \"|\" + // decimal bigint\n        /\\d+(?:_\\d+)*n/.source + \"|\" + // decimal number (integer or float) but no bigint\n        /(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?/.source) + \")\" + /(?![\\w$])/.source),\n        lookbehind: true\n    },\n    \"operator\": /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n});\nPrism.languages.javascript[\"class-name\"][0].pattern = /(\\b(?:class|extends|implements|instanceof|interface|new)\\s+)[\\w.\\\\]+/;\nPrism.languages.insertBefore(\"javascript\", \"keyword\", {\n    \"regex\": {\n        pattern: RegExp(// lookbehind\n        // eslint-disable-next-line regexp/no-dupe-characters-character-class\n        /((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)/.source + // Regex pattern:\n        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character\n        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible\n        // with the only syntax, so we have to define 2 different regex patterns.\n        /\\//.source + \"(?:\" + /(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}/.source + \"|\" + // `v` flag syntax. This supports 3 levels of nested character classes.\n        /(?:\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.)*\\])*\\])*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + \")\" + // lookahead\n        /(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/.source),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n            \"regex-source\": {\n                pattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n                lookbehind: true,\n                alias: \"language-regex\",\n                inside: Prism.languages.regex\n            },\n            \"regex-delimiter\": /^\\/|\\/$/,\n            \"regex-flags\": /^[a-z]+$/\n        }\n    },\n    // This must be declared before keyword because we use \"function\" inside the look-forward\n    \"function-variable\": {\n        pattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n        alias: \"function\"\n    },\n    \"parameter\": [\n        {\n            pattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n            lookbehind: true,\n            inside: Prism.languages.javascript\n        },\n        {\n            pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n            lookbehind: true,\n            inside: Prism.languages.javascript\n        },\n        {\n            pattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n            lookbehind: true,\n            inside: Prism.languages.javascript\n        },\n        {\n            pattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n            lookbehind: true,\n            inside: Prism.languages.javascript\n        }\n    ],\n    \"constant\": /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n});\nPrism.languages.insertBefore(\"javascript\", \"string\", {\n    \"hashbang\": {\n        pattern: /^#!.*/,\n        greedy: true,\n        alias: \"comment\"\n    },\n    \"template-string\": {\n        pattern: /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n        greedy: true,\n        inside: {\n            \"template-punctuation\": {\n                pattern: /^`|`$/,\n                alias: \"string\"\n            },\n            \"interpolation\": {\n                pattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n                lookbehind: true,\n                inside: {\n                    \"interpolation-punctuation\": {\n                        pattern: /^\\$\\{|\\}$/,\n                        alias: \"punctuation\"\n                    },\n                    rest: Prism.languages.javascript\n                }\n            },\n            \"string\": /[\\s\\S]+/\n        }\n    },\n    \"string-property\": {\n        pattern: /((?:^|[,{])[ \\t]*)([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2(?=\\s*:)/m,\n        lookbehind: true,\n        greedy: true,\n        alias: \"property\"\n    }\n});\nPrism.languages.insertBefore(\"javascript\", \"operator\", {\n    \"literal-property\": {\n        pattern: /((?:^|[,{])[ \\t]*)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/m,\n        lookbehind: true,\n        alias: \"property\"\n    }\n});\nif (Prism.languages.markup) {\n    Prism.languages.markup.tag.addInlined(\"script\", \"javascript\");\n    // add attribute support for all DOM events.\n    // https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events\n    Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, \"javascript\");\n}\nPrism.languages.js = Prism.languages.javascript;\n(function(Prism) {\n    var javascript = Prism.util.clone(Prism.languages.javascript);\n    var space = /(?:\\s|\\/\\/.*(?!.)|\\/\\*(?:[^*]|\\*(?!\\/))\\*\\/)/.source;\n    var braces = /(?:\\{(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])*\\})/.source;\n    var spread = /(?:\\{<S>*\\.{3}(?:[^{}]|<BRACES>)*\\})/.source;\n    /**\n   * @param {string} source\n   * @param {string} [flags]\n   */ function re(source, flags) {\n        source = source.replace(/<S>/g, function() {\n            return space;\n        }).replace(/<BRACES>/g, function() {\n            return braces;\n        }).replace(/<SPREAD>/g, function() {\n            return spread;\n        });\n        return RegExp(source, flags);\n    }\n    spread = re(spread).source;\n    Prism.languages.jsx = Prism.languages.extend(\"markup\", javascript);\n    Prism.languages.jsx.tag.pattern = re(/<\\/?(?:[\\w.:-]+(?:<S>+(?:[\\w.:$-]+(?:=(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s{'\"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\\/?)?>/.source);\n    Prism.languages.jsx.tag.inside[\"tag\"].pattern = /^<\\/?[^\\s>\\/]*/;\n    Prism.languages.jsx.tag.inside[\"attr-value\"].pattern = /=(?!\\{)(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s'\">]+)/;\n    Prism.languages.jsx.tag.inside[\"tag\"].inside[\"class-name\"] = /^[A-Z]\\w*(?:\\.[A-Z]\\w*)*$/;\n    Prism.languages.jsx.tag.inside[\"comment\"] = javascript[\"comment\"];\n    Prism.languages.insertBefore(\"inside\", \"attr-name\", {\n        \"spread\": {\n            pattern: re(/<SPREAD>/.source),\n            inside: Prism.languages.jsx\n        }\n    }, Prism.languages.jsx.tag);\n    Prism.languages.insertBefore(\"inside\", \"special-attr\", {\n        \"script\": {\n            // Allow for two levels of nesting\n            pattern: re(/=<BRACES>/.source),\n            alias: \"language-javascript\",\n            inside: {\n                \"script-punctuation\": {\n                    pattern: /^=(?=\\{)/,\n                    alias: \"punctuation\"\n                },\n                rest: Prism.languages.jsx\n            }\n        }\n    }, Prism.languages.jsx.tag);\n    // The following will handle plain text inside tags\n    var stringifyToken = function(token) {\n        if (!token) {\n            return \"\";\n        }\n        if (typeof token === \"string\") {\n            return token;\n        }\n        if (typeof token.content === \"string\") {\n            return token.content;\n        }\n        return token.content.map(stringifyToken).join(\"\");\n    };\n    var walkTokens = function(tokens) {\n        var openedTags = [];\n        for(var i = 0; i < tokens.length; i++){\n            var token = tokens[i];\n            var notTagNorBrace = false;\n            if (typeof token !== \"string\") {\n                if (token.type === \"tag\" && token.content[0] && token.content[0].type === \"tag\") {\n                    // We found a tag, now find its kind\n                    if (token.content[0].content[0].content === \"</\") {\n                        // Closing tag\n                        if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {\n                            // Pop matching opening tag\n                            openedTags.pop();\n                        }\n                    } else {\n                        if (token.content[token.content.length - 1].content === \"/>\") ;\n                        else {\n                            // Opening tag\n                            openedTags.push({\n                                tagName: stringifyToken(token.content[0].content[1]),\n                                openedBraces: 0\n                            });\n                        }\n                    }\n                } else if (openedTags.length > 0 && token.type === \"punctuation\" && token.content === \"{\") {\n                    // Here we might have entered a JSX context inside a tag\n                    openedTags[openedTags.length - 1].openedBraces++;\n                } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === \"punctuation\" && token.content === \"}\") {\n                    // Here we might have left a JSX context inside a tag\n                    openedTags[openedTags.length - 1].openedBraces--;\n                } else {\n                    notTagNorBrace = true;\n                }\n            }\n            if (notTagNorBrace || typeof token === \"string\") {\n                if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {\n                    // Here we are inside a tag, and not inside a JSX context.\n                    // That's plain text: drop any tokens matched.\n                    var plainText = stringifyToken(token);\n                    // And merge text with adjacent text\n                    if (i < tokens.length - 1 && (typeof tokens[i + 1] === \"string\" || tokens[i + 1].type === \"plain-text\")) {\n                        plainText += stringifyToken(tokens[i + 1]);\n                        tokens.splice(i + 1, 1);\n                    }\n                    if (i > 0 && (typeof tokens[i - 1] === \"string\" || tokens[i - 1].type === \"plain-text\")) {\n                        plainText = stringifyToken(tokens[i - 1]) + plainText;\n                        tokens.splice(i - 1, 1);\n                        i--;\n                    }\n                    tokens[i] = new Prism.Token(\"plain-text\", plainText, null, plainText);\n                }\n            }\n            if (token.content && typeof token.content !== \"string\") {\n                walkTokens(token.content);\n            }\n        }\n    };\n    Prism.hooks.add(\"after-tokenize\", function(env) {\n        if (env.language !== \"jsx\" && env.language !== \"tsx\") {\n            return;\n        }\n        walkTokens(env.tokens);\n    });\n})(Prism);\n// https://www.json.org/json-en.html\nPrism.languages.json = {\n    \"property\": {\n        pattern: /(^|[^\\\\])\"(?:\\\\.|[^\\\\\"\\r\\n])*\"(?=\\s*:)/,\n        lookbehind: true,\n        greedy: true\n    },\n    \"string\": {\n        pattern: /(^|[^\\\\])\"(?:\\\\.|[^\\\\\"\\r\\n])*\"(?!\\s*:)/,\n        lookbehind: true,\n        greedy: true\n    },\n    \"comment\": {\n        pattern: /\\/\\/.*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n        greedy: true\n    },\n    \"number\": /-?\\b\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n    \"punctuation\": /[{}[\\],]/,\n    \"operator\": /:/,\n    \"boolean\": /\\b(?:false|true)\\b/,\n    \"null\": {\n        pattern: /\\bnull\\b/,\n        alias: \"keyword\"\n    }\n};\nPrism.languages.webmanifest = Prism.languages.json;\n(function(Prism) {\n    Prism.languages.kotlin = Prism.languages.extend(\"clike\", {\n        \"keyword\": {\n            // The lookbehind prevents wrong highlighting of e.g. kotlin.properties.get\n            pattern: /(^|[^.])\\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\\b/,\n            lookbehind: true\n        },\n        \"function\": [\n            {\n                pattern: /(?:`[^\\r\\n`]+`|\\b\\w+)(?=\\s*\\()/,\n                greedy: true\n            },\n            {\n                pattern: /(\\.)(?:`[^\\r\\n`]+`|\\w+)(?=\\s*\\{)/,\n                lookbehind: true,\n                greedy: true\n            }\n        ],\n        \"number\": /\\b(?:0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\\d+(?:_\\d+)*(?:\\.\\d+(?:_\\d+)*)?(?:[eE][+-]?\\d+(?:_\\d+)*)?[fFL]?)\\b/,\n        \"operator\": /\\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\\/*%<>]=?|[?:]:?|\\.\\.|&&|\\|\\||\\b(?:and|inv|or|shl|shr|ushr|xor)\\b/\n    });\n    delete Prism.languages.kotlin[\"class-name\"];\n    var interpolationInside = {\n        \"interpolation-punctuation\": {\n            pattern: /^\\$\\{?|\\}$/,\n            alias: \"punctuation\"\n        },\n        \"expression\": {\n            pattern: /[\\s\\S]+/,\n            inside: Prism.languages.kotlin\n        }\n    };\n    Prism.languages.insertBefore(\"kotlin\", \"string\", {\n        // https://kotlinlang.org/spec/expressions.html#string-interpolation-expressions\n        \"string-literal\": [\n            {\n                pattern: /\"\"\"(?:[^$]|\\$(?:(?!\\{)|\\{[^{}]*\\}))*?\"\"\"/,\n                alias: \"multiline\",\n                inside: {\n                    \"interpolation\": {\n                        pattern: /\\$(?:[a-z_]\\w*|\\{[^{}]*\\})/i,\n                        inside: interpolationInside\n                    },\n                    \"string\": /[\\s\\S]+/\n                }\n            },\n            {\n                pattern: /\"(?:[^\"\\\\\\r\\n$]|\\\\.|\\$(?:(?!\\{)|\\{[^{}]*\\}))*\"/,\n                alias: \"singleline\",\n                inside: {\n                    \"interpolation\": {\n                        pattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$(?:[a-z_]\\w*|\\{[^{}]*\\})/i,\n                        lookbehind: true,\n                        inside: interpolationInside\n                    },\n                    \"string\": /[\\s\\S]+/\n                }\n            }\n        ],\n        \"char\": {\n            // https://kotlinlang.org/spec/expressions.html#character-literals\n            pattern: /'(?:[^'\\\\\\r\\n]|\\\\(?:.|u[a-fA-F0-9]{0,4}))'/,\n            greedy: true\n        }\n    });\n    delete Prism.languages.kotlin[\"string\"];\n    Prism.languages.insertBefore(\"kotlin\", \"keyword\", {\n        \"annotation\": {\n            pattern: /\\B@(?:\\w+:)?(?:[A-Z]\\w*|\\[[^\\]]+\\])/,\n            alias: \"builtin\"\n        }\n    });\n    Prism.languages.insertBefore(\"kotlin\", \"function\", {\n        \"label\": {\n            pattern: /\\b\\w+@|@\\w+\\b/,\n            alias: \"symbol\"\n        }\n    });\n    Prism.languages.kt = Prism.languages.kotlin;\n    Prism.languages.kts = Prism.languages.kotlin;\n})(Prism);\n/* FIXME :\n :extend() is not handled specifically : its highlighting is buggy.\n Mixin usage must be inside a ruleset to be highlighted.\n At-rules (e.g. import) containing interpolations are buggy.\n Detached rulesets are highlighted as at-rules.\n A comment before a mixin usage prevents the latter to be properly highlighted.\n */ Prism.languages.less = Prism.languages.extend(\"css\", {\n    \"comment\": [\n        /\\/\\*[\\s\\S]*?\\*\\//,\n        {\n            pattern: /(^|[^\\\\])\\/\\/.*/,\n            lookbehind: true\n        }\n    ],\n    \"atrule\": {\n        pattern: /@[\\w-](?:\\((?:[^(){}]|\\([^(){}]*\\))*\\)|[^(){};\\s]|\\s+(?!\\s))*?(?=\\s*\\{)/,\n        inside: {\n            \"punctuation\": /[:()]/\n        }\n    },\n    // selectors and mixins are considered the same\n    \"selector\": {\n        pattern: /(?:@\\{[\\w-]+\\}|[^{};\\s@])(?:@\\{[\\w-]+\\}|\\((?:[^(){}]|\\([^(){}]*\\))*\\)|[^(){};@\\s]|\\s+(?!\\s))*?(?=\\s*\\{)/,\n        inside: {\n            // mixin parameters\n            \"variable\": /@+[\\w-]+/\n        }\n    },\n    \"property\": /(?:@\\{[\\w-]+\\}|[\\w-])+(?:\\+_?)?(?=\\s*:)/,\n    \"operator\": /[+\\-*\\/]/\n});\nPrism.languages.insertBefore(\"less\", \"property\", {\n    \"variable\": [\n        // Variable declaration (the colon must be consumed!)\n        {\n            pattern: /@[\\w-]+\\s*:/,\n            inside: {\n                \"punctuation\": /:/\n            }\n        },\n        // Variable usage\n        /@@?[\\w-]+/\n    ],\n    \"mixin-usage\": {\n        pattern: /([{;]\\s*)[.#](?!\\d)[\\w-].*?(?=[(;])/,\n        lookbehind: true,\n        alias: \"function\"\n    }\n});\nPrism.languages.lua = {\n    \"comment\": /^#!.+|--(?:\\[(=*)\\[[\\s\\S]*?\\]\\1\\]|.*)/m,\n    // \\z may be used to skip the following space\n    \"string\": {\n        pattern: /([\"'])(?:(?!\\1)[^\\\\\\r\\n]|\\\\z(?:\\r\\n|\\s)|\\\\(?:\\r\\n|[^z]))*\\1|\\[(=*)\\[[\\s\\S]*?\\]\\2\\]/,\n        greedy: true\n    },\n    \"number\": /\\b0x[a-f\\d]+(?:\\.[a-f\\d]*)?(?:p[+-]?\\d+)?\\b|\\b\\d+(?:\\.\\B|(?:\\.\\d*)?(?:e[+-]?\\d+)?\\b)|\\B\\.\\d+(?:e[+-]?\\d+)?\\b/i,\n    \"keyword\": /\\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\\b/,\n    \"function\": /(?!\\d)\\w+(?=\\s*(?:[({]))/,\n    \"operator\": [\n        /[-+*%^&|#]|\\/\\/?|<[<=]?|>[>=]?|[=~]=?/,\n        {\n            // Match \"..\" but don't break \"...\"\n            pattern: /(^|[^.])\\.\\.(?!\\.)/,\n            lookbehind: true\n        }\n    ],\n    \"punctuation\": /[\\[\\](){},;]|\\.+|:+/\n};\nPrism.languages.makefile = {\n    \"comment\": {\n        pattern: /(^|[^\\\\])#(?:\\\\(?:\\r\\n|[\\s\\S])|[^\\\\\\r\\n])*/,\n        lookbehind: true\n    },\n    \"string\": {\n        pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n        greedy: true\n    },\n    \"builtin-target\": {\n        pattern: /\\.[A-Z][^:#=\\s]+(?=\\s*:(?!=))/,\n        alias: \"builtin\"\n    },\n    \"target\": {\n        pattern: /^(?:[^:=\\s]|[ \\t]+(?![\\s:]))+(?=\\s*:(?!=))/m,\n        alias: \"symbol\",\n        inside: {\n            \"variable\": /\\$+(?:(?!\\$)[^(){}:#=\\s]+|(?=[({]))/\n        }\n    },\n    \"variable\": /\\$+(?:(?!\\$)[^(){}:#=\\s]+|\\([@*%<^+?][DF]\\)|(?=[({]))/,\n    // Directives\n    \"keyword\": /-include\\b|\\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\\b/,\n    \"function\": {\n        pattern: /(\\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \\t])/,\n        lookbehind: true\n    },\n    \"operator\": /(?:::|[?:+!])?=|[|@]/,\n    \"punctuation\": /[:;(){}]/\n};\n(function(Prism) {\n    // https://yaml.org/spec/1.2/spec.html#c-ns-anchor-property\n    // https://yaml.org/spec/1.2/spec.html#c-ns-alias-node\n    var anchorOrAlias = /[*&][^\\s[\\]{},]+/;\n    // https://yaml.org/spec/1.2/spec.html#c-ns-tag-property\n    var tag = /!(?:<[\\w\\-%#;/?:@&=+$,.!~*'()[\\]]+>|(?:[a-zA-Z\\d-]*!)?[\\w\\-%#;/?:@&=+$.~*'()]+)?/;\n    // https://yaml.org/spec/1.2/spec.html#c-ns-properties(n,c)\n    var properties = \"(?:\" + tag.source + \"(?:[ \t]+\" + anchorOrAlias.source + \")?|\" + anchorOrAlias.source + \"(?:[ \t]+\" + tag.source + \")?)\";\n    // https://yaml.org/spec/1.2/spec.html#ns-plain(n,c)\n    // This is a simplified version that doesn't support \"#\" and multiline keys\n    // All these long scarry character classes are simplified versions of YAML's characters\n    var plainKey = /(?:[^\\s\\x00-\\x08\\x0e-\\x1f!\"#%&'*,\\-:>?@[\\]`{|}\\x7f-\\x84\\x86-\\x9f\\ud800-\\udfff\\ufffe\\uffff]|[?:-]<PLAIN>)(?:[ \\t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {\n        return /[^\\s\\x00-\\x08\\x0e-\\x1f,[\\]{}\\x7f-\\x84\\x86-\\x9f\\ud800-\\udfff\\ufffe\\uffff]/.source;\n    });\n    var string = /\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"|'(?:[^'\\\\\\r\\n]|\\\\.)*'/.source;\n    /**\n   *\n   * @param {string} value\n   * @param {string} [flags]\n   * @returns {RegExp}\n   */ function createValuePattern(value, flags) {\n        flags = (flags || \"\").replace(/m/g, \"\") + \"m\"; // add m flag\n        var pattern = /([:\\-,[{]\\s*(?:\\s<<prop>>[ \\t]+)?)(?:<<value>>)(?=[ \\t]*(?:$|,|\\]|\\}|(?:[\\r\\n]\\s*)?#))/.source.replace(/<<prop>>/g, function() {\n            return properties;\n        }).replace(/<<value>>/g, function() {\n            return value;\n        });\n        return RegExp(pattern, flags);\n    }\n    Prism.languages.yaml = {\n        \"scalar\": {\n            pattern: RegExp(/([\\-:]\\s*(?:\\s<<prop>>[ \\t]+)?[|>])[ \\t]*(?:((?:\\r?\\n|\\r)[ \\t]+)\\S[^\\r\\n]*(?:\\2[^\\r\\n]+)*)/.source.replace(/<<prop>>/g, function() {\n                return properties;\n            })),\n            lookbehind: true,\n            alias: \"string\"\n        },\n        \"comment\": /#.*/,\n        \"key\": {\n            pattern: RegExp(/((?:^|[:\\-,[{\\r\\n?])[ \\t]*(?:<<prop>>[ \\t]+)?)<<key>>(?=\\s*:\\s)/.source.replace(/<<prop>>/g, function() {\n                return properties;\n            }).replace(/<<key>>/g, function() {\n                return \"(?:\" + plainKey + \"|\" + string + \")\";\n            })),\n            lookbehind: true,\n            greedy: true,\n            alias: \"atrule\"\n        },\n        \"directive\": {\n            pattern: /(^[ \\t]*)%.+/m,\n            lookbehind: true,\n            alias: \"important\"\n        },\n        \"datetime\": {\n            pattern: createValuePattern(/\\d{4}-\\d\\d?-\\d\\d?(?:[tT]|[ \\t]+)\\d\\d?:\\d{2}:\\d{2}(?:\\.\\d*)?(?:[ \\t]*(?:Z|[-+]\\d\\d?(?::\\d{2})?))?|\\d{4}-\\d{2}-\\d{2}|\\d\\d?:\\d{2}(?::\\d{2}(?:\\.\\d*)?)?/.source),\n            lookbehind: true,\n            alias: \"number\"\n        },\n        \"boolean\": {\n            pattern: createValuePattern(/false|true/.source, \"i\"),\n            lookbehind: true,\n            alias: \"important\"\n        },\n        \"null\": {\n            pattern: createValuePattern(/null|~/.source, \"i\"),\n            lookbehind: true,\n            alias: \"important\"\n        },\n        \"string\": {\n            pattern: createValuePattern(string),\n            lookbehind: true,\n            greedy: true\n        },\n        \"number\": {\n            pattern: createValuePattern(/[+-]?(?:0x[\\da-f]+|0o[0-7]+|(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?|\\.inf|\\.nan)/.source, \"i\"),\n            lookbehind: true\n        },\n        \"tag\": tag,\n        \"important\": anchorOrAlias,\n        \"punctuation\": /---|[:[\\]{}\\-,|>?]|\\.\\.\\./\n    };\n    Prism.languages.yml = Prism.languages.yaml;\n})(Prism);\n(function(Prism) {\n    // Allow only one line break\n    var inner = /(?:\\\\.|[^\\\\\\n\\r]|(?:\\n|\\r\\n?)(?![\\r\\n]))/.source;\n    /**\n   * This function is intended for the creation of the bold or italic pattern.\n   *\n   * This also adds a lookbehind group to the given pattern to ensure that the pattern is not backslash-escaped.\n   *\n   * _Note:_ Keep in mind that this adds a capturing group.\n   *\n   * @param {string} pattern\n   * @returns {RegExp}\n   */ function createInline(pattern) {\n        pattern = pattern.replace(/<inner>/g, function() {\n            return inner;\n        });\n        return RegExp(/((?:^|[^\\\\])(?:\\\\{2})*)/.source + \"(?:\" + pattern + \")\");\n    }\n    var tableCell = /(?:\\\\.|``(?:[^`\\r\\n]|`(?!`))+``|`[^`\\r\\n]+`|[^\\\\|\\r\\n`])+/.source;\n    var tableRow = /\\|?__(?:\\|__)+\\|?(?:(?:\\n|\\r\\n?)|(?![\\s\\S]))/.source.replace(/__/g, function() {\n        return tableCell;\n    });\n    var tableLine = /\\|?[ \\t]*:?-{3,}:?[ \\t]*(?:\\|[ \\t]*:?-{3,}:?[ \\t]*)+\\|?(?:\\n|\\r\\n?)/.source;\n    Prism.languages.markdown = Prism.languages.extend(\"markup\", {});\n    Prism.languages.insertBefore(\"markdown\", \"prolog\", {\n        \"front-matter-block\": {\n            pattern: /(^(?:\\s*[\\r\\n])?)---(?!.)[\\s\\S]*?[\\r\\n]---(?!.)/,\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"punctuation\": /^---|---$/,\n                \"front-matter\": {\n                    pattern: /\\S+(?:\\s+\\S+)*/,\n                    alias: [\n                        \"yaml\",\n                        \"language-yaml\"\n                    ],\n                    inside: Prism.languages.yaml\n                }\n            }\n        },\n        \"blockquote\": {\n            // > ...\n            pattern: /^>(?:[\\t ]*>)*/m,\n            alias: \"punctuation\"\n        },\n        \"table\": {\n            pattern: RegExp(\"^\" + tableRow + tableLine + \"(?:\" + tableRow + \")*\", \"m\"),\n            inside: {\n                \"table-data-rows\": {\n                    pattern: RegExp(\"^(\" + tableRow + tableLine + \")(?:\" + tableRow + \")*$\"),\n                    lookbehind: true,\n                    inside: {\n                        \"table-data\": {\n                            pattern: RegExp(tableCell),\n                            inside: Prism.languages.markdown\n                        },\n                        \"punctuation\": /\\|/\n                    }\n                },\n                \"table-line\": {\n                    pattern: RegExp(\"^(\" + tableRow + \")\" + tableLine + \"$\"),\n                    lookbehind: true,\n                    inside: {\n                        \"punctuation\": /\\||:?-{3,}:?/\n                    }\n                },\n                \"table-header-row\": {\n                    pattern: RegExp(\"^\" + tableRow + \"$\"),\n                    inside: {\n                        \"table-header\": {\n                            pattern: RegExp(tableCell),\n                            alias: \"important\",\n                            inside: Prism.languages.markdown\n                        },\n                        \"punctuation\": /\\|/\n                    }\n                }\n            }\n        },\n        \"code\": [\n            {\n                // Prefixed by 4 spaces or 1 tab and preceded by an empty line\n                pattern: /((?:^|\\n)[ \\t]*\\n|(?:^|\\r\\n?)[ \\t]*\\r\\n?)(?: {4}|\\t).+(?:(?:\\n|\\r\\n?)(?: {4}|\\t).+)*/,\n                lookbehind: true,\n                alias: \"keyword\"\n            },\n            {\n                // ```optional language\n                // code block\n                // ```\n                pattern: /^```[\\s\\S]*?^```$/m,\n                greedy: true,\n                inside: {\n                    \"code-block\": {\n                        pattern: /^(```.*(?:\\n|\\r\\n?))[\\s\\S]+?(?=(?:\\n|\\r\\n?)^```$)/m,\n                        lookbehind: true\n                    },\n                    \"code-language\": {\n                        pattern: /^(```).+/,\n                        lookbehind: true\n                    },\n                    \"punctuation\": /```/\n                }\n            }\n        ],\n        \"title\": [\n            {\n                // title 1\n                // =======\n                // title 2\n                // -------\n                pattern: /\\S.*(?:\\n|\\r\\n?)(?:==+|--+)(?=[ \\t]*$)/m,\n                alias: \"important\",\n                inside: {\n                    punctuation: /==+$|--+$/\n                }\n            },\n            {\n                // # title 1\n                // ###### title 6\n                pattern: /(^\\s*)#.+/m,\n                lookbehind: true,\n                alias: \"important\",\n                inside: {\n                    punctuation: /^#+|#+$/\n                }\n            }\n        ],\n        \"hr\": {\n            // ***\n            // ---\n            // * * *\n            // -----------\n            pattern: /(^\\s*)([*-])(?:[\\t ]*\\2){2,}(?=\\s*$)/m,\n            lookbehind: true,\n            alias: \"punctuation\"\n        },\n        \"list\": {\n            // * item\n            // + item\n            // - item\n            // 1. item\n            pattern: /(^\\s*)(?:[*+-]|\\d+\\.)(?=[\\t ].)/m,\n            lookbehind: true,\n            alias: \"punctuation\"\n        },\n        \"url-reference\": {\n            // [id]: http://example.com \"Optional title\"\n            // [id]: http://example.com 'Optional title'\n            // [id]: http://example.com (Optional title)\n            // [id]: <http://example.com> \"Optional title\"\n            pattern: /!?\\[[^\\]]+\\]:[\\t ]+(?:\\S+|<(?:\\\\.|[^>\\\\])+>)(?:[\\t ]+(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\)))?/,\n            inside: {\n                \"variable\": {\n                    pattern: /^(!?\\[)[^\\]]+/,\n                    lookbehind: true\n                },\n                \"string\": /(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\))$/,\n                \"punctuation\": /^[\\[\\]!:]|[<>]/\n            },\n            alias: \"url\"\n        },\n        \"bold\": {\n            // **strong**\n            // __strong__\n            // allow one nested instance of italic text using the same delimiter\n            pattern: createInline(/\\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\\b|\\*\\*(?:(?!\\*)<inner>|\\*(?:(?!\\*)<inner>)+\\*)+\\*\\*/.source),\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"content\": {\n                    pattern: /(^..)[\\s\\S]+(?=..$)/,\n                    lookbehind: true,\n                    inside: {} // see below\n                },\n                \"punctuation\": /\\*\\*|__/\n            }\n        },\n        \"italic\": {\n            // *em*\n            // _em_\n            // allow one nested instance of bold text using the same delimiter\n            pattern: createInline(/\\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\\b|\\*(?:(?!\\*)<inner>|\\*\\*(?:(?!\\*)<inner>)+\\*\\*)+\\*/.source),\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"content\": {\n                    pattern: /(^.)[\\s\\S]+(?=.$)/,\n                    lookbehind: true,\n                    inside: {} // see below\n                },\n                \"punctuation\": /[*_]/\n            }\n        },\n        \"strike\": {\n            // ~~strike through~~\n            // ~strike~\n            // eslint-disable-next-line regexp/strict\n            pattern: createInline(/(~~?)(?:(?!~)<inner>)+\\2/.source),\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"content\": {\n                    pattern: /(^~~?)[\\s\\S]+(?=\\1$)/,\n                    lookbehind: true,\n                    inside: {} // see below\n                },\n                \"punctuation\": /~~?/\n            }\n        },\n        \"code-snippet\": {\n            // `code`\n            // ``code``\n            pattern: /(^|[^\\\\`])(?:``[^`\\r\\n]+(?:`[^`\\r\\n]+)*``(?!`)|`[^`\\r\\n]+`(?!`))/,\n            lookbehind: true,\n            greedy: true,\n            alias: [\n                \"code\",\n                \"keyword\"\n            ]\n        },\n        \"url\": {\n            // [example](http://example.com \"Optional title\")\n            // [example][id]\n            // [example] [id]\n            pattern: createInline(/!?\\[(?:(?!\\])<inner>)+\\](?:\\([^\\s)]+(?:[\\t ]+\"(?:\\\\.|[^\"\\\\])*\")?\\)|[ \\t]?\\[(?:(?!\\])<inner>)+\\])/.source),\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"operator\": /^!/,\n                \"content\": {\n                    pattern: /(^\\[)[^\\]]+(?=\\])/,\n                    lookbehind: true,\n                    inside: {} // see below\n                },\n                \"variable\": {\n                    pattern: /(^\\][ \\t]?\\[)[^\\]]+(?=\\]$)/,\n                    lookbehind: true\n                },\n                \"url\": {\n                    pattern: /(^\\]\\()[^\\s)]+/,\n                    lookbehind: true\n                },\n                \"string\": {\n                    pattern: /(^[ \\t]+)\"(?:\\\\.|[^\"\\\\])*\"(?=\\)$)/,\n                    lookbehind: true\n                }\n            }\n        }\n    });\n    [\n        \"url\",\n        \"bold\",\n        \"italic\",\n        \"strike\"\n    ].forEach(function(token) {\n        [\n            \"url\",\n            \"bold\",\n            \"italic\",\n            \"strike\",\n            \"code-snippet\"\n        ].forEach(function(inside) {\n            if (token !== inside) {\n                Prism.languages.markdown[token].inside.content.inside[inside] = Prism.languages.markdown[inside];\n            }\n        });\n    });\n    Prism.hooks.add(\"after-tokenize\", function(env) {\n        if (env.language !== \"markdown\" && env.language !== \"md\") {\n            return;\n        }\n        function walkTokens(tokens) {\n            if (!tokens || typeof tokens === \"string\") {\n                return;\n            }\n            for(var i = 0, l = tokens.length; i < l; i++){\n                var token = tokens[i];\n                if (token.type !== \"code\") {\n                    walkTokens(token.content);\n                    continue;\n                }\n                /*\n         * Add the correct `language-xxxx` class to this code block. Keep in mind that the `code-language` token\n         * is optional. But the grammar is defined so that there is only one case we have to handle:\n         *\n         * token.content = [\n         *     <span class=\"punctuation\">```</span>,\n         *     <span class=\"code-language\">xxxx</span>,\n         *     '\\n', // exactly one new lines (\\r or \\n or \\r\\n)\n         *     <span class=\"code-block\">...</span>,\n         *     '\\n', // exactly one new lines again\n         *     <span class=\"punctuation\">```</span>\n         * ];\n         */ var codeLang = token.content[1];\n                var codeBlock = token.content[3];\n                if (codeLang && codeBlock && codeLang.type === \"code-language\" && codeBlock.type === \"code-block\" && typeof codeLang.content === \"string\") {\n                    // this might be a language that Prism does not support\n                    // do some replacements to support C++, C#, and F#\n                    var lang = codeLang.content.replace(/\\b#/g, \"sharp\").replace(/\\b\\+\\+/g, \"pp\");\n                    // only use the first word\n                    lang = (/[a-z][\\w-]*/i.exec(lang) || [\n                        \"\"\n                    ])[0].toLowerCase();\n                    var alias = \"language-\" + lang;\n                    // add alias\n                    if (!codeBlock.alias) {\n                        codeBlock.alias = [\n                            alias\n                        ];\n                    } else if (typeof codeBlock.alias === \"string\") {\n                        codeBlock.alias = [\n                            codeBlock.alias,\n                            alias\n                        ];\n                    } else {\n                        codeBlock.alias.push(alias);\n                    }\n                }\n            }\n        }\n        walkTokens(env.tokens);\n    });\n    Prism.hooks.add(\"wrap\", function(env) {\n        if (env.type !== \"code-block\") {\n            return;\n        }\n        var codeLang = \"\";\n        for(var i = 0, l = env.classes.length; i < l; i++){\n            var cls = env.classes[i];\n            var match = /language-(.+)/.exec(cls);\n            if (match) {\n                codeLang = match[1];\n                break;\n            }\n        }\n        var grammar = Prism.languages[codeLang];\n        if (!grammar) {\n            if (codeLang && codeLang !== \"none\" && Prism.plugins.autoloader) {\n                var id = \"md-\" + new Date().valueOf() + \"-\" + Math.floor(Math.random() * 1e16);\n                env.attributes[\"id\"] = id;\n                Prism.plugins.autoloader.loadLanguages(codeLang, function() {\n                    var ele = document.getElementById(id);\n                    if (ele) {\n                        ele.innerHTML = Prism.highlight(ele.textContent, Prism.languages[codeLang], codeLang);\n                    }\n                });\n            }\n        } else {\n            env.content = Prism.highlight(textContent(env.content), grammar, codeLang);\n        }\n    });\n    var tagPattern = RegExp(Prism.languages.markup.tag.pattern.source, \"gi\");\n    /**\n   * A list of known entity names.\n   *\n   * This will always be incomplete to save space. The current list is the one used by lowdash's unescape function.\n   *\n   * @see {@link https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/unescape.js#L2}\n   */ var KNOWN_ENTITY_NAMES = {\n        \"amp\": \"&\",\n        \"lt\": \"<\",\n        \"gt\": \">\",\n        \"quot\": '\"'\n    };\n    // IE 11 doesn't support `String.fromCodePoint`\n    var fromCodePoint = String.fromCodePoint || String.fromCharCode;\n    /**\n   * Returns the text content of a given HTML source code string.\n   *\n   * @param {string} html\n   * @returns {string}\n   */ function textContent(html) {\n        // remove all tags\n        var text = html.replace(tagPattern, \"\");\n        // decode known entities\n        text = text.replace(/&(\\w{1,8}|#x?[\\da-f]{1,8});/gi, function(m, code) {\n            code = code.toLowerCase();\n            if (code[0] === \"#\") {\n                var value;\n                if (code[1] === \"x\") {\n                    value = parseInt(code.slice(2), 16);\n                } else {\n                    value = Number(code.slice(1));\n                }\n                return fromCodePoint(value);\n            } else {\n                var known = KNOWN_ENTITY_NAMES[code];\n                if (known) {\n                    return known;\n                }\n                // unable to decode\n                return m;\n            }\n        });\n        return text;\n    }\n    Prism.languages.md = Prism.languages.markdown;\n})(Prism);\nPrism.languages.objectivec = Prism.languages.extend(\"c\", {\n    \"string\": {\n        pattern: /@?\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"/,\n        greedy: true\n    },\n    \"keyword\": /\\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\\b/,\n    \"operator\": /-[->]?|\\+\\+?|!=?|<<?=?|>>?=?|==?|&&?|\\|\\|?|[~^%?*\\/@]/\n});\ndelete Prism.languages.objectivec[\"class-name\"];\nPrism.languages.objc = Prism.languages.objectivec;\n(function(Prism) {\n    var brackets = /(?:\\((?:[^()\\\\]|\\\\[\\s\\S])*\\)|\\{(?:[^{}\\\\]|\\\\[\\s\\S])*\\}|\\[(?:[^[\\]\\\\]|\\\\[\\s\\S])*\\]|<(?:[^<>\\\\]|\\\\[\\s\\S])*>)/.source;\n    Prism.languages.perl = {\n        \"comment\": [\n            {\n                // POD\n                pattern: /(^\\s*)=\\w[\\s\\S]*?=cut.*/m,\n                lookbehind: true,\n                greedy: true\n            },\n            {\n                pattern: /(^|[^\\\\$])#.*/,\n                lookbehind: true,\n                greedy: true\n            }\n        ],\n        // TODO Could be nice to handle Heredoc too.\n        \"string\": [\n            {\n                pattern: RegExp(/\\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\\s*/.source + \"(?:\" + [\n                    // q/.../\n                    /([^a-zA-Z0-9\\s{(\\[<])(?:(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1/.source,\n                    // q a...a\n                    // eslint-disable-next-line regexp/strict\n                    /([a-zA-Z0-9])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2/.source,\n                    // q(...)\n                    // q{...}\n                    // q[...]\n                    // q<...>\n                    brackets\n                ].join(\"|\") + \")\"),\n                greedy: true\n            },\n            // \"...\", `...`\n            {\n                pattern: /(\"|`)(?:(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1/,\n                greedy: true\n            },\n            // '...'\n            // FIXME Multi-line single-quoted strings are not supported as they would break variables containing '\n            {\n                pattern: /'(?:[^'\\\\\\r\\n]|\\\\.)*'/,\n                greedy: true\n            }\n        ],\n        \"regex\": [\n            {\n                pattern: RegExp(/\\b(?:m|qr)(?![a-zA-Z0-9])\\s*/.source + \"(?:\" + [\n                    // m/.../\n                    /([^a-zA-Z0-9\\s{(\\[<])(?:(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1/.source,\n                    // m a...a\n                    // eslint-disable-next-line regexp/strict\n                    /([a-zA-Z0-9])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2/.source,\n                    // m(...)\n                    // m{...}\n                    // m[...]\n                    // m<...>\n                    brackets\n                ].join(\"|\") + \")\" + /[msixpodualngc]*/.source),\n                greedy: true\n            },\n            // The lookbehinds prevent -s from breaking\n            {\n                pattern: RegExp(/(^|[^-])\\b(?:s|tr|y)(?![a-zA-Z0-9])\\s*/.source + \"(?:\" + [\n                    // s/.../.../\n                    // eslint-disable-next-line regexp/strict\n                    /([^a-zA-Z0-9\\s{(\\[<])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2/.source,\n                    // s a...a...a\n                    // eslint-disable-next-line regexp/strict\n                    /([a-zA-Z0-9])(?:(?!\\3)[^\\\\]|\\\\[\\s\\S])*\\3(?:(?!\\3)[^\\\\]|\\\\[\\s\\S])*\\3/.source,\n                    // s(...)(...)\n                    // s{...}{...}\n                    // s[...][...]\n                    // s<...><...>\n                    // s(...)[...]\n                    brackets + /\\s*/.source + brackets\n                ].join(\"|\") + \")\" + /[msixpodualngcer]*/.source),\n                lookbehind: true,\n                greedy: true\n            },\n            // /.../\n            // The look-ahead tries to prevent two divisions on\n            // the same line from being highlighted as regex.\n            // This does not support multi-line regex.\n            {\n                pattern: /\\/(?:[^\\/\\\\\\r\\n]|\\\\.)*\\/[msixpodualngc]*(?=\\s*(?:$|[\\r\\n,.;})&|\\-+*~<>!?^]|(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|x|xor)\\b))/,\n                greedy: true\n            }\n        ],\n        // FIXME Not sure about the handling of ::, ', and #\n        \"variable\": [\n            // ${^POSTMATCH}\n            /[&*$@%]\\{\\^[A-Z]+\\}/,\n            // $^V\n            /[&*$@%]\\^[A-Z_]/,\n            // ${...}\n            /[&*$@%]#?(?=\\{)/,\n            // $foo\n            /[&*$@%]#?(?:(?:::)*'?(?!\\d)[\\w$]+(?![\\w$]))+(?:::)*/,\n            // $1\n            /[&*$@%]\\d+/,\n            // $_, @_, %!\n            // The negative lookahead prevents from breaking the %= operator\n            /(?!%=)[$@%][!\"#$%&'()*+,\\-.\\/:;<=>?@[\\\\\\]^_`{|}~]/\n        ],\n        \"filehandle\": {\n            // <>, <FOO>, _\n            pattern: /<(?![<=])\\S*?>|\\b_\\b/,\n            alias: \"symbol\"\n        },\n        \"v-string\": {\n            // v1.2, 1.2.3\n            pattern: /v\\d+(?:\\.\\d+)*|\\d+(?:\\.\\d+){2,}/,\n            alias: \"string\"\n        },\n        \"function\": {\n            pattern: /(\\bsub[ \\t]+)\\w+/,\n            lookbehind: true\n        },\n        \"keyword\": /\\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\\b/,\n        \"number\": /\\b(?:0x[\\dA-Fa-f](?:_?[\\dA-Fa-f])*|0b[01](?:_?[01])*|(?:(?:\\d(?:_?\\d)*)?\\.)?\\d(?:_?\\d)*(?:[Ee][+-]?\\d+)?)\\b/,\n        \"operator\": /-[rwxoRWXOezsfdlpSbctugkTBMAC]\\b|\\+[+=]?|-[-=>]?|\\*\\*?=?|\\/\\/?=?|=[=~>]?|~[~=]?|\\|\\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\\.(?:=|\\.\\.?)?|[\\\\?]|\\bx(?:=|\\b)|\\b(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|xor)\\b/,\n        \"punctuation\": /[{}[\\];(),:]/\n    };\n})(Prism);\n(function(Prism) {\n    /**\n   * Returns the placeholder for the given language id and index.\n   *\n   * @param {string} language\n   * @param {string|number} index\n   * @returns {string}\n   */ function getPlaceholder(language, index) {\n        return \"___\" + language.toUpperCase() + index + \"___\";\n    }\n    Object.defineProperties(Prism.languages[\"markup-templating\"] = {}, {\n        buildPlaceholders: {\n            /**\n       * Tokenize all inline templating expressions matching `placeholderPattern`.\n       *\n       * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns\n       * `true` will be replaced.\n       *\n       * @param {object} env The environment of the `before-tokenize` hook.\n       * @param {string} language The language id.\n       * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.\n       * @param {(match: string) => boolean} [replaceFilter]\n       */ value: function(env, language, placeholderPattern, replaceFilter) {\n                if (env.language !== language) {\n                    return;\n                }\n                var tokenStack = env.tokenStack = [];\n                env.code = env.code.replace(placeholderPattern, function(match) {\n                    if (typeof replaceFilter === \"function\" && !replaceFilter(match)) {\n                        return match;\n                    }\n                    var i = tokenStack.length;\n                    var placeholder;\n                    // Check for existing strings\n                    while(env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1){\n                        ++i;\n                    }\n                    // Create a sparse array\n                    tokenStack[i] = match;\n                    return placeholder;\n                });\n                // Switch the grammar to markup\n                env.grammar = Prism.languages.markup;\n            }\n        },\n        tokenizePlaceholders: {\n            /**\n       * Replace placeholders with proper tokens after tokenizing.\n       *\n       * @param {object} env The environment of the `after-tokenize` hook.\n       * @param {string} language The language id.\n       */ value: function(env, language) {\n                if (env.language !== language || !env.tokenStack) {\n                    return;\n                }\n                // Switch the grammar back\n                env.grammar = Prism.languages[language];\n                var j = 0;\n                var keys = Object.keys(env.tokenStack);\n                function walkTokens(tokens) {\n                    for(var i = 0; i < tokens.length; i++){\n                        // all placeholders are replaced already\n                        if (j >= keys.length) {\n                            break;\n                        }\n                        var token = tokens[i];\n                        if (typeof token === \"string\" || token.content && typeof token.content === \"string\") {\n                            var k = keys[j];\n                            var t = env.tokenStack[k];\n                            var s = typeof token === \"string\" ? token : token.content;\n                            var placeholder = getPlaceholder(language, k);\n                            var index = s.indexOf(placeholder);\n                            if (index > -1) {\n                                ++j;\n                                var before = s.substring(0, index);\n                                var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), \"language-\" + language, t);\n                                var after = s.substring(index + placeholder.length);\n                                var replacement = [];\n                                if (before) {\n                                    replacement.push.apply(replacement, walkTokens([\n                                        before\n                                    ]));\n                                }\n                                replacement.push(middle);\n                                if (after) {\n                                    replacement.push.apply(replacement, walkTokens([\n                                        after\n                                    ]));\n                                }\n                                if (typeof token === \"string\") {\n                                    tokens.splice.apply(tokens, [\n                                        i,\n                                        1\n                                    ].concat(replacement));\n                                } else {\n                                    token.content = replacement;\n                                }\n                            }\n                        } else if (token.content /* && typeof token.content !== 'string' */ ) {\n                            walkTokens(token.content);\n                        }\n                    }\n                    return tokens;\n                }\n                walkTokens(env.tokens);\n            }\n        }\n    });\n})(Prism);\n/**\n * Original by Aaron Harun: http://aahacreative.com/2012/07/31/php-syntax-highlighting-prism/\n * Modified by Miles Johnson: http://milesj.me\n * Rewritten by Tom Pavelec\n *\n * Supports PHP 5.3 - 8.0\n */ (function(Prism) {\n    var comment = /\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*|#(?!\\[).*/;\n    var constant = [\n        {\n            pattern: /\\b(?:false|true)\\b/i,\n            alias: \"boolean\"\n        },\n        {\n            pattern: /(::\\s*)\\b[a-z_]\\w*\\b(?!\\s*\\()/i,\n            greedy: true,\n            lookbehind: true\n        },\n        {\n            pattern: /(\\b(?:case|const)\\s+)\\b[a-z_]\\w*(?=\\s*[;=])/i,\n            greedy: true,\n            lookbehind: true\n        },\n        /\\b(?:null)\\b/i,\n        /\\b[A-Z_][A-Z0-9_]*\\b(?!\\s*\\()/\n    ];\n    var number = /\\b0b[01]+(?:_[01]+)*\\b|\\b0o[0-7]+(?:_[0-7]+)*\\b|\\b0x[\\da-f]+(?:_[\\da-f]+)*\\b|(?:\\b\\d+(?:_\\d+)*\\.?(?:\\d+(?:_\\d+)*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i;\n    var operator = /<?=>|\\?\\?=?|\\.{3}|\\??->|[!=]=?=?|::|\\*\\*=?|--|\\+\\+|&&|\\|\\||<<|>>|[?~]|[/^|%*&<>.+-]=?/;\n    var punctuation = /[{}\\[\\](),:;]/;\n    Prism.languages.php = {\n        \"delimiter\": {\n            pattern: /\\?>$|^<\\?(?:php(?=\\s)|=)?/i,\n            alias: \"important\"\n        },\n        \"comment\": comment,\n        \"variable\": /\\$+(?:\\w+\\b|(?=\\{))/,\n        \"package\": {\n            pattern: /(namespace\\s+|use\\s+(?:function\\s+)?)(?:\\\\?\\b[a-z_]\\w*)+\\b(?!\\\\)/i,\n            lookbehind: true,\n            inside: {\n                \"punctuation\": /\\\\/\n            }\n        },\n        \"class-name-definition\": {\n            pattern: /(\\b(?:class|enum|interface|trait)\\s+)\\b[a-z_]\\w*(?!\\\\)\\b/i,\n            lookbehind: true,\n            alias: \"class-name\"\n        },\n        \"function-definition\": {\n            pattern: /(\\bfunction\\s+)[a-z_]\\w*(?=\\s*\\()/i,\n            lookbehind: true,\n            alias: \"function\"\n        },\n        \"keyword\": [\n            {\n                pattern: /(\\(\\s*)\\b(?:array|bool|boolean|float|int|integer|object|string)\\b(?=\\s*\\))/i,\n                alias: \"type-casting\",\n                greedy: true,\n                lookbehind: true\n            },\n            {\n                pattern: /([(,?]\\s*)\\b(?:array(?!\\s*\\()|bool|callable|(?:false|null)(?=\\s*\\|)|float|int|iterable|mixed|object|self|static|string)\\b(?=\\s*\\$)/i,\n                alias: \"type-hint\",\n                greedy: true,\n                lookbehind: true\n            },\n            {\n                pattern: /(\\)\\s*:\\s*(?:\\?\\s*)?)\\b(?:array(?!\\s*\\()|bool|callable|(?:false|null)(?=\\s*\\|)|float|int|iterable|mixed|never|object|self|static|string|void)\\b/i,\n                alias: \"return-type\",\n                greedy: true,\n                lookbehind: true\n            },\n            {\n                pattern: /\\b(?:array(?!\\s*\\()|bool|float|int|iterable|mixed|object|string|void)\\b/i,\n                alias: \"type-declaration\",\n                greedy: true\n            },\n            {\n                pattern: /(\\|\\s*)(?:false|null)\\b|\\b(?:false|null)(?=\\s*\\|)/i,\n                alias: \"type-declaration\",\n                greedy: true,\n                lookbehind: true\n            },\n            {\n                pattern: /\\b(?:parent|self|static)(?=\\s*::)/i,\n                alias: \"static-context\",\n                greedy: true\n            },\n            {\n                // yield from\n                pattern: /(\\byield\\s+)from\\b/i,\n                lookbehind: true\n            },\n            // `class` is always a keyword unlike other keywords\n            /\\bclass\\b/i,\n            {\n                // https://www.php.net/manual/en/reserved.keywords.php\n                //\n                // keywords cannot be preceded by \"->\"\n                // the complex lookbehind means `(?<!(?:->|::)\\s*)`\n                pattern: /((?:^|[^\\s>:]|(?:^|[^-])>|(?:^|[^:]):)\\s*)\\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|never|new|or|parent|print|private|protected|public|readonly|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\\b/i,\n                lookbehind: true\n            }\n        ],\n        \"argument-name\": {\n            pattern: /([(,]\\s*)\\b[a-z_]\\w*(?=\\s*:(?!:))/i,\n            lookbehind: true\n        },\n        \"class-name\": [\n            {\n                pattern: /(\\b(?:extends|implements|instanceof|new(?!\\s+self|\\s+static))\\s+|\\bcatch\\s*\\()\\b[a-z_]\\w*(?!\\\\)\\b/i,\n                greedy: true,\n                lookbehind: true\n            },\n            {\n                pattern: /(\\|\\s*)\\b[a-z_]\\w*(?!\\\\)\\b/i,\n                greedy: true,\n                lookbehind: true\n            },\n            {\n                pattern: /\\b[a-z_]\\w*(?!\\\\)\\b(?=\\s*\\|)/i,\n                greedy: true\n            },\n            {\n                pattern: /(\\|\\s*)(?:\\\\?\\b[a-z_]\\w*)+\\b/i,\n                alias: \"class-name-fully-qualified\",\n                greedy: true,\n                lookbehind: true,\n                inside: {\n                    \"punctuation\": /\\\\/\n                }\n            },\n            {\n                pattern: /(?:\\\\?\\b[a-z_]\\w*)+\\b(?=\\s*\\|)/i,\n                alias: \"class-name-fully-qualified\",\n                greedy: true,\n                inside: {\n                    \"punctuation\": /\\\\/\n                }\n            },\n            {\n                pattern: /(\\b(?:extends|implements|instanceof|new(?!\\s+self\\b|\\s+static\\b))\\s+|\\bcatch\\s*\\()(?:\\\\?\\b[a-z_]\\w*)+\\b(?!\\\\)/i,\n                alias: \"class-name-fully-qualified\",\n                greedy: true,\n                lookbehind: true,\n                inside: {\n                    \"punctuation\": /\\\\/\n                }\n            },\n            {\n                pattern: /\\b[a-z_]\\w*(?=\\s*\\$)/i,\n                alias: \"type-declaration\",\n                greedy: true\n            },\n            {\n                pattern: /(?:\\\\?\\b[a-z_]\\w*)+(?=\\s*\\$)/i,\n                alias: [\n                    \"class-name-fully-qualified\",\n                    \"type-declaration\"\n                ],\n                greedy: true,\n                inside: {\n                    \"punctuation\": /\\\\/\n                }\n            },\n            {\n                pattern: /\\b[a-z_]\\w*(?=\\s*::)/i,\n                alias: \"static-context\",\n                greedy: true\n            },\n            {\n                pattern: /(?:\\\\?\\b[a-z_]\\w*)+(?=\\s*::)/i,\n                alias: [\n                    \"class-name-fully-qualified\",\n                    \"static-context\"\n                ],\n                greedy: true,\n                inside: {\n                    \"punctuation\": /\\\\/\n                }\n            },\n            {\n                pattern: /([(,?]\\s*)[a-z_]\\w*(?=\\s*\\$)/i,\n                alias: \"type-hint\",\n                greedy: true,\n                lookbehind: true\n            },\n            {\n                pattern: /([(,?]\\s*)(?:\\\\?\\b[a-z_]\\w*)+(?=\\s*\\$)/i,\n                alias: [\n                    \"class-name-fully-qualified\",\n                    \"type-hint\"\n                ],\n                greedy: true,\n                lookbehind: true,\n                inside: {\n                    \"punctuation\": /\\\\/\n                }\n            },\n            {\n                pattern: /(\\)\\s*:\\s*(?:\\?\\s*)?)\\b[a-z_]\\w*(?!\\\\)\\b/i,\n                alias: \"return-type\",\n                greedy: true,\n                lookbehind: true\n            },\n            {\n                pattern: /(\\)\\s*:\\s*(?:\\?\\s*)?)(?:\\\\?\\b[a-z_]\\w*)+\\b(?!\\\\)/i,\n                alias: [\n                    \"class-name-fully-qualified\",\n                    \"return-type\"\n                ],\n                greedy: true,\n                lookbehind: true,\n                inside: {\n                    \"punctuation\": /\\\\/\n                }\n            }\n        ],\n        \"constant\": constant,\n        \"function\": {\n            pattern: /(^|[^\\\\\\w])\\\\?[a-z_](?:[\\w\\\\]*\\w)?(?=\\s*\\()/i,\n            lookbehind: true,\n            inside: {\n                \"punctuation\": /\\\\/\n            }\n        },\n        \"property\": {\n            pattern: /(->\\s*)\\w+/,\n            lookbehind: true\n        },\n        \"number\": number,\n        \"operator\": operator,\n        \"punctuation\": punctuation\n    };\n    var string_interpolation = {\n        pattern: /\\{\\$(?:\\{(?:\\{[^{}]+\\}|[^{}]+)\\}|[^{}])+\\}|(^|[^\\\\{])\\$+(?:\\w+(?:\\[[^\\r\\n\\[\\]]+\\]|->\\w+)?)/,\n        lookbehind: true,\n        inside: Prism.languages.php\n    };\n    var string = [\n        {\n            pattern: /<<<'([^']+)'[\\r\\n](?:.*[\\r\\n])*?\\1;/,\n            alias: \"nowdoc-string\",\n            greedy: true,\n            inside: {\n                \"delimiter\": {\n                    pattern: /^<<<'[^']+'|[a-z_]\\w*;$/i,\n                    alias: \"symbol\",\n                    inside: {\n                        \"punctuation\": /^<<<'?|[';]$/\n                    }\n                }\n            }\n        },\n        {\n            pattern: /<<<(?:\"([^\"]+)\"[\\r\\n](?:.*[\\r\\n])*?\\1;|([a-z_]\\w*)[\\r\\n](?:.*[\\r\\n])*?\\2;)/i,\n            alias: \"heredoc-string\",\n            greedy: true,\n            inside: {\n                \"delimiter\": {\n                    pattern: /^<<<(?:\"[^\"]+\"|[a-z_]\\w*)|[a-z_]\\w*;$/i,\n                    alias: \"symbol\",\n                    inside: {\n                        \"punctuation\": /^<<<\"?|[\";]$/\n                    }\n                },\n                \"interpolation\": string_interpolation\n            }\n        },\n        {\n            pattern: /`(?:\\\\[\\s\\S]|[^\\\\`])*`/,\n            alias: \"backtick-quoted-string\",\n            greedy: true\n        },\n        {\n            pattern: /'(?:\\\\[\\s\\S]|[^\\\\'])*'/,\n            alias: \"single-quoted-string\",\n            greedy: true\n        },\n        {\n            pattern: /\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"/,\n            alias: \"double-quoted-string\",\n            greedy: true,\n            inside: {\n                \"interpolation\": string_interpolation\n            }\n        }\n    ];\n    Prism.languages.insertBefore(\"php\", \"variable\", {\n        \"string\": string,\n        \"attribute\": {\n            pattern: /#\\[(?:[^\"'\\/#]|\\/(?![*/])|\\/\\/.*$|#(?!\\[).*$|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*')+\\](?=\\s*[a-z$#])/im,\n            greedy: true,\n            inside: {\n                \"attribute-content\": {\n                    pattern: /^(#\\[)[\\s\\S]+(?=\\]$)/,\n                    lookbehind: true,\n                    // inside can appear subset of php\n                    inside: {\n                        \"comment\": comment,\n                        \"string\": string,\n                        \"attribute-class-name\": [\n                            {\n                                pattern: /([^:]|^)\\b[a-z_]\\w*(?!\\\\)\\b/i,\n                                alias: \"class-name\",\n                                greedy: true,\n                                lookbehind: true\n                            },\n                            {\n                                pattern: /([^:]|^)(?:\\\\?\\b[a-z_]\\w*)+/i,\n                                alias: [\n                                    \"class-name\",\n                                    \"class-name-fully-qualified\"\n                                ],\n                                greedy: true,\n                                lookbehind: true,\n                                inside: {\n                                    \"punctuation\": /\\\\/\n                                }\n                            }\n                        ],\n                        \"constant\": constant,\n                        \"number\": number,\n                        \"operator\": operator,\n                        \"punctuation\": punctuation\n                    }\n                },\n                \"delimiter\": {\n                    pattern: /^#\\[|\\]$/,\n                    alias: \"punctuation\"\n                }\n            }\n        }\n    });\n    Prism.hooks.add(\"before-tokenize\", function(env) {\n        if (!/<\\?/.test(env.code)) {\n            return;\n        }\n        var phpPattern = /<\\?(?:[^\"'/#]|\\/(?![*/])|(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1|(?:\\/\\/|#(?!\\[))(?:[^?\\n\\r]|\\?(?!>))*(?=$|\\?>|[\\r\\n])|#\\[|\\/\\*(?:[^*]|\\*(?!\\/))*(?:\\*\\/|$))*?(?:\\?>|$)/g;\n        Prism.languages[\"markup-templating\"].buildPlaceholders(env, \"php\", phpPattern);\n    });\n    Prism.hooks.add(\"after-tokenize\", function(env) {\n        Prism.languages[\"markup-templating\"].tokenizePlaceholders(env, \"php\");\n    });\n})(Prism);\nPrism.languages.python = {\n    \"comment\": {\n        pattern: /(^|[^\\\\])#.*/,\n        lookbehind: true,\n        greedy: true\n    },\n    \"string-interpolation\": {\n        pattern: /(?:f|fr|rf)(?:(\"\"\"|''')[\\s\\S]*?\\1|(\"|')(?:\\\\.|(?!\\2)[^\\\\\\r\\n])*\\2)/i,\n        greedy: true,\n        inside: {\n            \"interpolation\": {\n                // \"{\" <expression> <optional \"!s\", \"!r\", or \"!a\"> <optional \":\" format specifier> \"}\"\n                pattern: /((?:^|[^{])(?:\\{\\{)*)\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}])+\\})+\\})+\\}/,\n                lookbehind: true,\n                inside: {\n                    \"format-spec\": {\n                        pattern: /(:)[^:(){}]+(?=\\}$)/,\n                        lookbehind: true\n                    },\n                    \"conversion-option\": {\n                        pattern: /![sra](?=[:}]$)/,\n                        alias: \"punctuation\"\n                    },\n                    rest: null\n                }\n            },\n            \"string\": /[\\s\\S]+/\n        }\n    },\n    \"triple-quoted-string\": {\n        pattern: /(?:[rub]|br|rb)?(\"\"\"|''')[\\s\\S]*?\\1/i,\n        greedy: true,\n        alias: \"string\"\n    },\n    \"string\": {\n        pattern: /(?:[rub]|br|rb)?(\"|')(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/i,\n        greedy: true\n    },\n    \"function\": {\n        pattern: /((?:^|\\s)def[ \\t]+)[a-zA-Z_]\\w*(?=\\s*\\()/g,\n        lookbehind: true\n    },\n    \"class-name\": {\n        pattern: /(\\bclass\\s+)\\w+/i,\n        lookbehind: true\n    },\n    \"decorator\": {\n        pattern: /(^[\\t ]*)@\\w+(?:\\.\\w+)*/m,\n        lookbehind: true,\n        alias: [\n            \"annotation\",\n            \"punctuation\"\n        ],\n        inside: {\n            \"punctuation\": /\\./\n        }\n    },\n    \"keyword\": /\\b(?:_(?=\\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\\b/,\n    \"builtin\": /\\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\\b/,\n    \"boolean\": /\\b(?:False|None|True)\\b/,\n    \"number\": /\\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\\b|(?:\\b\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\B\\.\\d+(?:_\\d+)*)(?:e[+-]?\\d+(?:_\\d+)*)?j?(?!\\w)/i,\n    \"operator\": /[-+%=]=?|!=|:=|\\*\\*?=?|\\/\\/?=?|<[<=>]?|>[=>]?|[&|^~]/,\n    \"punctuation\": /[{}[\\];(),.:]/\n};\nPrism.languages.python[\"string-interpolation\"].inside[\"interpolation\"].inside.rest = Prism.languages.python;\nPrism.languages.py = Prism.languages.python;\nPrism.languages.r = {\n    \"comment\": /#.*/,\n    \"string\": {\n        pattern: /(['\"])(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/,\n        greedy: true\n    },\n    \"percent-operator\": {\n        // Includes user-defined operators\n        // and %%, %*%, %/%, %in%, %o%, %x%\n        pattern: /%[^%\\s]*%/,\n        alias: \"operator\"\n    },\n    \"boolean\": /\\b(?:FALSE|TRUE)\\b/,\n    \"ellipsis\": /\\.\\.(?:\\.|\\d+)/,\n    \"number\": [\n        /\\b(?:Inf|NaN)\\b/,\n        /(?:\\b0x[\\dA-Fa-f]+(?:\\.\\d*)?|\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[EePp][+-]?\\d+)?[iL]?/\n    ],\n    \"keyword\": /\\b(?:NA|NA_character_|NA_complex_|NA_integer_|NA_real_|NULL|break|else|for|function|if|in|next|repeat|while)\\b/,\n    \"operator\": /->?>?|<(?:=|<?-)?|[>=!]=?|::?|&&?|\\|\\|?|[+*\\/^$@~]/,\n    \"punctuation\": /[(){}\\[\\],;]/\n};\n/**\n * Original by Samuel Flores\n *\n * Adds the following new token classes:\n *     constant, builtin, variable, symbol, regex\n */ (function(Prism) {\n    Prism.languages.ruby = Prism.languages.extend(\"clike\", {\n        \"comment\": {\n            pattern: /#.*|^=begin\\s[\\s\\S]*?^=end/m,\n            greedy: true\n        },\n        \"class-name\": {\n            pattern: /(\\b(?:class|module)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+|\\b[A-Z_]\\w*(?=\\s*\\.\\s*new\\b)/,\n            lookbehind: true,\n            inside: {\n                \"punctuation\": /[.\\\\]/\n            }\n        },\n        \"keyword\": /\\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\\b/,\n        \"operator\": /\\.{2,3}|&\\.|===|<?=>|[!=]?~|(?:&&|\\|\\||<<|>>|\\*\\*|[+\\-*/%<>!^&|=])=?|[?:]/,\n        \"punctuation\": /[(){}[\\].,;]/\n    });\n    Prism.languages.insertBefore(\"ruby\", \"operator\", {\n        \"double-colon\": {\n            pattern: /::/,\n            alias: \"punctuation\"\n        }\n    });\n    var interpolation = {\n        pattern: /((?:^|[^\\\\])(?:\\\\{2})*)#\\{(?:[^{}]|\\{[^{}]*\\})*\\}/,\n        lookbehind: true,\n        inside: {\n            \"content\": {\n                pattern: /^(#\\{)[\\s\\S]+(?=\\}$)/,\n                lookbehind: true,\n                inside: Prism.languages.ruby\n            },\n            \"delimiter\": {\n                pattern: /^#\\{|\\}$/,\n                alias: \"punctuation\"\n            }\n        }\n    };\n    delete Prism.languages.ruby.function;\n    var percentExpression = \"(?:\" + [\n        /([^a-zA-Z0-9\\s{(\\[<=])(?:(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1/.source,\n        /\\((?:[^()\\\\]|\\\\[\\s\\S]|\\((?:[^()\\\\]|\\\\[\\s\\S])*\\))*\\)/.source,\n        /\\{(?:[^{}\\\\]|\\\\[\\s\\S]|\\{(?:[^{}\\\\]|\\\\[\\s\\S])*\\})*\\}/.source,\n        /\\[(?:[^\\[\\]\\\\]|\\\\[\\s\\S]|\\[(?:[^\\[\\]\\\\]|\\\\[\\s\\S])*\\])*\\]/.source,\n        /<(?:[^<>\\\\]|\\\\[\\s\\S]|<(?:[^<>\\\\]|\\\\[\\s\\S])*>)*>/.source\n    ].join(\"|\") + \")\";\n    var symbolName = /(?:\"(?:\\\\.|[^\"\\\\\\r\\n])*\"|(?:\\b[a-zA-Z_]\\w*|[^\\s\\0-\\x7F]+)[?!]?|\\$.)/.source;\n    Prism.languages.insertBefore(\"ruby\", \"keyword\", {\n        \"regex-literal\": [\n            {\n                pattern: RegExp(/%r/.source + percentExpression + /[egimnosux]{0,6}/.source),\n                greedy: true,\n                inside: {\n                    \"interpolation\": interpolation,\n                    \"regex\": /[\\s\\S]+/\n                }\n            },\n            {\n                pattern: /(^|[^/])\\/(?!\\/)(?:\\[[^\\r\\n\\]]+\\]|\\\\.|[^[/\\\\\\r\\n])+\\/[egimnosux]{0,6}(?=\\s*(?:$|[\\r\\n,.;})#]))/,\n                lookbehind: true,\n                greedy: true,\n                inside: {\n                    \"interpolation\": interpolation,\n                    \"regex\": /[\\s\\S]+/\n                }\n            }\n        ],\n        \"variable\": /[@$]+[a-zA-Z_]\\w*(?:[?!]|\\b)/,\n        \"symbol\": [\n            {\n                pattern: RegExp(/(^|[^:]):/.source + symbolName),\n                lookbehind: true,\n                greedy: true\n            },\n            {\n                pattern: RegExp(/([\\r\\n{(,][ \\t]*)/.source + symbolName + /(?=:(?!:))/.source),\n                lookbehind: true,\n                greedy: true\n            }\n        ],\n        \"method-definition\": {\n            pattern: /(\\bdef\\s+)\\w+(?:\\s*\\.\\s*\\w+)?/,\n            lookbehind: true,\n            inside: {\n                \"function\": /\\b\\w+$/,\n                \"keyword\": /^self\\b/,\n                \"class-name\": /^\\w+/,\n                \"punctuation\": /\\./\n            }\n        }\n    });\n    Prism.languages.insertBefore(\"ruby\", \"string\", {\n        \"string-literal\": [\n            {\n                pattern: RegExp(/%[qQiIwWs]?/.source + percentExpression),\n                greedy: true,\n                inside: {\n                    \"interpolation\": interpolation,\n                    \"string\": /[\\s\\S]+/\n                }\n            },\n            {\n                pattern: /(\"|')(?:#\\{[^}]+\\}|#(?!\\{)|\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\#\\r\\n])*\\1/,\n                greedy: true,\n                inside: {\n                    \"interpolation\": interpolation,\n                    \"string\": /[\\s\\S]+/\n                }\n            },\n            {\n                pattern: /<<[-~]?([a-z_]\\w*)[\\r\\n](?:.*[\\r\\n])*?[\\t ]*\\1/i,\n                alias: \"heredoc-string\",\n                greedy: true,\n                inside: {\n                    \"delimiter\": {\n                        pattern: /^<<[-~]?[a-z_]\\w*|\\b[a-z_]\\w*$/i,\n                        inside: {\n                            \"symbol\": /\\b\\w+/,\n                            \"punctuation\": /^<<[-~]?/\n                        }\n                    },\n                    \"interpolation\": interpolation,\n                    \"string\": /[\\s\\S]+/\n                }\n            },\n            {\n                pattern: /<<[-~]?'([a-z_]\\w*)'[\\r\\n](?:.*[\\r\\n])*?[\\t ]*\\1/i,\n                alias: \"heredoc-string\",\n                greedy: true,\n                inside: {\n                    \"delimiter\": {\n                        pattern: /^<<[-~]?'[a-z_]\\w*'|\\b[a-z_]\\w*$/i,\n                        inside: {\n                            \"symbol\": /\\b\\w+/,\n                            \"punctuation\": /^<<[-~]?'|'$/\n                        }\n                    },\n                    \"string\": /[\\s\\S]+/\n                }\n            }\n        ],\n        \"command-literal\": [\n            {\n                pattern: RegExp(/%x/.source + percentExpression),\n                greedy: true,\n                inside: {\n                    \"interpolation\": interpolation,\n                    \"command\": {\n                        pattern: /[\\s\\S]+/,\n                        alias: \"string\"\n                    }\n                }\n            },\n            {\n                pattern: /`(?:#\\{[^}]+\\}|#(?!\\{)|\\\\(?:\\r\\n|[\\s\\S])|[^\\\\`#\\r\\n])*`/,\n                greedy: true,\n                inside: {\n                    \"interpolation\": interpolation,\n                    \"command\": {\n                        pattern: /[\\s\\S]+/,\n                        alias: \"string\"\n                    }\n                }\n            }\n        ]\n    });\n    delete Prism.languages.ruby.string;\n    Prism.languages.insertBefore(\"ruby\", \"number\", {\n        \"builtin\": /\\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\\b/,\n        \"constant\": /\\b[A-Z][A-Z0-9_]*(?:[?!]|\\b)/\n    });\n    Prism.languages.rb = Prism.languages.ruby;\n})(Prism);\n(function(Prism) {\n    var multilineComment = /\\/\\*(?:[^*/]|\\*(?!\\/)|\\/(?!\\*)|<self>)*\\*\\//.source;\n    for(var i = 0; i < 2; i++){\n        // support 4 levels of nested comments\n        multilineComment = multilineComment.replace(/<self>/g, function() {\n            return multilineComment;\n        });\n    }\n    multilineComment = multilineComment.replace(/<self>/g, function() {\n        return /[^\\s\\S]/.source;\n    });\n    Prism.languages.rust = {\n        \"comment\": [\n            {\n                pattern: RegExp(/(^|[^\\\\])/.source + multilineComment),\n                lookbehind: true,\n                greedy: true\n            },\n            {\n                pattern: /(^|[^\\\\:])\\/\\/.*/,\n                lookbehind: true,\n                greedy: true\n            }\n        ],\n        \"string\": {\n            pattern: /b?\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|b?r(#*)\"(?:[^\"]|\"(?!\\1))*\"\\1/,\n            greedy: true\n        },\n        \"char\": {\n            pattern: /b?'(?:\\\\(?:x[0-7][\\da-fA-F]|u\\{(?:[\\da-fA-F]_*){1,6}\\}|.)|[^\\\\\\r\\n\\t'])'/,\n            greedy: true\n        },\n        \"attribute\": {\n            pattern: /#!?\\[(?:[^\\[\\]\"]|\"(?:\\\\[\\s\\S]|[^\\\\\"])*\")*\\]/,\n            greedy: true,\n            alias: \"attr-name\",\n            inside: {\n                \"string\": null // see below\n            }\n        },\n        // Closure params should not be confused with bitwise OR |\n        \"closure-params\": {\n            pattern: /([=(,:]\\s*|\\bmove\\s*)\\|[^|]*\\||\\|[^|]*\\|(?=\\s*(?:\\{|->))/,\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"closure-punctuation\": {\n                    pattern: /^\\||\\|$/,\n                    alias: \"punctuation\"\n                },\n                rest: null // see below\n            }\n        },\n        \"lifetime-annotation\": {\n            pattern: /'\\w+/,\n            alias: \"symbol\"\n        },\n        \"fragment-specifier\": {\n            pattern: /(\\$\\w+:)[a-z]+/,\n            lookbehind: true,\n            alias: \"punctuation\"\n        },\n        \"variable\": /\\$\\w+/,\n        \"function-definition\": {\n            pattern: /(\\bfn\\s+)\\w+/,\n            lookbehind: true,\n            alias: \"function\"\n        },\n        \"type-definition\": {\n            pattern: /(\\b(?:enum|struct|trait|type|union)\\s+)\\w+/,\n            lookbehind: true,\n            alias: \"class-name\"\n        },\n        \"module-declaration\": [\n            {\n                pattern: /(\\b(?:crate|mod)\\s+)[a-z][a-z_\\d]*/,\n                lookbehind: true,\n                alias: \"namespace\"\n            },\n            {\n                pattern: /(\\b(?:crate|self|super)\\s*)::\\s*[a-z][a-z_\\d]*\\b(?:\\s*::(?:\\s*[a-z][a-z_\\d]*\\s*::)*)?/,\n                lookbehind: true,\n                alias: \"namespace\",\n                inside: {\n                    \"punctuation\": /::/\n                }\n            }\n        ],\n        \"keyword\": [\n            // https://github.com/rust-lang/reference/blob/master/src/keywords.md\n            /\\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\\b/,\n            // primitives and str\n            // https://doc.rust-lang.org/stable/rust-by-example/primitives.html\n            /\\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\\b/\n        ],\n        // functions can technically start with an upper-case letter, but this will introduce a lot of false positives\n        // and Rust's naming conventions recommend snake_case anyway.\n        // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html\n        \"function\": /\\b[a-z_]\\w*(?=\\s*(?:::\\s*<|\\())/,\n        \"macro\": {\n            pattern: /\\b\\w+!/,\n            alias: \"property\"\n        },\n        \"constant\": /\\b[A-Z_][A-Z_\\d]+\\b/,\n        \"class-name\": /\\b[A-Z]\\w*\\b/,\n        \"namespace\": {\n            pattern: /(?:\\b[a-z][a-z_\\d]*\\s*::\\s*)*\\b[a-z][a-z_\\d]*\\s*::(?!\\s*<)/,\n            inside: {\n                \"punctuation\": /::/\n            }\n        },\n        // Hex, oct, bin, dec numbers with visual separators and type suffix\n        \"number\": /\\b(?:0x[\\dA-Fa-f](?:_?[\\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\\d(?:_?\\d)*)?\\.)?\\d(?:_?\\d)*(?:[Ee][+-]?\\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\\b/,\n        \"boolean\": /\\b(?:false|true)\\b/,\n        \"punctuation\": /->|\\.\\.=|\\.{1,3}|::|[{}[\\];(),:]/,\n        \"operator\": /[-+*\\/%!^]=?|=[=>]?|&[&=]?|\\|[|=]?|<<?=?|>>?=?|[@?]/\n    };\n    Prism.languages.rust[\"closure-params\"].inside.rest = Prism.languages.rust;\n    Prism.languages.rust[\"attribute\"].inside[\"string\"] = Prism.languages.rust[\"string\"];\n})(Prism);\n(function(Prism) {\n    Prism.languages.sass = Prism.languages.extend(\"css\", {\n        // Sass comments don't need to be closed, only indented\n        \"comment\": {\n            pattern: /^([ \\t]*)\\/[\\/*].*(?:(?:\\r?\\n|\\r)\\1[ \\t].+)*/m,\n            lookbehind: true,\n            greedy: true\n        }\n    });\n    Prism.languages.insertBefore(\"sass\", \"atrule\", {\n        // We want to consume the whole line\n        \"atrule-line\": {\n            // Includes support for = and + shortcuts\n            pattern: /^(?:[ \\t]*)[@+=].+/m,\n            greedy: true,\n            inside: {\n                \"atrule\": /(?:@[\\w-]+|[+=])/\n            }\n        }\n    });\n    delete Prism.languages.sass.atrule;\n    var variable = /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/;\n    var operator = [\n        /[+*\\/%]|[=!]=|<=?|>=?|\\b(?:and|not|or)\\b/,\n        {\n            pattern: /(\\s)-(?=\\s)/,\n            lookbehind: true\n        }\n    ];\n    Prism.languages.insertBefore(\"sass\", \"property\", {\n        // We want to consume the whole line\n        \"variable-line\": {\n            pattern: /^[ \\t]*\\$.+/m,\n            greedy: true,\n            inside: {\n                \"punctuation\": /:/,\n                \"variable\": variable,\n                \"operator\": operator\n            }\n        },\n        // We want to consume the whole line\n        \"property-line\": {\n            pattern: /^[ \\t]*(?:[^:\\s]+ *:.*|:[^:\\s].*)/m,\n            greedy: true,\n            inside: {\n                \"property\": [\n                    /[^:\\s]+(?=\\s*:)/,\n                    {\n                        pattern: /(:)[^:\\s]+/,\n                        lookbehind: true\n                    }\n                ],\n                \"punctuation\": /:/,\n                \"variable\": variable,\n                \"operator\": operator,\n                \"important\": Prism.languages.sass.important\n            }\n        }\n    });\n    delete Prism.languages.sass.property;\n    delete Prism.languages.sass.important;\n    // Now that whole lines for other patterns are consumed,\n    // what's left should be selectors\n    Prism.languages.insertBefore(\"sass\", \"punctuation\", {\n        \"selector\": {\n            pattern: /^([ \\t]*)\\S(?:,[^,\\r\\n]+|[^,\\r\\n]*)(?:,[^,\\r\\n]+)*(?:,(?:\\r?\\n|\\r)\\1[ \\t]+\\S(?:,[^,\\r\\n]+|[^,\\r\\n]*)(?:,[^,\\r\\n]+)*)*/m,\n            lookbehind: true,\n            greedy: true\n        }\n    });\n})(Prism);\nPrism.languages.scss = Prism.languages.extend(\"css\", {\n    \"comment\": {\n        pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*)/,\n        lookbehind: true\n    },\n    \"atrule\": {\n        pattern: /@[\\w-](?:\\([^()]+\\)|[^()\\s]|\\s+(?!\\s))*?(?=\\s+[{;])/,\n        inside: {\n            \"rule\": /@[\\w-]+/\n        }\n    },\n    // url, compassified\n    \"url\": /(?:[-a-z]+-)?url(?=\\()/i,\n    // CSS selector regex is not appropriate for Sass\n    // since there can be lot more things (var, @ directive, nesting..)\n    // a selector must start at the end of a property or after a brace (end of other rules or nesting)\n    // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable\n    // the end of a selector is found when there is no rules in it ( {} or {\\s}) or if there is a property (because an interpolated var\n    // can \"pass\" as a selector- e.g: proper#{$erty})\n    // this one was hard to do, so please be careful if you edit this one :)\n    \"selector\": {\n        // Initial look-ahead is used to prevent matching of blank selectors\n        pattern: /(?=\\S)[^@;{}()]?(?:[^@;{}()\\s]|\\s+(?!\\s)|#\\{\\$[-\\w]+\\})+(?=\\s*\\{(?:\\}|\\s|[^}][^:{}]*[:{][^}]))/,\n        inside: {\n            \"parent\": {\n                pattern: /&/,\n                alias: \"important\"\n            },\n            \"placeholder\": /%[-\\w]+/,\n            \"variable\": /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n        }\n    },\n    \"property\": {\n        pattern: /(?:[-\\w]|\\$[-\\w]|#\\{\\$[-\\w]+\\})+(?=\\s*:)/,\n        inside: {\n            \"variable\": /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n        }\n    }\n});\nPrism.languages.insertBefore(\"scss\", \"atrule\", {\n    \"keyword\": [\n        /@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\\b/i,\n        {\n            pattern: /( )(?:from|through)(?= )/,\n            lookbehind: true\n        }\n    ]\n});\nPrism.languages.insertBefore(\"scss\", \"important\", {\n    // var and interpolated vars\n    \"variable\": /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n});\nPrism.languages.insertBefore(\"scss\", \"function\", {\n    \"module-modifier\": {\n        pattern: /\\b(?:as|hide|show|with)\\b/i,\n        alias: \"keyword\"\n    },\n    \"placeholder\": {\n        pattern: /%[-\\w]+/,\n        alias: \"selector\"\n    },\n    \"statement\": {\n        pattern: /\\B!(?:default|optional)\\b/i,\n        alias: \"keyword\"\n    },\n    \"boolean\": /\\b(?:false|true)\\b/,\n    \"null\": {\n        pattern: /\\bnull\\b/,\n        alias: \"keyword\"\n    },\n    \"operator\": {\n        pattern: /(\\s)(?:[-+*\\/%]|[=!]=|<=?|>=?|and|not|or)(?=\\s)/,\n        lookbehind: true\n    }\n});\nPrism.languages.scss[\"atrule\"].inside.rest = Prism.languages.scss;\nPrism.languages.sql = {\n    \"comment\": {\n        pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|(?:--|\\/\\/|#).*)/,\n        lookbehind: true\n    },\n    \"variable\": [\n        {\n            pattern: /@([\"'`])(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])+\\1/,\n            greedy: true\n        },\n        /@[\\w.$]+/\n    ],\n    \"string\": {\n        pattern: /(^|[^@\\\\])(\"|')(?:\\\\[\\s\\S]|(?!\\2)[^\\\\]|\\2\\2)*\\2/,\n        greedy: true,\n        lookbehind: true\n    },\n    \"identifier\": {\n        pattern: /(^|[^@\\\\])`(?:\\\\[\\s\\S]|[^`\\\\]|``)*`/,\n        greedy: true,\n        lookbehind: true,\n        inside: {\n            \"punctuation\": /^`|`$/\n        }\n    },\n    \"function\": /\\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\\s*\\()/i,\n    // Should we highlight user defined functions too?\n    \"keyword\": /\\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\\b/i,\n    \"boolean\": /\\b(?:FALSE|NULL|TRUE)\\b/i,\n    \"number\": /\\b0x[\\da-f]+\\b|\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+\\b/i,\n    \"operator\": /[-+*\\/=%^~]|&&?|\\|\\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\\b/i,\n    \"punctuation\": /[;[\\]()`,.]/\n};\nPrism.languages.swift = {\n    \"comment\": {\n        // Nested comments are supported up to 2 levels\n        pattern: /(^|[^\\\\:])(?:\\/\\/.*|\\/\\*(?:[^/*]|\\/(?!\\*)|\\*(?!\\/)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*\\*\\/)/,\n        lookbehind: true,\n        greedy: true\n    },\n    \"string-literal\": [\n        // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html\n        {\n            pattern: RegExp(/(^|[^\"#])/.source + \"(?:\" + /\"(?:\\\\(?:\\((?:[^()]|\\([^()]*\\))*\\)|\\r\\n|[^(])|[^\\\\\\r\\n\"])*\"/.source + \"|\" + /\"\"\"(?:\\\\(?:\\((?:[^()]|\\([^()]*\\))*\\)|[^(])|[^\\\\\"]|\"(?!\"\"))*\"\"\"/.source + \")\" + /(?![\"#])/.source),\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"interpolation\": {\n                    pattern: /(\\\\\\()(?:[^()]|\\([^()]*\\))*(?=\\))/,\n                    lookbehind: true,\n                    inside: null // see below\n                },\n                \"interpolation-punctuation\": {\n                    pattern: /^\\)|\\\\\\($/,\n                    alias: \"punctuation\"\n                },\n                \"punctuation\": /\\\\(?=[\\r\\n])/,\n                \"string\": /[\\s\\S]+/\n            }\n        },\n        {\n            pattern: RegExp(/(^|[^\"#])(#+)/.source + \"(?:\" + /\"(?:\\\\(?:#+\\((?:[^()]|\\([^()]*\\))*\\)|\\r\\n|[^#])|[^\\\\\\r\\n])*?\"/.source + \"|\" + /\"\"\"(?:\\\\(?:#+\\((?:[^()]|\\([^()]*\\))*\\)|[^#])|[^\\\\])*?\"\"\"/.source + \")\" + \"\\\\2\"),\n            lookbehind: true,\n            greedy: true,\n            inside: {\n                \"interpolation\": {\n                    pattern: /(\\\\#+\\()(?:[^()]|\\([^()]*\\))*(?=\\))/,\n                    lookbehind: true,\n                    inside: null // see below\n                },\n                \"interpolation-punctuation\": {\n                    pattern: /^\\)|\\\\#+\\($/,\n                    alias: \"punctuation\"\n                },\n                \"string\": /[\\s\\S]+/\n            }\n        }\n    ],\n    \"directive\": {\n        // directives with conditions\n        pattern: RegExp(/#/.source + \"(?:\" + (/(?:elseif|if)\\b/.source + \"(?:[ \t]*\" + /(?:![ \\t]*)?(?:\\b\\w+\\b(?:[ \\t]*\\((?:[^()]|\\([^()]*\\))*\\))?|\\((?:[^()]|\\([^()]*\\))*\\))(?:[ \\t]*(?:&&|\\|\\|))?/.source + \")+\") + \"|\" + /(?:else|endif)\\b/.source + \")\"),\n        alias: \"property\",\n        inside: {\n            \"directive-name\": /^#\\w+/,\n            \"boolean\": /\\b(?:false|true)\\b/,\n            \"number\": /\\b\\d+(?:\\.\\d+)*\\b/,\n            \"operator\": /!|&&|\\|\\||[<>]=?/,\n            \"punctuation\": /[(),]/\n        }\n    },\n    \"literal\": {\n        pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\\b/,\n        alias: \"constant\"\n    },\n    \"other-directive\": {\n        pattern: /#\\w+\\b/,\n        alias: \"property\"\n    },\n    \"attribute\": {\n        pattern: /@\\w+/,\n        alias: \"atrule\"\n    },\n    \"function-definition\": {\n        pattern: /(\\bfunc\\s+)\\w+/,\n        lookbehind: true,\n        alias: \"function\"\n    },\n    \"label\": {\n        // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141\n        pattern: /\\b(break|continue)\\s+\\w+|\\b[a-zA-Z_]\\w*(?=\\s*:\\s*(?:for|repeat|while)\\b)/,\n        lookbehind: true,\n        alias: \"important\"\n    },\n    \"keyword\": /\\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\\b/,\n    \"boolean\": /\\b(?:false|true)\\b/,\n    \"nil\": {\n        pattern: /\\bnil\\b/,\n        alias: \"constant\"\n    },\n    \"short-argument\": /\\$\\d+\\b/,\n    \"omit\": {\n        pattern: /\\b_\\b/,\n        alias: \"keyword\"\n    },\n    \"number\": /\\b(?:[\\d_]+(?:\\.[\\de_]+)?|0x[a-f0-9_]+(?:\\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\\b/i,\n    // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.\n    \"class-name\": /\\b[A-Z](?:[A-Z_\\d]*[a-z]\\w*)?\\b/,\n    \"function\": /\\b[a-z_]\\w*(?=\\s*\\()/i,\n    \"constant\": /\\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\\b/,\n    // Operators are generic in Swift. Developers can even create new operators (e.g. +++).\n    // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481\n    // This regex only supports ASCII operators.\n    \"operator\": /[-+*/%=!<>&|^~?]+|\\.[.\\-+*/%=!<>&|^~?]+/,\n    \"punctuation\": /[{}[\\]();,.:\\\\]/\n};\nPrism.languages.swift[\"string-literal\"].forEach(function(rule) {\n    rule.inside[\"interpolation\"].inside = Prism.languages.swift;\n});\n(function(Prism) {\n    Prism.languages.typescript = Prism.languages.extend(\"javascript\", {\n        \"class-name\": {\n            pattern: /(\\b(?:class|extends|implements|instanceof|interface|new|type)\\s+)(?!keyof\\b)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?:\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,\n            lookbehind: true,\n            greedy: true,\n            inside: null // see below\n        },\n        \"builtin\": /\\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\\b/\n    });\n    // The keywords TypeScript adds to JavaScript\n    Prism.languages.typescript.keyword.push(/\\b(?:abstract|declare|is|keyof|readonly|require)\\b/, // keywords that have to be followed by an identifier\n    /\\b(?:asserts|infer|interface|module|namespace|type)\\b(?=\\s*(?:[{_$a-zA-Z\\xA0-\\uFFFF]|$))/, // This is for `import type *, {}`\n    /\\btype\\b(?=\\s*(?:[\\{*]|$))/);\n    // doesn't work with TS because TS is too complex\n    delete Prism.languages.typescript[\"parameter\"];\n    delete Prism.languages.typescript[\"literal-property\"];\n    // a version of typescript specifically for highlighting types\n    var typeInside = Prism.languages.extend(\"typescript\", {});\n    delete typeInside[\"class-name\"];\n    Prism.languages.typescript[\"class-name\"].inside = typeInside;\n    Prism.languages.insertBefore(\"typescript\", \"function\", {\n        \"decorator\": {\n            pattern: /@[$\\w\\xA0-\\uFFFF]+/,\n            inside: {\n                \"at\": {\n                    pattern: /^@/,\n                    alias: \"operator\"\n                },\n                \"function\": /^[\\s\\S]+/\n            }\n        },\n        \"generic-function\": {\n            // e.g. foo<T extends \"bar\" | \"baz\">( ...\n            pattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\\s*\\()/,\n            greedy: true,\n            inside: {\n                \"function\": /^#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*/,\n                \"generic\": {\n                    pattern: /<[\\s\\S]+/,\n                    // everything after the first <\n                    alias: \"class-name\",\n                    inside: typeInside\n                }\n            }\n        }\n    });\n    Prism.languages.ts = Prism.languages.typescript;\n})(Prism);\n(function(Prism) {\n    var typescript = Prism.util.clone(Prism.languages.typescript);\n    Prism.languages.tsx = Prism.languages.extend(\"jsx\", typescript);\n    // doesn't work with TS because TS is too complex\n    delete Prism.languages.tsx[\"parameter\"];\n    delete Prism.languages.tsx[\"literal-property\"];\n    // This will prevent collisions between TSX tags and TS generic types.\n    // Idea by https://github.com/karlhorky\n    // Discussion: https://github.com/PrismJS/prism/issues/2594#issuecomment-710666928\n    var tag = Prism.languages.tsx.tag;\n    tag.pattern = RegExp(/(^|[^\\w$]|(?=<\\/))/.source + \"(?:\" + tag.pattern.source + \")\", tag.pattern.flags);\n    tag.lookbehind = true;\n})(Prism);\nPrism.languages.basic = {\n    \"comment\": {\n        pattern: /(?:!|REM\\b).+/i,\n        inside: {\n            \"keyword\": /^REM/i\n        }\n    },\n    \"string\": {\n        pattern: /\"(?:\"\"|[!#$%&'()*,\\/:;<=>?^\\w +\\-.])*\"/,\n        greedy: true\n    },\n    \"number\": /(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:E[+-]?\\d+)?/i,\n    \"keyword\": /\\b(?:AS|BEEP|BLOAD|BSAVE|CALL(?: ABSOLUTE)?|CASE|CHAIN|CHDIR|CLEAR|CLOSE|CLS|COM|COMMON|CONST|DATA|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DIM|DO|DOUBLE|ELSE|ELSEIF|END|ENVIRON|ERASE|ERROR|EXIT|FIELD|FILES|FOR|FUNCTION|GET|GOSUB|GOTO|IF|INPUT|INTEGER|IOCTL|KEY|KILL|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|MKDIR|NAME|NEXT|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPTION BASE|OUT|POKE|PUT|READ|REDIM|REM|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SELECT CASE|SHARED|SHELL|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|SUB|SWAP|SYSTEM|THEN|TIMER|TO|TROFF|TRON|TYPE|UNLOCK|UNTIL|USING|VIEW PRINT|WAIT|WEND|WHILE|WRITE)(?:\\$|\\b)/i,\n    \"function\": /\\b(?:ABS|ACCESS|ACOS|ANGLE|AREA|ARITHMETIC|ARRAY|ASIN|ASK|AT|ATN|BASE|BEGIN|BREAK|CAUSE|CEIL|CHR|CLIP|COLLATE|COLOR|CON|COS|COSH|COT|CSC|DATE|DATUM|DEBUG|DECIMAL|DEF|DEG|DEGREES|DELETE|DET|DEVICE|DISPLAY|DOT|ELAPSED|EPS|ERASABLE|EXLINE|EXP|EXTERNAL|EXTYPE|FILETYPE|FIXED|FP|GO|GRAPH|HANDLER|IDN|IMAGE|IN|INT|INTERNAL|IP|IS|KEYED|LBOUND|LCASE|LEFT|LEN|LENGTH|LET|LINE|LINES|LOG|LOG10|LOG2|LTRIM|MARGIN|MAT|MAX|MAXNUM|MID|MIN|MISSING|MOD|NATIVE|NUL|NUMERIC|OF|OPTION|ORD|ORGANIZATION|OUTIN|OUTPUT|PI|POINT|POINTER|POINTS|POS|PRINT|PROGRAM|PROMPT|RAD|RADIANS|RANDOMIZE|RECORD|RECSIZE|RECTYPE|RELATIVE|REMAINDER|REPEAT|REST|RETRY|REWRITE|RIGHT|RND|ROUND|RTRIM|SAME|SEC|SELECT|SEQUENTIAL|SET|SETTER|SGN|SIN|SINH|SIZE|SKIP|SQR|STANDARD|STATUS|STR|STREAM|STYLE|TAB|TAN|TANH|TEMPLATE|TEXT|THERE|TIME|TIMEOUT|TRACE|TRANSFORM|TRUNCATE|UBOUND|UCASE|USE|VAL|VARIABLE|VIEWPORT|WHEN|WINDOW|WITH|ZER|ZONEWIDTH)(?:\\$|\\b)/i,\n    \"operator\": /<[=>]?|>=?|[+\\-*\\/^=&]|\\b(?:AND|EQV|IMP|NOT|OR|XOR)\\b/i,\n    \"punctuation\": /[,;:()]/\n};\nPrism.languages.vbnet = Prism.languages.extend(\"basic\", {\n    \"comment\": [\n        {\n            pattern: /(?:!|REM\\b).+/i,\n            inside: {\n                \"keyword\": /^REM/i\n            }\n        },\n        {\n            pattern: /(^|[^\\\\:])'.*/,\n            lookbehind: true,\n            greedy: true\n        }\n    ],\n    \"string\": {\n        pattern: /(^|[^\"])\"(?:\"\"|[^\"])*\"(?!\")/,\n        lookbehind: true,\n        greedy: true\n    },\n    \"keyword\": /(?:\\b(?:ADDHANDLER|ADDRESSOF|ALIAS|AND|ANDALSO|AS|BEEP|BLOAD|BOOLEAN|BSAVE|BYREF|BYTE|BYVAL|CALL(?: ABSOLUTE)?|CASE|CATCH|CBOOL|CBYTE|CCHAR|CDATE|CDBL|CDEC|CHAIN|CHAR|CHDIR|CINT|CLASS|CLEAR|CLNG|CLOSE|CLS|COBJ|COM|COMMON|CONST|CONTINUE|CSBYTE|CSHORT|CSNG|CSTR|CTYPE|CUINT|CULNG|CUSHORT|DATA|DATE|DECIMAL|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DEFAULT|DELEGATE|DIM|DIRECTCAST|DO|DOUBLE|ELSE|ELSEIF|END|ENUM|ENVIRON|ERASE|ERROR|EVENT|EXIT|FALSE|FIELD|FILES|FINALLY|FOR(?: EACH)?|FRIEND|FUNCTION|GET|GETTYPE|GETXMLNAMESPACE|GLOBAL|GOSUB|GOTO|HANDLES|IF|IMPLEMENTS|IMPORTS|IN|INHERITS|INPUT|INTEGER|INTERFACE|IOCTL|IS|ISNOT|KEY|KILL|LET|LIB|LIKE|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|ME|MKDIR|MOD|MODULE|MUSTINHERIT|MUSTOVERRIDE|MYBASE|MYCLASS|NAME|NAMESPACE|NARROWING|NEW|NEXT|NOT|NOTHING|NOTINHERITABLE|NOTOVERRIDABLE|OBJECT|OF|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPERATOR|OPTION(?: BASE)?|OPTIONAL|OR|ORELSE|OUT|OVERLOADS|OVERRIDABLE|OVERRIDES|PARAMARRAY|PARTIAL|POKE|PRIVATE|PROPERTY|PROTECTED|PUBLIC|PUT|RAISEEVENT|READ|READONLY|REDIM|REM|REMOVEHANDLER|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SBYTE|SELECT(?: CASE)?|SET|SHADOWS|SHARED|SHELL|SHORT|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|STRUCTURE|SUB|SWAP|SYNCLOCK|SYSTEM|THEN|THROW|TIMER|TO|TROFF|TRON|TRUE|TRY|TRYCAST|TYPE|TYPEOF|UINTEGER|ULONG|UNLOCK|UNTIL|USHORT|USING|VIEW PRINT|WAIT|WEND|WHEN|WHILE|WIDENING|WITH|WITHEVENTS|WRITE|WRITEONLY|XOR)|\\B(?:#CONST|#ELSE|#ELSEIF|#END|#IF))(?:\\$|\\b)/i,\n    \"punctuation\": /[,;:(){}]/\n});\nconst languages = [\n    {\n        label: \"C\",\n        value: \"c\"\n    },\n    {\n        label: \"C++\",\n        value: \"cpp\"\n    },\n    {\n        label: \"Arduino\",\n        value: \"arduino\"\n    },\n    {\n        label: \"Bash\",\n        value: \"bash\"\n    },\n    {\n        label: \"C#\",\n        value: \"csharp\"\n    },\n    {\n        label: \"CSS\",\n        value: \"css\"\n    },\n    {\n        label: \"Diff\",\n        value: \"diff\"\n    },\n    {\n        label: \"Go\",\n        value: \"go\"\n    },\n    {\n        label: \"INI\",\n        value: \"ini\"\n    },\n    {\n        label: \"Java\",\n        value: \"java\"\n    },\n    {\n        label: \"JavaScript\",\n        value: \"javascript\"\n    },\n    {\n        label: \"JSX\",\n        value: \"jsx\"\n    },\n    {\n        label: \"JSON\",\n        value: \"json\"\n    },\n    {\n        label: \"Kotlin\",\n        value: \"kotlin\"\n    },\n    {\n        label: \"Less\",\n        value: \"less\"\n    },\n    {\n        label: \"Lua\",\n        value: \"lua\"\n    },\n    {\n        label: \"Makefile\",\n        value: \"makefile\"\n    },\n    {\n        label: \"Markdown\",\n        value: \"markdown\"\n    },\n    {\n        label: \"Objective-C\",\n        value: \"objectivec\"\n    },\n    {\n        label: \"Perl\",\n        value: \"perl\"\n    },\n    {\n        label: \"PHP\",\n        value: \"php\"\n    },\n    {\n        label: \"Python\",\n        value: \"python\"\n    },\n    {\n        label: \"R\",\n        value: \"r\"\n    },\n    {\n        label: \"Ruby\",\n        value: \"ruby\"\n    },\n    {\n        label: \"Rust\",\n        value: \"rust\"\n    },\n    {\n        label: \"Sass\",\n        value: \"sass\"\n    },\n    {\n        label: \"SCSS\",\n        value: \"scss\"\n    },\n    {\n        label: \"SQL\",\n        value: \"sql\"\n    },\n    {\n        label: \"Swift\",\n        value: \"swift\"\n    },\n    {\n        label: \"TypeScript\",\n        value: \"typescript\"\n    },\n    {\n        label: \"TSX\",\n        value: \"tsx\"\n    },\n    {\n        label: \"VB.NET\",\n        value: \"vbnet\"\n    },\n    {\n        label: \"YAML\",\n        value: \"yaml\"\n    }\n];\nconst canonicalNameToLabel = new Map(languages.map((x)=>[\n        x.value,\n        x.label\n    ]));\nnew Map(languages.map((x)=>[\n        x.label,\n        x.value\n    ]));\nconst languageToCanonicalName = new Map(languages.map((lang)=>[\n        Prism.languages[lang.value],\n        lang.value\n    ]));\nconst aliasesToCanonicalName = new Map(Object.keys(Prism.languages).flatMap((lang)=>{\n    const canonicalName = languageToCanonicalName.get(Prism.languages[lang]);\n    if (canonicalName === undefined) {\n        return [];\n    }\n    return [\n        [\n            lang,\n            canonicalName\n        ]\n    ];\n}));\nconst languagesToAliases = new Map(languages.map((lang)=>[\n        lang.value,\n        []\n    ]));\nfor (const [alias, canonicalName] of aliasesToCanonicalName){\n    languagesToAliases.get(canonicalName).push(alias);\n}\n[\n    {\n        label: \"Plain text\",\n        value: \"plain\",\n        aliases: []\n    },\n    ...[\n        ...languagesToAliases\n    ].map(([canonicalName, aliases])=>({\n            label: canonicalNameToLabel.get(canonicalName),\n            value: canonicalName,\n            aliases\n        }))\n];\nnew Map([\n    ...aliasesToCanonicalName\n].map(([alias, canonicalName])=>[\n        alias,\n        canonicalNameToLabel.get(canonicalName)\n    ]));\nconst codeBlockShortcutPattern = /^```(\\w+)? ?$/;\nfunction withCodeBlock(documentFeatures, componentBlocks, editor) {\n    const { insertBreak, normalizeNode, insertText } = editor;\n    function codeBlockShortcut(block) {\n        var _aliasesToCanonicalNa;\n        if ((block === null || block === void 0 ? void 0 : block[0].type) !== \"paragraph\" || block[0].children.length !== 1 || block[0].children[0].type !== undefined) {\n            return false;\n        }\n        const match = codeBlockShortcutPattern.exec(block[0].children[0].text);\n        if (!match) {\n            return false;\n        }\n        const locationDocumentFeatures = getAncestorComponentChildFieldDocumentFeatures(editor, documentFeatures, componentBlocks);\n        if (locationDocumentFeatures && (locationDocumentFeatures.kind === \"inline\" || !locationDocumentFeatures.documentFeatures.formatting.blockTypes.code)) {\n            return false;\n        }\n        // so that this starts a new undo group\n        editor.history.undos.push({\n            operations: [],\n            selectionBefore: editor.selection\n        });\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, block[1]);\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.delete(editor);\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.wrapNodes(editor, {\n            type: \"code\",\n            ...match[1] ? {\n                language: (_aliasesToCanonicalNa = aliasesToCanonicalName.get(match[1].toLowerCase())) !== null && _aliasesToCanonicalNa !== void 0 ? _aliasesToCanonicalNa : match[1]\n            } : {},\n            children: []\n        }, {\n            match: (node)=>node.type === \"paragraph\"\n        });\n        return true;\n    }\n    editor.insertBreak = ()=>{\n        const block = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n            match: isBlock\n        });\n        if ((block === null || block === void 0 ? void 0 : block[0].type) === \"code\" && slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText(block[0].children[0])) {\n            const text = block[0].children[0].text;\n            if (text[text.length - 1] === \"\\n\" && editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(editor.selection) && slate__WEBPACK_IMPORTED_MODULE_7__.Point.equals(slate__WEBPACK_IMPORTED_MODULE_7__.Editor.end(editor, block[1]), editor.selection.anchor)) {\n                insertBreak();\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.setNodes(editor, {\n                    type: \"paragraph\",\n                    children: []\n                });\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.delete(editor, {\n                    distance: 1,\n                    at: {\n                        path: [\n                            ...block[1],\n                            0\n                        ],\n                        offset: text.length - 1\n                    }\n                });\n                return;\n            }\n            editor.insertText(\"\\n\");\n            return;\n        }\n        if (editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(editor.selection) && codeBlockShortcut(block)) {\n            return;\n        }\n        insertBreak();\n    };\n    editor.insertText = (text)=>{\n        insertText(text);\n        if (text === \" \" && editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(editor.selection)) {\n            codeBlockShortcut(slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n                match: isBlock\n            }));\n        }\n    };\n    editor.normalizeNode = ([node, path])=>{\n        if (node.type === \"code\" && slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node)) {\n            for (const [index, childNode] of node.children.entries()){\n                if (!slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText(childNode)) {\n                    if (editor.isVoid(childNode)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.removeNodes(editor, {\n                            at: [\n                                ...path,\n                                index\n                            ]\n                        });\n                    } else {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.unwrapNodes(editor, {\n                            at: [\n                                ...path,\n                                index\n                            ]\n                        });\n                    }\n                    return;\n                }\n                const marks = Object.keys(childNode).filter((x)=>x !== \"text\");\n                if (marks.length) {\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.unsetNodes(editor, marks, {\n                        at: [\n                            ...path,\n                            index\n                        ]\n                    });\n                    return;\n                }\n            }\n        }\n        normalizeNode([\n            node,\n            path\n        ]);\n    };\n    return editor;\n}\nfunction findChildPropPathsForProp(value, schema, path) {\n    switch(schema.kind){\n        case \"form\":\n            return [];\n        case \"child\":\n            return [\n                {\n                    path: path,\n                    options: schema.options\n                }\n            ];\n        case \"conditional\":\n            return findChildPropPathsForProp(value.value, schema.values[value.discriminant], path.concat(\"value\"));\n        case \"object\":\n            {\n                const paths = [];\n                Object.keys(schema.fields).forEach((key)=>{\n                    paths.push(...findChildPropPathsForProp(value[key], schema.fields[key], path.concat(key)));\n                });\n                return paths;\n            }\n        case \"array\":\n            {\n                const paths = [];\n                value.forEach((val, i)=>{\n                    paths.push(...findChildPropPathsForProp(val, schema.element, path.concat(i)));\n                });\n                return paths;\n            }\n    }\n}\nfunction findChildPropPaths(value, props) {\n    const propPaths = findChildPropPathsForProp(value, {\n        kind: \"object\",\n        fields: props\n    }, []);\n    if (!propPaths.length) {\n        return [\n            {\n                path: undefined,\n                options: {\n                    kind: \"inline\",\n                    placeholder: \"\"\n                }\n            }\n        ];\n    }\n    return propPaths;\n}\nfunction getAncestorComponentBlock(editor) {\n    if (editor.selection) {\n        const ancestorEntry = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n            match: (node)=>isBlock(node) && node.type !== \"paragraph\"\n        });\n        if (ancestorEntry && (ancestorEntry[0].type === \"component-block-prop\" || ancestorEntry[0].type === \"component-inline-prop\")) {\n            return {\n                isInside: true,\n                componentBlock: slate__WEBPACK_IMPORTED_MODULE_7__.Editor.parent(editor, ancestorEntry[1]),\n                prop: ancestorEntry\n            };\n        }\n    }\n    return {\n        isInside: false\n    };\n}\nconst alreadyNormalizedThings = new WeakMap();\nfunction normalizeNodeWithinComponentProp([node, path], editor, fieldOptions) {\n    let alreadyNormalizedNodes = alreadyNormalizedThings.get(fieldOptions);\n    if (!alreadyNormalizedNodes) {\n        alreadyNormalizedNodes = new WeakSet();\n        alreadyNormalizedThings.set(fieldOptions, alreadyNormalizedNodes);\n    }\n    if (alreadyNormalizedNodes.has(node)) {\n        return false;\n    }\n    let didNormalization = false;\n    if (fieldOptions.inlineMarks !== \"inherit\" && slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText(node)) {\n        didNormalization = normalizeTextBasedOnInlineMarksAndSoftBreaks([\n            node,\n            path\n        ], editor, fieldOptions.inlineMarks, fieldOptions.softBreaks);\n    }\n    if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node)) {\n        let childrenHasChanged = node.children.map((node, i)=>normalizeNodeWithinComponentProp([\n                node,\n                [\n                    ...path,\n                    i\n                ]\n            ], editor, fieldOptions))// .map then .some because we don't want to exit early\n        .some((x)=>x);\n        if (fieldOptions.kind === \"block\") {\n            if (node.type === \"component-block\") {\n                if (!fieldOptions.componentBlocks) {\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.unwrapNodes(editor, {\n                        at: path\n                    });\n                    didNormalization = true;\n                }\n            } else {\n                didNormalization = normalizeElementBasedOnDocumentFeatures([\n                    node,\n                    path\n                ], editor, fieldOptions.documentFeatures) || childrenHasChanged;\n            }\n        } else {\n            didNormalization = normalizeInlineBasedOnLinks([\n                node,\n                path\n            ], editor, fieldOptions.documentFeatures.links);\n        }\n    }\n    if (didNormalization === false) {\n        alreadyNormalizedNodes.add(node);\n    }\n    return didNormalization;\n}\nfunction canSchemaContainChildField(rootSchema) {\n    const queue = new Set([\n        rootSchema\n    ]);\n    for (const schema of queue){\n        if (schema.kind === \"form\") ;\n        else if (schema.kind === \"child\") {\n            return true;\n        } else if (schema.kind === \"array\") {\n            queue.add(schema.element);\n        } else if (schema.kind === \"object\") {\n            for (const innerProp of Object.values(schema.fields)){\n                queue.add(innerProp);\n            }\n        } else if (schema.kind === \"conditional\") {\n            for (const innerProp of Object.values(schema.values)){\n                queue.add(innerProp);\n            }\n        } else {\n            (0,emery__WEBPACK_IMPORTED_MODULE_1__.assertNever)(schema);\n        }\n    }\n    return false;\n}\nfunction doesSchemaOnlyEverContainASingleChildField(rootSchema) {\n    const queue = new Set([\n        rootSchema\n    ]);\n    let hasFoundChildField = false;\n    for (const schema of queue){\n        if (schema.kind === \"form\") ;\n        else if (schema.kind === \"child\") {\n            if (hasFoundChildField) {\n                return false;\n            }\n            hasFoundChildField = true;\n        } else if (schema.kind === \"array\") {\n            if (canSchemaContainChildField(schema.element)) {\n                return false;\n            }\n        } else if (schema.kind === \"object\") {\n            for (const innerProp of Object.values(schema.fields)){\n                queue.add(innerProp);\n            }\n        } else if (schema.kind === \"conditional\") {\n            for (const innerProp of Object.values(schema.values)){\n                queue.add(innerProp);\n            }\n        } else {\n            (0,emery__WEBPACK_IMPORTED_MODULE_1__.assertNever)(schema);\n        }\n    }\n    return hasFoundChildField;\n}\nfunction findArrayFieldsWithSingleChildField(schema, value) {\n    const propPaths = [];\n    traverseProps(schema, value, (schema, value, path)=>{\n        if (schema.kind === \"array\" && doesSchemaOnlyEverContainASingleChildField(schema.element)) {\n            propPaths.push([\n                path,\n                schema\n            ]);\n        }\n    });\n    return propPaths;\n}\nfunction isEmptyChildFieldNode(element) {\n    const firstChild = element.children[0];\n    return element.children.length === 1 && (element.type === \"component-inline-prop\" && firstChild.type === undefined && firstChild.text === \"\" || element.type === \"component-block-prop\" && firstChild.type === \"paragraph\" && firstChild.children.length === 1 && firstChild.children[0].type === undefined && firstChild.children[0].text === \"\");\n}\nfunction withComponentBlocks(blockComponents, editorDocumentFeatures, editor) {\n    // note that conflicts between the editor document features\n    // and the child field document features are dealt with elsewhere\n    const memoizedGetDocumentFeaturesForChildField = (0,_emotion_weak_memoize__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((options)=>{\n        return getDocumentFeaturesForChildField(editorDocumentFeatures, options);\n    });\n    const { normalizeNode, deleteBackward, insertBreak } = editor;\n    editor.deleteBackward = (unit)=>{\n        if (editor.selection) {\n            const ancestorComponentBlock = getAncestorComponentBlock(editor);\n            if (ancestorComponentBlock.isInside && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(editor.selection) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isStart(editor, editor.selection.anchor, ancestorComponentBlock.prop[1]) && ancestorComponentBlock.prop[1][ancestorComponentBlock.prop[1].length - 1] === 0) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.unwrapNodes(editor, {\n                    at: ancestorComponentBlock.componentBlock[1]\n                });\n                return;\n            }\n        }\n        deleteBackward(unit);\n    };\n    editor.insertBreak = ()=>{\n        const ancestorComponentBlock = getAncestorComponentBlock(editor);\n        if (editor.selection && ancestorComponentBlock.isInside) {\n            const { prop: [componentPropNode, componentPropPath], componentBlock: [componentBlockNode, componentBlockPath] } = ancestorComponentBlock;\n            const isLastProp = componentPropPath[componentPropPath.length - 1] === componentBlockNode.children.length - 1;\n            if (componentPropNode.type === \"component-block-prop\") {\n                const [[paragraphNode, paragraphPath]] = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.nodes(editor, {\n                    match: (node)=>node.type === \"paragraph\"\n                });\n                const isLastParagraph = paragraphPath[paragraphPath.length - 1] === componentPropNode.children.length - 1;\n                if (slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(paragraphNode) === \"\" && isLastParagraph) {\n                    if (isLastProp) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.moveNodes(editor, {\n                            at: paragraphPath,\n                            to: slate__WEBPACK_IMPORTED_MODULE_7__.Path.next(ancestorComponentBlock.componentBlock[1])\n                        });\n                    } else {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                            distance: 1,\n                            unit: \"line\"\n                        });\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.removeNodes(editor, {\n                            at: paragraphPath\n                        });\n                    }\n                    return;\n                }\n            }\n            if (componentPropNode.type === \"component-inline-prop\") {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.withoutNormalizing(editor, ()=>{\n                    const componentBlock = blockComponents[componentBlockNode.component];\n                    if (componentPropNode.propPath !== undefined && componentBlock !== undefined) {\n                        const rootSchema = {\n                            kind: \"object\",\n                            fields: componentBlock.schema\n                        };\n                        const ancestorFields = getAncestorSchemas(rootSchema, componentPropNode.propPath, componentBlockNode.props);\n                        const idx = [\n                            ...ancestorFields\n                        ].reverse().findIndex((item)=>item.kind === \"array\");\n                        if (idx !== -1) {\n                            const arrayFieldIdx = ancestorFields.length - 1 - idx;\n                            const arrayField = ancestorFields[arrayFieldIdx];\n                            (0,emery__WEBPACK_IMPORTED_MODULE_1__.assert)(arrayField.kind === \"array\");\n                            const val = getValueAtPropPath(componentBlockNode.props, componentPropNode.propPath.slice(0, arrayFieldIdx));\n                            if (doesSchemaOnlyEverContainASingleChildField(arrayField.element)) {\n                                if (slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(componentPropNode) === \"\" && val.length - 1 === componentPropNode.propPath[arrayFieldIdx]) {\n                                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.removeNodes(editor, {\n                                        at: componentPropPath\n                                    });\n                                    if (isLastProp) {\n                                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.insertNodes(editor, {\n                                            type: \"paragraph\",\n                                            children: [\n                                                {\n                                                    text: \"\"\n                                                }\n                                            ]\n                                        }, {\n                                            at: slate__WEBPACK_IMPORTED_MODULE_7__.Path.next(componentBlockPath)\n                                        });\n                                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_7__.Path.next(componentBlockPath));\n                                    } else {\n                                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                                            distance: 1,\n                                            unit: \"line\"\n                                        });\n                                    }\n                                } else {\n                                    insertBreak();\n                                }\n                                return;\n                            }\n                        }\n                    }\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.splitNodes(editor, {\n                        always: true\n                    });\n                    const splitNodePath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.next(componentPropPath);\n                    if (isLastProp) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.moveNodes(editor, {\n                            at: splitNodePath,\n                            to: slate__WEBPACK_IMPORTED_MODULE_7__.Path.next(componentBlockPath)\n                        });\n                    } else {\n                        moveChildren(editor, splitNodePath, [\n                            ...slate__WEBPACK_IMPORTED_MODULE_7__.Path.next(splitNodePath),\n                            0\n                        ]);\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.removeNodes(editor, {\n                            at: splitNodePath\n                        });\n                    }\n                });\n                return;\n            }\n        }\n        insertBreak();\n    };\n    editor.normalizeNode = (entry)=>{\n        const [node, path] = entry;\n        if (node.type === \"component-inline-prop\" && !node.propPath && (node.children.length !== 1 || !slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText(node.children[0]) || node.children[0].text !== \"\")) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.removeNodes(editor, {\n                at: path\n            });\n            return;\n        }\n        if (node.type === \"component-block\") {\n            const componentBlock = blockComponents[node.component];\n            if (componentBlock) {\n                const rootSchema = {\n                    kind: \"object\",\n                    fields: componentBlock.schema\n                };\n                const updatedProps = addMissingFields(node.props, rootSchema);\n                if (updatedProps !== node.props) {\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.setNodes(editor, {\n                        props: updatedProps\n                    }, {\n                        at: path\n                    });\n                    return;\n                }\n                for (const [propPath, arrayField] of findArrayFieldsWithSingleChildField(rootSchema, node.props)){\n                    if (node.children.length === 1 && node.children[0].type === \"component-inline-prop\" && node.children[0].propPath === undefined) {\n                        break;\n                    }\n                    const nodesWithin = [];\n                    for (const [idx, childNode] of node.children.entries()){\n                        if ((childNode.type === \"component-block-prop\" || childNode.type === \"component-inline-prop\") && childNode.propPath !== undefined) {\n                            const subPath = childNode.propPath.concat();\n                            while(subPath.length){\n                                if (typeof subPath.pop() === \"number\") break;\n                            }\n                            if (areArraysEqual(propPath, subPath)) {\n                                nodesWithin.push([\n                                    idx,\n                                    childNode\n                                ]);\n                            }\n                        }\n                    }\n                    const arrVal = getValueAtPropPath(node.props, propPath);\n                    const prevKeys = getKeysForArrayValue(arrVal);\n                    const prevKeysSet = new Set(prevKeys);\n                    const alreadyUsedIndicies = new Set();\n                    const newVal = [];\n                    const newKeys = [];\n                    const getNewKey = ()=>{\n                        let key = getNewArrayElementKey();\n                        while(prevKeysSet.has(key)){\n                            key = getNewArrayElementKey();\n                        }\n                        return key;\n                    };\n                    for (const [, node] of nodesWithin){\n                        const idxFromValue = node.propPath[propPath.length];\n                        (0,emery__WEBPACK_IMPORTED_MODULE_1__.assert)(typeof idxFromValue === \"number\");\n                        if (arrVal.length <= idxFromValue || alreadyUsedIndicies.has(idxFromValue) && isEmptyChildFieldNode(node)) {\n                            newVal.push(getInitialPropsValue(arrayField.element));\n                            newKeys.push(getNewKey());\n                        } else {\n                            alreadyUsedIndicies.add(idxFromValue);\n                            newVal.push(arrVal[idxFromValue]);\n                            newKeys.push(alreadyUsedIndicies.has(idxFromValue) ? getNewKey() : prevKeys[idxFromValue]);\n                        }\n                    }\n                    setKeysForArrayValue(newVal, newKeys);\n                    if (!areArraysEqual(arrVal, newVal)) {\n                        const transformedProps = replaceValueAtPropPath(rootSchema, node.props, newVal, propPath);\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.setNodes(editor, {\n                            props: transformedProps\n                        }, {\n                            at: path\n                        });\n                        for (const [idx, [idxInChildrenOfBlock, nodeWithin]] of nodesWithin.entries()){\n                            const newPropPath = [\n                                ...nodeWithin.propPath\n                            ];\n                            newPropPath[propPath.length] = idx;\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.setNodes(editor, {\n                                propPath: newPropPath\n                            }, {\n                                at: [\n                                    ...path,\n                                    idxInChildrenOfBlock\n                                ]\n                            });\n                        }\n                        return;\n                    }\n                }\n                const missingKeys = new Map(findChildPropPaths(node.props, componentBlock.schema).map((x)=>[\n                        JSON.stringify(x.path),\n                        x.options.kind\n                    ]));\n                node.children.forEach((node)=>{\n                    (0,emery__WEBPACK_IMPORTED_MODULE_1__.assert)(node.type === \"component-block-prop\" || node.type === \"component-inline-prop\");\n                    missingKeys.delete(JSON.stringify(node.propPath));\n                });\n                if (missingKeys.size) {\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.insertNodes(editor, [\n                        ...missingKeys\n                    ].map(([prop, kind])=>({\n                            type: `component-${kind}-prop`,\n                            propPath: prop ? JSON.parse(prop) : prop,\n                            children: [\n                                {\n                                    text: \"\"\n                                }\n                            ]\n                        })), {\n                        at: [\n                            ...path,\n                            node.children.length\n                        ]\n                    });\n                    return;\n                }\n                const foundProps = new Set();\n                const stringifiedInlinePropPaths = {};\n                findChildPropPaths(node.props, blockComponents[node.component].schema).forEach((x, index)=>{\n                    stringifiedInlinePropPaths[JSON.stringify(x.path)] = {\n                        options: x.options,\n                        index\n                    };\n                });\n                for (const [index, childNode] of node.children.entries()){\n                    if (// children that are not these will be handled by\n                    // the generic allowedChildren normalization\n                    childNode.type !== \"component-inline-prop\" && childNode.type !== \"component-block-prop\") {\n                        continue;\n                    }\n                    const childPath = [\n                        ...path,\n                        index\n                    ];\n                    const stringifiedPropPath = JSON.stringify(childNode.propPath);\n                    if (stringifiedInlinePropPaths[stringifiedPropPath] === undefined) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.removeNodes(editor, {\n                            at: childPath\n                        });\n                        return;\n                    }\n                    if (foundProps.has(stringifiedPropPath)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.removeNodes(editor, {\n                            at: childPath\n                        });\n                        return;\n                    }\n                    foundProps.add(stringifiedPropPath);\n                    const propInfo = stringifiedInlinePropPaths[stringifiedPropPath];\n                    const expectedIndex = propInfo.index;\n                    if (index !== expectedIndex) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.moveNodes(editor, {\n                            at: childPath,\n                            to: [\n                                ...path,\n                                expectedIndex\n                            ]\n                        });\n                        return;\n                    }\n                    const expectedChildNodeType = `component-${propInfo.options.kind}-prop`;\n                    if (childNode.type !== expectedChildNodeType) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.setNodes(editor, {\n                            type: expectedChildNodeType\n                        }, {\n                            at: childPath\n                        });\n                        return;\n                    }\n                    const documentFeatures = memoizedGetDocumentFeaturesForChildField(propInfo.options);\n                    if (normalizeNodeWithinComponentProp([\n                        childNode,\n                        childPath\n                    ], editor, documentFeatures)) {\n                        return;\n                    }\n                }\n            }\n        }\n        normalizeNode(entry);\n    };\n    return editor;\n}\n// the only thing that this will fix is a new field being added to an object field, nothing else.\nfunction addMissingFields(value, schema) {\n    if (schema.kind === \"child\" || schema.kind === \"form\") {\n        return value;\n    }\n    if (schema.kind === \"conditional\") {\n        const conditionalValue = value;\n        const updatedInnerValue = addMissingFields(conditionalValue.value, schema.values[conditionalValue.discriminant.toString()]);\n        if (updatedInnerValue === conditionalValue.value) {\n            return value;\n        }\n        return {\n            discriminant: conditionalValue.discriminant,\n            value: updatedInnerValue\n        };\n    }\n    if (schema.kind === \"array\") {\n        const arrValue = value;\n        const newArrValue = arrValue.map((x)=>addMissingFields(x, schema.element));\n        if (areArraysEqual(arrValue, newArrValue)) {\n            return value;\n        }\n        return newArrValue;\n    }\n    if (schema.kind === \"object\") {\n        const objectValue = value;\n        let hasChanged = false;\n        const newObjectValue = {};\n        for (const [key, innerSchema] of Object.entries(schema.fields)){\n            const innerValue = objectValue[key];\n            if (innerValue === undefined) {\n                hasChanged = true;\n                newObjectValue[key] = getInitialPropsValue(innerSchema);\n                continue;\n            }\n            const newInnerValue = addMissingFields(innerValue, innerSchema);\n            if (newInnerValue !== innerValue) {\n                hasChanged = true;\n            }\n            newObjectValue[key] = newInnerValue;\n        }\n        if (hasChanged) {\n            return newObjectValue;\n        }\n        return value;\n    }\n    (0,emery__WEBPACK_IMPORTED_MODULE_1__.assertNever)(schema);\n}\nconst paragraphElement = ()=>({\n        type: \"paragraph\",\n        children: [\n            {\n                text: \"\"\n            }\n        ]\n    });\nfunction withParagraphs(editor) {\n    const { normalizeNode } = editor;\n    editor.normalizeNode = (entry)=>{\n        const [node, path] = entry;\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEditor(node)) {\n            let lastNode = node.children[node.children.length - 1];\n            if ((lastNode === null || lastNode === void 0 ? void 0 : lastNode.type) !== \"paragraph\") {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.insertNodes(editor, paragraphElement(), {\n                    at: [\n                        ...path,\n                        node.children.length\n                    ]\n                });\n                return;\n            }\n        }\n        normalizeNode(entry);\n    };\n    return editor;\n}\nfunction withLayouts(editor) {\n    const { normalizeNode, deleteBackward } = editor;\n    editor.deleteBackward = (unit)=>{\n        if (editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(editor.selection) && // this is just an little optimisation\n        // we're only doing things if we're at the start of a layout area\n        // and the start of anything will always be offset 0\n        // so we'll bailout if we're not at offset 0\n        editor.selection.anchor.offset === 0) {\n            const [aboveNode, abovePath] = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n                match: (node)=>node.type === \"layout-area\"\n            }) || [\n                editor,\n                []\n            ];\n            if (aboveNode.type === \"layout-area\" && slate__WEBPACK_IMPORTED_MODULE_7__.Point.equals(slate__WEBPACK_IMPORTED_MODULE_7__.Editor.start(editor, abovePath), editor.selection.anchor)) {\n                return;\n            }\n        }\n        deleteBackward(unit);\n    };\n    editor.normalizeNode = (entry)=>{\n        const [node, path] = entry;\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && node.type === \"layout\") {\n            if (node.layout === undefined) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.unwrapNodes(editor, {\n                    at: path\n                });\n                return;\n            }\n            if (node.children.length < node.layout.length) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.insertNodes(editor, Array.from({\n                    length: node.layout.length - node.children.length\n                }).map(()=>({\n                        type: \"layout-area\",\n                        children: [\n                            paragraphElement()\n                        ]\n                    })), {\n                    at: [\n                        ...path,\n                        node.children.length\n                    ]\n                });\n                return;\n            }\n            if (node.children.length > node.layout.length) {\n                Array.from({\n                    length: node.children.length - node.layout.length\n                }).map((_, i)=>i).reverse().forEach((i)=>{\n                    const layoutAreaToRemovePath = [\n                        ...path,\n                        i + node.layout.length\n                    ];\n                    const child = node.children[i + node.layout.length];\n                    moveChildren(editor, layoutAreaToRemovePath, [\n                        ...path,\n                        node.layout.length - 1,\n                        node.children[node.layout.length - 1].children.length\n                    ], (node)=>node.type !== \"paragraph\" || slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(child) !== \"\");\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.removeNodes(editor, {\n                        at: layoutAreaToRemovePath\n                    });\n                });\n                return;\n            }\n        }\n        normalizeNode(entry);\n    };\n    return editor;\n}\nconst markdownLinkPattern = /(^|\\s)\\[(.+?)\\]\\((\\S+)\\)$/;\nfunction withLink(editorDocumentFeatures, componentBlocks, editor) {\n    const { insertText, isInline, normalizeNode } = editor;\n    editor.isInline = (element)=>{\n        return element.type === \"link\" ? true : isInline(element);\n    };\n    if (editorDocumentFeatures.links) {\n        editor.insertText = (text)=>{\n            insertText(text);\n            if (text !== \")\" || !editor.selection) {\n                return;\n            }\n            const startOfBlock = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.start(editor, slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n                match: isBlock\n            })[1]);\n            const startOfBlockToEndOfShortcutString = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.string(editor, {\n                anchor: editor.selection.anchor,\n                focus: startOfBlock\n            });\n            const match = markdownLinkPattern.exec(startOfBlockToEndOfShortcutString);\n            if (!match) {\n                return;\n            }\n            const ancestorComponentChildFieldDocumentFeatures = getAncestorComponentChildFieldDocumentFeatures(editor, editorDocumentFeatures, componentBlocks);\n            if ((ancestorComponentChildFieldDocumentFeatures === null || ancestorComponentChildFieldDocumentFeatures === void 0 ? void 0 : ancestorComponentChildFieldDocumentFeatures.documentFeatures.links) === false) {\n                return;\n            }\n            const [, maybeWhitespace, linkText, href] = match;\n            // by doing this, the insertText(')') above will happen in a different undo than the link replacement\n            // so that means that when someone does an undo after this\n            // it will undo to the state of \"[content](link)\" rather than \"[content](link\" (note the missing closing bracket)\n            editor.history.undos.push({\n                operations: [],\n                selectionBefore: editor.selection\n            });\n            const startOfShortcut = match.index === 0 ? startOfBlock : EditorAfterButIgnoringingPointsWithNoContent(editor, startOfBlock, {\n                distance: match.index\n            });\n            const startOfLinkText = EditorAfterButIgnoringingPointsWithNoContent(editor, startOfShortcut, {\n                distance: maybeWhitespace === \"\" ? 1 : 2\n            });\n            const endOfLinkText = EditorAfterButIgnoringingPointsWithNoContent(editor, startOfLinkText, {\n                distance: linkText.length\n            });\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.delete(editor, {\n                at: {\n                    anchor: endOfLinkText,\n                    focus: editor.selection.anchor\n                }\n            });\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.delete(editor, {\n                at: {\n                    anchor: startOfShortcut,\n                    focus: startOfLinkText\n                }\n            });\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.wrapNodes(editor, {\n                type: \"link\",\n                href,\n                children: []\n            }, {\n                at: {\n                    anchor: editor.selection.anchor,\n                    focus: startOfShortcut\n                },\n                split: true\n            });\n            const nextNode = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.next(editor);\n            if (nextNode) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, nextNode[1]);\n            }\n        };\n    }\n    editor.normalizeNode = ([node, path])=>{\n        if (node.type === \"link\") {\n            if (slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(node) === \"\") {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.unwrapNodes(editor, {\n                    at: path\n                });\n                return;\n            }\n            for (const [idx, child] of node.children.entries()){\n                if (child.type === \"link\") {\n                    // links cannot contain links\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.unwrapNodes(editor, {\n                        at: [\n                            ...path,\n                            idx\n                        ]\n                    });\n                    return;\n                }\n            }\n        }\n        if (isInlineContainer(node)) {\n            let lastMergableLink = null;\n            for (const [idx, child] of node.children.entries()){\n                var _lastMergableLink;\n                if (child.type === \"link\" && child.href === ((_lastMergableLink = lastMergableLink) === null || _lastMergableLink === void 0 ? void 0 : _lastMergableLink.node.href)) {\n                    const firstLinkPath = [\n                        ...path,\n                        lastMergableLink.index\n                    ];\n                    const secondLinkPath = [\n                        ...path,\n                        idx\n                    ];\n                    const to = [\n                        ...firstLinkPath,\n                        lastMergableLink.node.children.length\n                    ];\n                    // note this is going in reverse, js doesn't have double-ended iterators so it's a for(;;)\n                    for(let i = child.children.length - 1; i >= 0; i--){\n                        const childPath = [\n                            ...secondLinkPath,\n                            i\n                        ];\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.moveNodes(editor, {\n                            at: childPath,\n                            to\n                        });\n                    }\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.removeNodes(editor, {\n                        at: secondLinkPath\n                    });\n                    return;\n                }\n                if (!slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText(child) || child.text !== \"\") {\n                    lastMergableLink = null;\n                }\n                if (child.type === \"link\") {\n                    lastMergableLink = {\n                        index: idx,\n                        node: child\n                    };\n                }\n            }\n        }\n        normalizeNode([\n            node,\n            path\n        ]);\n    };\n    return editor;\n}\nconst isListType = (type)=>type === \"ordered-list\" || type === \"unordered-list\";\nconst isListNode = (node)=>isListType(node.type);\nfunction getAncestorList(editor) {\n    if (editor.selection) {\n        const listItem = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n            match: nodeTypeMatcher(\"list-item\")\n        });\n        const list = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n            match: isListNode\n        });\n        if (listItem && list) {\n            return {\n                isInside: true,\n                listItem,\n                list\n            };\n        }\n    }\n    return {\n        isInside: false\n    };\n}\nfunction withList(editor) {\n    const { insertBreak, normalizeNode, deleteBackward } = editor;\n    editor.deleteBackward = (unit)=>{\n        if (editor.selection) {\n            const ancestorList = getAncestorList(editor);\n            if (ancestorList.isInside && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(editor.selection) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isStart(editor, editor.selection.anchor, ancestorList.list[1])) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.unwrapNodes(editor, {\n                    match: isListNode,\n                    split: true\n                });\n                return;\n            }\n        }\n        deleteBackward(unit);\n    };\n    editor.insertBreak = ()=>{\n        const [listItem] = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.nodes(editor, {\n            match: (node)=>node.type === \"list-item\",\n            mode: \"lowest\"\n        });\n        if (listItem && slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(listItem[0]) === \"\") {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.unwrapNodes(editor, {\n                match: isListNode,\n                split: true\n            });\n            return;\n        }\n        insertBreak();\n    };\n    editor.normalizeNode = (entry)=>{\n        const [node, path] = entry;\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) || slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEditor(node)) {\n            const isElementBeingNormalizedAList = isListNode(node);\n            for (const [childNode, childPath] of slate__WEBPACK_IMPORTED_MODULE_7__.Node.children(editor, path)){\n                const index = childPath[childPath.length - 1];\n                // merge sibling lists\n                if (isListNode(childNode)) {\n                    var _node$children;\n                    if (((_node$children = node.children[childPath[childPath.length - 1] + 1]) === null || _node$children === void 0 ? void 0 : _node$children.type) === childNode.type) {\n                        const siblingNodePath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.next(childPath);\n                        moveChildren(editor, siblingNodePath, [\n                            ...childPath,\n                            childNode.children.length\n                        ]);\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.removeNodes(editor, {\n                            at: siblingNodePath\n                        });\n                        return;\n                    }\n                    if (isElementBeingNormalizedAList) {\n                        const previousChild = node.children[index - 1];\n                        if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(previousChild)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.moveNodes(editor, {\n                                at: childPath,\n                                to: [\n                                    ...slate__WEBPACK_IMPORTED_MODULE_7__.Path.previous(childPath),\n                                    previousChild.children.length - 1\n                                ]\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.unwrapNodes(editor, {\n                                at: childPath\n                            });\n                        }\n                        return;\n                    }\n                }\n                if (node.type === \"list-item\" && childNode.type !== \"list-item-content\" && index === 0 && isBlock(childNode)) {\n                    if (path[path.length - 1] !== 0) {\n                        const previousChild = slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(editor, slate__WEBPACK_IMPORTED_MODULE_7__.Path.previous(path));\n                        if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(previousChild)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.moveNodes(editor, {\n                                at: path,\n                                to: [\n                                    ...slate__WEBPACK_IMPORTED_MODULE_7__.Path.previous(path),\n                                    previousChild.children.length\n                                ]\n                            });\n                            return;\n                        }\n                    }\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.unwrapNodes(editor, {\n                        at: childPath\n                    });\n                    return;\n                }\n                if (node.type === \"list-item\" && childNode.type === \"list-item-content\" && index !== 0) {\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.splitNodes(editor, {\n                        at: childPath\n                    });\n                    return;\n                }\n            }\n        }\n        normalizeNode(entry);\n    };\n    return editor;\n}\nfunction order(a, b) {\n    return {\n        start: Math.min(a, b),\n        end: Math.max(a, b)\n    };\n}\nfunction getRelativeRowPath(hasHead, rowIndex) {\n    return hasHead ? rowIndex === 0 ? [\n        0,\n        0\n    ] : [\n        1,\n        rowIndex - 1\n    ] : [\n        0,\n        rowIndex\n    ];\n}\nfunction getSelectedTableArea(editor) {\n    var _Editor$above, _editor$selection, _Editor$above2, _editor$selection2;\n    const anchor = (_Editor$above = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n        match: nodeTypeMatcher(\"table-cell\"),\n        at: (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.anchor.path\n    })) === null || _Editor$above === void 0 ? void 0 : _Editor$above[1];\n    const focus = (_Editor$above2 = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n        match: nodeTypeMatcher(\"table-cell\"),\n        at: (_editor$selection2 = editor.selection) === null || _editor$selection2 === void 0 ? void 0 : _editor$selection2.focus.path\n    })) === null || _Editor$above2 === void 0 ? void 0 : _Editor$above2[1];\n    const table = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n        match: nodeTypeMatcher(\"table\")\n    });\n    if (editor.selection && table && slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(table[0].children[0]) && anchor && focus && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(anchor.slice(0, -3), focus.slice(0, -3))) {\n        const [start, end] = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.edges(editor, editor.selection);\n        return {\n            tablePath: table[1],\n            table: table[0],\n            singleCell: slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(anchor, focus) ? slate__WEBPACK_IMPORTED_MODULE_7__.Point.equals(slate__WEBPACK_IMPORTED_MODULE_7__.Editor.start(editor, anchor), start) && slate__WEBPACK_IMPORTED_MODULE_7__.Point.equals(slate__WEBPACK_IMPORTED_MODULE_7__.Editor.end(editor, anchor), end) && !slate__WEBPACK_IMPORTED_MODULE_7__.Point.equals(start, end) ? \"selected\" : \"not-selected\" : \"many\",\n            row: order(anchor[anchor.length - 2] + anchor[anchor.length - 3], focus[focus.length - 2] + focus[anchor.length - 3]),\n            column: order(anchor[anchor.length - 1], focus[focus.length - 1])\n        };\n    }\n}\nconst cell = (header)=>({\n        type: \"table-cell\",\n        ...header ? {\n            header: true\n        } : {},\n        children: [\n            {\n                type: \"paragraph\",\n                children: [\n                    {\n                        text: \"\"\n                    }\n                ]\n            }\n        ]\n    });\nfunction cloneDescendant(node) {\n    if (slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText(node)) return {\n        ...node\n    };\n    return {\n        ...node,\n        children: node.children.map(cloneDescendant)\n    };\n}\nfunction withTable(editor) {\n    const { deleteFragment, normalizeNode, getFragment, insertFragment, deleteBackward } = editor;\n    editor.insertFragment = (fragment)=>{\n        const selectedTableArea = getSelectedTableArea(editor);\n        if (!selectedTableArea || fragment.length !== 1 || fragment[0].type !== \"table\") {\n            insertFragment(fragment);\n            return;\n        }\n        const newRows = fragment[0].children.flatMap((child)=>child.type === \"table-head\" || child.type === \"table-body\" ? child.children : []);\n        if (!newRows.every(nodeTypeMatcher(\"table-row\"))) {\n            insertFragment(fragment);\n            return;\n        }\n        let { row, column, tablePath, table } = selectedTableArea;\n        const existingBody = selectedTableArea.table.children[selectedTableArea.table.children.length === 1 ? 0 : 1];\n        if (newRows[0].type !== \"table-row\" || existingBody.type !== \"table-body\" || existingBody.children[0].type !== \"table-row\") {\n            insertFragment(fragment);\n            return;\n        }\n        const hasHead = table.children[0].type === \"table-head\";\n        if (selectedTableArea.singleCell !== \"many\") {\n            row = {\n                start: row.start,\n                end: Math.min(row.start + newRows.length - 1, existingBody.children.length - 1 + (hasHead ? 1 : 0))\n            };\n            column = {\n                start: column.start,\n                end: Math.min(column.start + newRows[0].children.length - 1, existingBody.children[0].children.length - 1)\n            };\n        }\n        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.withoutNormalizing(editor, ()=>{\n            for(let rowIndex = row.start; rowIndex <= row.end; rowIndex++){\n                const newRow = newRows[(rowIndex - row.start) % newRows.length];\n                for(let cellIndex = column.start; cellIndex <= column.end; cellIndex++){\n                    const relativeCellPath = [\n                        ...getRelativeRowPath(hasHead, rowIndex),\n                        cellIndex\n                    ];\n                    const cell = slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(table, relativeCellPath);\n                    const newCell = newRow.children[(cellIndex - column.start) % newRow.children.length];\n                    if (cell.type !== \"table-cell\" || newCell.type !== \"table-cell\") {\n                        continue;\n                    }\n                    const cellPath = [\n                        ...tablePath,\n                        ...relativeCellPath\n                    ];\n                    for (const childIdx of [\n                        ...cell.children.keys()\n                    ].reverse()){\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.removeNodes(editor, {\n                            at: [\n                                ...cellPath,\n                                childIdx\n                            ]\n                        });\n                    }\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.insertNodes(editor, newCell.children.map(cloneDescendant), {\n                        at: [\n                            ...cellPath,\n                            0\n                        ]\n                    });\n                }\n            }\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.setSelection(editor, {\n                anchor: slate__WEBPACK_IMPORTED_MODULE_7__.Editor.start(editor, [\n                    ...tablePath,\n                    ...getRelativeRowPath(hasHead, row.start),\n                    column.start\n                ]),\n                focus: slate__WEBPACK_IMPORTED_MODULE_7__.Editor.end(editor, [\n                    ...tablePath,\n                    ...getRelativeRowPath(hasHead, row.end),\n                    column.end\n                ])\n            });\n        });\n    };\n    editor.deleteBackward = (unit)=>{\n        if (editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(editor.selection) && editor.selection.anchor.offset === 0) {\n            const tableCell = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n                match: nodeTypeMatcher(\"table-cell\")\n            });\n            if (tableCell && tableCell[0].children[0].type === \"paragraph\" && tableCell[0].children[0].children[0].type === undefined && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(editor.selection.anchor.path, [\n                ...tableCell[1],\n                0,\n                0\n            ])) {\n                return;\n            }\n        }\n        deleteBackward(unit);\n    };\n    editor.getFragment = ()=>{\n        const selectedTableArea = getSelectedTableArea(editor);\n        if (selectedTableArea && selectedTableArea.singleCell !== \"not-selected\") {\n            var _table$children$;\n            const { table } = selectedTableArea;\n            const first = table.children[0].type === \"table-head\" || table.children[0].type === \"table-body\" ? table.children[0] : undefined;\n            if (!first) {\n                return getFragment();\n            }\n            const second = ((_table$children$ = table.children[1]) === null || _table$children$ === void 0 ? void 0 : _table$children$.type) === \"table-body\" ? table.children[1] : undefined;\n            const body = second || first;\n            const hasHead = first.type === \"table-head\";\n            const isSelectionInHead = selectedTableArea.row.start === 0 && !!second;\n            const columnLength = selectedTableArea.column.end - selectedTableArea.column.start + 1;\n            return [\n                {\n                    type: \"table\",\n                    children: [\n                        ...isSelectionInHead ? [\n                            {\n                                type: \"table-head\",\n                                children: [\n                                    {\n                                        type: \"table-row\",\n                                        children: Array.from({\n                                            length: columnLength\n                                        }).map((_, columnIndex)=>first.children[0].children[columnIndex + selectedTableArea.column.start])\n                                    }\n                                ]\n                            }\n                        ] : [],\n                        {\n                            type: \"table-body\",\n                            children: Array.from({\n                                length: selectedTableArea.row.end - selectedTableArea.row.start + (isSelectionInHead ? 0 : 1)\n                            }).map((_, rowIndex)=>({\n                                    type: \"table-row\",\n                                    children: Array.from({\n                                        length: columnLength\n                                    }).map((_, columnIndex)=>body.children[rowIndex + selectedTableArea.row.start - (hasHead && !isSelectionInHead ? 1 : 0)].children[columnIndex + selectedTableArea.column.start])\n                                }))\n                        }\n                    ]\n                }\n            ];\n        }\n        return getFragment();\n    };\n    editor.deleteFragment = (direction)=>{\n        if (!editor.selection || slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(editor.selection)) {\n            deleteFragment(direction);\n            return;\n        }\n        const selectedTableArea = getSelectedTableArea(editor);\n        if (!selectedTableArea || selectedTableArea.singleCell === \"not-selected\") {\n            deleteFragment(direction);\n            return;\n        }\n        const headOrBody = selectedTableArea.table.children[0];\n        if (!slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(headOrBody) || !slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(headOrBody.children[0])) {\n            deleteFragment(direction);\n            return;\n        }\n        const maxRowIdx = selectedTableArea.table.children.reduce((sum, headOrBody)=>sum + (headOrBody.type === \"table-head\" || headOrBody.type === \"table-body\" ? headOrBody.children.length : 0), 0) - 1;\n        const { row, column, tablePath } = selectedTableArea;\n        // note the fact that hasWholeColumnSelected uses row and hasWholeRowSelected uses column\n        // is not a mistake. if a whole column has been selected, then the starting row is 0 and the end is the last row\n        const hasWholeColumnSelected = row.start === 0 && row.end === maxRowIdx;\n        const hasWholeRowSelected = column.start === 0 && column.end === headOrBody.children[0].children.length - 1;\n        if (hasWholeColumnSelected && hasWholeRowSelected) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.removeNodes(editor, {\n                at: tablePath\n            });\n            return;\n        }\n        const hasHead = headOrBody.type === \"table-head\";\n        if (hasWholeRowSelected) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.withoutNormalizing(editor, ()=>{\n                for(let i = row.end; i >= row.start; i--){\n                    if (hasHead) {\n                        if (i === 0) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.removeNodes(editor, {\n                                at: [\n                                    ...tablePath,\n                                    0\n                                ]\n                            });\n                            continue;\n                        }\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.removeNodes(editor, {\n                            at: [\n                                ...tablePath,\n                                1,\n                                i - 1\n                            ]\n                        });\n                        continue;\n                    }\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.removeNodes(editor, {\n                        at: [\n                            ...tablePath,\n                            0,\n                            i\n                        ]\n                    });\n                }\n            });\n            return;\n        }\n        if (hasWholeColumnSelected) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.withoutNormalizing(editor, ()=>{\n                for(let i = column.end; i >= column.start; i--){\n                    for(let rowIdx = 0; rowIdx <= maxRowIdx; rowIdx++){\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.removeNodes(editor, {\n                            at: [\n                                ...tablePath,\n                                ...getRelativeRowPath(hasHead, rowIdx),\n                                i\n                            ]\n                        });\n                    }\n                }\n                const selectionPath = [\n                    ...tablePath,\n                    0,\n                    0,\n                    column.start\n                ];\n                const point = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.start(editor, column.start === 0 ? selectionPath : slate__WEBPACK_IMPORTED_MODULE_7__.Path.previous(selectionPath));\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, point);\n            });\n            return;\n        }\n        const selectionStart = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.start(editor, editor.selection).path;\n        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.withoutNormalizing(editor, ()=>{\n            for(let rowIndex = row.start; rowIndex <= row.end; rowIndex++){\n                for(let cellIndex = column.start; cellIndex <= column.end; cellIndex++){\n                    const relativeCellPath = [\n                        ...getRelativeRowPath(hasHead, rowIndex),\n                        cellIndex\n                    ];\n                    const cell = slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(selectedTableArea.table, relativeCellPath);\n                    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(cell)) {\n                        continue;\n                    }\n                    const cellPath = [\n                        ...tablePath,\n                        ...relativeCellPath\n                    ];\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.insertNodes(editor, {\n                        type: \"paragraph\",\n                        children: [\n                            {\n                                text: \"\"\n                            }\n                        ]\n                    }, {\n                        at: [\n                            ...cellPath,\n                            0\n                        ]\n                    });\n                    for (const childIdx of [\n                        ...cell.children.keys()\n                    ].reverse()){\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.removeNodes(editor, {\n                            at: [\n                                ...cellPath,\n                                childIdx + 1\n                            ]\n                        });\n                    }\n                }\n            }\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, selectionStart);\n        });\n    };\n    editor.normalizeNode = (entry)=>{\n        const [node, path] = entry;\n        if (node.type === \"table-head\" && node.children.length > 1) {\n            moveChildren(editor, path, slate__WEBPACK_IMPORTED_MODULE_7__.Path.next(path), (_, i)=>i !== 0);\n            return;\n        }\n        let didUpdateThings = false;\n        for (const parent of [\n            \"table-body\",\n            \"table-head\"\n        ]){\n            if (node.type === parent) {\n                for (const [rowIdx, row] of node.children.entries()){\n                    if (row.type === \"table-row\") {\n                        for (const [cellIdx, cell] of row.children.entries()){\n                            if (cell.type === \"table-cell\") {\n                                const at = [\n                                    ...path,\n                                    rowIdx,\n                                    cellIdx\n                                ];\n                                if (cell.header && parent === \"table-body\") {\n                                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.unsetNodes(editor, \"header\", {\n                                        at\n                                    });\n                                    didUpdateThings = true;\n                                }\n                                if (!cell.header && parent === \"table-head\") {\n                                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.setNodes(editor, {\n                                        header: true\n                                    }, {\n                                        at\n                                    });\n                                    didUpdateThings = true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (didUpdateThings) {\n            return;\n        }\n        if (node.type === \"table\") {\n            const maxRowCount = node.children.reduce((max, node)=>node.type === \"table-head\" || node.type === \"table-body\" ? node.children.reduce((max, node)=>node.type === \"table-row\" ? Math.max(max, node.children.length) : max, max) : max, 0);\n            let didInsert = false;\n            for (const [idx, child] of node.children.entries()){\n                if (child.type === \"table-body\" || child.type === \"table-head\") {\n                    for (const [rowIdx, row] of child.children.entries()){\n                        if (row.type === \"table-row\" && row.children.length !== maxRowCount) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.insertNodes(editor, Array.from({\n                                length: maxRowCount - row.children.length\n                            }, ()=>cell(child.type === \"table-head\")), {\n                                at: [\n                                    ...path,\n                                    idx,\n                                    rowIdx,\n                                    row.children.length\n                                ]\n                            });\n                            didInsert = true;\n                        }\n                    }\n                }\n            }\n            if (didInsert) {\n                return;\n            }\n            if (node.children.length === 1 && node.children[0].type === \"table-head\") {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.insertNodes(editor, {\n                    type: \"table-body\",\n                    children: Array.from({\n                        length: node.children[0].children.length\n                    }, ()=>cell(false))\n                }, {\n                    at: [\n                        ...path,\n                        1\n                    ]\n                });\n                return;\n            }\n            if (node.children.length === 2 && node.children[1].type === \"table-head\") {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.moveNodes(editor, {\n                    at: [\n                        ...path,\n                        1\n                    ],\n                    to: [\n                        ...path,\n                        0\n                    ]\n                });\n                return;\n            }\n            if (node.children.length > 2) {\n                moveChildren(editor, path, slate__WEBPACK_IMPORTED_MODULE_7__.Path.next(path), (_, i)=>i !== 0 && i !== 1);\n                return;\n            }\n        }\n        normalizeNode(entry);\n    };\n    return editor;\n}\nfunction createDocumentEditorForNormalization(documentFeatures, componentBlocks) {\n    return _createDocumentEditor((0,slate__WEBPACK_IMPORTED_MODULE_7__.createEditor)(), documentFeatures, componentBlocks);\n}\nfunction _createDocumentEditor(baseEditor, documentFeatures, componentBlocks) {\n    return withBlocksSchema(withParagraphs(withLink(documentFeatures, componentBlocks, withList(withTable(withComponentBlocks(componentBlocks, documentFeatures, withVoidElements(withLayouts(withCodeBlock(documentFeatures, componentBlocks, withDocumentFeaturesNormalization(documentFeatures, baseEditor))))))))));\n}\nfunction withBlocksSchema(editor) {\n    const { normalizeNode } = editor;\n    editor.normalizeNode = ([node, path])=>{\n        if (!slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText(node) && node.type !== \"link\") {\n            const nodeType = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEditor(node) ? \"editor\" : node.type;\n            if (typeof nodeType !== \"string\" || editorSchema[nodeType] === undefined) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.unwrapNodes(editor, {\n                    at: path\n                });\n                return;\n            }\n            const info = editorSchema[nodeType];\n            if (info.kind === \"blocks\" && node.children.length !== 0 && node.children.every((child)=>!isBlock(child))) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.wrapNodes(editor, {\n                    type: info.blockToWrapInlinesIn,\n                    children: []\n                }, {\n                    at: path,\n                    match: (node)=>!isBlock(node)\n                });\n                return;\n            }\n            let didUpdate = false;\n            for (const [index, childNode] of [\n                ...node.children.entries()\n            ].reverse()){\n                const childPath = [\n                    ...path,\n                    index\n                ];\n                if (info.kind === \"inlines\") {\n                    if (!slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText(childNode) && isBlock(childNode)) {\n                        handleNodeInInvalidPosition(editor, [\n                            childNode,\n                            childPath\n                        ], path);\n                        didUpdate = true;\n                        continue;\n                    }\n                } else {\n                    if (!isBlock(childNode)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.wrapNodes(editor, {\n                            type: info.blockToWrapInlinesIn,\n                            children: []\n                        }, {\n                            at: childPath\n                        });\n                        didUpdate = true;\n                        continue;\n                    }\n                    if (!info.allowedChildren.has(childNode.type)) {\n                        handleNodeInInvalidPosition(editor, [\n                            childNode,\n                            childPath\n                        ], path);\n                        didUpdate = true;\n                        continue;\n                    }\n                }\n            }\n            if (didUpdate) {\n                return;\n            }\n        }\n        normalizeNode([\n            node,\n            path\n        ]);\n    };\n    return editor;\n}\nfunction handleNodeInInvalidPosition(editor, [node, path], ancestorPath) {\n    const nodeType = node.type;\n    const childNodeInfo = editorSchema[nodeType];\n    // the parent of a block will never be an inline so this casting is okay\n    const ancestorNode = slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(editor, ancestorPath);\n    const parentNodeType = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEditor(ancestorNode) ? \"editor\" : ancestorNode.type;\n    const parentNodeInfo = editorSchema[parentNodeType];\n    if (!childNodeInfo || childNodeInfo.invalidPositionHandleMode === \"unwrap\") {\n        if (parentNodeInfo.kind === \"blocks\" && parentNodeInfo.blockToWrapInlinesIn) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.setNodes(editor, {\n                type: parentNodeInfo.blockToWrapInlinesIn,\n                ...Object.fromEntries(Object.keys(node).filter((key)=>key !== \"type\" && key !== \"children\").map((key)=>[\n                        key,\n                        null\n                    ])) // the Slate types don't understand that null is allowed and it will unset properties with setNodes\n            }, {\n                at: path\n            });\n            return;\n        }\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.unwrapNodes(editor, {\n            at: path\n        });\n        return;\n    }\n    const info = editorSchema[ancestorNode.type || \"editor\"];\n    if ((info === null || info === void 0 ? void 0 : info.kind) === \"blocks\" && info.allowedChildren.has(nodeType)) {\n        if (ancestorPath.length === 0) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.moveNodes(editor, {\n                at: path,\n                to: [\n                    path[0] + 1\n                ]\n            });\n        } else {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.moveNodes(editor, {\n                at: path,\n                to: slate__WEBPACK_IMPORTED_MODULE_7__.Path.next(ancestorPath)\n            });\n        }\n        return;\n    }\n    if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEditor(ancestorNode)) {\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.moveNodes(editor, {\n            at: path,\n            to: [\n                path[0] + 1\n            ]\n        });\n        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.unwrapNodes(editor, {\n            at: [\n                path[0] + 1\n            ]\n        });\n        return;\n    }\n    handleNodeInInvalidPosition(editor, [\n        node,\n        path\n    ], ancestorPath.slice(0, -1));\n}\nfunction withVoidElements(editor) {\n    const { isVoid } = editor;\n    editor.isVoid = (node)=>{\n        return node.type === \"divider\" || node.type === \"image\" || isVoid(node);\n    };\n    return editor;\n}\nconst textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\nconst defaultAltField = text({\n    label: \"Alt text\",\n    description: \"This text will be used by screen readers and search engines.\"\n});\nconst emptyTitleField = basicFormFieldWithSimpleReaderParse({\n    Input () {\n        return null;\n    },\n    defaultValue () {\n        return \"\";\n    },\n    parse (value) {\n        if (value === undefined) return \"\";\n        if (typeof value !== \"string\") {\n            throw new FieldDataError(\"Must be string\");\n        }\n        return value;\n    },\n    validate (value) {\n        return value;\n    },\n    serialize (value) {\n        return {\n            value\n        };\n    }\n});\nfunction normaliseDocumentFeatures(config) {\n    var _config$formatting, _formatting$alignment, _formatting$alignment2, _formatting$blockType, _formatting$inlineMar, _formatting$inlineMar2, _formatting$inlineMar3, _formatting$inlineMar4, _formatting$inlineMar5, _formatting$inlineMar6, _formatting$inlineMar7, _formatting$inlineMar8, _formatting$listTypes, _formatting$listTypes2, _imagesConfig$schema$, _imagesConfig$schema, _imagesConfig$schema$2, _imagesConfig$schema2;\n    const formatting = config.formatting === true ? {\n        // alignment: true, // not supported natively in markdown\n        blockTypes: true,\n        headingLevels: true,\n        inlineMarks: true,\n        listTypes: true,\n        softBreaks: true\n    } : (_config$formatting = config.formatting) !== null && _config$formatting !== void 0 ? _config$formatting : {};\n    const imagesConfig = config.images === true ? {} : config.images;\n    return {\n        formatting: {\n            alignment: formatting.alignment === true ? {\n                center: true,\n                end: true\n            } : {\n                center: !!((_formatting$alignment = formatting.alignment) !== null && _formatting$alignment !== void 0 && _formatting$alignment.center),\n                end: !!((_formatting$alignment2 = formatting.alignment) !== null && _formatting$alignment2 !== void 0 && _formatting$alignment2.end)\n            },\n            blockTypes: (formatting === null || formatting === void 0 ? void 0 : formatting.blockTypes) === true ? {\n                blockquote: true,\n                code: {\n                    schema: object({})\n                }\n            } : {\n                blockquote: !!((_formatting$blockType = formatting.blockTypes) !== null && _formatting$blockType !== void 0 && _formatting$blockType.blockquote),\n                code: ((_formatting$blockType2)=>{\n                    if (((_formatting$blockType2 = formatting.blockTypes) === null || _formatting$blockType2 === void 0 ? void 0 : _formatting$blockType2.code) === undefined) {\n                        return false;\n                    }\n                    if (formatting.blockTypes.code === true || !formatting.blockTypes.code.schema) {\n                        return {\n                            schema: object({})\n                        };\n                    }\n                    for (const key of [\n                        \"type\",\n                        \"children\",\n                        \"language\"\n                    ]){\n                        if (key in formatting.blockTypes.code.schema) {\n                            throw new Error(`\"${key}\" cannot be a key in the schema for code blocks`);\n                        }\n                    }\n                    return {\n                        schema: object(formatting.blockTypes.code.schema)\n                    };\n                })()\n            },\n            headings: ((_obj$schema)=>{\n                const opt = formatting === null || formatting === void 0 ? void 0 : formatting.headingLevels;\n                const obj = typeof opt === \"object\" && \"levels\" in opt ? opt : {\n                    levels: opt,\n                    schema: undefined\n                };\n                if (obj.schema) {\n                    for (const key of [\n                        \"type\",\n                        \"children\",\n                        \"level\",\n                        \"textAlign\"\n                    ]){\n                        if (key in obj.schema) {\n                            throw new Error(`\"${key}\" cannot be a key in the schema for headings`);\n                        }\n                    }\n                }\n                return {\n                    levels: [\n                        ...new Set(obj.levels === true ? [\n                            1,\n                            2,\n                            3,\n                            4,\n                            5,\n                            6\n                        ] : obj.levels)\n                    ],\n                    schema: object((_obj$schema = obj.schema) !== null && _obj$schema !== void 0 ? _obj$schema : {})\n                };\n            })(),\n            inlineMarks: formatting.inlineMarks === true ? {\n                bold: true,\n                code: true,\n                italic: true,\n                keyboard: false,\n                // not supported natively in markdown\n                strikethrough: true,\n                subscript: false,\n                // not supported natively in markdown\n                superscript: false,\n                // not supported natively in markdown\n                underline: false // not supported natively in markdown\n            } : {\n                bold: !!((_formatting$inlineMar = formatting.inlineMarks) !== null && _formatting$inlineMar !== void 0 && _formatting$inlineMar.bold),\n                code: !!((_formatting$inlineMar2 = formatting.inlineMarks) !== null && _formatting$inlineMar2 !== void 0 && _formatting$inlineMar2.code),\n                italic: !!((_formatting$inlineMar3 = formatting.inlineMarks) !== null && _formatting$inlineMar3 !== void 0 && _formatting$inlineMar3.italic),\n                strikethrough: !!((_formatting$inlineMar4 = formatting.inlineMarks) !== null && _formatting$inlineMar4 !== void 0 && _formatting$inlineMar4.strikethrough),\n                underline: !!((_formatting$inlineMar5 = formatting.inlineMarks) !== null && _formatting$inlineMar5 !== void 0 && _formatting$inlineMar5.underline),\n                keyboard: !!((_formatting$inlineMar6 = formatting.inlineMarks) !== null && _formatting$inlineMar6 !== void 0 && _formatting$inlineMar6.keyboard),\n                subscript: !!((_formatting$inlineMar7 = formatting.inlineMarks) !== null && _formatting$inlineMar7 !== void 0 && _formatting$inlineMar7.subscript),\n                superscript: !!((_formatting$inlineMar8 = formatting.inlineMarks) !== null && _formatting$inlineMar8 !== void 0 && _formatting$inlineMar8.superscript)\n            },\n            listTypes: formatting.listTypes === true ? {\n                ordered: true,\n                unordered: true\n            } : {\n                ordered: !!((_formatting$listTypes = formatting.listTypes) !== null && _formatting$listTypes !== void 0 && _formatting$listTypes.ordered),\n                unordered: !!((_formatting$listTypes2 = formatting.listTypes) !== null && _formatting$listTypes2 !== void 0 && _formatting$listTypes2.unordered)\n            },\n            softBreaks: !!formatting.softBreaks\n        },\n        links: !!config.links,\n        layouts: [\n            ...new Set((config.layouts || []).map((x)=>JSON.stringify(x)))\n        ].map((x)=>JSON.parse(x)),\n        dividers: !!config.dividers,\n        images: imagesConfig === undefined ? false : {\n            ...imagesConfig,\n            schema: {\n                alt: (_imagesConfig$schema$ = (_imagesConfig$schema = imagesConfig.schema) === null || _imagesConfig$schema === void 0 ? void 0 : _imagesConfig$schema.alt) !== null && _imagesConfig$schema$ !== void 0 ? _imagesConfig$schema$ : defaultAltField,\n                title: (_imagesConfig$schema$2 = (_imagesConfig$schema2 = imagesConfig.schema) === null || _imagesConfig$schema2 === void 0 ? void 0 : _imagesConfig$schema2.title) !== null && _imagesConfig$schema$2 !== void 0 ? _imagesConfig$schema$2 : emptyTitleField\n            }\n        },\n        tables: !!config.tables\n    };\n}\nfunction document$1({ label, componentBlocks = {}, description, ...documentFeaturesConfig }) {\n    const documentFeatures = normaliseDocumentFeatures(documentFeaturesConfig);\n    const parse = (mode)=>(_value, data)=>{\n            const markdoc = textDecoder.decode(data.content);\n            const document1 = fromMarkdoc(_markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8___default().parse(markdoc), componentBlocks);\n            const editor = createDocumentEditorForNormalization(documentFeatures, componentBlocks);\n            editor.children = document1;\n            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.normalize(editor, {\n                force: true\n            });\n            return deserializeFiles(editor.children, componentBlocks, data.other, data.external || new Map(), mode, documentFeatures, data.slug);\n        };\n    return {\n        kind: \"form\",\n        formKind: \"content\",\n        defaultValue () {\n            return [\n                {\n                    type: \"paragraph\",\n                    children: [\n                        {\n                            text: \"\"\n                        }\n                    ]\n                }\n            ];\n        },\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_empty_field_ui_5b08ee07_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_3__.D, {\n                componentBlocks: componentBlocks,\n                description: description,\n                label: label,\n                documentFeatures: documentFeatures,\n                ...props\n            });\n        },\n        parse: parse(\"edit\"),\n        contentExtension: \".mdoc\",\n        validate (value) {\n            return value;\n        },\n        directories: [\n            ...collectDirectoriesUsedInSchema(object(Object.fromEntries(Object.entries(componentBlocks).map(([name, block])=>[\n                    name,\n                    object(block.schema)\n                ])))),\n            ...typeof documentFeatures.images === \"object\" && typeof documentFeatures.images.directory === \"string\" ? [\n                fixPath(documentFeatures.images.directory)\n            ] : []\n        ],\n        serialize (value, opts) {\n            const { extraFiles, node } = toMarkdocDocument(value, {\n                componentBlocks,\n                documentFeatures,\n                slug: opts.slug\n            });\n            const other = new Map();\n            const external = new Map();\n            for (const file of extraFiles){\n                if (file.parent === undefined) {\n                    other.set(file.path, file.contents);\n                    continue;\n                }\n                if (!external.has(file.parent)) {\n                    external.set(file.parent, new Map());\n                }\n                external.get(file.parent).set(file.path, file.contents);\n            }\n            return {\n                content: textEncoder.encode(_markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8___default().format(_markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8___default().parse(_markdoc_markdoc__WEBPACK_IMPORTED_MODULE_8___default().format(node)))),\n                other,\n                external,\n                value: undefined\n            };\n        },\n        reader: {\n            parse: parse(\"read\")\n        }\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BrZXlzdGF0aWMrY29yZUAwLjEuN19uZXh0QDEzLjUuNl9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQGtleXN0YXRpYy9jb3JlL2Rpc3QvaW5kZXgtYjBlZWU5MjMubm9kZS5yZWFjdC1zZXJ2ZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Q7QUFDK0Q7QUFDM0I7QUFDeEM7QUFDRDtBQUNQO0FBQzhFO0FBQzFFO0FBQ1E7QUFFaEQsU0FBU3dCLFFBQVFDLElBQUk7SUFDbkIsT0FBT0EsS0FBS0MsT0FBTyxDQUFDLFdBQVcsSUFBSUEsT0FBTyxDQUFDLFFBQVE7QUFDckQ7QUFDQSxNQUFNQyxpQkFBaUI7QUFDdkIsU0FBU0MsNEJBQTRCQyxNQUFNLEVBQUVDLFVBQVU7SUFDckQsSUFBSUM7SUFDSixNQUFNQyxtQkFBbUJILE9BQU9JLFdBQVcsQ0FBQ0gsV0FBVztJQUN2RCxNQUFNTCxPQUFPLENBQUNNLHdCQUF3QkMsaUJBQWlCUCxJQUFJLE1BQU0sUUFBUU0sMEJBQTBCLEtBQUssSUFBSUEsd0JBQXdCLENBQUMsRUFBRUQsV0FBVyxHQUFHLENBQUM7SUFDdEosSUFBSSxDQUFDSCxlQUFlTyxJQUFJLENBQUNULE9BQU87UUFDOUIsTUFBTSxJQUFJVSxNQUFNLENBQUMsbUVBQW1FLEVBQUVMLFdBQVcsS0FBSyxFQUFFTCxLQUFLLENBQUM7SUFDaEg7SUFDQSxPQUFPQTtBQUNUO0FBQ0EsU0FBU1csa0JBQWtCUCxNQUFNLEVBQUVDLFVBQVU7SUFDM0MsTUFBTU8saUJBQWlCVCw0QkFBNEJDLFFBQVFDO0lBQzNELE1BQU1MLE9BQU9ELFFBQVFhLGVBQWVYLE9BQU8sQ0FBQyxZQUFZO0lBQ3hELE9BQU9EO0FBQ1Q7QUFDQSxTQUFTYSxvQkFBb0JULE1BQU0sRUFBRUMsVUFBVTtJQUM3QyxJQUFJUztJQUNKLE1BQU1QLG1CQUFtQkgsT0FBT0ksV0FBVyxDQUFDSCxXQUFXO0lBQ3ZELE9BQU9VLGNBQWMsQ0FBQ0Qsd0JBQXdCUCxpQkFBaUJTLE1BQU0sTUFBTSxRQUFRRiwwQkFBMEIsS0FBSyxJQUFJQSx3QkFBd0IsUUFBUVAsaUJBQWlCVSxNQUFNLEVBQUVkLDRCQUE0QkMsUUFBUUM7QUFDck47QUFDQSxTQUFTYSxtQkFBbUJkLE1BQU0sRUFBRWUsU0FBUztJQUMzQyxJQUFJQyx1QkFBdUJDO0lBQzNCLE1BQU1DLGtCQUFrQmxCLE9BQU9tQixVQUFVLENBQUNKLFVBQVU7SUFDcEQsT0FBT0osY0FBYyxDQUFDSyx3QkFBd0JFLGdCQUFnQk4sTUFBTSxNQUFNLFFBQVFJLDBCQUEwQixLQUFLLElBQUlBLHdCQUF3QixRQUFRRSxnQkFBZ0JMLE1BQU0sRUFBRSxDQUFDSSx3QkFBd0JDLGdCQUFnQnRCLElBQUksTUFBTSxRQUFRcUIsMEJBQTBCLEtBQUssSUFBSUEsd0JBQXdCLENBQUMsRUFBRUYsVUFBVSxDQUFDLENBQUM7QUFDcFQ7QUFDQSxTQUFTSyxzQkFBc0JwQixNQUFNLEVBQUVDLFVBQVUsRUFBRW9CLElBQUk7SUFDckQsTUFBTUMsV0FBV2Ysa0JBQWtCUCxRQUFRQztJQUMzQyxNQUFNc0IsU0FBU0MsNEJBQTRCeEIsUUFBUUM7SUFDbkQsT0FBTyxDQUFDLEVBQUVxQixTQUFTLENBQUMsRUFBRUQsS0FBSyxFQUFFRSxPQUFPLENBQUM7QUFDdkM7QUFDQSxTQUFTRSxxQkFBcUJDLEdBQUcsRUFBRUMsVUFBVTtJQUMzQyxPQUFPLENBQUMsRUFBRUQsSUFBSSxFQUFFQyxXQUFXQyxZQUFZLEtBQUssVUFBVSxXQUFXLEdBQUcsRUFBRUMscUJBQXFCRixZQUFZLENBQUM7QUFDMUc7QUFDQSxTQUFTRyx5QkFBeUI5QixNQUFNLEVBQUVDLFVBQVU7SUFDbEQsTUFBTUgsaUJBQWlCQyw0QkFBNEJDLFFBQVFDO0lBQzNELE9BQU9ILGVBQWVpQyxRQUFRLENBQUMsUUFBUSxPQUFPO0FBQ2hEO0FBQ0EsU0FBU1AsNEJBQTRCeEIsTUFBTSxFQUFFQyxVQUFVO0lBQ3JELE1BQU1PLGlCQUFpQlQsNEJBQTRCQyxRQUFRQztJQUMzRCxNQUFNTCxPQUFPRCxRQUFRYSxlQUFlWCxPQUFPLENBQUMsZUFBZTtJQUMzRCxPQUFPRCxPQUFPLENBQUMsQ0FBQyxFQUFFQSxLQUFLLENBQUMsR0FBRztBQUM3QjtBQUNBLFNBQVNvQyxpQkFBaUJoQyxNQUFNLEVBQUVlLFNBQVM7SUFDekMsSUFBSWtCLGlCQUFpQkM7SUFDckIsSUFBSSxDQUFDRCxrQkFBa0JqQyxPQUFPbUIsVUFBVSxDQUFDSixVQUFVLENBQUNuQixJQUFJLE1BQU0sUUFBUXFDLG9CQUFvQixLQUFLLEtBQUtBLGdCQUFnQkYsUUFBUSxDQUFDLE1BQU07UUFDakksTUFBTSxJQUFJekIsTUFBTSxDQUFDLHFDQUFxQyxFQUFFUyxVQUFVLEtBQUssRUFBRWYsT0FBT21CLFVBQVUsQ0FBQ0osVUFBVSxDQUFDbkIsSUFBSSxDQUFDLENBQUM7SUFDOUc7SUFDQSxPQUFPRCxRQUFRLENBQUN1QyxtQkFBbUJsQyxPQUFPbUIsVUFBVSxDQUFDSixVQUFVLENBQUNuQixJQUFJLE1BQU0sUUFBUXNDLHFCQUFxQixLQUFLLElBQUlBLG1CQUFtQm5CO0FBQ3JJO0FBQ0EsU0FBU2MscUJBQXFCRixVQUFVO0lBQ3RDLE9BQU9BLFdBQVdRLFlBQVksR0FBR1IsV0FBV1EsWUFBWSxDQUFDbkMsTUFBTSxDQUFDb0MsZ0JBQWdCLEdBQUcsTUFBTVQsV0FBV1UsSUFBSTtBQUMxRztBQUNBLFNBQVMxQixjQUFjQyxNQUFNLEVBQUVDLE1BQU0sRUFBRWpCLElBQUk7SUFDekMsSUFBSTBDO0lBQ0osTUFBTVYsZUFBZWhDLEtBQUsyQyxRQUFRLENBQUMsT0FBTyxVQUFVO0lBQ3BELElBQUksT0FBTzNCLFdBQVcsVUFBVTtRQUM5QixPQUFPO1lBQ0xnQjtZQUNBTyxjQUFjSztZQUNkSCxNQUFNekI7UUFDUjtJQUNGO0lBQ0EsSUFBSXVCO0lBQ0osSUFBSXZCLE9BQU91QixZQUFZLEVBQUU7UUFDdkIsTUFBTU0sUUFBUTVCLE1BQU0sQ0FBQ0QsT0FBT3VCLFlBQVksQ0FBQztRQUN6Q2xELDZDQUFNQSxDQUFDLENBQUN3RCxVQUFVLFFBQVFBLFVBQVUsS0FBSyxJQUFJLEtBQUssSUFBSUEsTUFBTUMsSUFBSSxNQUFNLFFBQVEsQ0FBQyxFQUFFOUIsT0FBT3VCLFlBQVksQ0FBQyxvQkFBb0IsQ0FBQztRQUMxSGxELDZDQUFNQSxDQUFDd0QsTUFBTUUsUUFBUSxLQUFLLFdBQVcsQ0FBQyxFQUFFL0IsT0FBT3VCLFlBQVksQ0FBQyx1QkFBdUIsQ0FBQztRQUNwRkEsZUFBZTtZQUNiUyxLQUFLaEMsT0FBT3VCLFlBQVk7WUFDeEJuQyxRQUFReUM7UUFDVjtJQUNGO0lBQ0EsT0FBTztRQUNMSixNQUFNLENBQUNDLGVBQWUxQixPQUFPeUIsSUFBSSxNQUFNLFFBQVFDLGlCQUFpQixLQUFLLElBQUlBLGVBQWU7UUFDeEZIO1FBQ0FQO0lBQ0Y7QUFDRjtBQUNBLFNBQVNpQixjQUFjQyxPQUFPO0lBQzVCLElBQUlBLFFBQVFKLElBQUksS0FBSyxXQUFXLENBQUNJLFFBQVFDLFVBQVUsRUFBRTtRQUNuRCxPQUFPUDtJQUNUO0lBQ0EsT0FBTzdDLFFBQVFtRCxRQUFRQyxVQUFVLElBQUk7QUFDdkM7QUFFQSxlQUFlQyxLQUFLQyxPQUFPO0lBQ3pCLE9BQU83RCxrREFBVUEsQ0FBQyxRQUFROEQsTUFBTSxDQUFDRCxTQUFTRSxNQUFNLENBQUM7QUFDbkQ7QUFFQSxNQUFNQyxnQkFBZ0IsSUFBSUM7QUFDMUIsU0FBU0MsUUFBUUMsUUFBUTtJQUN2QixNQUFNQyxhQUFhSixjQUFjSyxNQUFNLENBQUMsVUFBVUYsU0FBU0csTUFBTSxHQUFHO0lBQ3BFLE1BQU1DLFFBQVEsSUFBSUMsV0FBV0osV0FBV0ssVUFBVSxHQUFHTixTQUFTTSxVQUFVO0lBQ3hFRixNQUFNRyxHQUFHLENBQUNOLFlBQVk7SUFDdEJHLE1BQU1HLEdBQUcsQ0FBQ1AsVUFBVUMsV0FBV0ssVUFBVTtJQUN6QyxPQUFPYixLQUFLVztBQUNkO0FBQ0EsU0FBU0ksa0JBQWtCQyxJQUFJLEVBQUVwRSxJQUFJO0lBQ25DLE1BQU1xRSxRQUFRckUsS0FBS3NFLEtBQUssQ0FBQztJQUN6QixJQUFJQyxPQUFPSCxLQUFLSSxHQUFHLENBQUNILEtBQUssQ0FBQyxFQUFFO0lBQzVCLEtBQUssTUFBTUksUUFBUUosTUFBTUssS0FBSyxDQUFDLEdBQUk7UUFDakMsSUFBSSxDQUFDSCxNQUFNLE9BQU8zQjtRQUNsQixJQUFJLENBQUMyQixLQUFLSSxRQUFRLEVBQUUsT0FBTy9CO1FBQzNCMkIsT0FBT0EsS0FBS0ksUUFBUSxDQUFDSCxHQUFHLENBQUNDO0lBQzNCO0lBQ0EsT0FBT0Y7QUFDVDtBQUNBLFNBQVNLLGNBQWNDLElBQUksRUFBRTdFLElBQUk7SUFDL0IsSUFBSXVFLE9BQU9NO0lBQ1gsS0FBSyxNQUFNSixRQUFRekUsS0FBS3NFLEtBQUssQ0FBQyxLQUFNO1FBQ2xDLElBQUksQ0FBQ0MsS0FBS08sR0FBRyxDQUFDTCxPQUFPO1lBQ25CRixLQUFLTCxHQUFHLENBQUNPLE1BQU0sSUFBSU07UUFDckI7UUFDQSxNQUFNQyxZQUFZVCxLQUFLQyxHQUFHLENBQUNDO1FBQzNCcEYsNkNBQU1BLENBQUMyRixxQkFBcUJELEtBQUs7UUFDakNSLE9BQU9TO0lBQ1Q7SUFDQSxPQUFPVDtBQUNUO0FBQ0EsU0FBU1UsWUFBWWpGLElBQUk7SUFDdkIsT0FBT0EsS0FBS0MsT0FBTyxDQUFDLFFBQVE7QUFDOUI7QUFDQSxTQUFTaUYsV0FBV2xGLElBQUk7SUFDdEIsT0FBT0EsS0FBS0MsT0FBTyxDQUFDLFlBQVk7QUFDbEM7QUFDQSxTQUFTa0YsY0FBY0MsT0FBTztJQUM1QixNQUFNQyxjQUFjLElBQUlOO0lBQ3hCLEtBQUssTUFBTU8sWUFBWUYsUUFBUUcsU0FBUyxDQUFFO1FBQ3hDLE1BQU1DLGFBQWFaLGNBQWNTLGFBQWFILFdBQVdJO1FBQ3pERSxXQUFXdEIsR0FBRyxDQUFDZSxZQUFZSyxXQUFXO0lBQ3hDO0lBQ0EsS0FBSyxNQUFNRyxZQUFZTCxRQUFRTSxTQUFTLENBQUU7UUFDeEMsTUFBTUYsYUFBYVosY0FBY1MsYUFBYUgsV0FBV08sU0FBU3pGLElBQUk7UUFDdEV3RixXQUFXdEIsR0FBRyxDQUFDZSxZQUFZUSxTQUFTekYsSUFBSSxHQUFHeUYsU0FBUzlCLFFBQVE7SUFDOUQ7SUFDQSxPQUFPMEI7QUFDVDtBQUNBLE1BQU1NLGtCQUFrQjtBQUN4QixNQUFNQyxRQUFRLElBQUk1QixXQUFXO0lBQUMyQjtDQUFnQjtBQUM5QyxNQUFNRSxXQUFXLElBQUk3QixXQUFXO0lBQUM7Q0FBRTtBQUNuQyxNQUFNYSxPQUFPckIsY0FBY0ssTUFBTSxDQUFDO0FBRWxDLDBJQUEwSTtBQUMxSSxTQUFTaUMsUUFBUW5CLFFBQVE7SUFDdkIsTUFBTW9CLFVBQVU7V0FBSXBCO0tBQVMsQ0FBQ3FCLEdBQUcsQ0FBQyxDQUFDLENBQUNDLE1BQU0xQixLQUFLLEdBQU07WUFDbkQwQjtZQUNBQyxLQUFLM0IsS0FBSzRCLEtBQUssQ0FBQ0QsR0FBRztZQUNuQkUsTUFBTTdCLEtBQUs0QixLQUFLLENBQUNDLElBQUk7UUFDdkI7SUFDQUwsUUFBUU0sSUFBSSxDQUFDLENBQUNDLEdBQUdDO1FBQ2YsTUFBTUMsUUFBUUYsRUFBRUYsSUFBSSxLQUFLLFdBQVdFLEVBQUVMLElBQUksR0FBRyxNQUFNSyxFQUFFTCxJQUFJO1FBQ3pELE1BQU1RLFFBQVFGLEVBQUVILElBQUksS0FBSyxXQUFXRyxFQUFFTixJQUFJLEdBQUcsTUFBTU0sRUFBRU4sSUFBSTtRQUN6RCxPQUFPTyxVQUFVQyxRQUFRLElBQUlELFFBQVFDLFFBQVEsQ0FBQyxJQUFJO0lBQ3BEO0lBQ0EsTUFBTUMsYUFBYVgsUUFBUVksT0FBTyxDQUFDUixDQUFBQTtRQUNqQyxNQUFNQyxPQUFPNUMsY0FBY0ssTUFBTSxDQUFDc0MsTUFBTUMsSUFBSSxDQUFDbkcsT0FBTyxDQUFDLE1BQU07UUFDM0QsTUFBTWdHLE9BQU96QyxjQUFjSyxNQUFNLENBQUNzQyxNQUFNRixJQUFJO1FBQzVDLE1BQU1DLE1BQU1VLFdBQVdULE1BQU1ELEdBQUc7UUFDaEMsT0FBTztZQUFDRTtZQUFNUjtZQUFPSztZQUFNSjtZQUFVSztTQUFJO0lBQzNDO0lBQ0EsT0FBTzlDLEtBQUt5RCxZQUFZO1FBQUNoQztRQUFNckIsY0FBY0ssTUFBTSxDQUFDNkMsV0FBV0ksTUFBTSxDQUFDLENBQUNDLEtBQUtDLE1BQVFELE1BQU1DLElBQUkvQyxVQUFVLEVBQUUsR0FBR2dELFFBQVE7UUFBS3BCO1dBQWFhO0tBQVc7QUFDcEo7QUFDQSxTQUFTRyxZQUFZSyxVQUFVO0lBQzdCLE1BQU1DLGNBQWNELFdBQVdKLE1BQU0sQ0FBQyxDQUFDQyxLQUFLSyxNQUFRTCxNQUFNSyxJQUFJbkQsVUFBVSxFQUFFO0lBQzFFLE1BQU1vRCxTQUFTLElBQUlyRCxXQUFXbUQ7SUFDOUIsSUFBSUcsU0FBUztJQUNiLEtBQUssTUFBTUYsT0FBT0YsV0FBWTtRQUM1QkcsT0FBT25ELEdBQUcsQ0FBQ2tELEtBQUtFO1FBQ2hCQSxVQUFVRixJQUFJbkQsVUFBVTtJQUMxQjtJQUNBLE9BQU9vRDtBQUNUO0FBQ0EsU0FBU1QsV0FBV1csR0FBRztJQUNyQixNQUFNQyxRQUFRLElBQUl4RCxXQUFXdUQsSUFBSXpELE1BQU0sR0FBRztJQUMxQyxJQUFLLElBQUkyRCxJQUFJLEdBQUdBLElBQUlELE1BQU12RCxVQUFVLEVBQUV3RCxLQUFLLEVBQUc7UUFDNUMsTUFBTUMsUUFBUUQsSUFBSTtRQUNsQkQsS0FBSyxDQUFDQyxFQUFFLEdBQUdFLFNBQVNKLElBQUk3QyxLQUFLLENBQUNnRCxPQUFPQSxRQUFRLElBQUk7SUFDbkQ7SUFDQSxPQUFPRjtBQUNUO0FBQ0EsZUFBZUksb0JBQW9CNUgsSUFBSSxFQUFFMkUsUUFBUTtJQUMvQyxNQUFNdUIsTUFBTSxNQUFNSixRQUFRbkI7SUFDMUIsT0FBTztRQUNMM0U7UUFDQW9HLE1BQU07UUFDTnlCLE1BQU07UUFDTjNCO0lBQ0Y7QUFDRjtBQUNBLGVBQWU0QixvQkFBb0I5SCxJQUFJLEVBQUUyRCxRQUFRO0lBQy9DLE1BQU11QyxNQUFNLFNBQVN2QyxXQUFXQSxTQUFTdUMsR0FBRyxHQUFHLE1BQU14QyxRQUFRQztJQUM3RCxPQUFPO1FBQ0wzRDtRQUNBb0csTUFBTTtRQUNOeUIsTUFBTTtRQUNOM0I7UUFDQTZCLE1BQU1wRSxTQUFTTSxVQUFVO0lBQzNCO0FBQ0Y7QUFDQSxlQUFlK0Qsc0JBQXNCbkQsSUFBSSxFQUFFTyxPQUFPO0lBQ2hELElBQUk2QztJQUNKLE1BQU1DLFVBQVUsQ0FBQ0Qsb0JBQW9CLE1BQU1FLFdBQVd0RCxNQUFNTSxjQUFjQyxVQUFVLEVBQUUsT0FBTyxRQUFRNkMsc0JBQXNCLEtBQUssSUFBSUEsb0JBQW9CLElBQUlsRDtJQUM1SixPQUFPO1FBQ0xnQixTQUFTcUMsY0FBY0Y7UUFDdkJoQyxLQUFLLE1BQU1KLFFBQVFvQyxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJQSxVQUFVLElBQUluRDtJQUM1RTtBQUNGO0FBQ0EsU0FBU3FELGNBQWN2RCxJQUFJO0lBQ3pCLE9BQU87V0FBSUEsS0FBS3dELE1BQU07S0FBRyxDQUFDMUIsT0FBTyxDQUFDMkIsQ0FBQUEsSUFBS0EsRUFBRTNELFFBQVEsR0FBRztZQUFDMkQsRUFBRW5DLEtBQUs7ZUFBS2lDLGNBQWNFLEVBQUUzRCxRQUFRO1NBQUUsR0FBRztZQUFDMkQsRUFBRW5DLEtBQUs7U0FBQztBQUN6RztBQUNBLGVBQWVnQyxXQUFXdEQsSUFBSSxFQUFFMEQsV0FBVyxFQUFFdkksSUFBSTtJQUMvQyxNQUFNa0ksVUFBVSxJQUFJbkQsSUFBSUY7SUFDeEIsS0FBSyxNQUFNLENBQUM3QixLQUFLd0YsTUFBTSxJQUFJRCxZQUFhO1FBQ3RDLElBQUlDLFVBQVUsVUFBVTtZQUN0Qk4sUUFBUU8sTUFBTSxDQUFDekY7UUFDakI7UUFDQSxJQUFJd0YsaUJBQWlCekQsS0FBSztZQUN4QixJQUFJMkQsdUJBQXVCQztZQUMzQixNQUFNQyxtQkFBbUIsQ0FBQ0Ysd0JBQXdCLENBQUNDLGVBQWVULFFBQVExRCxHQUFHLENBQUN4QixJQUFHLE1BQU8sUUFBUTJGLGlCQUFpQixLQUFLLElBQUksS0FBSyxJQUFJQSxhQUFhaEUsUUFBUSxNQUFNLFFBQVErRCwwQkFBMEIsS0FBSyxJQUFJQSx3QkFBd0IsSUFBSTNEO1lBQ3JPLE1BQU1KLFdBQVcsTUFBTXdELFdBQVdTLGtCQUFrQkosT0FBT3hJLEtBQUs2SSxNQUFNLENBQUM3RjtZQUN2RSxJQUFJMkIsYUFBYS9CLFdBQVc7Z0JBQzFCc0YsUUFBUU8sTUFBTSxDQUFDekY7Z0JBQ2Y7WUFDRjtZQUNBLE1BQU1tRCxRQUFRLE1BQU15QixvQkFBb0I1SCxLQUFLNkksTUFBTSxDQUFDN0YsS0FBSzhGLElBQUksQ0FBQyxNQUFNbkU7WUFDcEV1RCxRQUFRaEUsR0FBRyxDQUFDbEIsS0FBSztnQkFDZm1EO2dCQUNBeEI7WUFDRjtRQUNGO1FBQ0EsSUFBSTZELGlCQUFpQnhFLGNBQWMsT0FBT3dFLFVBQVUsWUFBWSxTQUFTQSxPQUFPO1lBQzlFLE1BQU1yQyxRQUFRLE1BQU0yQixvQkFBb0I5SCxLQUFLNkksTUFBTSxDQUFDN0YsS0FBSzhGLElBQUksQ0FBQyxNQUFNTjtZQUNwRU4sUUFBUWhFLEdBQUcsQ0FBQ2xCLEtBQUs7Z0JBQ2ZtRDtZQUNGO1FBQ0Y7SUFDRjtJQUNBLElBQUkrQixRQUFRSCxJQUFJLEtBQUssR0FBRztRQUN0QixPQUFPbkY7SUFDVDtJQUNBLE9BQU9zRjtBQUNUO0FBQ0EsU0FBU2EsdUJBQXVCaEQsT0FBTztJQUNyQyxNQUFNM0IsT0FBTyxJQUFJVztJQUNqQixNQUFNaUUsb0JBQW9CM0UsQ0FBQUE7UUFDeEIsSUFBSTRFO1FBQ0osSUFBSTVFLE1BQU1QLE1BQU0sS0FBSyxHQUFHO1lBQ3RCLE9BQU9NO1FBQ1Q7UUFDQSxJQUFJRyxPQUFPSCxLQUFLSSxHQUFHLENBQUNILEtBQUssQ0FBQyxFQUFFO1FBQzVCLEtBQUssTUFBTUksUUFBUUosTUFBTUssS0FBSyxDQUFDLEdBQUk7WUFDakMsSUFBSSxDQUFDSCxNQUFNLE9BQU8zQjtZQUNsQixJQUFJLENBQUMyQixLQUFLSSxRQUFRLEVBQUUsT0FBTy9CO1lBQzNCMkIsT0FBT0EsS0FBS0ksUUFBUSxDQUFDSCxHQUFHLENBQUNDO1FBQzNCO1FBQ0EsT0FBTyxDQUFDd0UsUUFBUTFFLElBQUcsTUFBTyxRQUFRMEUsVUFBVSxLQUFLLElBQUksS0FBSyxJQUFJQSxNQUFNdEUsUUFBUTtJQUM5RTtJQUNBLEtBQUssTUFBTXdCLFNBQVNKLFFBQVM7UUFDM0IsTUFBTXpCLFFBQVE2QixNQUFNbkcsSUFBSSxDQUFDc0UsS0FBSyxDQUFDO1FBQy9CLE1BQU1LLFdBQVdxRSxrQkFBa0IxRSxNQUFNSSxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQ25ELElBQUlDLFVBQVU7WUFDWkEsU0FBU1QsR0FBRyxDQUFDSSxLQUFLLENBQUNBLE1BQU1SLE1BQU0sR0FBRyxFQUFFLEVBQUU7Z0JBQ3BDcUM7Z0JBQ0F4QixVQUFVd0IsTUFBTTBCLElBQUksS0FBSyxTQUFTLElBQUk5QyxRQUFRbkM7WUFDaEQ7UUFDRjtJQUNGO0lBQ0EsT0FBT3dCO0FBQ1Q7QUFFQSxTQUFTOEUsb0NBQW9DakksTUFBTSxFQUFFa0ksV0FBVyxFQUFFQyxXQUFXO0lBQzNFLElBQUlBLFlBQVl0RSxHQUFHLENBQUM3RCxTQUFTO1FBQzNCO0lBQ0Y7SUFDQW1JLFlBQVlDLEdBQUcsQ0FBQ3BJO0lBQ2hCLElBQUlBLE9BQU82QixJQUFJLEtBQUssU0FBUztRQUMzQixPQUFPb0csb0NBQW9DakksT0FBT3FJLE9BQU8sRUFBRUgsYUFBYUM7SUFDMUU7SUFDQSxJQUFJbkksT0FBTzZCLElBQUksS0FBSyxTQUFTO1FBQzNCO0lBQ0Y7SUFDQSxJQUFJN0IsT0FBTzZCLElBQUksS0FBSyxRQUFRO1FBQzFCLElBQUk3QixPQUFPOEIsUUFBUSxLQUFLLFdBQVc5QixPQUFPc0ksU0FBUyxLQUFLM0csV0FBVztZQUNqRXVHLFlBQVlFLEdBQUcsQ0FBQ3RKLFFBQVFrQixPQUFPc0ksU0FBUztRQUMxQztRQUNBLElBQUl0SSxPQUFPOEIsUUFBUSxLQUFLLGFBQWE5QixPQUFPa0ksV0FBVyxLQUFLdkcsV0FBVztZQUNyRSxLQUFLLE1BQU0yRyxhQUFhdEksT0FBT2tJLFdBQVcsQ0FBRTtnQkFDMUNBLFlBQVlFLEdBQUcsQ0FBQ3RKLFFBQVF3SjtZQUMxQjtRQUNGO1FBQ0E7SUFDRjtJQUNBLElBQUl0SSxPQUFPNkIsSUFBSSxLQUFLLFVBQVU7UUFDNUIsS0FBSyxNQUFNRCxTQUFTMkcsT0FBT25CLE1BQU0sQ0FBQ3BILE9BQU93SSxNQUFNLEVBQUc7WUFDaERQLG9DQUFvQ3JHLE9BQU9zRyxhQUFhQztRQUMxRDtRQUNBO0lBQ0Y7SUFDQSxJQUFJbkksT0FBTzZCLElBQUksS0FBSyxlQUFlO1FBQ2pDLEtBQUssTUFBTTRHLGVBQWVGLE9BQU9uQixNQUFNLENBQUNwSCxPQUFPb0gsTUFBTSxFQUFHO1lBQ3REYSxvQ0FBb0NRLGFBQWFQLGFBQWFDO1FBQ2hFO1FBQ0E7SUFDRjtJQUNBakssa0RBQVdBLENBQUM4QjtBQUNkO0FBQ0EsU0FBUzBJLCtCQUErQjFJLE1BQU07SUFDNUMsTUFBTWtJLGNBQWMsSUFBSVM7SUFDeEJWLG9DQUFvQ2pJLFFBQVFrSSxhQUFhLElBQUlTO0lBQzdELE9BQU9UO0FBQ1Q7QUFDQSxTQUFTVSx5QkFBeUI1SSxNQUFNLEVBQUVzSSxTQUFTLEVBQUU5SCxJQUFJLEVBQUVULE1BQU07SUFDL0QsTUFBTW1JLGNBQWM7UUFBQ3BKLFFBQVF3SjtLQUFXO0lBQ3hDLElBQUl2SSxPQUFPZ0IsWUFBWSxLQUFLLFNBQVM7UUFDbkNtSCxZQUFZVyxJQUFJLENBQUMvSixRQUFRd0osYUFBYXRILHFCQUFxQmpCO0lBQzdEO0lBQ0EsTUFBTStJLFFBQVF0SSxTQUFTbUIsWUFBWSxLQUFLLENBQUMsQ0FBQyxFQUFFbkIsS0FBSyxDQUFDO0lBQ2xELEtBQUssTUFBTThILGFBQWFJLCtCQUErQjFJLFFBQVM7UUFDOURrSSxZQUFZVyxJQUFJLENBQUNQLFlBQVlRO0lBQy9CO0lBQ0EsT0FBT1o7QUFDVDtBQUNBLFNBQVNhLFdBQVdiLFdBQVcsRUFBRXRFLElBQUk7SUFDbkMsT0FBT3NFLFlBQVluRCxHQUFHLENBQUNpRSxDQUFBQTtRQUNyQixJQUFJQztRQUNKLE9BQU8sQ0FBQ0EscUJBQXFCL0Ysa0JBQWtCVSxNQUFNb0YsRUFBQyxNQUFPLFFBQVFDLHVCQUF1QixLQUFLLElBQUksS0FBSyxJQUFJQSxtQkFBbUIvRCxLQUFLLENBQUNELEdBQUc7SUFDNUksR0FBRzRDLElBQUksQ0FBQztBQUNWO0FBRUEsSUFBSXFCLFVBQVU7SUFDYmxFLE1BQU07SUFDTm1FLFNBQVM7SUFDVEMsU0FBUztJQUNUQyxZQUFZO1FBQ1h6QyxNQUFNO1FBQ04wQyxLQUFLO1FBQ0xoQixXQUFXO0lBQ1o7SUFDQWlCLFNBQVM7UUFDUixRQUFRO1lBQ1BDLE9BQU87WUFDUGxHLE1BQU07Z0JBQ0wsZ0JBQWdCO29CQUNmbUcsUUFBUTtvQkFDUixXQUFXO2dCQUNaO2dCQUNBQSxRQUFRO2dCQUNSLFdBQVc7WUFDWjtZQUNBLGdCQUFnQjtnQkFDZkEsUUFBUTtnQkFDUixXQUFXO1lBQ1o7WUFDQUEsUUFBUTtZQUNSLFdBQVc7UUFDWjtRQUNBLEtBQUs7WUFDSkQsT0FBTztZQUNQbEcsTUFBTTtnQkFDTCxnQkFBZ0I7b0JBQ2ZtRyxRQUFRO29CQUNSLFdBQVc7Z0JBQ1o7Z0JBQ0FBLFFBQVE7Z0JBQ1IsV0FBVztZQUNaO1lBQ0EsZ0JBQWdCO2dCQUNmQSxRQUFRO2dCQUNSLFdBQVc7WUFDWjtZQUNBQSxRQUFRO1lBQ1IsV0FBVztRQUNaO1FBQ0EsZUFBZTtZQUNkRCxPQUFPO1lBQ1BsRyxNQUFNO2dCQUNMLGdCQUFnQjtvQkFDZm1HLFFBQVE7b0JBQ1IsV0FBVztnQkFDWjtnQkFDQUEsUUFBUTtnQkFDUixXQUFXO1lBQ1o7WUFDQSxnQkFBZ0I7Z0JBQ2ZBLFFBQVE7Z0JBQ1IsV0FBVztZQUNaO1lBQ0FBLFFBQVE7WUFDUixXQUFXO1FBQ1o7UUFDQSxjQUFjO1lBQ2JELE9BQU87WUFDUGxHLE1BQU07Z0JBQ0wsZ0JBQWdCO29CQUNmbUcsUUFBUTtvQkFDUixXQUFXO2dCQUNaO2dCQUNBQSxRQUFRO2dCQUNSLFdBQVc7WUFDWjtZQUNBLGdCQUFnQjtnQkFDZkEsUUFBUTtnQkFDUixXQUFXO1lBQ1o7WUFDQUEsUUFBUTtZQUNSLFdBQVc7UUFDWjtRQUNBLGlCQUFpQjtZQUNoQkQsT0FBTztZQUNQbEcsTUFBTTtnQkFDTCxnQkFBZ0I7b0JBQ2ZtRyxRQUFRO29CQUNSLFdBQVc7Z0JBQ1o7Z0JBQ0FBLFFBQVE7Z0JBQ1IsV0FBVztZQUNaO1lBQ0EsZ0JBQWdCO2dCQUNmQSxRQUFRO2dCQUNSLFdBQVc7WUFDWjtZQUNBQSxRQUFRO1lBQ1IsV0FBVztRQUNaO1FBQ0EsWUFBWTtZQUNYRCxPQUFPO1lBQ1BsRyxNQUFNO2dCQUNMLGdCQUFnQjtvQkFDZm1HLFFBQVE7b0JBQ1IsV0FBVztnQkFDWjtnQkFDQUEsUUFBUTtnQkFDUixXQUFXO1lBQ1o7WUFDQSxnQkFBZ0I7Z0JBQ2ZBLFFBQVE7Z0JBQ1IsV0FBVztZQUNaO1lBQ0FBLFFBQVE7WUFDUixXQUFXO1FBQ1o7UUFDQSxtQkFBbUI7WUFDbEJELE9BQU87WUFDUGxHLE1BQU07Z0JBQ0wsZ0JBQWdCO29CQUNmbUcsUUFBUTtvQkFDUixXQUFXO2dCQUNaO2dCQUNBQSxRQUFRO2dCQUNSLFdBQVc7WUFDWjtZQUNBLGdCQUFnQjtnQkFDZkEsUUFBUTtnQkFDUixXQUFXO1lBQ1o7WUFDQUEsUUFBUTtZQUNSLFdBQVc7UUFDWjtRQUNBLHNCQUFzQjtZQUNyQkQsT0FBTztZQUNQbEcsTUFBTTtnQkFDTCxnQkFBZ0I7b0JBQ2ZtRyxRQUFRO29CQUNSLFdBQVc7Z0JBQ1o7Z0JBQ0FBLFFBQVE7Z0JBQ1IsV0FBVztZQUNaO1lBQ0EsZ0JBQWdCO2dCQUNmQSxRQUFRO2dCQUNSLFdBQVc7WUFDWjtZQUNBQSxRQUFRO1lBQ1IsV0FBVztRQUNaO1FBQ0EseUJBQXlCO1lBQ3hCRCxPQUFPO1lBQ1BsRyxNQUFNO2dCQUNMLGdCQUFnQjtvQkFDZm1HLFFBQVE7b0JBQ1IsV0FBVztnQkFDWjtnQkFDQUEsUUFBUTtnQkFDUixXQUFXO1lBQ1o7WUFDQSxnQkFBZ0I7Z0JBQ2ZBLFFBQVE7Z0JBQ1IsV0FBVztZQUNaO1lBQ0FBLFFBQVE7WUFDUixXQUFXO1FBQ1o7UUFDQSxrQkFBa0I7SUFDbkI7SUFDQUMsTUFBTTtJQUNORCxRQUFRO0lBQ1JFLE9BQU87UUFDTjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNBO0lBQ0RDLFNBQVM7UUFDUkMsT0FBTztRQUNQQyxPQUFPO1FBQ1BDLEtBQUs7UUFDTHRELE9BQU87SUFDUjtJQUNBdUQsY0FBYztRQUNiLGtCQUFrQjtRQUNsQiwyQkFBMkI7UUFDM0IsZ0JBQWdCO1FBQ2hCLHlCQUF5QjtRQUN6QixzQkFBc0I7UUFDdEIsNkJBQTZCO1FBQzdCLGVBQWU7UUFDZixvQkFBb0I7UUFDcEIscUJBQXFCO1FBQ3JCLG9CQUFvQjtRQUNwQiw0QkFBNEI7UUFDNUIsd0JBQXdCO1FBQ3hCLHlCQUF5QjtRQUN6QixxQkFBcUI7UUFDckIsK0JBQStCO1FBQy9CLDhCQUE4QjtRQUM5Qix1QkFBdUI7UUFDdkIsMkJBQTJCO1FBQzNCLHdCQUF3QjtRQUN4Qix1QkFBdUI7UUFDdkIseUJBQXlCO1FBQ3pCLGVBQWU7UUFDZixlQUFlO1FBQ2YsZ0JBQWdCO1FBQ2hCLG9CQUFvQjtRQUNwQixjQUFjO1FBQ2QsdUJBQXVCO1FBQ3ZCLDZCQUE2QjtRQUM3Qiw0QkFBNEI7UUFDNUJDLFFBQVE7UUFDUkMsT0FBTztRQUNQLHdCQUF3QjtRQUN4QixtQkFBbUI7UUFDbkJDLFNBQVM7UUFDVCxjQUFjO1FBQ2RDLFFBQVE7UUFDUixrQkFBa0I7UUFDbEIsYUFBYTtRQUNiLGFBQWE7UUFDYixXQUFXO1FBQ1gsYUFBYTtRQUNiLGdCQUFnQjtRQUNoQiw0QkFBNEI7UUFDNUIsbUNBQW1DO1FBQ25DLGdDQUFnQztRQUNoQyw0Q0FBNEM7UUFDNUMseUNBQXlDO1FBQ3pDQyxXQUFXO1FBQ1gsd0JBQXdCO1FBQ3hCLHVCQUF1QjtRQUN2QixzQkFBc0I7UUFDdEIscUJBQXFCO1FBQ3JCLHFCQUFxQjtRQUNyQix5QkFBeUI7UUFDekIsb0JBQW9CO1FBQ3BCLDhCQUE4QjtRQUM5QkMsT0FBTztRQUNQLGlCQUFpQjtRQUNqQixlQUFlO1FBQ2ZDLE1BQU07UUFDTkMsS0FBSztJQUNOO0lBQ0FDLGlCQUFpQjtRQUNoQiwrQkFBK0I7UUFDL0Isb0JBQW9CO1FBQ3BCLHlCQUF5QjtRQUN6QixnQkFBZ0I7UUFDaEIsaUJBQWlCO1FBQ2pCLG9CQUFvQjtRQUNwQixrQkFBa0I7UUFDbEIsa0JBQWtCO1FBQ2xCLHNCQUFzQjtRQUN0QkMsUUFBUTtRQUNSLGFBQWE7UUFDYixhQUFhO1FBQ2JDLFNBQVM7UUFDVCxpQkFBaUI7UUFDakJDLFNBQVM7UUFDVEMsT0FBTztRQUNQLGFBQWE7UUFDYiwrQkFBK0I7UUFDL0IsNEJBQTRCO1FBQzVCLGVBQWU7UUFDZixxQkFBcUI7UUFDckJDLEtBQUs7UUFDTEMsWUFBWTtJQUNiO0lBQ0FDLGtCQUFrQjtRQUNqQkgsT0FBTztRQUNQLGFBQWE7SUFDZDtJQUNBSSxjQUFjO1FBQ2JDLGFBQWE7WUFDWjtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7U0FDQTtJQUNGO0lBQ0EsVUFBVTtRQUNUbEwsUUFBUTtRQUNSbUYsTUFBTTtRQUNOZ0csYUFBYTtRQUNiQyxTQUFTO1lBQ1JDLGFBQWE7UUFDZDtJQUNEO0lBQ0FDLFNBQVM7UUFDUixnQ0FBZ0M7WUFDL0IsZ0JBQWdCO1lBQ2hCLFdBQVc7UUFDWjtRQUNBLFNBQVM7WUFDUmhJLE1BQU07WUFDTixXQUFXO1FBQ1o7UUFDQSxjQUFjO1lBQ2JBLE1BQU07WUFDTixXQUFXO1FBQ1o7UUFDQSxnQkFBZ0I7WUFDZkEsTUFBTTtZQUNOLFdBQVc7UUFDWjtRQUNBLGVBQWU7WUFDZCxnQkFBZ0I7WUFDaEIsV0FBVztRQUNaO1FBQ0EsK0JBQStCO1lBQzlCLGdCQUFnQjtZQUNoQixXQUFXO1FBQ1o7UUFDQSx3QkFBd0I7WUFDdkIsZ0JBQWdCO1lBQ2hCLFdBQVc7UUFDWjtJQUNEO0FBQ0Q7QUFFQSxTQUFTaUksT0FBTy9DLE1BQU0sRUFBRWdELElBQUk7SUFDMUIsT0FBTztRQUNMLEdBQUdBLElBQUk7UUFDUDNKLE1BQU07UUFDTjJHO0lBQ0Y7QUFDRjtBQUVBLFNBQVNpRCxVQUFVQyxLQUFLLEVBQUVDLE9BQU87SUFDL0IsTUFBTSxFQUNKQyxRQUFRLEVBQ1JDLFNBQVNELFdBQVcsR0FBRyxFQUN2QkUsWUFBWSxJQUFJLEVBQ2pCLEdBQUdIO0lBQ0osTUFBTUksVUFBVUwsVUFBVSxJQUFJRSxXQUFXQztJQUN6QyxPQUFPQyxZQUFZLENBQUMsRUFBRUosTUFBTSxDQUFDLEVBQUVLLFFBQVEsQ0FBQyxHQUFHQTtBQUM3QztBQUNBLFNBQVNDLGdCQUFnQjdNLE1BQU07SUFDN0IsT0FBT0EsT0FBTzhDLE9BQU8sQ0FBQ0osSUFBSSxLQUFLLFVBQVUxQyxPQUFPOEMsT0FBTyxDQUFDZ0ssWUFBWSxHQUFHdEs7QUFDekU7QUFDQSxTQUFTdUssYUFBYUMsR0FBRztJQUN2QixPQUFPNUQsT0FBT3pELE9BQU8sQ0FBQ3FILEtBQUtwSCxHQUFHLENBQUMsQ0FBQyxDQUFDaEQsS0FBS3dGLE1BQU0sR0FBTTtZQUNoRHhGO1lBQ0EsR0FBR3dGLEtBQUs7UUFDVjtBQUNGO0FBQ0EsU0FBUzZFLGVBQWVqTixNQUFNO0lBQzVCLE9BQU9BLE9BQU84QyxPQUFPLENBQUNKLElBQUksS0FBSztBQUNqQztBQUNBLFNBQVN3SyxjQUFjbE4sTUFBTTtJQUMzQixPQUFPQSxPQUFPOEMsT0FBTyxDQUFDSixJQUFJLEtBQUs7QUFDakM7QUFDQSxTQUFTeUssY0FBY25OLE1BQU07SUFDM0IsSUFBSW9OO0lBQ0osSUFBSXBOLE9BQU84QyxPQUFPLENBQUNKLElBQUksS0FBSyxTQUFTLE9BQU87SUFDNUMsSUFBSSxDQUFFLEVBQUMwSyxnQkFBZ0JwTixPQUFPcU4sS0FBSyxNQUFNLFFBQVFELGtCQUFrQixLQUFLLEtBQUtBLGNBQWNFLE9BQU8sS0FBSyxDQUFDdE4sT0FBT3FOLEtBQUssQ0FBQ0MsT0FBTyxDQUFDdkwsUUFBUSxDQUFDLE1BQU07UUFDMUksTUFBTSxJQUFJekIsTUFBTSxDQUFDOzs7O0VBSW5CLENBQUM7SUFDRDtJQUNBLE9BQU87QUFDVDtBQUNBLFNBQVNpTixxQkFBcUJ2TixNQUFNO0lBQ2xDLElBQUl3TjtJQUNKLElBQUksQ0FBRSxFQUFDQSxpQkFBaUJ4TixPQUFPcU4sS0FBSyxNQUFNLFFBQVFHLG1CQUFtQixLQUFLLEtBQUtBLGVBQWVGLE9BQU8sR0FBRyxPQUFPOUs7SUFDL0csTUFBTSxDQUFDaUwsTUFBTUgsUUFBUSxHQUFHdE4sT0FBT3FOLEtBQUssQ0FBQ0MsT0FBTyxDQUFDcEosS0FBSyxDQUFDO0lBQ25ELE9BQU87UUFDTHVKO1FBQ0FIO0lBQ0Y7QUFDRjtBQUNBLFNBQVNJLFlBQVkxTixNQUFNO0lBQ3pCLE9BQU8sQ0FBQyxFQUFFQSxPQUFPMk4sU0FBUyxDQUFDLENBQUMsRUFBRTNOLE9BQU80TixRQUFRLENBQUMsQ0FBQztBQUNqRDtBQUNBLFNBQVNDLFdBQVc3TixNQUFNO0lBQ3hCLE9BQU8sQ0FBQyxtQkFBbUIsRUFBRTBOLFlBQVkxTixRQUFRLENBQUM7QUFDcEQ7QUFDQSxTQUFTOE4saUJBQWlCM04sZ0JBQWdCLEVBQUU0TixLQUFLO0lBQy9DLE1BQU0zRixRQUFRMkYsS0FBSyxDQUFDNU4saUJBQWlCNk4sU0FBUyxDQUFDO0lBQy9DLE1BQU12TCxRQUFRdEMsaUJBQWlCVSxNQUFNLENBQUNWLGlCQUFpQjZOLFNBQVMsQ0FBQztJQUNqRSxJQUFJdkwsTUFBTUMsSUFBSSxLQUFLLFVBQVVELE1BQU1FLFFBQVEsS0FBSyxRQUFRO1FBQ3RELE1BQU0sSUFBSXJDLE1BQU0sQ0FBQyw2QkFBNkIsQ0FBQztJQUNqRDtJQUNBLE9BQU9tQyxNQUFNd0wsaUJBQWlCLENBQUM3RixPQUFPL0csSUFBSTtBQUM1QztBQUNBLFNBQVM2TSxrQ0FBa0NsTyxNQUFNLEVBQUVDLFVBQVUsRUFBRWtPLFFBQVE7SUFDckUsSUFBSUMsdUJBQXVCdEU7SUFDM0IsTUFBTTNKLG1CQUFtQkgsT0FBT0ksV0FBVyxDQUFDSCxXQUFXO0lBQ3ZELE1BQU1ZLFNBQVN1TCxPQUFPak0saUJBQWlCVSxNQUFNO0lBQzdDLE1BQU1jLGFBQWFsQixvQkFBb0JULFFBQVFDO0lBQy9DLE1BQU1vTyxZQUFZeE0scUJBQXFCRjtJQUN2QyxNQUFNMk0sT0FBT3hNLHlCQUF5QjlCLFFBQVFDO0lBQzlDLE1BQU1ILGlCQUFpQlMsa0JBQWtCUCxRQUFRQztJQUNqRCxNQUFNa0osWUFBWSxDQUFDaUYsd0JBQXdCLENBQUN0RSxxQkFBcUIvRixrQkFBa0JvSyxVQUFVck8sZUFBYyxNQUFPLFFBQVFnSyx1QkFBdUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsbUJBQW1CdkYsUUFBUSxNQUFNLFFBQVE2SiwwQkFBMEIsS0FBSyxJQUFJQSx3QkFBd0IsSUFBSXpKO0lBQzNRLE1BQU1nQixVQUFVLEVBQUU7SUFDbEIsTUFBTTRJLDBCQUEwQjtXQUFJaEYsK0JBQStCMUk7S0FBUTtJQUMzRSxNQUFNVSxTQUFTQyw0QkFBNEJ4QixRQUFRQztJQUNuRCxNQUFNdU8sa0JBQWtCLElBQUk3SixJQUFJd0U7SUFDaEMsSUFBSW1GLFNBQVMsTUFBTTtRQUNqQixNQUFNRyxrQkFBa0IsQ0FBQy9NLEtBQUtnTjtZQUM1QixLQUFLLE1BQU0sQ0FBQzlMLEtBQUttRCxNQUFNLElBQUlyRSxJQUFLO2dCQUM5QixJQUFJcUUsTUFBTXhCLFFBQVEsRUFBRTtvQkFDbEJpSyxnQkFBZ0IxSyxHQUFHLENBQUMsQ0FBQyxFQUFFNEssT0FBTyxFQUFFOUwsSUFBSSxDQUFDLEVBQUVtRDtvQkFDdkMwSSxnQkFBZ0IxSSxNQUFNeEIsUUFBUSxFQUFFLENBQUMsRUFBRW1LLE9BQU8sRUFBRTlMLElBQUksQ0FBQyxDQUFDO2dCQUNwRCxPQUFPO29CQUNMNEwsZ0JBQWdCMUssR0FBRyxDQUFDLENBQUMsRUFBRTRLLE9BQU8sRUFBRTlMLElBQUksQ0FBQyxFQUFFbUQ7Z0JBQ3pDO1lBQ0Y7UUFDRjtRQUNBMEksZ0JBQWdCdEYsV0FBVztJQUM3QjtJQUNBLEtBQUssTUFBTSxDQUFDdkcsS0FBS21ELE1BQU0sSUFBSXlJLGdCQUFpQjtRQUMxQyxJQUFJN00sV0FBV0MsWUFBWSxLQUFLLFNBQVM7WUFDdkMsSUFBSStNO1lBQ0osTUFBTUMsY0FBYzdLLGtCQUFrQm9LLFVBQVUvTSxzQkFBc0JwQixRQUFRQyxZQUFZMkM7WUFDMUYsSUFBSSxDQUFFZ00sQ0FBQUEsZ0JBQWdCLFFBQVFBLGdCQUFnQixLQUFLLEtBQUssQ0FBQ0Qsd0JBQXdCQyxZQUFZckssUUFBUSxNQUFNLFFBQVFvSywwQkFBMEIsS0FBSyxLQUFLQSxzQkFBc0JqSyxHQUFHLENBQUMsVUFBVTJKLFVBQVMsR0FBSTtZQUN4TTFJLFFBQVErRCxJQUFJLENBQUM7Z0JBQ1g5RyxLQUFLZ0gsV0FBVztvQkFBQ2dGLFlBQVk3SSxLQUFLLENBQUNuRyxJQUFJO3VCQUFLMk8sd0JBQXdCM0ksR0FBRyxDQUFDc0MsQ0FBQUEsSUFBSyxDQUFDLEVBQUVBLEVBQUUsQ0FBQyxFQUFFdEYsSUFBSSxDQUFDO2lCQUFFLEVBQUV1TDtnQkFDOUY5TSxNQUFNdUI7WUFDUjtRQUNGLE9BQU87WUFDTCxJQUFJckIsUUFBUTtnQkFDVixNQUFNc04sV0FBVzlLLGtCQUFrQm9LLFVBQVUvTSxzQkFBc0JwQixRQUFRQyxZQUFZMkMsT0FBT3lMO2dCQUM5RixJQUFJLENBQUNRLFlBQVlBLFNBQVN0SyxRQUFRLEVBQUU7Z0JBQ3BDb0IsUUFBUStELElBQUksQ0FBQztvQkFDWDlHLEtBQUtnSCxXQUFXO3dCQUFDN0QsTUFBTUEsS0FBSyxDQUFDbkcsSUFBSTt3QkFBRXdCLHNCQUFzQnBCLFFBQVFDLFlBQVkyQzsyQkFBUzJMLHdCQUF3QjNJLEdBQUcsQ0FBQ3NDLENBQUFBLElBQUssQ0FBQyxFQUFFQSxFQUFFLENBQUMsRUFBRXRGLElBQUksQ0FBQztxQkFBRSxFQUFFdUw7b0JBQ3hJOU0sTUFBTXVCO2dCQUNSO1lBQ0Y7WUFDQSxJQUFJbUQsTUFBTXhCLFFBQVEsSUFBSSxDQUFDM0IsSUFBSUwsUUFBUSxDQUFDOEwsWUFBWTtZQUNoRCxNQUFNaE4sT0FBT3VCLElBQUkwQixLQUFLLENBQUMsR0FBRyxDQUFDK0osVUFBVTNLLE1BQU07WUFDM0NpQyxRQUFRK0QsSUFBSSxDQUFDO2dCQUNYOUcsS0FBS2dILFdBQVc7b0JBQUM3RCxNQUFNQSxLQUFLLENBQUNuRyxJQUFJO29CQUFFd0Isc0JBQXNCcEIsUUFBUUMsWUFBWW9CO3VCQUFVa04sd0JBQXdCM0ksR0FBRyxDQUFDc0MsQ0FBQUEsSUFBSyxDQUFDLEVBQUVBLEVBQUUsQ0FBQyxFQUFFN0csS0FBSyxDQUFDO2lCQUFFLEVBQUU4TTtnQkFDMUk5TTtZQUNGO1FBQ0Y7SUFDRjtJQUNBLE9BQU9zRTtBQUNUO0FBQ0EsTUFBTW1KLDBCQUEwQjtBQUNoQyxNQUFNQywwQkFBMEI7SUFDOUIsdUJBQXVCaEYsUUFBUUMsT0FBTztBQUN4QztBQUNBLE1BQU1nRixnQkFBZ0IsSUFBSTNMO0FBQzFCLGVBQWU0TCxvQkFBb0JDLElBQUksRUFBRWxQLE1BQU07SUFDN0MsSUFBSW1QO0lBQ0osSUFBSSxDQUFFLEVBQUNBLGlCQUFpQm5QLE9BQU9xTixLQUFLLE1BQU0sUUFBUThCLG1CQUFtQixLQUFLLEtBQUtBLGVBQWU3QixPQUFPLEdBQUc7UUFDdEcsTUFBTSxJQUFJaE4sTUFBTTtJQUNsQjtJQUNBLE1BQU04TyxnQkFBZ0JqUSx5REFBY0EsQ0FBQ2tRLE9BQU9DLGVBQWUsQ0FBQyxJQUFJMUwsV0FBVyxNQUFNO0lBQ2pGLE1BQU0yTCxpQkFBaUJwUSx5REFBY0EsQ0FBQyxJQUFJeUUsV0FBVyxNQUFNeUwsT0FBT0csTUFBTSxDQUFDck0sTUFBTSxDQUFDLFdBQVc2TCxjQUFjdkwsTUFBTSxDQUFDMkwsa0JBQWtCO0lBQ2xJLE1BQU1yQixRQUFRNU8seURBQWNBLENBQUNrUSxPQUFPQyxlQUFlLENBQUMsSUFBSTFMLFdBQVcsTUFBTTtJQUN6RTZMLGFBQWFDLE9BQU8sQ0FBQyx5QkFBeUJDLEtBQUtDLFNBQVMsQ0FBQztRQUMzRDdCO1FBQ0FtQjtRQUNBRTtJQUNGO0lBQ0EsTUFBTWpGLE1BQU0sSUFBSTBGLElBQUksQ0FBQyxFQUFFZix3QkFBd0IsZ0JBQWdCLENBQUM7SUFDaEUzRSxJQUFJMkYsWUFBWSxDQUFDaE0sR0FBRyxDQUFDLFNBQVNpSztJQUM5QjVELElBQUkyRixZQUFZLENBQUNoTSxHQUFHLENBQUMsYUFBYTlELE9BQU9xTixLQUFLLENBQUNDLE9BQU87SUFDdERuRCxJQUFJMkYsWUFBWSxDQUFDaE0sR0FBRyxDQUFDLGdCQUFnQixDQUFDLEVBQUVpTSxPQUFPQyxRQUFRLENBQUNDLE1BQU0sQ0FBQywrQkFBK0IsQ0FBQztJQUMvRjlGLElBQUkyRixZQUFZLENBQUNoTSxHQUFHLENBQUMsaUJBQWlCO0lBQ3RDcUcsSUFBSTJGLFlBQVksQ0FBQ2hNLEdBQUcsQ0FBQyx5QkFBeUI7SUFDOUNxRyxJQUFJMkYsWUFBWSxDQUFDaE0sR0FBRyxDQUFDLGtCQUFrQnlMO0lBQ3ZDcEYsSUFBSTJGLFlBQVksQ0FBQ2hNLEdBQUcsQ0FBQyxxQkFBcUJpRyxRQUFRQyxPQUFPO0lBQ3pEK0YsT0FBT0MsUUFBUSxDQUFDRSxJQUFJLEdBQUcvRixJQUFJdEQsUUFBUTtBQUNyQztBQUVBLE1BQU1zSix1QkFBdUI3UDtJQUMzQjhQLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDeEssSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQUVBLFNBQVN5SyxlQUFlbEksS0FBSyxFQUFFbUksVUFBVSxFQUFFQyxLQUFLO0lBQzlDLElBQUlwSSxVQUFVLFFBQVFtSSxlQUFlLFFBQVFBLGVBQWUsS0FBSyxLQUFLQSxXQUFXRSxVQUFVLEVBQUU7UUFDM0YsTUFBTSxJQUFJTixlQUFlLENBQUMsRUFBRUssTUFBTSxZQUFZLENBQUM7SUFDakQ7QUFDRjtBQUNBLFNBQVNFLG9DQUFvQzFRLE1BQU07SUFDakQsT0FBTztRQUNMMEMsTUFBTTtRQUNOaU8sT0FBTzNRLE9BQU8yUSxLQUFLO1FBQ25CQyxjQUFjNVEsT0FBTzRRLFlBQVk7UUFDakNDLE9BQU83USxPQUFPNlEsS0FBSztRQUNuQkMsV0FBVzlRLE9BQU84USxTQUFTO1FBQzNCQyxVQUFVL1EsT0FBTytRLFFBQVE7UUFDekJDLFFBQVE7WUFDTkgsT0FBTXpJLEtBQUs7Z0JBQ1QsT0FBT3BJLE9BQU8rUSxRQUFRLENBQUMvUSxPQUFPNlEsS0FBSyxDQUFDekk7WUFDdEM7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxNQUFNNkksMkJBQTJCLElBQUlDO0FBQ3JDLElBQUlDLFVBQVU7QUFDZCxTQUFTQyxxQkFBcUJoSixLQUFLO0lBQ2pDLElBQUksQ0FBQzZJLHlCQUF5QnZNLEdBQUcsQ0FBQzBELFFBQVE7UUFDeEM2SSx5QkFBeUJuTixHQUFHLENBQUNzRSxPQUFPaUosTUFBTW5DLElBQUksQ0FBQztZQUM3Q3hMLFFBQVEwRSxNQUFNMUUsTUFBTTtRQUN0QixHQUFHNE47SUFDTDtJQUNBLE9BQU9MLHlCQUF5QjdNLEdBQUcsQ0FBQ2dFO0FBQ3RDO0FBQ0EsU0FBU21KLHFCQUFxQm5KLEtBQUssRUFBRW9KLFVBQVU7SUFDN0NQLHlCQUF5Qm5OLEdBQUcsQ0FBQ3NFLE9BQU9vSjtBQUN0QztBQUNBLFNBQVNGO0lBQ1AsT0FBTyxDQUFDSCxTQUFRLEVBQUd0SyxRQUFRO0FBQzdCO0FBQ0EsTUFBTTRLLHVCQUF1QkM7QUFDN0IsU0FBU0Esc0JBQXNCN1EsTUFBTTtJQUNuQyxPQUFRQSxPQUFPNkIsSUFBSTtRQUNqQixLQUFLO1lBQ0gsT0FBTzdCLE9BQU8rUCxZQUFZO1FBQzVCLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNIO2dCQUNFLE1BQU1BLGVBQWUvUCxPQUFPOFEsWUFBWSxDQUFDZixZQUFZO2dCQUNyRCxPQUFPO29CQUNMZSxjQUFjZjtvQkFDZHhJLE9BQU9xSixxQkFBcUI1USxPQUFPb0gsTUFBTSxDQUFDMkksYUFBYS9KLFFBQVEsR0FBRztnQkFDcEU7WUFDRjtRQUNGLEtBQUs7WUFDSDtnQkFDRSxNQUFNbUcsTUFBTSxDQUFDO2dCQUNiLEtBQUssTUFBTXBLLE9BQU93RyxPQUFPd0ksSUFBSSxDQUFDL1EsT0FBT3dJLE1BQU0sRUFBRztvQkFDNUMyRCxHQUFHLENBQUNwSyxJQUFJLEdBQUc2TyxxQkFBcUI1USxPQUFPd0ksTUFBTSxDQUFDekcsSUFBSTtnQkFDcEQ7Z0JBQ0EsT0FBT29LO1lBQ1Q7UUFDRixLQUFLO1lBQ0g7Z0JBQ0UsT0FBTyxFQUFFO1lBQ1g7SUFDSjtJQUNBak8sa0RBQVdBLENBQUM4QjtBQUNkO0FBQ0EsU0FBU2dSLG9DQUFvQ2hSLE1BQU0sRUFBRWlSLFdBQVc7SUFDOUQsT0FBUWpSLE9BQU82QixJQUFJO1FBQ2pCLEtBQUs7WUFDSCxPQUFPb1AsZ0JBQWdCdFAsWUFBWTNCLE9BQU8rUCxZQUFZLEtBQUtrQjtRQUM3RCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSDtnQkFDRSxNQUFNbEIsZUFBZWtCLGdCQUFnQnRQLFlBQVkzQixPQUFPOFEsWUFBWSxDQUFDZixZQUFZLEtBQUtrQixZQUFZSCxZQUFZO2dCQUM5RyxPQUFPO29CQUNMQSxjQUFjZjtvQkFDZHhJLE9BQU95SixvQ0FBb0NoUixPQUFPb0gsTUFBTSxDQUFDMkksYUFBYS9KLFFBQVEsR0FBRyxFQUFFaUwsZ0JBQWdCdFAsWUFBWUEsWUFBWXNQLFlBQVkxSixLQUFLO2dCQUM5STtZQUNGO1FBQ0YsS0FBSztZQUNIO2dCQUNFLE1BQU00RSxNQUFNLENBQUM7Z0JBQ2IsS0FBSyxNQUFNcEssT0FBT3dHLE9BQU93SSxJQUFJLENBQUMvUSxPQUFPd0ksTUFBTSxFQUFHO29CQUM1QzJELEdBQUcsQ0FBQ3BLLElBQUksR0FBR2lQLG9DQUFvQ2hSLE9BQU93SSxNQUFNLENBQUN6RyxJQUFJLEVBQUVrUCxnQkFBZ0J0UCxZQUFZQSxZQUFZc1AsV0FBVyxDQUFDbFAsSUFBSTtnQkFDN0g7Z0JBQ0EsT0FBT29LO1lBQ1Q7UUFDRixLQUFLO1lBQ0g7Z0JBQ0UsT0FBTyxDQUFDOEUsZ0JBQWdCLFFBQVFBLGdCQUFnQixLQUFLLElBQUlBLGNBQWMsRUFBRSxFQUFFbE0sR0FBRyxDQUFDc0MsQ0FBQUEsSUFBSzJKLG9DQUFvQ2hSLE9BQU9xSSxPQUFPLEVBQUVoQixFQUFFRSxLQUFLO1lBQ2pKO0lBQ0o7SUFDQXJKLGtEQUFXQSxDQUFDOEI7QUFDZDtBQUNBLFNBQVNrUixZQUFZbFIsTUFBTSxFQUFFbVIsWUFBWSxFQUFFQyxPQUFPO0lBQ2hELElBQUlBLFlBQVl6UCxXQUFXLE9BQU93UDtJQUNsQyxPQUFRblIsT0FBTzZCLElBQUk7UUFDakIsS0FBSztZQUNILE9BQU91UDtRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNIO2dCQUNFLE9BQU87b0JBQ0xOLGNBQWNNLFFBQVFOLFlBQVk7b0JBQ2xDdkosT0FBTzZKLFFBQVFOLFlBQVksS0FBS0ssYUFBYUwsWUFBWSxHQUFHSSxZQUFZbFIsT0FBT29ILE1BQU0sQ0FBQ2dLLFFBQVFOLFlBQVksQ0FBQzlLLFFBQVEsR0FBRyxFQUFFbUwsYUFBYTVKLEtBQUssRUFBRTZKLFFBQVE3SixLQUFLLElBQUl5SixvQ0FBb0NoUixPQUFPb0gsTUFBTSxDQUFDZ0ssUUFBUU4sWUFBWSxDQUFDOUssUUFBUSxHQUFHLEVBQUVvTCxRQUFRN0osS0FBSztnQkFDaFE7WUFDRjtRQUNGLEtBQUs7WUFDSDtnQkFDRSxNQUFNNEUsTUFBTSxDQUFDO2dCQUNiLEtBQUssTUFBTXBLLE9BQU93RyxPQUFPd0ksSUFBSSxDQUFDL1EsT0FBT3dJLE1BQU0sRUFBRztvQkFDNUMyRCxHQUFHLENBQUNwSyxJQUFJLEdBQUdtUCxZQUFZbFIsT0FBT3dJLE1BQU0sQ0FBQ3pHLElBQUksRUFBRW9QLFlBQVksQ0FBQ3BQLElBQUksRUFBRXFQLE9BQU8sQ0FBQ3JQLElBQUk7Z0JBQzVFO2dCQUNBLE9BQU9vSztZQUNUO1FBQ0YsS0FBSztZQUNIO2dCQUNFLE1BQU1rRixnQkFBZ0JGO2dCQUN0QixNQUFNRyxTQUFTRjtnQkFDZixNQUFNRyxhQUFhLElBQUk1STtnQkFDdkIsS0FBSyxNQUFNdEIsS0FBS2lLLE9BQVE7b0JBQ3RCLElBQUlqSyxFQUFFdEYsR0FBRyxLQUFLSixXQUFXO3dCQUN2QixJQUFJNFAsV0FBVzFOLEdBQUcsQ0FBQ3dELEVBQUV0RixHQUFHLEdBQUc7NEJBQ3pCLE1BQU0sSUFBSXRDLE1BQU07d0JBQ2xCO3dCQUNBOFIsV0FBV25KLEdBQUcsQ0FBQ2YsRUFBRXRGLEdBQUc7b0JBQ3RCO2dCQUNGO2dCQUNBLE1BQU1nUCxPQUFPTyxPQUFPdk0sR0FBRyxDQUFDc0MsQ0FBQUE7b0JBQ3RCLElBQUlBLEVBQUV0RixHQUFHLEtBQUtKLFdBQVcsT0FBTzBGLEVBQUV0RixHQUFHO29CQUNyQyxJQUFJeVAsYUFBYWY7b0JBQ2pCLDZEQUE2RDtvQkFDN0QsTUFBT2MsV0FBVzFOLEdBQUcsQ0FBQzJOLFlBQWE7d0JBQ2pDQSxhQUFhZjtvQkFDZjtvQkFDQWMsV0FBV25KLEdBQUcsQ0FBQ29KO29CQUNmLE9BQU9BO2dCQUNUO2dCQUNBLE1BQU1DLFdBQVdsQixxQkFBcUJjO2dCQUN0QyxNQUFNSyxrQkFBa0IsSUFBSTVOLElBQUl1TixjQUFjdE0sR0FBRyxDQUFDLENBQUN3QyxPQUFPZjtvQkFDeEQsT0FBTzt3QkFBQ2lMLFFBQVEsQ0FBQ2pMLEVBQUU7d0JBQUVlO3FCQUFNO2dCQUM3QjtnQkFDQSxNQUFNeEIsTUFBTXVMLE9BQU92TSxHQUFHLENBQUMsQ0FBQ3NDLEdBQUdiO29CQUN6QixNQUFNbUwsS0FBS1osSUFBSSxDQUFDdkssRUFBRTtvQkFDbEIsSUFBSWtMLGdCQUFnQjdOLEdBQUcsQ0FBQzhOLEtBQUs7d0JBQzNCLE9BQU9ULFlBQVlsUixPQUFPcUksT0FBTyxFQUFFcUosZ0JBQWdCbk8sR0FBRyxDQUFDb08sS0FBS3RLLEVBQUVFLEtBQUs7b0JBQ3JFO29CQUNBLE9BQU95SixvQ0FBb0NoUixPQUFPcUksT0FBTyxFQUFFaEIsRUFBRUUsS0FBSztnQkFDcEU7Z0JBQ0FtSixxQkFBcUIzSyxLQUFLZ0w7Z0JBQzFCLE9BQU9oTDtZQUNUO0lBQ0o7SUFDQTdILGtEQUFXQSxDQUFDOEI7QUFDZDtBQUVBLFNBQVM0UixtQkFBbUJySyxLQUFLLEVBQUVzSyxTQUFTO0lBQzFDLE1BQU05UyxPQUFPO1dBQUk4UztLQUFVO0lBQzNCLE1BQU85UyxLQUFLOEQsTUFBTSxDQUFFO1FBQ2xCLE1BQU1kLE1BQU1oRCxLQUFLK1MsS0FBSztRQUN0QnZLLFFBQVFBLEtBQUssQ0FBQ3hGLElBQUk7SUFDcEI7SUFDQSxPQUFPd0Y7QUFDVDtBQUNBLFNBQVN3SyxjQUFjL1IsTUFBTSxFQUFFdUgsS0FBSyxFQUFFeUssT0FBTyxFQUFFalQsT0FBTyxFQUFFO0lBQ3RELElBQUlpQixPQUFPNkIsSUFBSSxLQUFLLFVBQVU3QixPQUFPNkIsSUFBSSxLQUFLLFNBQVM7UUFDckRtUSxRQUFRaFMsUUFBUXVILE9BQU94STtRQUN2QjtJQUNGO0lBQ0EsSUFBSWlCLE9BQU82QixJQUFJLEtBQUssVUFBVTtRQUM1QixLQUFLLE1BQU0sQ0FBQ0UsS0FBS2tRLFVBQVUsSUFBSTFKLE9BQU96RCxPQUFPLENBQUM5RSxPQUFPd0ksTUFBTSxFQUFHO1lBQzVEdUosY0FBY0UsV0FBVzFLLEtBQUssQ0FBQ3hGLElBQUksRUFBRWlRLFNBQVM7bUJBQUlqVDtnQkFBTWdEO2FBQUk7UUFDOUQ7UUFDQWlRLFFBQVFoUyxRQUFRdUgsT0FBT3hJO1FBQ3ZCO0lBQ0Y7SUFDQSxJQUFJaUIsT0FBTzZCLElBQUksS0FBSyxTQUFTO1FBQzNCLEtBQUssTUFBTSxDQUFDcVEsS0FBS25NLElBQUksSUFBSXdCLE1BQU16QyxPQUFPLEdBQUk7WUFDeENpTixjQUFjL1IsT0FBT3FJLE9BQU8sRUFBRXRDLEtBQUtpTSxTQUFTalQsS0FBSzZJLE1BQU0sQ0FBQ3NLO1FBQzFEO1FBQ0EsT0FBT0YsUUFBUWhTLFFBQVF1SCxPQUFPeEk7SUFDaEM7SUFDQSxJQUFJaUIsT0FBTzZCLElBQUksS0FBSyxlQUFlO1FBQ2pDLE1BQU1pUCxlQUFldkosTUFBTXVKLFlBQVk7UUFDdkNrQixRQUFRaFMsUUFBUThRLGNBQWMvUixLQUFLNkksTUFBTSxDQUFDO1FBQzFDbUssY0FBYy9SLE9BQU9vSCxNQUFNLENBQUMwSixhQUFhOUssUUFBUSxHQUFHLEVBQUV1QixNQUFNQSxLQUFLLEVBQUV5SyxTQUFTalQsS0FBSzZJLE1BQU0sQ0FBQztRQUN4Rm9LLFFBQVFoUyxRQUFRdUgsT0FBT3hJO1FBQ3ZCO0lBQ0Y7SUFDQVosNkRBQWFBLENBQUM2QjtBQUNoQjtBQUNBLFNBQVNtUyxlQUFlblMsTUFBTSxFQUFFdUgsS0FBSyxFQUFFNkssUUFBUSxFQUFFclQsT0FBTyxFQUFFO0lBQ3hELElBQUlpQixPQUFPNkIsSUFBSSxLQUFLLFVBQVU3QixPQUFPNkIsSUFBSSxLQUFLLFNBQVM7UUFDckQsSUFBSXVRLFFBQVEsQ0FBQ3BTLE9BQU82QixJQUFJLENBQUMsRUFBRTtZQUN6QixPQUFPdVEsUUFBUSxDQUFDcFMsT0FBTzZCLElBQUksQ0FBQyxDQUFDN0IsUUFBUXVILE9BQU94STtRQUM5QztRQUNBLE9BQU93STtJQUNUO0lBQ0EsSUFBSXZILE9BQU82QixJQUFJLEtBQUssVUFBVTtRQUM1QixNQUFNa0UsTUFBTXdDLE9BQU84SixXQUFXLENBQUM5SixPQUFPekQsT0FBTyxDQUFDOUUsT0FBT3dJLE1BQU0sRUFBRXpELEdBQUcsQ0FBQyxDQUFDLENBQUNoRCxLQUFLZ0UsSUFBSTtZQUMxRSxPQUFPO2dCQUFDaEU7Z0JBQUtvUSxlQUFlcE0sS0FBS3dCLEtBQUssQ0FBQ3hGLElBQUksRUFBRXFRLFVBQVU7dUJBQUlyVDtvQkFBTWdEO2lCQUFJO2FBQUU7UUFDekU7UUFDQSxJQUFJcVEsU0FBUzdHLE1BQU0sRUFBRTtZQUNuQixPQUFPNkcsUUFBUSxDQUFDcFMsT0FBTzZCLElBQUksQ0FBQyxDQUFDN0IsUUFBUStGLEtBQUtoSDtRQUM1QztRQUNBLE9BQU9nSDtJQUNUO0lBQ0EsSUFBSS9GLE9BQU82QixJQUFJLEtBQUssU0FBUztRQUMzQixNQUFNa0UsTUFBTXdCLE1BQU14QyxHQUFHLENBQUMsQ0FBQ2dCLEtBQUttTSxNQUFRQyxlQUFlblMsT0FBT3FJLE9BQU8sRUFBRXRDLEtBQUtxTSxVQUFVclQsS0FBSzZJLE1BQU0sQ0FBQ3NLO1FBQzlGLElBQUlFLFNBQVN0UCxLQUFLLEVBQUU7WUFDbEIsT0FBT3NQLFFBQVEsQ0FBQ3BTLE9BQU82QixJQUFJLENBQUMsQ0FBQzdCLFFBQVErRixLQUFLaEg7UUFDNUM7UUFDQSxPQUFPZ0g7SUFDVDtJQUNBLElBQUkvRixPQUFPNkIsSUFBSSxLQUFLLGVBQWU7UUFDakMsTUFBTWlQLGVBQWVxQixlQUFlblMsT0FBTzhRLFlBQVksRUFBRXZKLE1BQU11SixZQUFZLEVBQUVzQixVQUFVclQsS0FBSzZJLE1BQU0sQ0FBQztRQUNuRyxNQUFNMEssaUJBQWlCSCxlQUFlblMsT0FBT29ILE1BQU0sQ0FBQzBKLGFBQWE5SyxRQUFRLEdBQUcsRUFBRXVCLE1BQU1BLEtBQUssRUFBRTZLLFVBQVVyVCxLQUFLNkksTUFBTSxDQUFDO1FBQ2pILE1BQU03QixNQUFNO1lBQ1YrSztZQUNBdkosT0FBTytLO1FBQ1Q7UUFDQSxJQUFJRixTQUFTRyxXQUFXLEVBQUU7WUFDeEIsT0FBT0gsUUFBUSxDQUFDcFMsT0FBTzZCLElBQUksQ0FBQyxDQUFDN0IsUUFBUStGLEtBQUtoSDtRQUM1QztRQUNBLE9BQU9nSDtJQUNUO0lBQ0E1SCw2REFBYUEsQ0FBQzZCO0FBQ2hCO0FBQ0EsU0FBU3dTLHVCQUF1QnhTLE1BQU0sRUFBRXVILEtBQUssRUFBRWtMLFFBQVEsRUFBRTFULElBQUk7SUFDM0QsSUFBSUEsS0FBSzhELE1BQU0sS0FBSyxHQUFHO1FBQ3JCLE9BQU80UDtJQUNUO0lBQ0EsTUFBTSxDQUFDMVEsS0FBSyxHQUFHMlEsUUFBUSxHQUFHM1Q7SUFDMUIsSUFBSWlCLE9BQU82QixJQUFJLEtBQUssVUFBVTtRQUM1QixPQUFPO1lBQ0wsR0FBRzBGLEtBQUs7WUFDUixDQUFDeEYsSUFBSSxFQUFFeVEsdUJBQXVCeFMsT0FBT3dJLE1BQU0sQ0FBQ3pHLElBQUksRUFBRXdGLEtBQUssQ0FBQ3hGLElBQUksRUFBRTBRLFVBQVVDO1FBQzFFO0lBQ0Y7SUFDQSxJQUFJMVMsT0FBTzZCLElBQUksS0FBSyxlQUFlO1FBQ2pDLE1BQU04USxtQkFBbUJwTDtRQUN6QixtR0FBbUc7UUFDbkcsa0hBQWtIO1FBQ2xIbEosd0RBQVFBLENBQUMwRCxRQUFRO1FBQ2pCLE9BQU87WUFDTCtPLGNBQWM2QixpQkFBaUI3QixZQUFZO1lBQzNDdkosT0FBT2lMLHVCQUF1QnhTLE9BQU9vSCxNQUFNLENBQUNyRixJQUFJLEVBQUU0USxpQkFBaUJwTCxLQUFLLEVBQUVrTCxVQUFVQztRQUN0RjtJQUNGO0lBQ0EsSUFBSTFTLE9BQU82QixJQUFJLEtBQUssU0FBUztRQUMzQixNQUFNK1EsVUFBVXJMO1FBQ2hCLE1BQU0rSixTQUFTO2VBQUlzQjtTQUFRO1FBQzNCbEMscUJBQXFCWSxRQUFRZixxQkFBcUJxQztRQUNsRHRCLE1BQU0sQ0FBQ3ZQLElBQUksR0FBR3lRLHVCQUF1QnhTLE9BQU9xSSxPQUFPLEVBQUVpSixNQUFNLENBQUN2UCxJQUFJLEVBQUUwUSxVQUFVQztRQUM1RSxPQUFPcEI7SUFDVDtJQUVBLG1GQUFtRjtJQUNuRixpSUFBaUk7SUFDaklqVCx3REFBUUEsQ0FBQzJCLE9BQU82QixJQUFJLEtBQUssVUFBVTdCLE9BQU82QixJQUFJLEtBQUs7SUFDbkQxRCw2REFBYUEsQ0FBQzZCO0FBQ2hCO0FBRUEscUJBQXFCO0FBQ3JCLDRGQUE0RjtBQUM1Rix5RUFBeUU7QUFDekUsK0NBQStDO0FBQy9DLHlEQUF5RDtBQUN6RCxNQUFNNlMsdUJBQXVCLElBQUlsSztBQUNqQyxNQUFNbUsseUJBQXlCLElBQUluSztBQUNuQyxJQUFJb0ssY0FBYztBQUNsQixTQUFTQyxrQkFBa0JDLElBQUksRUFBRUMsRUFBRTtJQUNqQyxNQUFNQyxzQkFBc0JOLHFCQUFxQmhQLEdBQUcsQ0FBQ29QO0lBQ3JESixxQkFBcUJ6SyxHQUFHLENBQUM2SztJQUN6QixJQUFJO1FBQ0YsT0FBT0M7SUFDVCxTQUFVO1FBQ1IsSUFBSSxDQUFDQyxxQkFBcUI7WUFDeEJOLHFCQUFxQnJMLE1BQU0sQ0FBQ3lMO1FBQzlCO0lBQ0Y7QUFDRjtBQUNBLFNBQVNHLG1CQUFtQi9ELElBQUksRUFBRTZELEVBQUU7SUFDbEMsZ0NBQWdDO0lBQ2hDLElBQUlILGdCQUFnQixNQUFNO1FBQ3hCLE9BQU9HO0lBQ1Q7SUFDQUgsY0FBYzFEO0lBQ2QsSUFBSTtRQUNGLE9BQU82RDtJQUNULFNBQVU7UUFDUkgsY0FBYztJQUNoQjtBQUNGO0FBRUE7Ozs7Ozs7OztDQVNDLEdBRUQsU0FBU00sZUFBZUMsSUFBSTtJQUMxQixNQUFNaFEsT0FBTztRQUNYZ1E7SUFDRjtJQUNBLEtBQUssTUFBTUwsUUFBUUoscUJBQXNCO1FBQ3ZDLElBQUksQ0FBQ0MsdUJBQXVCalAsR0FBRyxDQUFDb1AsT0FBTztZQUNyQzNQLElBQUksQ0FBQzJQLEtBQUssR0FBRztRQUNmO0lBQ0Y7SUFDQSxJQUFJRixnQkFBZ0IsTUFBTTtRQUN4QixPQUFPO1lBQUM7Z0JBQ05PLE1BQU07WUFDUjtZQUFHO2dCQUNEMU0sTUFBTTtnQkFDTnlJLE1BQU0wRDtnQkFDTnJQLFVBQVU7b0JBQUNKO2lCQUFLO1lBQ2xCO1lBQUc7Z0JBQ0RnUSxNQUFNO1lBQ1I7U0FBRTtJQUNKO0lBQ0EsT0FBTztRQUFDaFE7S0FBSztBQUNmO0FBRUEsTUFBTWlRLDRCQUE0QjlUO0lBQ2hDOFAsYUFBYztRQUNaLEtBQUssQ0FBQztJQUNSO0FBQ0Y7QUFDQSxTQUFTaUUscUJBQXFCeFQsTUFBTTtJQUNsQyxJQUFJO1FBQ0YsTUFBTW9HLFNBQVNxTix5QkFBeUJ6VCxRQUFRLEVBQUUsRUFBRSxJQUFJMkk7UUFDeEQsSUFBSXZDLE9BQU92RCxNQUFNLEtBQUssR0FBRztZQUN2QixPQUFPdUQsTUFBTSxDQUFDLEVBQUU7UUFDbEI7UUFDQTtJQUNGLEVBQUUsT0FBT3NOLEtBQUs7UUFDWixJQUFJQSxlQUFlSCxxQkFBcUI7WUFDdEM7UUFDRjtRQUNBLE1BQU1HO0lBQ1I7QUFDRjtBQUNBLFNBQVNELHlCQUF5QnpULE1BQU0sRUFBRWpCLElBQUksRUFBRW9KLFdBQVc7SUFDekQsSUFBSUEsWUFBWXRFLEdBQUcsQ0FBQzdELFNBQVM7UUFDM0IsT0FBTyxFQUFFO0lBQ1g7SUFDQW1JLFlBQVlDLEdBQUcsQ0FBQ3BJO0lBQ2hCLE9BQVFBLE9BQU82QixJQUFJO1FBQ2pCLEtBQUs7WUFDSCxPQUFPLEVBQUU7UUFDWCxLQUFLO1lBQ0gsT0FBTztnQkFBQztvQkFDTjhSLGNBQWM1VTtvQkFDZDRNLFNBQVMzTCxPQUFPMkwsT0FBTztvQkFDdkI5SixNQUFNO2dCQUNSO2FBQUU7UUFDSixLQUFLO1lBQ0g7Z0JBQ0UsSUFBSStSLHVCQUF1QjVULFNBQVM7b0JBQ2xDLE1BQU0sSUFBSXVUO2dCQUNaO2dCQUNBLE9BQU8sRUFBRTtZQUNYO1FBQ0YsS0FBSztZQUNIO2dCQUNFLElBQUl2VCxPQUFPNlQsVUFBVSxFQUFFO29CQUNyQixNQUFNQyxRQUFRTCx5QkFBeUJ6VCxPQUFPcUksT0FBTyxFQUFFLEVBQUUsRUFBRUY7b0JBQzNELElBQUkyTCxNQUFNalIsTUFBTSxHQUFHLEdBQUc7d0JBQ3BCLE9BQU8sRUFBRTtvQkFDWDtvQkFDQSxPQUFPO3dCQUFDOzRCQUNOaEIsTUFBTTs0QkFDTmdTLFlBQVk3VCxPQUFPNlQsVUFBVTs0QkFDN0JqUyxPQUFPNUI7NEJBQ1AyVCxjQUFjNVU7NEJBQ2QrVSxPQUFPQSxLQUFLLENBQUMsRUFBRTt3QkFDakI7cUJBQUU7Z0JBQ0o7Z0JBQ0EsSUFBSUYsdUJBQXVCNVQsU0FBUztvQkFDbEMsTUFBTSxJQUFJdVQ7Z0JBQ1o7Z0JBQ0EsT0FBTyxFQUFFO1lBQ1g7UUFDRixLQUFLO1lBQ0g7Z0JBQ0UsTUFBTVEsUUFBUSxFQUFFO2dCQUNoQixLQUFLLE1BQU0sQ0FBQ2hTLEtBQUt3RixNQUFNLElBQUlnQixPQUFPekQsT0FBTyxDQUFDOUUsT0FBT3dJLE1BQU0sRUFBRztvQkFDeER1TCxNQUFNbEwsSUFBSSxJQUFJNEsseUJBQXlCbE0sT0FBT3hJLEtBQUs2SSxNQUFNLENBQUM3RixNQUFNb0c7Z0JBQ2xFO2dCQUNBLE9BQU80TDtZQUNUO0lBQ0o7QUFDRjtBQUNBLFNBQVNILHVCQUF1QjVULE1BQU0sRUFBRWdVLE9BQU8sSUFBSXJMLEtBQUs7SUFDdEQsSUFBSXFMLEtBQUtuUSxHQUFHLENBQUM3RCxTQUFTO1FBQ3BCLE9BQU87SUFDVDtJQUNBZ1UsS0FBSzVMLEdBQUcsQ0FBQ3BJO0lBQ1QsT0FBUUEsT0FBTzZCLElBQUk7UUFDakIsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPMEcsT0FBT25CLE1BQU0sQ0FBQ3BILE9BQU9vSCxNQUFNLEVBQUU2TSxJQUFJLENBQUMxTSxDQUFBQSxRQUFTcU0sdUJBQXVCck0sT0FBT3lNO1FBQ2xGLEtBQUs7WUFDSCxPQUFPekwsT0FBT3dJLElBQUksQ0FBQy9RLE9BQU93SSxNQUFNLEVBQUV5TCxJQUFJLENBQUNsUyxDQUFBQSxNQUFPNlIsdUJBQXVCNVQsT0FBT3dJLE1BQU0sQ0FBQ3pHLElBQUksRUFBRWlTO1FBQzNGLEtBQUs7WUFDSCxPQUFPSix1QkFBdUI1VCxPQUFPcUksT0FBTyxFQUFFMkw7SUFDbEQ7QUFDRjtBQUVBLFNBQVNFLHNCQUFzQjVRLElBQUk7SUFDakMsSUFBSUEsS0FBS3NELElBQUksS0FBSyxVQUFVO1FBQzFCLE9BQU91TiwwQkFBMEI3USxLQUFLSSxRQUFRO0lBQ2hEO0lBQ0EsSUFBSUosS0FBS3NELElBQUksS0FBSyxRQUFRO1FBQ3hCLE9BQU93TSxtQkFBbUI5UCxLQUFLOFEsVUFBVSxDQUFDL0UsSUFBSSxFQUFFLElBQU04RSwwQkFBMEI3USxLQUFLSSxRQUFRO0lBQy9GO0lBQ0EsSUFBSUosS0FBS3NELElBQUksS0FBSyxRQUFRO1FBQ3hCLE9BQU95TSxlQUFlL1AsS0FBSzhRLFVBQVUsQ0FBQ2hTLE9BQU87SUFDL0M7SUFDQSxJQUFJa0IsS0FBS3NELElBQUksS0FBSyxVQUFVO1FBQzFCLE9BQU9vTSxrQkFBa0IsUUFBUSxJQUFNbUIsMEJBQTBCN1EsS0FBS0ksUUFBUTtJQUNoRjtJQUNBLElBQUlKLEtBQUtzRCxJQUFJLEtBQUssUUFBUTtRQUN4QixPQUFPb00sa0JBQWtCLFFBQVEsSUFBTTtnQkFBQztvQkFDdENNLE1BQU1oUSxLQUFLOFEsVUFBVSxDQUFDaFMsT0FBTztvQkFDN0JpUyxNQUFNO2dCQUNSO2FBQUU7SUFDSjtJQUNBLElBQUkvUSxLQUFLc0QsSUFBSSxLQUFLLE1BQU07UUFDdEIsT0FBT29NLGtCQUFrQixVQUFVLElBQU1tQiwwQkFBMEI3USxLQUFLSSxRQUFRO0lBQ2xGO0lBQ0EsSUFBSUosS0FBS3NELElBQUksS0FBSyxLQUFLO1FBQ3JCLE9BQU9vTSxrQkFBa0IsaUJBQWlCLElBQU1tQiwwQkFBMEI3USxLQUFLSSxRQUFRO0lBQ3pGO0lBQ0EsSUFBSUosS0FBS3NELElBQUksS0FBSyxPQUFPO1FBQ3ZCLElBQUl0RCxLQUFLZ1IsR0FBRyxLQUFLLEtBQUs7WUFDcEIsT0FBT3RCLGtCQUFrQixhQUFhLElBQU1tQiwwQkFBMEI3USxLQUFLSSxRQUFRO1FBQ3JGO1FBQ0EsSUFBSUosS0FBS2dSLEdBQUcsS0FBSyxPQUFPO1lBQ3RCLE9BQU90QixrQkFBa0IsWUFBWSxJQUFNbUIsMEJBQTBCN1EsS0FBS0ksUUFBUTtRQUNwRjtRQUNBLElBQUlKLEtBQUtnUixHQUFHLEtBQUssT0FBTztZQUN0QixPQUFPdEIsa0JBQWtCLGFBQWEsSUFBTW1CLDBCQUEwQjdRLEtBQUtJLFFBQVE7UUFDckY7UUFDQSxJQUFJSixLQUFLZ1IsR0FBRyxLQUFLLE9BQU87WUFDdEIsT0FBT3RCLGtCQUFrQixlQUFlLElBQU1tQiwwQkFBMEI3USxLQUFLSSxRQUFRO1FBQ3ZGO0lBQ0Y7SUFDQSxJQUFJSixLQUFLc0QsSUFBSSxLQUFLLGFBQWE7UUFDN0IsT0FBT3lNLGVBQWU7SUFDeEI7SUFDQSxJQUFJL1AsS0FBS3NELElBQUksS0FBSyxhQUFhO1FBQzdCLE9BQU95TSxlQUFlO0lBQ3hCO0lBQ0EsSUFBSS9QLEtBQUtnUixHQUFHLEtBQUssMkJBQTJCOUQsTUFBTStELE9BQU8sQ0FBQ2pSLEtBQUs4USxVQUFVLENBQUNJLFFBQVEsS0FBS2xSLEtBQUs4USxVQUFVLENBQUNJLFFBQVEsQ0FBQ0MsS0FBSyxDQUFDcE4sQ0FBQUEsSUFBSyxPQUFPQSxNQUFNLFlBQVksT0FBT0EsTUFBTSxXQUFXO1FBQzFLLE9BQU87WUFDTFQsTUFBTTtZQUNObEQsVUFBVWdSLGtCQUFrQnBSLEtBQUtJLFFBQVE7WUFDekM4USxVQUFVbFIsS0FBSzhRLFVBQVUsQ0FBQ0ksUUFBUTtRQUNwQztJQUNGO0lBQ0EsTUFBTSxJQUFJL1UsTUFBTSxDQUFDLDBCQUEwQixFQUFFNkQsS0FBS3NELElBQUksQ0FBQyxDQUFDO0FBQzFEO0FBQ0EsU0FBU3VOLDBCQUEwQlEsS0FBSztJQUN0QyxPQUFPQSxNQUFNalAsT0FBTyxDQUFDd087QUFDdkI7QUFDQSxTQUFTUSxrQkFBa0JDLEtBQUs7SUFDOUIsTUFBTUMsbUJBQW1CRCxNQUFNalAsT0FBTyxDQUFDd087SUFDdkMsTUFBTVcsWUFBWSxFQUFFO0lBQ3BCLElBQUlDO0lBQ0osS0FBSyxNQUFNLENBQUM1QyxLQUFLNU8sS0FBSyxJQUFJc1IsaUJBQWlCOVAsT0FBTyxHQUFJO1FBQ3BELElBQUlpUTtRQUNKLElBQUl6UixLQUFLc0QsSUFBSSxLQUFLakYsYUFBYTJCLEtBQUtnUSxJQUFJLEtBQUssTUFBTSxDQUFDLENBQUN5QixZQUFZRCxRQUFPLE1BQU8sUUFBUUMsY0FBYyxLQUFLLElBQUksS0FBSyxJQUFJQSxVQUFVbk8sSUFBSSxNQUFNakYsYUFBYXVRLFFBQVEwQyxpQkFBaUIvUixNQUFNLEdBQUcsR0FBRztZQUMzTDtRQUNGO1FBQ0FnUyxVQUFVaE0sSUFBSSxDQUFDdkY7UUFDZndSLFdBQVd4UjtJQUNiO0lBQ0EsSUFBSSxDQUFDdVIsVUFBVWhTLE1BQU0sRUFBRTtRQUNyQmdTLFVBQVVoTSxJQUFJLENBQUM7WUFDYnlLLE1BQU07UUFDUjtJQUNGO0lBQ0EsT0FBT3VCO0FBQ1Q7QUFDQSxTQUFTRyxZQUFZMVIsSUFBSSxFQUFFMlIsZUFBZTtJQUN4QyxNQUFNTixRQUFRclIsS0FBS0ksUUFBUSxDQUFDZ0MsT0FBTyxDQUFDMkIsQ0FBQUEsSUFBSzZOLGdCQUFnQjdOLEdBQUc0TjtJQUM1RCxJQUFJTixNQUFNOVIsTUFBTSxLQUFLLEdBQUc7UUFDdEIsT0FBTztZQUFDO2dCQUNOK0QsTUFBTTtnQkFDTmxELFVBQVU7b0JBQUM7d0JBQ1Q0UCxNQUFNO29CQUNSO2lCQUFFO1lBQ0o7U0FBRTtJQUNKO0lBQ0EsSUFBSXFCLEtBQUssQ0FBQ0EsTUFBTTlSLE1BQU0sR0FBRyxFQUFFLENBQUMrRCxJQUFJLEtBQUssYUFBYTtRQUNoRCtOLE1BQU05TCxJQUFJLENBQUM7WUFDVGpDLE1BQU07WUFDTmxELFVBQVU7Z0JBQUM7b0JBQ1Q0UCxNQUFNO2dCQUNSO2FBQUU7UUFDSjtJQUNGO0lBQ0EsT0FBT3FCO0FBQ1Q7QUFDQSxTQUFTTyxnQkFBZ0I1UixJQUFJLEVBQUUyUixlQUFlO0lBQzVDLElBQUkzUixLQUFLc0QsSUFBSSxLQUFLLGNBQWM7UUFDOUIsT0FBTztZQUNMQSxNQUFNO1lBQ05sRCxVQUFVSixLQUFLSSxRQUFRLENBQUNnQyxPQUFPLENBQUMyQixDQUFBQSxJQUFLNk4sZ0JBQWdCN04sR0FBRzROO1FBQzFEO0lBQ0Y7SUFDQSxJQUFJM1IsS0FBS3NELElBQUksS0FBSyxTQUFTO1FBQ3pCLE1BQU0sRUFDSnVPLFFBQVEsRUFDUi9TLE9BQU8sRUFDUCxHQUFHZ1QsTUFDSixHQUFHOVIsS0FBSzhRLFVBQVU7UUFDbkIsT0FBTztZQUNMeE4sTUFBTTtZQUNObEQsVUFBVTtnQkFBQztvQkFDVDRQLE1BQU1sUixRQUFRcEQsT0FBTyxDQUFDLE9BQU87Z0JBQy9CO2FBQUU7WUFDRixHQUFJLE9BQU9tVyxhQUFhLFdBQVc7Z0JBQ2pDQTtZQUNGLElBQUksQ0FBQyxDQUFDO1lBQ04sR0FBR0MsSUFBSTtRQUNUO0lBQ0Y7SUFDQSxJQUFJOVIsS0FBS3NELElBQUksS0FBSyxXQUFXO1FBQzNCLE9BQU87WUFDTCxHQUFHdEQsS0FBSzhRLFVBQVU7WUFDbEJpQixPQUFPL1IsS0FBSzhRLFVBQVUsQ0FBQ2lCLEtBQUs7WUFDNUJ6TyxNQUFNO1lBQ05sRCxVQUFVZ1Isa0JBQWtCcFIsS0FBS0ksUUFBUTtRQUMzQztJQUNGO0lBQ0EsSUFBSUosS0FBS3NELElBQUksS0FBSyxRQUFRO1FBQ3hCLE9BQU87WUFDTEEsTUFBTXRELEtBQUs4USxVQUFVLENBQUNrQixPQUFPLEdBQUcsaUJBQWlCO1lBQ2pENVIsVUFBVUosS0FBS0ksUUFBUSxDQUFDZ0MsT0FBTyxDQUFDMkIsQ0FBQUEsSUFBSzZOLGdCQUFnQjdOLEdBQUc0TjtRQUMxRDtJQUNGO0lBQ0EsSUFBSTNSLEtBQUtzRCxJQUFJLEtBQUssUUFBUTtRQUN4QixJQUFJMk87UUFDSixNQUFNN1IsV0FBVztZQUFDO2dCQUNoQmtELE1BQU07Z0JBQ05sRCxVQUFVSixLQUFLSSxRQUFRLENBQUNiLE1BQU0sR0FBRzZSLGtCQUFrQjtvQkFBQ3BSLEtBQUtJLFFBQVEsQ0FBQyxFQUFFO2lCQUFDLElBQUk7b0JBQUM7d0JBQ3hFNFAsTUFBTTtvQkFDUjtpQkFBRTtZQUNKO1NBQUU7UUFDRixJQUFJLENBQUMsQ0FBQ2lDLGtCQUFrQmpTLEtBQUtJLFFBQVEsQ0FBQyxFQUFFLE1BQU0sUUFBUTZSLG9CQUFvQixLQUFLLElBQUksS0FBSyxJQUFJQSxnQkFBZ0IzTyxJQUFJLE1BQU0sUUFBUTtZQUM1SCxNQUFNNE8sT0FBT2xTLEtBQUtJLFFBQVEsQ0FBQyxFQUFFO1lBQzdCQSxTQUFTbUYsSUFBSSxDQUFDO2dCQUNaakMsTUFBTTRPLEtBQUtwQixVQUFVLENBQUNrQixPQUFPLEdBQUcsaUJBQWlCO2dCQUNqRDVSLFVBQVU4UixLQUFLOVIsUUFBUSxDQUFDZ0MsT0FBTyxDQUFDMkIsQ0FBQUEsSUFBSzZOLGdCQUFnQjdOLEdBQUc0TjtZQUMxRDtRQUNGO1FBQ0EsT0FBTztZQUNMck8sTUFBTTtZQUNObEQ7UUFDRjtJQUNGO0lBQ0EsSUFBSUosS0FBS3NELElBQUksS0FBSyxhQUFhO1FBQzdCLElBQUl0RCxLQUFLSSxRQUFRLENBQUNiLE1BQU0sS0FBSyxLQUFLUyxLQUFLSSxRQUFRLENBQUMsRUFBRSxDQUFDa0QsSUFBSSxLQUFLLFlBQVl0RCxLQUFLSSxRQUFRLENBQUMsRUFBRSxDQUFDQSxRQUFRLENBQUNiLE1BQU0sS0FBSyxLQUFLUyxLQUFLSSxRQUFRLENBQUMsRUFBRSxDQUFDQSxRQUFRLENBQUMsRUFBRSxDQUFDa0QsSUFBSSxLQUFLLFNBQVM7WUFDL0osSUFBSTZPO1lBQ0osTUFBTUMsUUFBUXBTLEtBQUtJLFFBQVEsQ0FBQyxFQUFFLENBQUNBLFFBQVEsQ0FBQyxFQUFFO1lBQzFDLE9BQU87Z0JBQ0xrRCxNQUFNO2dCQUNOK08sS0FBS0MsVUFBVUYsTUFBTXRCLFVBQVUsQ0FBQ3VCLEdBQUc7Z0JBQ25DRSxLQUFLSCxNQUFNdEIsVUFBVSxDQUFDeUIsR0FBRztnQkFDekJDLE9BQU8sQ0FBQ0wsd0JBQXdCQyxNQUFNdEIsVUFBVSxDQUFDMEIsS0FBSyxNQUFNLFFBQVFMLDBCQUEwQixLQUFLLElBQUlBLHdCQUF3QjtnQkFDL0gvUixVQUFVO29CQUFDO3dCQUNUNFAsTUFBTTtvQkFDUjtpQkFBRTtZQUNKO1FBQ0Y7UUFDQSxNQUFNNVAsV0FBV2dSLGtCQUFrQnBSLEtBQUtJLFFBQVE7UUFDaEQsSUFBSUEsU0FBU2IsTUFBTSxLQUFLLEtBQUthLFFBQVEsQ0FBQyxFQUFFLENBQUNrRCxJQUFJLEtBQUsseUJBQXlCO1lBQ3pFLE9BQU9sRCxRQUFRLENBQUMsRUFBRTtRQUNwQjtRQUNBLE9BQU87WUFDTGtELE1BQU07WUFDTmxEO1lBQ0FxUyxXQUFXelMsS0FBSzhRLFVBQVUsQ0FBQzJCLFNBQVM7UUFDdEM7SUFDRjtJQUNBLElBQUl6UyxLQUFLc0QsSUFBSSxLQUFLLE1BQU07UUFDdEIsT0FBTztZQUNMQSxNQUFNO1lBQ05sRCxVQUFVO2dCQUFDO29CQUNUNFAsTUFBTTtnQkFDUjthQUFFO1FBQ0o7SUFDRjtJQUNBLElBQUloUSxLQUFLc0QsSUFBSSxLQUFLLFNBQVM7UUFDekIsT0FBTztZQUNMQSxNQUFNO1lBQ05sRCxVQUFVSixLQUFLSSxRQUFRLENBQUNnQyxPQUFPLENBQUMyQixDQUFBQSxJQUFLNk4sZ0JBQWdCN04sR0FBRzROO1FBQzFEO0lBQ0Y7SUFDQSxJQUFJM1IsS0FBS3NELElBQUksS0FBSyxTQUFTO1FBQ3pCLE9BQU87WUFDTEEsTUFBTTtZQUNObEQsVUFBVUosS0FBS0ksUUFBUSxDQUFDZ0MsT0FBTyxDQUFDMkIsQ0FBQUEsSUFBSzZOLGdCQUFnQjdOLEdBQUc0TjtRQUMxRDtJQUNGO0lBQ0EsSUFBSTNSLEtBQUtzRCxJQUFJLEtBQUssU0FBUztRQUN6QixJQUFJLENBQUN0RCxLQUFLSSxRQUFRLENBQUNiLE1BQU0sRUFBRSxPQUFPLEVBQUU7UUFDcEMsT0FBTztZQUNMK0QsTUFBTTtZQUNObEQsVUFBVUosS0FBS0ksUUFBUSxDQUFDZ0MsT0FBTyxDQUFDMkIsQ0FBQUEsSUFBSzZOLGdCQUFnQjdOLEdBQUc0TjtRQUMxRDtJQUNGO0lBQ0EsSUFBSTNSLEtBQUtzRCxJQUFJLEtBQUssTUFBTTtRQUN0QixPQUFPO1lBQ0xBLE1BQU07WUFDTmxELFVBQVVKLEtBQUtJLFFBQVEsQ0FBQ2dDLE9BQU8sQ0FBQzJCLENBQUFBLElBQUs2TixnQkFBZ0I3TixHQUFHNE47UUFDMUQ7SUFDRjtJQUNBLElBQUkzUixLQUFLc0QsSUFBSSxLQUFLLE1BQU07UUFDdEIsT0FBTztZQUNMQSxNQUFNO1lBQ05sRCxVQUFVSixLQUFLSSxRQUFRLENBQUNnQyxPQUFPLENBQUMyQixDQUFBQSxJQUFLNk4sZ0JBQWdCN04sR0FBRzROO1FBQzFEO0lBQ0Y7SUFDQSxJQUFJM1IsS0FBS3NELElBQUksS0FBSyxNQUFNO1FBQ3RCLE9BQU87WUFDTEEsTUFBTTtZQUNOb1AsUUFBUTtZQUNSdFMsVUFBVUosS0FBS0ksUUFBUSxDQUFDZ0MsT0FBTyxDQUFDMkIsQ0FBQUEsSUFBSzZOLGdCQUFnQjdOLEdBQUc0TjtRQUMxRDtJQUNGO0lBQ0EsSUFBSTNSLEtBQUtzRCxJQUFJLEtBQUssT0FBTztRQUN2QixJQUFJdEQsS0FBS2dSLEdBQUcsS0FBSyxTQUFTO1lBQ3hCLE9BQU9ZLGdCQUFnQjVSLEtBQUtJLFFBQVEsQ0FBQyxFQUFFLEVBQUV1UjtRQUMzQztRQUNBLElBQUkzUixLQUFLZ1IsR0FBRyxLQUFLLFVBQVU7WUFDekIsT0FBTztnQkFDTDFOLE1BQU07Z0JBQ05xUCxRQUFRM1MsS0FBSzhRLFVBQVUsQ0FBQzZCLE1BQU07Z0JBQzlCdlMsVUFBVUosS0FBS0ksUUFBUSxDQUFDZ0MsT0FBTyxDQUFDMkIsQ0FBQUEsSUFBSzZOLGdCQUFnQjdOLEdBQUc0TjtZQUMxRDtRQUNGO1FBQ0EsSUFBSTNSLEtBQUtnUixHQUFHLEtBQUssZUFBZTtZQUM5QixPQUFPO2dCQUNMMU4sTUFBTTtnQkFDTmxELFVBQVVKLEtBQUtJLFFBQVEsQ0FBQ2dDLE9BQU8sQ0FBQzJCLENBQUFBLElBQUs2TixnQkFBZ0I3TixHQUFHNE47WUFDMUQ7UUFDRjtRQUNBLElBQUkzUixLQUFLZ1IsR0FBRyxLQUFLLG1CQUFtQjtZQUNsQyxPQUFPO2dCQUNMMU4sTUFBTTtnQkFDTnNQLFdBQVc1UyxLQUFLOFEsVUFBVSxDQUFDOEIsU0FBUztnQkFDcENDLE9BQU83UyxLQUFLOFEsVUFBVSxDQUFDK0IsS0FBSztnQkFDNUJ6UyxVQUFVSixLQUFLSSxRQUFRLENBQUNiLE1BQU0sS0FBSyxJQUFJO29CQUFDO3dCQUN0QytELE1BQU07d0JBQ05sRCxVQUFVOzRCQUFDO2dDQUNUNFAsTUFBTTs0QkFDUjt5QkFBRTtvQkFDSjtpQkFBRSxHQUFHaFEsS0FBS0ksUUFBUSxDQUFDZ0MsT0FBTyxDQUFDMkIsQ0FBQUEsSUFBSzZOLGdCQUFnQjdOLEdBQUc0TjtZQUNyRDtRQUNGO1FBQ0EsSUFBSTNSLEtBQUtnUixHQUFHLEtBQUssMEJBQTBCOUQsTUFBTStELE9BQU8sQ0FBQ2pSLEtBQUs4USxVQUFVLENBQUNJLFFBQVEsS0FBS2xSLEtBQUs4USxVQUFVLENBQUNJLFFBQVEsQ0FBQ0MsS0FBSyxDQUFDcE4sQ0FBQUEsSUFBSyxPQUFPQSxNQUFNLFlBQVksT0FBT0EsTUFBTSxXQUFXO1lBQ3pLLE9BQU87Z0JBQ0xULE1BQU07Z0JBQ05sRCxVQUFVSixLQUFLSSxRQUFRLENBQUNnQyxPQUFPLENBQUMyQixDQUFBQSxJQUFLNk4sZ0JBQWdCN04sR0FBRzROO2dCQUN4RFQsVUFBVWxSLEtBQUs4USxVQUFVLENBQUNJLFFBQVE7WUFDcEM7UUFDRjtRQUNBLElBQUlsUixLQUFLZ1IsR0FBRyxFQUFFO1lBQ1osTUFBTThCLGlCQUFpQm5CLGVBQWUsQ0FBQzNSLEtBQUtnUixHQUFHLENBQUM7WUFDaEQsSUFBSThCLGdCQUFnQjtnQkFDbEIsTUFBTUMsbUJBQW1CN0MscUJBQXFCO29CQUM1QzNSLE1BQU07b0JBQ04yRyxRQUFRNE4sZUFBZXBXLE1BQU07Z0JBQy9CO2dCQUNBLElBQUlxVyxrQkFBa0I7b0JBQ3BCLE1BQU1DLGdCQUFnQnhILEtBQUtrQixLQUFLLENBQUNsQixLQUFLQyxTQUFTLENBQUN6TCxLQUFLOFEsVUFBVTtvQkFDL0QsTUFBTTFRLFdBQVcsRUFBRTtvQkFDbkI2UyxxQkFBcUJqVCxLQUFLSSxRQUFRLEVBQUVBLFVBQVU0UyxlQUFlRCxrQkFBa0IsRUFBRSxFQUFFcEI7b0JBQ25GLE9BQU87d0JBQ0xyTyxNQUFNO3dCQUNOc1AsV0FBVzVTLEtBQUtnUixHQUFHO3dCQUNuQjZCLE9BQU9HO3dCQUNQNVM7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0EsT0FBTztvQkFDTGtELE1BQU07b0JBQ05zUCxXQUFXNVMsS0FBS2dSLEdBQUc7b0JBQ25CNkIsT0FBTzdTLEtBQUs4USxVQUFVO29CQUN0QjFRLFVBQVVKLEtBQUtJLFFBQVEsQ0FBQ2IsTUFBTSxLQUFLLElBQUk7d0JBQUM7NEJBQ3RDK0QsTUFBTTs0QkFDTmxELFVBQVU7Z0NBQUM7b0NBQ1Q0UCxNQUFNO2dDQUNSOzZCQUFFO3dCQUNKO3FCQUFFLEdBQUdoUSxLQUFLSSxRQUFRLENBQUNnQyxPQUFPLENBQUMyQixDQUFBQSxJQUFLNk4sZ0JBQWdCN04sR0FBRzROO2dCQUNyRDtZQUNGO1FBQ0Y7UUFDQSxNQUFNLElBQUl4VixNQUFNLENBQUMsYUFBYSxFQUFFNkQsS0FBS2dSLEdBQUcsQ0FBQyxDQUFDO0lBQzVDO0lBQ0EsT0FBT0osc0JBQXNCNVE7QUFDL0I7QUFDQSxTQUFTaVQscUJBQXFCdkIsV0FBVyxFQUFFd0IsaUJBQWlCLEVBQUVqUCxLQUFLLEVBQUU4TyxnQkFBZ0IsRUFBRUksY0FBYyxFQUFFeEIsZUFBZTtJQUNwSCxJQUFJb0IsaUJBQWlCeFUsSUFBSSxLQUFLLFNBQVM7UUFDckMsTUFBTTZCLFdBQVdzUixZQUFZdFAsT0FBTyxDQUFDMkIsQ0FBQUEsSUFBSzZOLGdCQUFnQjdOLEdBQUc0TjtRQUM3RHVCLGtCQUFrQjNOLElBQUksQ0FBQztZQUNyQmpDLE1BQU0sQ0FBQyxVQUFVLEVBQUV5UCxpQkFBaUIxSyxPQUFPLENBQUM5SixJQUFJLENBQUMsS0FBSyxDQUFDO1lBQ3ZEMlMsVUFBVTttQkFBSWlDO21CQUFtQkosaUJBQWlCMUMsWUFBWTthQUFDO1lBQy9EalE7UUFDRjtJQUNGO0lBQ0EsSUFBSTJTLGlCQUFpQnhVLElBQUksS0FBSyxTQUFTO1FBQ3JDLE1BQU1zRSxNQUFNLEVBQUU7UUFDZCxLQUFLLElBQUksQ0FBQytMLEtBQUs0QixNQUFNLElBQUlrQixZQUFZbFEsT0FBTyxHQUFJO1lBQzlDLElBQUlnUCxNQUFNbE4sSUFBSSxLQUFLLGFBQWE7Z0JBQzlCa04sUUFBUUEsTUFBTXBRLFFBQVEsQ0FBQyxFQUFFLENBQUNBLFFBQVEsQ0FBQyxFQUFFO1lBQ3ZDO1lBQ0EsSUFBSW9RLE1BQU1sTixJQUFJLEtBQUssT0FBTztnQkFDeEIsTUFBTSxJQUFJbkgsTUFBTSxDQUFDLGFBQWEsRUFBRTRXLGlCQUFpQnhDLFVBQVUsQ0FBQyxjQUFjLEVBQUVDLE1BQU1sTixJQUFJLENBQUMsQ0FBQztZQUMxRjtZQUNBLElBQUlrTixNQUFNUSxHQUFHLEtBQUsrQixpQkFBaUJ4QyxVQUFVLEVBQUU7Z0JBQzdDLE1BQU0sSUFBSXBVLE1BQU0sQ0FBQyxhQUFhLEVBQUU0VyxpQkFBaUJ4QyxVQUFVLENBQUMsYUFBYSxFQUFFQyxNQUFNUSxHQUFHLENBQUMsQ0FBQztZQUN4RjtZQUNBLE1BQU1GLGFBQWF0RixLQUFLa0IsS0FBSyxDQUFDbEIsS0FBS0MsU0FBUyxDQUFDK0UsTUFBTU0sVUFBVTtZQUM3RCxJQUFJaUMsaUJBQWlCdkMsS0FBSyxFQUFFO2dCQUMxQnlDLHFCQUFxQnpDLE1BQU1wUSxRQUFRLEVBQUU4UyxtQkFBbUJwQyxZQUFZaUMsaUJBQWlCdkMsS0FBSyxFQUFFO3VCQUFJMkM7dUJBQW1CSixpQkFBaUIxQyxZQUFZO29CQUFFekI7aUJBQUksRUFBRStDO1lBQzFKO1lBQ0E5TyxJQUFJMEMsSUFBSSxDQUFDdUw7UUFDWDtRQUNBLE1BQU1yUyxNQUFNc1UsaUJBQWlCMUMsWUFBWSxDQUFDMEMsaUJBQWlCMUMsWUFBWSxDQUFDOVEsTUFBTSxHQUFHLEVBQUU7UUFDbkYsTUFBTTZULFNBQVM5RSxtQkFBbUJySyxPQUFPOE8saUJBQWlCMUMsWUFBWSxDQUFDbFEsS0FBSyxDQUFDLEdBQUcsQ0FBQztRQUNqRmlULE1BQU0sQ0FBQzNVLElBQUksR0FBR29FO0lBQ2hCO0FBQ0Y7QUFFQSxTQUFTd1EsZUFBZXRSLENBQUMsRUFBRUMsQ0FBQztJQUMxQixPQUFPRCxFQUFFeEMsTUFBTSxLQUFLeUMsRUFBRXpDLE1BQU0sSUFBSXdDLEVBQUVvUCxLQUFLLENBQUMsQ0FBQ3BOLEdBQUdiLElBQU1hLE1BQU0vQixDQUFDLENBQUNrQixFQUFFO0FBQzlEO0FBQ0EsU0FBU29RLDZDQUE2QyxDQUFDdFQsTUFBTXZFLEtBQUssRUFBRThYLE1BQU0sRUFBRUMsV0FBVyxFQUFFQyxVQUFVO0lBQ2pHLE1BQU1DLGdCQUFnQnpPLE9BQU93SSxJQUFJLENBQUN6TixNQUFNMlQsTUFBTSxDQUFDNVAsQ0FBQUEsSUFBS0EsTUFBTSxVQUFVQSxNQUFNLGdCQUFnQnlQLFdBQVcsQ0FBQ3pQLEVBQUUsS0FBSztJQUM3RyxJQUFJMlAsY0FBY25VLE1BQU0sRUFBRTtRQUN4QmxGLDZDQUFVQSxDQUFDdVosVUFBVSxDQUFDTCxRQUFRRyxlQUFlO1lBQzNDRyxJQUFJcFk7UUFDTjtRQUNBLE9BQU87SUFDVDtJQUNBLElBQUksQ0FBQ2dZLFlBQVk7UUFDZixNQUFNSyxnQkFBZ0I5VCxLQUFLZ1EsSUFBSSxDQUFDcFMsUUFBUSxDQUFDO1FBQ3pDLElBQUlrVyxlQUFlO1lBQ2pCLE1BQU0sQ0FBQ0MsV0FBVyxHQUFHeloseUNBQU1BLENBQUM4WSxNQUFNLENBQUNHLFFBQVE5WDtZQUMzQyxJQUFJc1ksV0FBV3pRLElBQUksS0FBSyxRQUFRO2dCQUM5QixLQUFLLE1BQU0wUSxZQUFZMVoseUNBQU1BLENBQUMyWixTQUFTLENBQUNWLFFBQVE7b0JBQzlDTSxJQUFJcFk7Z0JBQ04sR0FBSTtvQkFDRixNQUFNeVksWUFBWTNaLHVDQUFJQSxDQUFDMEYsR0FBRyxDQUFDc1QsUUFBUVMsU0FBU3ZZLElBQUksRUFBRXVVLElBQUksQ0FBQ2dFLFNBQVNqUixNQUFNLENBQUM7b0JBQ3ZFLElBQUltUixjQUFjLE1BQU07d0JBQ3RCN1osNkNBQVVBLENBQUM2SixNQUFNLENBQUNxUCxRQUFROzRCQUN4Qk0sSUFBSUc7d0JBQ047d0JBQ0EsT0FBTztvQkFDVDtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUNBLFNBQVNHLDRCQUE0QixDQUFDblUsTUFBTXZFLEtBQUssRUFBRThYLE1BQU0sRUFBRWEsS0FBSztJQUM5RCxJQUFJcFUsS0FBS3NELElBQUksS0FBSyxVQUFVLENBQUM4USxPQUFPO1FBQ2xDL1osNkNBQVVBLENBQUNnYSxVQUFVLENBQUNkLFFBQVEsQ0FBQyxFQUFFLEVBQUV2VCxLQUFLK0wsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQy9DOEgsSUFBSXZaLHlDQUFNQSxDQUFDZ2EsR0FBRyxDQUFDZixRQUFROVg7UUFDekI7UUFDQXBCLDZDQUFVQSxDQUFDa2EsV0FBVyxDQUFDaEIsUUFBUTtZQUM3Qk0sSUFBSXBZO1FBQ047UUFDQSxPQUFPO0lBQ1Q7SUFDQSxPQUFPO0FBQ1Q7QUFDQSxTQUFTK1ksd0NBQXdDLENBQUN4VSxNQUFNdkUsS0FBSyxFQUFFOFgsTUFBTSxFQUFFLEVBQ3JFa0IsVUFBVSxFQUNWQyxRQUFRLEVBQ1JDLE9BQU8sRUFDUFAsS0FBSyxFQUNMUSxNQUFNLEVBQ05DLE1BQU0sRUFDUDtJQUNDLElBQUk3VSxLQUFLc0QsSUFBSSxLQUFLLGFBQWMsRUFBQ21SLFdBQVdLLFFBQVEsQ0FBQ0MsTUFBTSxDQUFDeFYsTUFBTSxJQUFJLENBQUNrVixXQUFXSyxRQUFRLENBQUNDLE1BQU0sQ0FBQ25YLFFBQVEsQ0FBQ29DLEtBQUsrUixLQUFLLE1BQU0vUixLQUFLc0QsSUFBSSxLQUFLLGtCQUFrQixDQUFDbVIsV0FBV08sU0FBUyxDQUFDaEQsT0FBTyxJQUFJaFMsS0FBS3NELElBQUksS0FBSyxvQkFBb0IsQ0FBQ21SLFdBQVdPLFNBQVMsQ0FBQ0MsU0FBUyxJQUFJalYsS0FBS3NELElBQUksS0FBSyxVQUFVLENBQUNtUixXQUFXUyxVQUFVLENBQUNuRSxJQUFJLElBQUkvUSxLQUFLc0QsSUFBSSxLQUFLLGdCQUFnQixDQUFDbVIsV0FBV1MsVUFBVSxDQUFDQyxVQUFVLElBQUluVixLQUFLc0QsSUFBSSxLQUFLLFdBQVcsQ0FBQ3NSLFVBQVU1VSxLQUFLc0QsSUFBSSxLQUFLLFdBQVcsQ0FBQ3VSLFVBQVU3VSxLQUFLc0QsSUFBSSxLQUFLLFlBQWFxUixDQUFBQSxRQUFRcFYsTUFBTSxLQUFLLEtBQUssQ0FBQ29WLFFBQVFoRSxJQUFJLENBQUNnQyxDQUFBQSxTQUFVVSxlQUFlVixRQUFRM1MsS0FBSzJTLE1BQU0sRUFBQyxHQUFJO1FBQ25qQnRZLDZDQUFVQSxDQUFDa2EsV0FBVyxDQUFDaEIsUUFBUTtZQUM3Qk0sSUFBSXBZO1FBQ047UUFDQSxPQUFPO0lBQ1Q7SUFDQSxJQUFJLENBQUN1RSxLQUFLc0QsSUFBSSxLQUFLLGVBQWV0RCxLQUFLc0QsSUFBSSxLQUFLLFNBQVEsS0FBTyxFQUFDbVIsV0FBV1csU0FBUyxDQUFDQyxNQUFNLElBQUlyVixLQUFLeVMsU0FBUyxLQUFLLFlBQVksQ0FBQ2dDLFdBQVdXLFNBQVMsQ0FBQ2QsR0FBRyxJQUFJdFUsS0FBS3lTLFNBQVMsS0FBSyxTQUFTLGVBQWV6UyxRQUFRQSxLQUFLeVMsU0FBUyxLQUFLLFlBQVl6UyxLQUFLeVMsU0FBUyxLQUFLLEtBQUksR0FBSTtRQUN0UXBZLDZDQUFVQSxDQUFDdVosVUFBVSxDQUFDTCxRQUFRLGFBQWE7WUFDekNNLElBQUlwWTtRQUNOO1FBQ0EsT0FBTztJQUNUO0lBQ0EsSUFBSXVFLEtBQUtzRCxJQUFJLEtBQUssYUFBYSxDQUFDb1IsVUFBVTtRQUN4Q3JhLDZDQUFVQSxDQUFDaWIsV0FBVyxDQUFDL0IsUUFBUTtZQUM3Qk0sSUFBSXBZO1FBQ047UUFDQSxPQUFPO0lBQ1Q7SUFDQSxPQUFPMFksNEJBQTRCO1FBQUNuVTtRQUFNdkU7S0FBSyxFQUFFOFgsUUFBUWE7QUFDM0Q7QUFDQSxTQUFTbUIsa0NBQWtDQyxnQkFBZ0IsRUFBRWpDLE1BQU07SUFDakUsTUFBTSxFQUNKa0MsYUFBYSxFQUNkLEdBQUdsQztJQUNKQSxPQUFPa0MsYUFBYSxHQUFHLENBQUMsQ0FBQ3pWLE1BQU12RSxLQUFLO1FBQ2xDLElBQUl2Qix1Q0FBSUEsQ0FBQ3diLE1BQU0sQ0FBQzFWLE9BQU87WUFDckJzVCw2Q0FBNkM7Z0JBQUN0VDtnQkFBTXZFO2FBQUssRUFBRThYLFFBQVFpQyxpQkFBaUJmLFVBQVUsQ0FBQ2pCLFdBQVcsRUFBRWdDLGlCQUFpQmYsVUFBVSxDQUFDaEIsVUFBVTtRQUNwSixPQUFPLElBQUlyWiwwQ0FBU0EsQ0FBQ3ViLFNBQVMsQ0FBQzNWLE9BQU87WUFDcEN3VSx3Q0FBd0M7Z0JBQUN4VTtnQkFBTXZFO2FBQUssRUFBRThYLFFBQVFpQztRQUNoRTtRQUNBQyxjQUFjO1lBQUN6VjtZQUFNdkU7U0FBSztJQUM1QjtJQUNBLE9BQU84WDtBQUNUO0FBRUEsU0FBU3FDLGFBQWFDLFVBQVUsRUFBRTNZLElBQUk7SUFDcEMsT0FBTyxPQUFPMlksZUFBZSxXQUFXLENBQUMsRUFBRUEsV0FBV25hLE9BQU8sQ0FBQyxRQUFRLElBQUksQ0FBQyxFQUFFd0IsU0FBU21CLFlBQVksS0FBS25CLE9BQU8sSUFBSSxDQUFDLEdBQUc7QUFDeEg7QUFFQSxTQUFTNFksaUJBQWlCekUsS0FBSyxFQUFFTSxlQUFlLEVBQUV0TCxLQUFLLEVBQUUwUCxVQUFVLEVBQUVsVSxJQUFJLEVBQUUyVCxnQkFBZ0IsRUFBRXRZLElBQUk7SUFDL0YsT0FBT21VLE1BQU01UCxHQUFHLENBQUN6QixDQUFBQTtRQUNmLElBQUlBLEtBQUtzRCxJQUFJLEtBQUssbUJBQW1CO1lBQ25DLE1BQU13UCxpQkFBaUJuQixlQUFlLENBQUMzUixLQUFLNFMsU0FBUyxDQUFDO1lBQ3RELElBQUksQ0FBQ0UsZ0JBQWdCLE9BQU85UztZQUM1QixNQUFNdEQsU0FBU3VMLE9BQU82SyxlQUFlcFcsTUFBTTtZQUMzQyxPQUFPO2dCQUNMLEdBQUdzRCxJQUFJO2dCQUNQNlMsT0FBT21ELGlCQUFpQnRaLFFBQVFzRCxLQUFLNlMsS0FBSyxFQUFFeE0sT0FBTzBQLFlBQVlsVSxNQUFNM0U7WUFDdkU7UUFDRjtRQUNBLElBQUk4QyxLQUFLc0QsSUFBSSxLQUFLLFdBQVcsT0FBT3RELEtBQUtxUyxHQUFHLEtBQUssWUFBWXhRLFNBQVMsUUFBUTtZQUM1RSxJQUFJb1U7WUFDSixNQUFNMUwsU0FBUzJMLDBCQUEwQlYsa0JBQWtCdFk7WUFDM0QsTUFBTWlaLFdBQVduVyxLQUFLcVMsR0FBRyxDQUFDbFMsS0FBSyxDQUFDb0ssT0FBT2hMLE1BQU07WUFDN0MsTUFBTVQsVUFBVSxDQUFDbVgsT0FBTyxPQUFPVCxpQkFBaUJaLE1BQU0sS0FBSyxZQUFZLE9BQU9ZLGlCQUFpQlosTUFBTSxDQUFDNVAsU0FBUyxLQUFLLFdBQVcrUSxXQUFXOVYsR0FBRyxDQUFDekUsUUFBUWdhLGlCQUFpQlosTUFBTSxDQUFDNVAsU0FBUyxLQUFLcUIsS0FBSSxNQUFPLFFBQVE0UCxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUtoVyxHQUFHLENBQUNrVztZQUNuUCxJQUFJLENBQUNyWCxTQUFTO2dCQUNaLE9BQU87b0JBQ0x3RSxNQUFNO29CQUNObEQsVUFBVTt3QkFBQzs0QkFDVDRQLE1BQU0sQ0FBQyxjQUFjLEVBQUVtRyxTQUFTLENBQUM7d0JBQ25DO3FCQUFFO2dCQUNKO1lBQ0Y7WUFDQSxPQUFPO2dCQUNMN1MsTUFBTTtnQkFDTitPLEtBQUs7b0JBQ0g4RDtvQkFDQXJYO2dCQUNGO2dCQUNBeVQsS0FBS3ZTLEtBQUt1UyxHQUFHO2dCQUNiQyxPQUFPeFMsS0FBS3dTLEtBQUs7Z0JBQ2pCcFMsVUFBVTtvQkFBQzt3QkFDVDRQLE1BQU07b0JBQ1I7aUJBQUU7WUFDSjtRQUNGO1FBQ0EsSUFBSSxPQUFPaFEsS0FBS3NELElBQUksS0FBSyxVQUFVO1lBQ2pDLE1BQU1sRCxXQUFXMFYsaUJBQWlCOVYsS0FBS0ksUUFBUSxFQUFFdVIsaUJBQWlCdEwsT0FBTzBQLFlBQVlsVSxNQUFNMlQsa0JBQWtCdFk7WUFDN0csT0FBTztnQkFDTCxHQUFHOEMsSUFBSTtnQkFDUEk7WUFDRjtRQUNGO1FBQ0EsT0FBT0o7SUFDVDtBQUNGO0FBQ0EsU0FBU2dXLGlCQUFpQnRaLE1BQU0sRUFBRXVILEtBQUssRUFBRW9DLEtBQUssRUFBRTBQLFVBQVUsRUFBRWxVLElBQUksRUFBRTNFLElBQUk7SUFDcEUsT0FBTzJSLGVBQWVuUyxRQUFRdUgsT0FBTztRQUNuQ21TLE1BQU0sQ0FBQzFaLFFBQVF1SDtZQUNiLElBQUl2SCxPQUFPOEIsUUFBUSxLQUFLLFNBQVM7Z0JBQy9CLElBQUk2WDtnQkFDSixJQUFJeFUsU0FBUyxRQUFRO29CQUNuQixPQUFPbkYsT0FBT21RLE1BQU0sQ0FBQ0gsS0FBSyxDQUFDekk7Z0JBQzdCO2dCQUNBLE1BQU1rUyxXQUFXelosT0FBT3laLFFBQVEsQ0FBQ2xTLE9BQU87b0JBQ3RDL0c7b0JBQ0FvWix5QkFBeUJqWTtnQkFDM0I7Z0JBQ0EsT0FBTzNCLE9BQU9nUSxLQUFLLENBQUN6SSxPQUFPO29CQUN6QnNTLE9BQU9KLFdBQVd6WixPQUFPc0ksU0FBUyxHQUFHLENBQUNxUixrQkFBa0JOLFdBQVc5VixHQUFHLENBQUN2RCxPQUFPc0ksU0FBUyxPQUFPLFFBQVFxUixvQkFBb0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsZ0JBQWdCcFcsR0FBRyxDQUFDa1csWUFBWTlQLE1BQU1wRyxHQUFHLENBQUNrVyxZQUFZOVg7b0JBQ2xNbkI7Z0JBQ0Y7WUFDRjtZQUNBLElBQUlSLE9BQU84QixRQUFRLEtBQUssV0FBVztnQkFDakMsTUFBTSxJQUFJckMsTUFBTTtZQUNsQjtZQUNBLElBQUkwRixTQUFTLFFBQVE7Z0JBQ25CLE9BQU9uRixPQUFPbVEsTUFBTSxDQUFDSCxLQUFLLENBQUN6STtZQUM3QjtZQUNBLE9BQU92SCxPQUFPZ1EsS0FBSyxDQUFDekksT0FBTzVGO1FBQzdCO0lBQ0Y7QUFDRjtBQUNBLFNBQVM2WCwwQkFBMEJWLGdCQUFnQixFQUFFdFksSUFBSTtJQUN2RCxPQUFPMFksYUFBYSxPQUFPSixpQkFBaUJaLE1BQU0sS0FBSyxXQUFXWSxpQkFBaUJaLE1BQU0sQ0FBQ2lCLFVBQVUsR0FBR3hYLFdBQVduQjtBQUNwSDtBQUVBLFNBQVNzWixlQUFlQyxTQUFTLEVBQUVDLFVBQVUsRUFDN0Msd0hBQXdIO0FBQ3hIN00sU0FBUyxFQUFFM00sSUFBSSxFQUFFeVosMkJBQTJCO0lBQzFDLE1BQU1DLGFBQWEsRUFBRTtJQUNyQixPQUFPO1FBQ0wzUyxPQUFPNEssZUFBZTZILFlBQVlELFdBQVc7WUFDM0NMLE1BQUsxWixNQUFNLEVBQUV1SCxLQUFLLEVBQUVpTixRQUFRO2dCQUMxQixJQUFJQSxTQUFTM1IsTUFBTSxLQUFLLEtBQUtzSyxjQUFjcUgsUUFBUSxDQUFDLEVBQUUsRUFBRTtvQkFDdEQsSUFBSXhVLE9BQU84QixRQUFRLEtBQUssUUFBUTt3QkFDOUIsTUFBTSxJQUFJckMsTUFBTTtvQkFDbEI7b0JBQ0EsT0FBT08sT0FBT29OLGlCQUFpQixDQUFDN0YsT0FBT0EsS0FBSztnQkFDOUM7Z0JBQ0EsSUFBSXZILE9BQU84QixRQUFRLEtBQUssU0FBUztvQkFDL0IsTUFBTSxFQUNKK1gsS0FBSyxFQUNMdFMsT0FBTzRTLE9BQU8sRUFDZixHQUFHbmEsT0FBT2lRLFNBQVMsQ0FBQzFJLE9BQU87d0JBQzFCcVMseUJBQXlCSyw4QkFBOEJHLG1CQUFtQjVGLFVBQVV3RixZQUFZRCxhQUFhcFk7d0JBQzdHbkI7b0JBQ0Y7b0JBQ0EsSUFBSXFaLE9BQU87d0JBQ1RLLFdBQVdyUixJQUFJLENBQUM7NEJBQ2Q5SixNQUFNOGEsTUFBTUosUUFBUTs0QkFDcEIvVyxVQUFVbVgsTUFBTXpYLE9BQU87NEJBQ3ZCc1UsUUFBUTFXLE9BQU9zSSxTQUFTO3dCQUMxQjtvQkFDRjtvQkFDQSxPQUFPNlI7Z0JBQ1Q7Z0JBQ0EsSUFBSW5hLE9BQU84QixRQUFRLEtBQUssV0FBVztvQkFDakMsTUFBTSxFQUNKdVksS0FBSyxFQUNMQyxRQUFRLEVBQ1JsWSxPQUFPLEVBQ1BtRixPQUFPNFMsT0FBTyxFQUNmLEdBQUduYSxPQUFPaVEsU0FBUyxDQUFDMUksT0FBTzt3QkFDMUIvRztvQkFDRjtvQkFDQSxJQUFJNEIsU0FBUzt3QkFDWDhYLFdBQVdyUixJQUFJLENBQUM7NEJBQ2Q5SixNQUFNcWIsbUJBQW1CNUYsVUFBVXdGLFlBQVlELGFBQWEvWixPQUFPdUIsZ0JBQWdCOzRCQUNuRm1CLFVBQVVOOzRCQUNWc1UsUUFBUS9VO3dCQUNWO29CQUNGO29CQUNBLEtBQUssTUFBTSxDQUFDSSxLQUFLVyxTQUFTLElBQUkyWCxNQUFPO3dCQUNuQ0gsV0FBV3JSLElBQUksQ0FBQzs0QkFDZDlKLE1BQU1xYixtQkFBbUI1RixVQUFVd0YsWUFBWUQsYUFBYSxNQUFNaFk7NEJBQ2xFVzs0QkFDQWdVLFFBQVEvVTt3QkFDVjtvQkFDRjtvQkFDQSxNQUFNNFkscUJBQXFCLElBQUk1UixJQUFJM0ksT0FBT2tJLFdBQVc7b0JBQ3JELEtBQUssTUFBTSxDQUFDSSxXQUFXNUYsU0FBUyxJQUFJNFgsU0FBVTt3QkFDNUMsSUFBSSxDQUFDQyxtQkFBbUIxVyxHQUFHLENBQUN5RSxZQUFZOzRCQUN0QyxNQUFNLElBQUk3SSxNQUFNLENBQUMsa0JBQWtCLEVBQUU2SSxVQUFVLCtCQUErQixDQUFDO3dCQUNqRjt3QkFDQSxLQUFLLE1BQU0sQ0FBQ21SLFVBQVVlLGFBQWEsSUFBSTlYLFNBQVU7NEJBQy9Dd1gsV0FBV3JSLElBQUksQ0FBQztnQ0FDZDlKLE1BQU0wYTtnQ0FDTi9XLFVBQVU4WDtnQ0FDVjlELFFBQVFwTzs0QkFDVjt3QkFDRjtvQkFDRjtvQkFDQSxPQUFPNlI7Z0JBQ1Q7Z0JBQ0EsT0FBT25hLE9BQU9pUSxTQUFTLENBQUMxSSxPQUFPQSxLQUFLO1lBQ3RDO1lBQ0FnRSxRQUFPa1AsT0FBTyxFQUFFbFQsS0FBSztnQkFDbkIsT0FBT2dCLE9BQU84SixXQUFXLENBQUM5SixPQUFPekQsT0FBTyxDQUFDeUMsT0FBTzBQLE1BQU0sQ0FBQyxDQUFDLENBQUN5RCxHQUFHM1UsSUFBSSxHQUFLQSxRQUFRcEU7WUFDL0U7WUFDQW1CLE9BQU0yWCxPQUFPLEVBQUVsVCxLQUFLO2dCQUNsQixPQUFPQSxNQUFNeEMsR0FBRyxDQUFDZ0IsQ0FBQUEsTUFBT0EsUUFBUXBFLFlBQVksT0FBT29FO1lBQ3JEO1lBQ0ErTjtnQkFDRSxPQUFPblM7WUFDVDtRQUNGO1FBQ0F1WTtJQUNGO0FBQ0Y7QUFDQSxTQUFTRSxtQkFBbUJyYixJQUFJLEVBQUVpQixNQUFNLEVBQUV1SCxLQUFLO0lBQzdDLE1BQU1xUSxNQUFNLEVBQUU7SUFDZCxLQUFLLE1BQU0rQyxXQUFXNWIsS0FBTTtRQUMxQixJQUFJaUIsT0FBTzZCLElBQUksS0FBSyxTQUFTO1lBQzNCMEYsUUFBUUEsS0FBSyxDQUFDb1QsUUFBUTtZQUN0QixJQUFJM2EsT0FBT21OLFNBQVMsSUFBSW5OLE9BQU9xSSxPQUFPLENBQUN4RyxJQUFJLEtBQUssVUFBVTtnQkFDeEQsTUFBTXJCLE9BQU95TSxpQkFBaUI7b0JBQzVCak4sUUFBUUEsT0FBT3FJLE9BQU8sQ0FBQ0csTUFBTTtvQkFDN0IyRSxXQUFXbk4sT0FBT21OLFNBQVM7Z0JBQzdCLEdBQUc1RjtnQkFDSHFRLElBQUkvTyxJQUFJLENBQUNySTtZQUNYLE9BQU87Z0JBQ0xvWCxJQUFJL08sSUFBSSxDQUFDOFI7WUFDWDtZQUNBM2EsU0FBU0EsT0FBT3FJLE9BQU87WUFDdkI7UUFDRjtRQUNBdVAsSUFBSS9PLElBQUksQ0FBQzhSO1FBQ1QsSUFBSTNhLE9BQU82QixJQUFJLEtBQUssVUFBVTtZQUM1QjBGLFFBQVFBLEtBQUssQ0FBQ29ULFFBQVE7WUFDdEIzYSxTQUFTQSxPQUFPd0ksTUFBTSxDQUFDbVMsUUFBUTtZQUMvQjtRQUNGO1FBQ0EsSUFBSTNhLE9BQU82QixJQUFJLEtBQUssZUFBZTtZQUNqQyxJQUFJOFksWUFBWSxnQkFBZ0I7Z0JBQzlCM2EsU0FBU0EsT0FBTzhRLFlBQVk7WUFDOUIsT0FBTyxJQUFJNkosWUFBWSxTQUFTO2dCQUM5QjNhLFNBQVNBLE9BQU9vSCxNQUFNLENBQUNHLE1BQU11SixZQUFZLENBQUM7WUFDNUM7WUFDQXZKLFFBQVFBLEtBQUssQ0FBQ29ULFFBQVE7WUFDdEI7UUFDRjtRQUNBLE1BQU0sSUFBSWxiLE1BQU0sQ0FBQyxXQUFXLEVBQUVPLE9BQU82QixJQUFJLENBQUMsQ0FBQztJQUM3QztJQUNBLE9BQU8rVixJQUFJL1AsSUFBSSxDQUFDO0FBQ2xCO0FBRUEsU0FBUytTLFNBQVNqRyxLQUFLO0lBQ3JCLE9BQU8sSUFBSXBYLGlEQUFHQSxDQUFDTSxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUc4VyxNQUFNalAsT0FBTyxDQUFDbVY7QUFDbEQ7QUFDQSxNQUFNQyxnQkFBZ0I7SUFDcEJDLE1BQU07UUFDSm5VLE1BQU07SUFDUjtJQUNBeU4sTUFBTTtRQUNKek4sTUFBTTtJQUNSO0lBQ0FvVSxRQUFRO1FBQ05wVSxNQUFNO0lBQ1I7SUFDQXFVLFdBQVc7UUFDVHJVLE1BQU07UUFDTjBOLEtBQUs7SUFDUDtJQUNBNEcsVUFBVTtRQUNSdFUsTUFBTTtRQUNOME4sS0FBSztJQUNQO0lBQ0E2RyxlQUFlO1FBQ2J2VSxNQUFNO0lBQ1I7SUFDQXdVLFdBQVc7UUFDVHhVLE1BQU07UUFDTjBOLEtBQUs7SUFDUDtJQUNBK0csYUFBYTtRQUNYelUsTUFBTTtRQUNOME4sS0FBSztJQUNQO0FBQ0Y7QUFDQSxTQUFTdUcsZ0JBQWdCdlgsSUFBSTtJQUMzQixJQUFJQSxLQUFLc0QsSUFBSSxLQUFLLFFBQVE7UUFDeEIsT0FBTyxJQUFJckosaURBQUdBLENBQUNNLElBQUksQ0FBQyxRQUFRO1lBQzFCd1IsTUFBTS9MLEtBQUsrTCxJQUFJO1FBQ2pCLEdBQUcvTCxLQUFLSSxRQUFRLENBQUNnQyxPQUFPLENBQUNtVjtJQUMzQjtJQUNBLElBQUl2WCxLQUFLc0QsSUFBSSxLQUFLakYsV0FBVztRQUMzQixNQUFNLElBQUlsQyxNQUFNLENBQUMsNkJBQTZCLEVBQUU2RCxLQUFLc0QsSUFBSSxDQUFDLENBQUM7SUFDN0Q7SUFDQSxJQUFJdEQsS0FBSytRLElBQUksRUFBRTtRQUNiLE9BQU8sSUFBSTlXLGlEQUFHQSxDQUFDTSxJQUFJLENBQUMsUUFBUTtZQUMxQnVFLFNBQVNrQixLQUFLZ1EsSUFBSTtRQUNwQixHQUFHLEVBQUU7SUFDUDtJQUNBLE1BQU1nSSxRQUFRL1MsT0FBT3dJLElBQUksQ0FBQ3pOLE1BQU0yVCxNQUFNLENBQUNoRSxDQUFBQSxPQUFRQSxTQUFTLFFBQVE3TixJQUFJO0lBQ3BFLElBQUltVyxjQUFjLElBQUloZSxpREFBR0EsQ0FBQ00sSUFBSSxDQUFDLFFBQVE7UUFDckN1RSxTQUFTa0IsS0FBS2dRLElBQUk7SUFDcEI7SUFDQSxLQUFLLE1BQU1MLFFBQVFxSSxNQUFPO1FBQ3hCLE1BQU1uYyxTQUFTMmIsYUFBYSxDQUFDN0gsS0FBSztRQUNsQyxJQUFJOVQsUUFBUTtZQUNWb2MsY0FBYyxJQUFJaGUsaURBQUdBLENBQUNNLElBQUksQ0FBQ3NCLE9BQU95SCxJQUFJLEVBQUUsQ0FBQyxHQUFHO2dCQUFDMlU7YUFBWSxFQUFFcGMsT0FBT21WLEdBQUc7UUFDdkU7SUFDRjtJQUNBLE9BQU9pSDtBQUNUO0FBQ0EsU0FBU0Msa0JBQWtCN0csS0FBSyxFQUFFOEcsT0FBTztJQUN2QyxNQUFNdkIsYUFBYSxFQUFFO0lBQ3JCLE1BQU0vYSxTQUFTO1FBQ2IsR0FBR3NjLE9BQU87UUFDVnZCO0lBQ0Y7SUFDQSxNQUFNNVcsT0FBTyxJQUFJL0YsaURBQUdBLENBQUNNLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRzhXLE1BQU1qUCxPQUFPLENBQUMyQixDQUFBQSxJQUFLcVUsVUFBVXJVLEdBQUdsSTtJQUMxRSxPQUFPO1FBQ0xtRTtRQUNBNFc7SUFDRjtBQUNGO0FBQ0EsU0FBU3lCLG1CQUFtQkMsaUJBQWlCLEVBQUVwRixpQkFBaUIsRUFBRWpQLEtBQUssRUFBRThPLGdCQUFnQjtJQUN2RixJQUFJQSxpQkFBaUJ4VSxJQUFJLEtBQUssU0FBUztRQUNyQyxNQUFNaVMsUUFBUThILGtCQUFrQkMsSUFBSSxDQUFDeFUsQ0FBQUEsSUFBS3NQLGVBQWV0UCxFQUFFbU4sUUFBUSxFQUFFNkIsaUJBQWlCMUMsWUFBWTtRQUNsRyxJQUFJRyxPQUFPO1lBQ1QwQyxrQkFBa0IzTixJQUFJLElBQUlpTCxNQUFNcFEsUUFBUTtRQUMxQztRQUNBO0lBQ0Y7SUFDQSxJQUFJMlMsaUJBQWlCeFUsSUFBSSxLQUFLLFNBQVM7UUFDckMsTUFBTUUsTUFBTXNVLGlCQUFpQjFDLFlBQVksQ0FBQzBDLGlCQUFpQjFDLFlBQVksQ0FBQzlRLE1BQU0sR0FBRyxFQUFFO1FBQ25GLE1BQU02VCxTQUFTOUUsbUJBQW1CckssT0FBTzhPLGlCQUFpQjFDLFlBQVksQ0FBQ2xRLEtBQUssQ0FBQyxHQUFHLENBQUM7UUFDakYsTUFBTXFZLGtCQUFrQnBGLE1BQU0sQ0FBQzNVLElBQUk7UUFDbkMsT0FBTzJVLE1BQU0sQ0FBQzNVLElBQUk7UUFDbEIsTUFBTWdhLGFBQWEsSUFBSWpZO1FBQ3ZCLEtBQUssTUFBTWdRLFNBQVM4SCxrQkFBbUI7WUFDckMsTUFBTUksZ0JBQWdCbEksTUFBTVUsUUFBUSxDQUFDL1EsS0FBSyxDQUFDNFMsaUJBQWlCMUMsWUFBWSxDQUFDOVEsTUFBTSxHQUFHO1lBQ2xGLE1BQU1vWixNQUFNbkksTUFBTVUsUUFBUSxDQUFDNkIsaUJBQWlCMUMsWUFBWSxDQUFDOVEsTUFBTSxDQUFDO1lBQ2hFLElBQUlrWixXQUFXeFksR0FBRyxDQUFDMFksU0FBU3RhLFdBQVc7Z0JBQ3JDb2EsV0FBVzlZLEdBQUcsQ0FBQ2daLEtBQUssRUFBRTtZQUN4QjtZQUNBRixXQUFXeFksR0FBRyxDQUFDMFksS0FBS3BULElBQUksQ0FBQztnQkFDdkJuRixVQUFVb1EsTUFBTXBRLFFBQVE7Z0JBQ3hCOFEsVUFBVXdIO1lBQ1o7UUFDRjtRQUNBeEYsa0JBQWtCM04sSUFBSSxJQUFJaVQsZ0JBQWdCL1csR0FBRyxDQUFDLENBQUNzQyxHQUFHYjtZQUNoRCxJQUFJMFY7WUFDSixNQUFNQyx1QkFBdUIsQ0FBQ0Qsa0JBQWtCSCxXQUFXeFksR0FBRyxDQUFDaUQsRUFBQyxNQUFPLFFBQVEwVixvQkFBb0IsS0FBSyxJQUFJQSxrQkFBa0IsRUFBRTtZQUNoSSxNQUFNeFksV0FBVyxFQUFFO1lBQ25CaVksbUJBQW1CUSxzQkFBc0J6WSxVQUFVMkQsR0FBR2dQLGlCQUFpQnZDLEtBQUs7WUFDNUUsT0FBTyxJQUFJdlcsaURBQUdBLENBQUNNLElBQUksQ0FBQyxPQUFPd0osR0FBRzNELFVBQVUyUyxpQkFBaUJ4QyxVQUFVO1FBQ3JFO0lBQ0Y7QUFDRjtBQUNBLFNBQVM2SCxVQUFVcFksSUFBSSxFQUFFbkUsTUFBTTtJQUM3QixJQUFJbUUsS0FBS3NELElBQUksS0FBSyxhQUFhO1FBQzdCLE1BQU0yVSxjQUFjLElBQUloZSxpREFBR0EsQ0FBQ00sSUFBSSxDQUFDLGFBQWF5RixLQUFLeVMsU0FBUyxHQUFHO1lBQzdEQSxXQUFXelMsS0FBS3lTLFNBQVM7UUFDM0IsSUFBSSxDQUFDLEdBQUc7WUFBQzZFLFNBQVN0WCxLQUFLSSxRQUFRO1NBQUU7UUFDakMsSUFBSUosS0FBS3lTLFNBQVMsRUFBRTtZQUNsQndGLFlBQVlhLFdBQVcsQ0FBQ3ZULElBQUksQ0FBQztnQkFDM0I3RCxNQUFNO2dCQUNOdUMsT0FBT2pFLEtBQUt5UyxTQUFTO2dCQUNyQm5QLE1BQU07WUFDUjtRQUNGO1FBQ0EsT0FBTzJVO0lBQ1Q7SUFDQSxJQUFJalksS0FBS3NELElBQUksS0FBSyxTQUFTO1FBQ3pCekgsT0FBTythLFVBQVUsQ0FBQ3JSLElBQUksQ0FBQztZQUNyQm5HLFVBQVVZLEtBQUtxUyxHQUFHLENBQUN2VCxPQUFPO1lBQzFCckQsTUFBTXVFLEtBQUtxUyxHQUFHLENBQUM4RCxRQUFRO1lBQ3ZCL0MsUUFBUSxPQUFPdlgsT0FBTzJaLGdCQUFnQixDQUFDWixNQUFNLEtBQUssWUFBWSxPQUFPL1ksT0FBTzJaLGdCQUFnQixDQUFDWixNQUFNLENBQUM1UCxTQUFTLEtBQUssV0FBV3hKLFFBQVFLLE9BQU8yWixnQkFBZ0IsQ0FBQ1osTUFBTSxDQUFDNVAsU0FBUyxJQUFJM0c7UUFDbkw7UUFDQSxPQUFPLElBQUlwRSxpREFBR0EsQ0FBQ00sSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHO1lBQUMsSUFBSU4saURBQUdBLENBQUNNLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRztnQkFBQyxJQUFJTixpREFBR0EsQ0FBQ00sSUFBSSxDQUFDLFNBQVM7b0JBQ3RGOFgsS0FBSzBHLFVBQVUsQ0FBQyxFQUFFN0MsMEJBQTBCcmEsT0FBTzJaLGdCQUFnQixFQUFFM1osT0FBT3FCLElBQUksRUFBRSxFQUFFOEMsS0FBS3FTLEdBQUcsQ0FBQzhELFFBQVEsQ0FBQyxDQUFDO29CQUN2RzVELEtBQUt2UyxLQUFLdVMsR0FBRztvQkFDYkMsT0FBT3hTLEtBQUt3UyxLQUFLO2dCQUNuQjthQUFHO1NBQUU7SUFDUDtJQUNBLElBQUl4UyxLQUFLc0QsSUFBSSxLQUFLLFFBQVE7UUFDeEIsTUFBTTBWLGtCQUFrQixDQUFDO1FBQ3pCLE1BQU0sRUFDSjVZLFFBQVEsRUFDUnlSLFFBQVEsRUFDUnZPLElBQUksRUFDSixHQUFHd08sTUFDSixHQUFHOVI7UUFDSixNQUFNdEQsU0FBUyxPQUFPYixPQUFPMlosZ0JBQWdCLENBQUNmLFVBQVUsQ0FBQ1MsVUFBVSxDQUFDbkUsSUFBSSxLQUFLLFdBQVdsVixPQUFPMlosZ0JBQWdCLENBQUNmLFVBQVUsQ0FBQ1MsVUFBVSxDQUFDbkUsSUFBSSxDQUFDclUsTUFBTSxHQUFHMkI7UUFDcEosSUFBSTNCLFVBQVV1SSxPQUFPd0ksSUFBSSxDQUFDL1EsT0FBT3dJLE1BQU0sRUFBRTNGLE1BQU0sR0FBRyxHQUFHO1lBQ25ELE1BQU0wWixhQUFhekMsZUFBZTlJLG9DQUFvQ2hSLFFBQVFvVixPQUFPcFYsUUFBUTJCLFdBQVd4QyxPQUFPcUIsSUFBSSxFQUFFO1lBQ3JIK0gsT0FBT2lVLE1BQU0sQ0FBQ0YsaUJBQWlCQyxXQUFXaFYsS0FBSztZQUMvQ3BJLE9BQU8rYSxVQUFVLENBQUNyUixJQUFJLElBQUkwVCxXQUFXckMsVUFBVTtRQUNqRDtRQUNBLElBQUk5WCxVQUFVc0IsUUFBUSxDQUFDLEVBQUUsQ0FBQzRQLElBQUksR0FBRztRQUNqQyxNQUFNaUksY0FBYyxJQUFJaGUsaURBQUdBLENBQUNNLElBQUksQ0FBQyxTQUFTO1lBQ3hDdUU7WUFDQStTO1lBQ0EsR0FBR21ILGVBQWU7UUFDcEIsR0FBRztZQUFDLElBQUkvZSxpREFBR0EsQ0FBQ00sSUFBSSxDQUFDLFFBQVE7Z0JBQ3ZCdUU7WUFDRjtTQUFHO1FBQ0gsS0FBSyxNQUFNLENBQUNMLEtBQUt3RixNQUFNLElBQUlnQixPQUFPekQsT0FBTyxDQUFDd1gsaUJBQWtCO1lBQzFEZixZQUFZYSxXQUFXLENBQUN2VCxJQUFJLENBQUM7Z0JBQzNCN0QsTUFBTWpEO2dCQUNOd0Y7Z0JBQ0FYLE1BQU07WUFDUjtRQUNGO1FBQ0EsT0FBTzJVO0lBQ1Q7SUFDQSxNQUFNa0IsYUFBYW5aLENBQUFBLE9BQVFvWSxVQUFVcFksTUFBTW5FO0lBQzNDLElBQUltRSxLQUFLc0QsSUFBSSxLQUFLLGNBQWM7UUFDOUIsT0FBTyxJQUFJckosaURBQUdBLENBQUNNLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBR3lGLEtBQUtJLFFBQVEsQ0FBQ3FCLEdBQUcsQ0FBQzBYO0lBQzFEO0lBQ0EsSUFBSW5aLEtBQUtzRCxJQUFJLEtBQUssV0FBVztRQUMzQixPQUFPLElBQUlySixpREFBR0EsQ0FBQ00sSUFBSSxDQUFDO0lBQ3RCO0lBQ0EsSUFBSXlGLEtBQUtzRCxJQUFJLEtBQUssU0FBUztRQUN6QixNQUFNOFYsT0FBT3BaLEtBQUtJLFFBQVEsQ0FBQ21ZLElBQUksQ0FBQ3hVLENBQUFBLElBQUtBLEVBQUVULElBQUksS0FBSztRQUNoRCxPQUFPLElBQUlySixpREFBR0EsQ0FBQ00sSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHO1lBQUMsSUFBSU4saURBQUdBLENBQUNNLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRztnQkFBQyxJQUFJTixpREFBR0EsQ0FBQ00sSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHNmUsT0FBT0EsS0FBS2haLFFBQVEsQ0FBQ3FCLEdBQUcsQ0FBQzBYLGNBQWMsRUFBRTtnQkFBR0EsV0FBV25aLEtBQUtJLFFBQVEsQ0FBQ21ZLElBQUksQ0FBQ3hVLENBQUFBLElBQUtBLEVBQUVULElBQUksS0FBSzthQUFlO1NBQUUsRUFBRTtJQUNwTTtJQUNBLElBQUl0RCxLQUFLc0QsSUFBSSxLQUFLLGNBQWM7UUFDOUIsT0FBTyxJQUFJckosaURBQUdBLENBQUNNLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBR3lGLEtBQUtJLFFBQVEsQ0FBQ3FCLEdBQUcsQ0FBQzBYO0lBQ3JEO0lBQ0EsSUFBSW5aLEtBQUtzRCxJQUFJLEtBQUssYUFBYTtRQUM3QixPQUFPLElBQUlySixpREFBR0EsQ0FBQ00sSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHeUYsS0FBS0ksUUFBUSxDQUFDcUIsR0FBRyxDQUFDMFg7SUFDbEQ7SUFDQSxJQUFJblosS0FBS3NELElBQUksS0FBSyxjQUFjO1FBQzlCLE9BQU8sSUFBSXJKLGlEQUFHQSxDQUFDTSxJQUFJLENBQUN5RixLQUFLMFMsTUFBTSxHQUFHLE9BQU8sTUFBTSxDQUFDLEdBQUcxUyxLQUFLSSxRQUFRLENBQUNxQixHQUFHLENBQUMwWDtJQUN2RTtJQUNBLElBQUluWixLQUFLc0QsSUFBSSxLQUFLLFdBQVc7UUFDM0IsTUFBTTBWLGtCQUFrQixDQUFDO1FBQ3pCLElBQUloWixLQUFLeVMsU0FBUyxFQUFFO1lBQ2xCdUcsZ0JBQWdCdkcsU0FBUyxHQUFHelMsS0FBS3lTLFNBQVM7UUFDNUM7UUFDQSxNQUFNLEVBQ0pyUyxRQUFRLEVBQ1IyUixLQUFLLEVBQ0xVLFNBQVMsRUFDVG5QLElBQUksRUFDSixHQUFHd08sTUFDSixHQUFHOVI7UUFDSixNQUFNdEQsU0FBU2IsT0FBTzJaLGdCQUFnQixDQUFDZixVQUFVLENBQUNLLFFBQVEsQ0FBQ3BZLE1BQU07UUFDakUsSUFBSXVJLE9BQU93SSxJQUFJLENBQUMvUSxPQUFPd0ksTUFBTSxFQUFFM0YsTUFBTSxHQUFHLEdBQUc7WUFDekMwRixPQUFPaVUsTUFBTSxDQUFDRixpQkFBaUJ4QyxlQUFlOUksb0NBQW9DaFIsUUFBUW9WLE9BQU9wVixRQUFRMkIsV0FBV3hDLE9BQU9xQixJQUFJLEVBQUUsT0FBTytHLEtBQUs7UUFDL0k7UUFDQSxNQUFNZ1UsY0FBYyxJQUFJaGUsaURBQUdBLENBQUNNLElBQUksQ0FBQyxXQUFXO1lBQzFDd1gsT0FBTy9SLEtBQUsrUixLQUFLO1lBQ2pCLEdBQUdpSCxlQUFlO1FBQ3BCLEdBQUc7WUFBQzFCLFNBQVN0WCxLQUFLSSxRQUFRO1NBQUU7UUFDNUIsS0FBSyxNQUFNLENBQUMzQixLQUFLd0YsTUFBTSxJQUFJZ0IsT0FBT3pELE9BQU8sQ0FBQ3dYLGlCQUFrQjtZQUMxRGYsWUFBWWEsV0FBVyxDQUFDdlQsSUFBSSxDQUFDO2dCQUMzQjdELE1BQU1qRDtnQkFDTndGO2dCQUNBWCxNQUFNO1lBQ1I7UUFDRjtRQUNBLE9BQU8yVTtJQUNUO0lBQ0EsSUFBSWpZLEtBQUtzRCxJQUFJLEtBQUssZ0JBQWdCO1FBQ2hDLE9BQU8sSUFBSXJKLGlEQUFHQSxDQUFDTSxJQUFJLENBQUMsUUFBUTtZQUMxQnlYLFNBQVM7UUFDWCxHQUFHaFMsS0FBS0ksUUFBUSxDQUFDcUIsR0FBRyxDQUFDMFg7SUFDdkI7SUFDQSxJQUFJblosS0FBS3NELElBQUksS0FBSyxrQkFBa0I7UUFDbEMsT0FBTyxJQUFJckosaURBQUdBLENBQUNNLElBQUksQ0FBQyxRQUFRO1lBQzFCeVgsU0FBUztRQUNYLEdBQUdoUyxLQUFLSSxRQUFRLENBQUNxQixHQUFHLENBQUMwWDtJQUN2QjtJQUNBLElBQUluWixLQUFLc0QsSUFBSSxLQUFLLFVBQVU7UUFDMUIsT0FBTyxJQUFJckosaURBQUdBLENBQUNNLElBQUksQ0FBQyxPQUFPO1lBQ3pCb1ksUUFBUTNTLEtBQUsyUyxNQUFNO1FBQ3JCLEdBQUczUyxLQUFLSSxRQUFRLENBQUNxQixHQUFHLENBQUMwWCxhQUFhO0lBQ3BDO0lBQ0EsSUFBSW5aLEtBQUtzRCxJQUFJLEtBQUssZUFBZTtRQUMvQixPQUFPLElBQUlySixpREFBR0EsQ0FBQ00sSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHeUYsS0FBS0ksUUFBUSxDQUFDZ0MsT0FBTyxDQUFDK1csYUFBYTtJQUNwRTtJQUNBLElBQUluWixLQUFLc0QsSUFBSSxLQUFLLG1CQUFtQjtRQUNuQyxNQUFNK1YsU0FBU3JaLEtBQUtJLFFBQVEsQ0FBQ2IsTUFBTSxLQUFLLEtBQUtTLEtBQUtJLFFBQVEsQ0FBQyxFQUFFLENBQUNrRCxJQUFJLEtBQUssMkJBQTJCdEQsS0FBS0ksUUFBUSxDQUFDLEVBQUUsQ0FBQzhRLFFBQVEsS0FBSzdTO1FBQ2hJLE1BQU15VSxpQkFBaUJqWCxPQUFPOFYsZUFBZSxDQUFDM1IsS0FBSzRTLFNBQVMsQ0FBQztRQUM3RCxNQUFNMEYsb0JBQW9CLEVBQUU7UUFDNUIsS0FBSyxNQUFNOUgsU0FBU3hRLEtBQUtJLFFBQVEsQ0FBRTtZQUNqQyxJQUFJLENBQUNvUSxNQUFNbE4sSUFBSSxLQUFLLDBCQUEwQmtOLE1BQU1sTixJQUFJLEtBQUssdUJBQXNCLEtBQU1rTixNQUFNVSxRQUFRLEtBQUs3UyxXQUFXO2dCQUNySGlhLGtCQUFrQi9TLElBQUksQ0FBQztvQkFDckJqQyxNQUFNa04sTUFBTWxOLElBQUk7b0JBQ2hCNE4sVUFBVVYsTUFBTVUsUUFBUTtvQkFDeEI5USxVQUFVb1EsTUFBTWxOLElBQUksS0FBSyx5QkFBeUJrTixNQUFNcFEsUUFBUSxDQUFDZ0MsT0FBTyxDQUFDK1csY0FBYzt3QkFBQzdCLFNBQVM5RyxNQUFNcFEsUUFBUTtxQkFBRTtnQkFDbkg7WUFDRjtRQUNGO1FBQ0EsSUFBSTBRLGFBQWE5USxLQUFLNlMsS0FBSztRQUMzQixJQUFJQyxnQkFBZ0I7WUFDbEIsTUFBTW1HLGFBQWF6QyxlQUFleFcsS0FBSzZTLEtBQUssRUFBRTtnQkFDNUN0VSxNQUFNO2dCQUNOMkcsUUFBUTROLGVBQWVwVyxNQUFNO1lBQy9CLEdBQUcyQixXQUFXeEMsT0FBT3FCLElBQUksRUFBRTtZQUMzQjRULGFBQWFtSSxXQUFXaFYsS0FBSztZQUM3QnBJLE9BQU8rYSxVQUFVLENBQUNyUixJQUFJLElBQUkwVCxXQUFXckMsVUFBVTtZQUMvQyxNQUFNN0QsbUJBQW1CN0MscUJBQXFCO2dCQUM1QzNSLE1BQU07Z0JBQ04yRyxRQUFRNE4sZUFBZXBXLE1BQU07WUFDL0I7WUFDQSxJQUFJcVcsa0JBQWtCO2dCQUNwQixNQUFNM1MsV0FBVyxFQUFFO2dCQUNuQmlZLG1CQUFtQkMsbUJBQW1CbFksVUFBVTBRLFlBQVlpQztnQkFDNUQsT0FBTyxJQUFJOVksaURBQUdBLENBQUNNLElBQUksQ0FBQyxPQUFPdVcsWUFBWTFRLFVBQVVKLEtBQUs0UyxTQUFTO1lBQ2pFO1FBQ0Y7UUFDQSxNQUFNeFMsV0FBV2laLFNBQVMsRUFBRSxHQUFHZixrQkFBa0I3VyxHQUFHLENBQUNzQyxDQUFBQSxJQUFLLElBQUk5SixpREFBR0EsQ0FBQ00sSUFBSSxDQUFDLE9BQU87Z0JBQzVFMlcsVUFBVW5OLEVBQUVtTixRQUFRO1lBQ3RCLEdBQUduTixFQUFFM0QsUUFBUSxFQUFFMkQsRUFBRVQsSUFBSTtRQUNyQixPQUFPLElBQUlySixpREFBR0EsQ0FBQ00sSUFBSSxDQUFDLE9BQU91VyxZQUFZMVEsVUFBVUosS0FBSzRTLFNBQVM7SUFDakU7SUFDQSxJQUFJNVMsS0FBS3NELElBQUksS0FBSywwQkFBMEJ0RCxLQUFLc0QsSUFBSSxLQUFLLHlCQUF5QjtRQUNqRixPQUFPLElBQUlySixpREFBR0EsQ0FBQ00sSUFBSSxDQUFDLE9BQU87WUFDekIyVyxVQUFVbFIsS0FBS2tSLFFBQVE7UUFDekIsR0FBR2xSLEtBQUtzRCxJQUFJLEtBQUssMEJBQTBCO1lBQUNnVSxTQUFTdFgsS0FBS0ksUUFBUTtTQUFFLEdBQUdKLEtBQUtJLFFBQVEsQ0FBQ2dDLE9BQU8sQ0FBQytXLGFBQWFuWixLQUFLc0QsSUFBSTtJQUNySDtJQUNBLElBQUl0RCxLQUFLc0QsSUFBSSxLQUFLLGFBQWE7UUFDN0IsTUFBTWdXLGtCQUFrQnRaLEtBQUtJLFFBQVEsQ0FBQyxFQUFFO1FBQ3hDLElBQUlrWixnQkFBZ0JoVyxJQUFJLEtBQUsscUJBQXFCO1lBQ2hELE1BQU0sSUFBSW5ILE1BQU07UUFDbEI7UUFDQSxNQUFNb2QsU0FBU2pDLFNBQVNnQyxnQkFBZ0JsWixRQUFRO1FBQ2hELE1BQU1BLFdBQVc7WUFBQ21aO1NBQU87UUFDekIsTUFBTUMsYUFBYXhaLEtBQUtJLFFBQVEsQ0FBQyxFQUFFO1FBQ25DLElBQUlvWixZQUFZO1lBQ2RwWixTQUFTbUYsSUFBSSxDQUFDNlMsVUFBVW9CLFlBQVkzZDtRQUN0QztRQUNBLE9BQU8sSUFBSTVCLGlEQUFHQSxDQUFDTSxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUc2RjtJQUNsQztJQUNBLElBQUlKLEtBQUtzRCxJQUFJLEtBQUsscUJBQXFCO1FBQ3JDLE1BQU0sSUFBSW5ILE1BQU07SUFDbEI7SUFDQSxRQUFTO0lBQ1QsTUFBTSxJQUFJQSxNQUFNLENBQUMsc0JBQXNCLEVBQUU2RCxLQUFLc0QsSUFBSSxDQUFDLENBQUM7QUFDdEQ7QUFFQSxTQUFTbVcsYUFBYWhYLEdBQUcsRUFBRWlYLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxVQUFVLEVBQUVDLFFBQVE7SUFDdkQsSUFBSXBYLElBQUlsRCxNQUFNLEdBQUdtYSxLQUFLO1FBQ3BCLElBQUlBLFFBQVEsR0FBRztZQUNiLE9BQU8sQ0FBQyxFQUFFRSxXQUFXLGtCQUFrQixDQUFDO1FBQzFDLE9BQU87WUFDTCxPQUFPLENBQUMsRUFBRUEsV0FBVyxrQkFBa0IsRUFBRUYsSUFBSSxnQkFBZ0IsQ0FBQztRQUNoRTtJQUNGO0lBQ0EsSUFBSWpYLElBQUlsRCxNQUFNLEdBQUdvYSxLQUFLO1FBQ3BCLE9BQU8sQ0FBQyxFQUFFQyxXQUFXLHdCQUF3QixFQUFFRCxJQUFJLFdBQVcsQ0FBQztJQUNqRTtJQUNBLElBQUlFLFVBQVU7UUFDWixJQUFJcFgsUUFBUSxJQUFJO1lBQ2QsT0FBTyxDQUFDLEVBQUVtWCxXQUFXLGtCQUFrQixDQUFDO1FBQzFDO1FBQ0EsSUFBSW5YLFFBQVEsTUFBTTtZQUNoQixPQUFPLENBQUMsRUFBRW1YLFdBQVcsZUFBZSxDQUFDO1FBQ3ZDO1FBQ0EsSUFBSW5YLFFBQVEsS0FBSztZQUNmLE9BQU8sQ0FBQyxFQUFFbVgsV0FBVyxjQUFjLENBQUM7UUFDdEM7UUFDQSxJQUFJQyxTQUFTMVAsSUFBSSxLQUFLLE1BQU07WUFDMUIsTUFBTXBLLFFBQVEwQyxJQUFJMUMsS0FBSyxDQUFDO1lBQ3hCLElBQUlBLE1BQU00USxJQUFJLENBQUNtSixDQUFBQSxJQUFLQSxNQUFNLE9BQU87Z0JBQy9CLE9BQU8sQ0FBQyxFQUFFRixXQUFXLG9CQUFvQixDQUFDO1lBQzVDO1lBQ0EsSUFBSTdaLE1BQU00USxJQUFJLENBQUNtSixDQUFBQSxJQUFLQSxNQUFNLE1BQU07Z0JBQzlCLE9BQU8sQ0FBQyxFQUFFRixXQUFXLGNBQWMsQ0FBQztZQUN0QztRQUNGO1FBQ0EsSUFBSSxDQUFDQyxTQUFTMVAsSUFBSSxLQUFLLE1BQU0sVUFBVSxNQUFLLEVBQUdqTyxJQUFJLENBQUN1RyxNQUFNO1lBQ3hELE9BQU8sQ0FBQyxFQUFFbVgsV0FBVyx5QkFBeUIsQ0FBQztRQUNqRDtRQUNBLElBQUksVUFBVTFkLElBQUksQ0FBQ3VHLE1BQU07WUFDdkIsT0FBTyxDQUFDLEVBQUVtWCxXQUFXLGtDQUFrQyxDQUFDO1FBQzFEO1FBQ0EsSUFBSUMsU0FBU0UsS0FBSyxDQUFDeFosR0FBRyxDQUFDa0MsTUFBTTtZQUMzQixPQUFPLENBQUMsRUFBRW1YLFdBQVcsZUFBZSxDQUFDO1FBQ3ZDO0lBQ0Y7QUFDRjtBQUVBLFNBQVNJLG1CQUFtQi9WLEtBQUs7SUFDL0IsSUFBSUEsVUFBVTVGLFdBQVc7UUFDdkIsT0FBTztJQUNUO0lBQ0EsSUFBSSxPQUFPNEYsVUFBVSxVQUFVO1FBQzdCLE1BQU0sSUFBSStILGVBQWU7SUFDM0I7SUFDQSxPQUFPL0g7QUFDVDtBQUNBLE1BQU1nVyxXQUFXLElBQUk1VTtBQUNyQixTQUFTMkssS0FBSyxFQUNaM0QsS0FBSyxFQUNMSSxlQUFlLEVBQUUsRUFDakJMLFlBQVksRUFDVjdNLFFBQVEsRUFDTm9hLE1BQU1PLFFBQVEsRUFDZFIsTUFBTSxDQUFDLEVBQ1IsR0FBRyxDQUFDLENBQUMsRUFDUCxHQUFHLENBQUMsQ0FBQyxFQUNOUyxXQUFXLEVBQ1hDLFlBQVksS0FBSyxFQUNsQjtJQUNDLFNBQVN4TixTQUFTM0ksS0FBSyxFQUFFNEYsU0FBUztRQUNoQyxNQUFNcUMsVUFBVXVOLGFBQWF4VixPQUFPeVYsS0FBS0MsS0FBS3ROLE9BQU94QztRQUNyRCxJQUFJcUMsWUFBWTdOLFdBQVc7WUFDekIsTUFBTSxJQUFJMk4sZUFBZUU7UUFDM0I7UUFDQSxPQUFPakk7SUFDVDtJQUNBLE9BQU87UUFDTDFGLE1BQU07UUFDTkMsVUFBVTtRQUNWZ08sT0FBTXFHLEtBQUs7WUFDVCxPQUFPLFdBQVcsR0FBRXZYLHNEQUFHQSxDQUFDSCxnRkFBY0EsRUFBRTtnQkFDdENrUixPQUFPQTtnQkFDUDhOLGFBQWFBO2dCQUNiVCxLQUFLQTtnQkFDTEMsS0FBS0E7Z0JBQ0xTLFdBQVdBO2dCQUNYLEdBQUd2SCxLQUFLO1lBQ1Y7UUFDRjtRQUNBcEc7WUFDRSxPQUFPLE9BQU9BLGlCQUFpQixXQUFXQSxlQUFlQTtRQUMzRDtRQUNBQyxPQUFNekksS0FBSyxFQUFFb1csSUFBSTtZQUNmLElBQUksQ0FBQ0EsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUtuZCxJQUFJLE1BQU1tQixXQUFXO2dCQUN6RSxPQUFPZ2MsS0FBS25kLElBQUk7WUFDbEI7WUFDQSxPQUFPOGMsbUJBQW1CL1Y7UUFDNUI7UUFDQTBJLFdBQVUxSSxLQUFLO1lBQ2IsT0FBTztnQkFDTEEsT0FBT0EsVUFBVSxLQUFLNUYsWUFBWTRGO1lBQ3BDO1FBQ0Y7UUFDQTZGLG1CQUFrQjdGLEtBQUs7WUFDckIsT0FBTztnQkFDTC9HLE1BQU0rRztnQkFDTkEsT0FBTzVGO1lBQ1Q7UUFDRjtRQUNBd08sUUFBUTtZQUNOSCxPQUFNekksS0FBSztnQkFDVCxNQUFNcVcsU0FBU04sbUJBQW1CL1Y7Z0JBQ2xDLE9BQU8ySSxTQUFTME4sUUFBUWpjO1lBQzFCO1lBQ0FrYyxlQUFjQyxNQUFNLEVBQUVILElBQUk7Z0JBQ3hCek4sU0FBU29OLG1CQUFtQkssS0FBS25kLElBQUksR0FBRztvQkFDdENpTixNQUFNa1EsS0FBS2xRLElBQUk7b0JBQ2Y0UCxPQUFPRTtnQkFDVDtnQkFDQSxPQUFPO1lBQ1Q7UUFDRjtRQUNBck4sVUFBUzNJLEtBQUssRUFBRW9XLElBQUk7WUFDbEIsT0FBT3pOLFNBQVMzSSxPQUFPb1csU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUt4USxTQUFTO1FBQ25GO0lBQ0Y7QUFDRjtBQUVBLE1BQU00USxvQkFBb0I7SUFBQztJQUFhO0lBQVE7SUFBVztJQUFnQjtJQUFrQjtJQUFXO0NBQVE7QUFDaEgsTUFBTUMscUJBQXFCO09BQUlEO0lBQW1CO0NBQVE7QUFDMUQsTUFBTUUsZ0JBQWdCO09BQUlEO0lBQW9CO0NBQWE7QUFDM0QsTUFBTUUsa0JBQWtCO09BQUlEO0lBQWU7Q0FBa0I7QUFDN0QsU0FBU0UsZUFBZVIsSUFBSTtJQUMxQixPQUFPO1FBQ0w5YixNQUFNO1FBQ051YyxpQkFBaUIsSUFBSXpWLElBQUlnVixLQUFLUyxlQUFlO1FBQzdDQyxzQkFBc0JWLEtBQUtTLGVBQWUsQ0FBQyxFQUFFO1FBQzdDRSwyQkFBMkJYLEtBQUtXLHlCQUF5QjtJQUMzRDtBQUNGO0FBQ0EsU0FBU0MsZ0JBQWdCWixJQUFJO0lBQzNCLE9BQU87UUFDTDliLE1BQU07UUFDTnljLDJCQUEyQlgsS0FBS1cseUJBQXlCO0lBQzNEO0FBQ0Y7QUFFQSw4RUFBOEU7QUFDOUUsU0FBU0U7SUFDUCxPQUFPLFNBQVVqWCxLQUFLO1FBQ3BCLE9BQU9BO0lBQ1Q7QUFDRjtBQUNBLE1BQU1rWCxlQUFlRCxZQUFZO0lBQy9CM0gsUUFBUXNILGVBQWU7UUFDckJDLGlCQUFpQjtlQUFJRjtZQUFpQjtTQUFTO1FBQy9DSSwyQkFBMkI7SUFDN0I7SUFDQXJJLFFBQVFrSSxlQUFlO1FBQ3JCQyxpQkFBaUI7WUFBQztTQUFjO1FBQ2hDRSwyQkFBMkI7SUFDN0I7SUFDQSxlQUFlSCxlQUFlO1FBQzVCQyxpQkFBaUJGO1FBQ2pCSSwyQkFBMkI7SUFDN0I7SUFDQTdGLFlBQVkwRixlQUFlO1FBQ3pCQyxpQkFBaUJKO1FBQ2pCTSwyQkFBMkI7SUFDN0I7SUFDQUksV0FBV0gsZ0JBQWdCO1FBQ3pCRCwyQkFBMkI7SUFDN0I7SUFDQWpLLE1BQU1rSyxnQkFBZ0I7UUFDcEJELDJCQUEyQjtJQUM3QjtJQUNBSyxTQUFTSixnQkFBZ0I7UUFDdkJELDJCQUEyQjtJQUM3QjtJQUNBTSxTQUFTTCxnQkFBZ0I7UUFDdkJELDJCQUEyQjtJQUM3QjtJQUNBLG1CQUFtQkgsZUFBZTtRQUNoQ0MsaUJBQWlCO1lBQUM7WUFBd0I7U0FBd0I7UUFDbEVFLDJCQUEyQjtJQUM3QjtJQUNBLHlCQUF5QkMsZ0JBQWdCO1FBQ3ZDRCwyQkFBMkI7SUFDN0I7SUFDQSx3QkFBd0JILGVBQWU7UUFDckNDLGlCQUFpQjtlQUFJSDtZQUFlO1NBQWtCO1FBQ3RESywyQkFBMkI7SUFDN0I7SUFDQSxnQkFBZ0JILGVBQWU7UUFDN0JDLGlCQUFpQjtZQUFDO1NBQVk7UUFDOUJFLDJCQUEyQjtJQUM3QjtJQUNBLGtCQUFrQkgsZUFBZTtRQUMvQkMsaUJBQWlCO1lBQUM7U0FBWTtRQUM5QkUsMkJBQTJCO0lBQzdCO0lBQ0EsYUFBYUgsZUFBZTtRQUMxQkMsaUJBQWlCO1lBQUM7WUFBcUI7WUFBZ0I7U0FBaUI7UUFDeEVFLDJCQUEyQjtJQUM3QjtJQUNBLHFCQUFxQkMsZ0JBQWdCO1FBQ25DRCwyQkFBMkI7SUFDN0I7SUFDQTVJLE9BQU82SSxnQkFBZ0I7UUFDckJELDJCQUEyQjtJQUM3QjtJQUNBTyxPQUFPVixlQUFlO1FBQ3BCRywyQkFBMkI7UUFDM0JGLGlCQUFpQjtZQUFDO1lBQWM7U0FBYTtJQUMvQztJQUNBLGNBQWNELGVBQWU7UUFDM0JHLDJCQUEyQjtRQUMzQkYsaUJBQWlCO1lBQUM7U0FBWTtJQUNoQztJQUNBLGFBQWFELGVBQWU7UUFDMUJHLDJCQUEyQjtRQUMzQkYsaUJBQWlCO1lBQUM7U0FBYTtJQUNqQztJQUNBLGNBQWNELGVBQWU7UUFDM0JHLDJCQUEyQjtRQUMzQkYsaUJBQWlCTDtJQUNuQjtJQUNBLGNBQWNJLGVBQWU7UUFDM0JHLDJCQUEyQjtRQUMzQkYsaUJBQWlCO1lBQUM7U0FBWTtJQUNoQztBQUNGO0FBQ0EsTUFBTVUsdUJBQXVCLElBQUluVyxJQUFJSixPQUFPekQsT0FBTyxDQUFDMlosY0FBY3hILE1BQU0sQ0FBQyxDQUFDLEdBQUcxUCxNQUFNLEdBQUtBLE1BQU0xRixJQUFJLEtBQUssV0FBV2tELEdBQUcsQ0FBQyxDQUFDLENBQUM2QixLQUFLLEdBQUtBO0FBQ2xJLFNBQVNtWSxrQkFBa0J6YixJQUFJO0lBQzdCLE9BQU9BLEtBQUtzRCxJQUFJLEtBQUtqRixhQUFhbWQscUJBQXFCamIsR0FBRyxDQUFDUCxLQUFLc0QsSUFBSTtBQUN0RTtBQUNBLE1BQU00UixhQUFhLElBQUk3UCxJQUFJSixPQUFPd0ksSUFBSSxDQUFDME4sY0FBY3hILE1BQU0sQ0FBQzVQLENBQUFBLElBQUtBLE1BQU07QUFDdkUsU0FBUzJYLFFBQVExYixJQUFJO0lBQ25CLE9BQU9rVixXQUFXM1UsR0FBRyxDQUFDUCxLQUFLc0QsSUFBSTtBQUNqQztBQUVBLHFFQUFxRTtBQUNyRSwyREFBMkQ7QUFDM0Qsd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0QixnQ0FBZ0M7QUFDaEMsb0JBQW9CO0FBQ3BCLHFDQUFxQztBQUNyQyxzQ0FBc0M7QUFDdEMsd0NBQXdDO0FBQ3hDLFVBQVU7QUFDVixxQ0FBcUM7QUFDckMsb0dBQW9HO0FBQ3BHLFVBQVU7QUFDVixTQUFTO0FBQ1QscUJBQXFCO0FBQ3JCLE1BQU07QUFDTixJQUFJO0FBRUosU0FBU3FZLGlDQUFpQ0Msc0JBQXNCLEVBQUV2VCxPQUFPO0lBQ3ZFLElBQUl3VCxxQkFBcUJDLHNCQUFzQkMsc0JBQXNCQyxzQkFBc0JDLHNCQUFzQkM7SUFDakgsdUVBQXVFO0lBQ3ZFLHVEQUF1RDtJQUN2RCxtQ0FBbUM7SUFDbkMscUVBQXFFO0lBQ3JFLDBDQUEwQztJQUMxQyxtQ0FBbUM7SUFDbkMsTUFBTUMseUJBQXlCLENBQUNOLHNCQUFzQnhULFFBQVFvTSxVQUFVLE1BQU0sUUFBUW9ILHdCQUF3QixLQUFLLElBQUksS0FBSyxJQUFJQSxvQkFBb0JySSxXQUFXO0lBQy9KLE1BQU1BLGNBQWMySSwyQkFBMkIsWUFBWSxZQUFZbFgsT0FBTzhKLFdBQVcsQ0FBQzlKLE9BQU93SSxJQUFJLENBQUNtTyx1QkFBdUJuSCxVQUFVLENBQUNqQixXQUFXLEVBQUUvUixHQUFHLENBQUNrTyxDQUFBQTtRQUN2SixPQUFPO1lBQUNBO1lBQU0sQ0FBQyxDQUFDLENBQUN3TSwwQkFBMEIsQ0FBQyxFQUFFLENBQUN4TSxLQUFLO1NBQUM7SUFDdkQ7SUFDQSxJQUFJdEgsUUFBUTlKLElBQUksS0FBSyxVQUFVO1FBQzdCLElBQUk2ZDtRQUNKLE9BQU87WUFDTDdkLE1BQU07WUFDTmlWO1lBQ0FnQyxrQkFBa0I7Z0JBQ2hCcEIsT0FBTy9MLFFBQVErTCxLQUFLLEtBQUs7WUFDM0I7WUFDQVgsWUFBWSxDQUFDLENBQUMySSx1QkFBdUIvVCxRQUFRb00sVUFBVSxNQUFNLFFBQVEySCx5QkFBeUIsS0FBSyxJQUFJLEtBQUssSUFBSUEscUJBQXFCM0ksVUFBVSxNQUFNO1FBQ3ZKO0lBQ0Y7SUFDQSxNQUFNNEksZ0JBQWdCLENBQUNQLHVCQUF1QnpULFFBQVFvTSxVQUFVLE1BQU0sUUFBUXFILHlCQUF5QixLQUFLLElBQUksS0FBSyxJQUFJQSxxQkFBcUJPLGFBQWE7SUFDM0osT0FBTztRQUNMOWQsTUFBTTtRQUNOaVY7UUFDQUMsWUFBWSxDQUFDLENBQUNzSSx1QkFBdUIxVCxRQUFRb00sVUFBVSxNQUFNLFFBQVFzSCx5QkFBeUIsS0FBSyxJQUFJLEtBQUssSUFBSUEscUJBQXFCdEksVUFBVSxNQUFNO1FBQ3JKK0Isa0JBQWtCO1lBQ2hCYixTQUFTLEVBQUU7WUFDWEQsVUFBVXJNLFFBQVFxTSxRQUFRLEtBQUssWUFBWWtILHVCQUF1QmxILFFBQVEsR0FBRztZQUM3RUQsWUFBWTtnQkFDVlcsV0FBVyxDQUFDLENBQUM0Ryx1QkFBdUIzVCxRQUFRb00sVUFBVSxNQUFNLFFBQVF1SCx5QkFBeUIsS0FBSyxJQUFJLEtBQUssSUFBSUEscUJBQXFCNUcsU0FBUyxNQUFNLFlBQVl3Ryx1QkFBdUJuSCxVQUFVLENBQUNXLFNBQVMsR0FBRztvQkFDM01DLFFBQVE7b0JBQ1JmLEtBQUs7Z0JBQ1A7Z0JBQ0FZLFlBQVksQ0FBQyxDQUFDK0csdUJBQXVCNVQsUUFBUW9NLFVBQVUsTUFBTSxRQUFRd0gseUJBQXlCLEtBQUssSUFBSSxLQUFLLElBQUlBLHFCQUFxQi9HLFVBQVUsTUFBTSxZQUFZMEcsdUJBQXVCbkgsVUFBVSxDQUFDUyxVQUFVLEdBQUc7b0JBQzlNQyxZQUFZO29CQUNacEUsTUFBTTtnQkFDUjtnQkFDQStELFVBQVV1SCxrQkFBa0IsWUFBWVQsdUJBQXVCbkgsVUFBVSxDQUFDSyxRQUFRLEdBQUc7b0JBQ25GQyxRQUFRc0gsZ0JBQWdCVCx1QkFBdUJuSCxVQUFVLENBQUNLLFFBQVEsQ0FBQ0MsTUFBTSxDQUFDcEIsTUFBTSxDQUFDNUIsQ0FBQUEsUUFBU3NLLGNBQWN6ZSxRQUFRLENBQUNtVSxVQUFVLEVBQUU7b0JBQzdIclYsUUFBUWtmLHVCQUF1Qm5ILFVBQVUsQ0FBQ0ssUUFBUSxDQUFDcFksTUFBTTtnQkFDM0Q7Z0JBQ0FzWSxXQUFXLENBQUMsQ0FBQ2tILHVCQUF1QjdULFFBQVFvTSxVQUFVLE1BQU0sUUFBUXlILHlCQUF5QixLQUFLLElBQUksS0FBSyxJQUFJQSxxQkFBcUJsSCxTQUFTLE1BQU0sWUFBWTRHLHVCQUF1Qm5ILFVBQVUsQ0FBQ08sU0FBUyxHQUFHO29CQUMzTWhELFNBQVM7b0JBQ1RpRCxXQUFXO2dCQUNiO1lBQ0Y7WUFDQWIsT0FBTy9MLFFBQVErTCxLQUFLLEtBQUs7WUFDekJRLFFBQVF2TSxRQUFRdU0sTUFBTSxLQUFLLFlBQVlnSCx1QkFBdUJoSCxNQUFNLEdBQUc7WUFDdkVDLFFBQVF4TSxRQUFRd00sTUFBTSxLQUFLO1FBQzdCO1FBQ0FsRCxpQkFBaUJ0SixRQUFRc0osZUFBZSxLQUFLO0lBQy9DO0FBQ0Y7QUFDQSxTQUFTMksseUJBQXlCN2dCLElBQUksRUFBRXdJLEtBQUssRUFBRXZILE1BQU07SUFDbkQseUNBQXlDO0lBQ3pDLCtDQUErQztJQUMvQyxJQUFJakIsS0FBSzhELE1BQU0sS0FBSyxHQUFHO1FBQ3JCLE9BQU83QztJQUNUO0lBQ0EsSUFBSUEsT0FBTzZCLElBQUksS0FBSyxXQUFXN0IsT0FBTzZCLElBQUksS0FBSyxRQUFRO1FBQ3JEO0lBQ0Y7SUFDQSxJQUFJN0IsT0FBTzZCLElBQUksS0FBSyxlQUFlO1FBQ2pDLE1BQU1FLE1BQU1oRCxLQUFLK1MsS0FBSztRQUN0QixJQUFJL1AsUUFBUSxnQkFBZ0I7WUFDMUIsT0FBTzZkLHlCQUF5QjdnQixNQUFNd0ksTUFBTXVKLFlBQVksRUFBRTlRLE9BQU84USxZQUFZO1FBQy9FO1FBQ0EsSUFBSS9PLFFBQVEsU0FBUztZQUNuQixNQUFNOGQsVUFBVTdmLE9BQU9vSCxNQUFNLENBQUNHLE1BQU11SixZQUFZLENBQUM7WUFDakQsT0FBTzhPLHlCQUF5QjdnQixNQUFNd0ksTUFBTUEsS0FBSyxFQUFFc1k7UUFDckQ7UUFDQTtJQUNGO0lBQ0EsSUFBSTdmLE9BQU82QixJQUFJLEtBQUssVUFBVTtRQUM1QixNQUFNRSxNQUFNaEQsS0FBSytTLEtBQUs7UUFDdEIsT0FBTzhOLHlCQUF5QjdnQixNQUFNd0ksS0FBSyxDQUFDeEYsSUFBSSxFQUFFL0IsT0FBT3dJLE1BQU0sQ0FBQ3pHLElBQUk7SUFDdEU7SUFDQSxJQUFJL0IsT0FBTzZCLElBQUksS0FBSyxTQUFTO1FBQzNCLE1BQU1pZSxRQUFRL2dCLEtBQUsrUyxLQUFLO1FBQ3hCLE9BQU84Tix5QkFBeUI3Z0IsTUFBTXdJLEtBQUssQ0FBQ3VZLE1BQU0sRUFBRTlmLE9BQU9xSSxPQUFPO0lBQ3BFO0lBQ0FuSyxrREFBV0EsQ0FBQzhCO0FBQ2Q7QUFDQSxTQUFTK2Ysb0JBQW9CaGhCLElBQUksRUFBRXdJLEtBQUssRUFBRTRPLEtBQUs7SUFDN0MsT0FBT3lKLHlCQUF5QjtXQUFJN2dCO0tBQUssRUFBRXdJLE9BQU87UUFDaEQxRixNQUFNO1FBQ04yRyxRQUFRMk47SUFDVjtBQUNGO0FBQ0EsU0FBUzZKLG1CQUFtQmhHLFVBQVUsRUFBRWpiLElBQUksRUFBRXdJLEtBQUs7SUFDakQsTUFBTTBZLFlBQVksRUFBRTtJQUNwQixNQUFNQyxjQUFjO1dBQUluaEI7S0FBSztJQUM3QixJQUFJb2hCLGNBQWNuRztJQUNsQixJQUFJN0ksZUFBZTVKO0lBQ25CLE1BQU8yWSxZQUFZcmQsTUFBTSxDQUFFO1FBQ3pCb2QsVUFBVXBYLElBQUksQ0FBQ3NYO1FBQ2YsTUFBTXBlLE1BQU1tZSxZQUFZcE8sS0FBSyxJQUFJLG9GQUFvRjtRQUNySCxJQUFJcU8sWUFBWXRlLElBQUksS0FBSyxTQUFTO1lBQ2hDc2UsY0FBY0EsWUFBWTlYLE9BQU87WUFDakM4SSxlQUFlQSxZQUFZLENBQUNwUCxJQUFJO1FBQ2xDLE9BQU8sSUFBSW9lLFlBQVl0ZSxJQUFJLEtBQUssZUFBZTtZQUM3Q3NlLGNBQWNBLFlBQVkvWSxNQUFNLENBQUNHLE1BQU11SixZQUFZLENBQUM7WUFDcERLLGVBQWVBLGFBQWE1SixLQUFLO1FBQ25DLE9BQU8sSUFBSTRZLFlBQVl0ZSxJQUFJLEtBQUssVUFBVTtZQUN4Q3NQLGVBQWVBLFlBQVksQ0FBQ3BQLElBQUk7WUFDaENvZSxjQUFjQSxZQUFZM1gsTUFBTSxDQUFDekcsSUFBSTtRQUN2QyxPQUFPLElBQUlvZSxZQUFZdGUsSUFBSSxLQUFLLFdBQVdzZSxZQUFZdGUsSUFBSSxLQUFLLFFBQVE7WUFDdEUsTUFBTSxJQUFJcEMsTUFBTSxDQUFDLGlCQUFpQixFQUFFc0MsSUFBSSxDQUFDLENBQUM7UUFDNUMsT0FBTztZQUNMN0Qsa0RBQVdBLENBQUNpaUI7UUFDZDtJQUNGO0lBQ0EsT0FBT0Y7QUFDVDtBQUVBLFNBQVNHLGFBQWF2SixNQUFNLEVBQUVILE1BQU0sRUFBRTJKLEVBQUUsRUFBRUMsaUJBQWlCLElBQU0sSUFBSTtJQUNuRSxNQUFNQyxhQUFhemlCLHVDQUFJQSxDQUFDMGlCLE1BQU0sQ0FBQzlKLFVBQVVBLFNBQVNBLE1BQU0sQ0FBQyxFQUFFO0lBQzNELE1BQU1XLGFBQWF2Wix1Q0FBSUEsQ0FBQzBpQixNQUFNLENBQUM5SixVQUFVN1ksdUNBQUlBLENBQUMwRixHQUFHLENBQUNzVCxRQUFRMEosY0FBYzdKLE1BQU0sQ0FBQyxFQUFFO0lBQ2pGLElBQUksQ0FBQ3NJLFFBQVEzSCxhQUFhO0lBQzFCLElBQUssSUFBSTdRLElBQUk2USxXQUFXM1QsUUFBUSxDQUFDYixNQUFNLEdBQUcsR0FBRzJELEtBQUssR0FBR0EsSUFBSztRQUN4RCxJQUFJOFosZUFBZWpKLFdBQVczVCxRQUFRLENBQUM4QyxFQUFFLEVBQUVBLElBQUk7WUFDN0MsTUFBTWlhLFlBQVk7bUJBQUlGO2dCQUFZL1o7YUFBRTtZQUNwQzdJLDZDQUFVQSxDQUFDK2lCLFNBQVMsQ0FBQzdKLFFBQVE7Z0JBQzNCTSxJQUFJc0o7Z0JBQ0pKO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCwwRkFBMEY7QUFDMUYsU0FBU00sNkNBQTZDOUosTUFBTSxFQUFFTSxFQUFFLEVBQUUsRUFDaEV5SixXQUFXLENBQUMsRUFDYixHQUFHLENBQUMsQ0FBQztJQUNKLE1BQU1DLFNBQVNqakIseUNBQU1BLENBQUNrakIsS0FBSyxDQUFDakssUUFBUU0sSUFBSTtRQUN0QzRKLE1BQU07SUFDUjtJQUNBLE1BQU1DLFFBQVFwakIseUNBQU1BLENBQUNnYSxHQUFHLENBQUNmLFFBQVEsRUFBRTtJQUNuQyxNQUFNb0ssUUFBUTtRQUNaSjtRQUNBRztJQUNGO0lBQ0EsSUFBSWhZLElBQUk7SUFDUixJQUFJa1k7SUFDSixLQUFLLE1BQU1DLEtBQUt2akIseUNBQU1BLENBQUMyWixTQUFTLENBQUNWLFFBQVE7UUFDdkNNLElBQUk4SjtJQUNOLEdBQUk7UUFDRixJQUFJalksSUFBSTRYLFVBQVU7WUFDaEI7UUFDRjtRQUVBLCtCQUErQjtRQUMvQixNQUFNdGQsT0FBT3pGLHVDQUFJQSxDQUFDMEYsR0FBRyxDQUFDc1QsUUFBUXNLLEVBQUVwaUIsSUFBSTtRQUNwQyxJQUFJdUUsS0FBS2dRLElBQUksQ0FBQ3pRLE1BQU0sS0FBS3NlLEVBQUU5YSxNQUFNLEVBQUU7WUFDakM7UUFDRjtRQUNBLElBQUkyQyxNQUFNLEdBQUc7WUFDWGtZLFNBQVNDO1FBQ1g7UUFDQW5ZO0lBQ0Y7SUFDQSxPQUFPa1k7QUFDVDtBQUNBLFNBQVNFLGdCQUFnQixHQUFHekQsSUFBSTtJQUM5QixJQUFJQSxLQUFLOWEsTUFBTSxLQUFLLEdBQUc7UUFDckIsTUFBTStELE9BQU8rVyxJQUFJLENBQUMsRUFBRTtRQUNwQixPQUFPcmEsQ0FBQUEsT0FBUUEsS0FBS3NELElBQUksS0FBS0E7SUFDL0I7SUFDQSxNQUFNM0QsTUFBTSxJQUFJMEYsSUFBSWdWO0lBQ3BCLE9BQU9yYSxDQUFBQSxPQUFRLE9BQU9BLEtBQUtzRCxJQUFJLEtBQUssWUFBWTNELElBQUlZLEdBQUcsQ0FBQ1AsS0FBS3NELElBQUk7QUFDbkU7QUFDQSxTQUFTeWEsK0NBQStDeEssTUFBTSxFQUFFcUksc0JBQXNCLEVBQUVqSyxlQUFlO0lBQ3JHLE1BQU1xTSx3QkFBd0IxakIseUNBQU1BLENBQUMyakIsS0FBSyxDQUFDMUssUUFBUTtRQUNqRDJLLE9BQU9KLGdCQUFnQix3QkFBd0I7SUFDakQ7SUFDQSxJQUFJRSx1QkFBdUI7UUFDekIsTUFBTTlNLFdBQVc4TSxxQkFBcUIsQ0FBQyxFQUFFLENBQUM5TSxRQUFRO1FBQ2xELE1BQU1pTixvQkFBb0I3akIseUNBQU1BLENBQUM4WSxNQUFNLENBQUNHLFFBQVF5SyxxQkFBcUIsQ0FBQyxFQUFFO1FBQ3hFLElBQUlHLGlCQUFpQixDQUFDLEVBQUUsQ0FBQzdhLElBQUksS0FBSyxtQkFBbUI7WUFDbkQsTUFBTXNQLFlBQVl1TCxpQkFBaUIsQ0FBQyxFQUFFLENBQUN2TCxTQUFTO1lBQ2hELE1BQU1FLGlCQUFpQm5CLGVBQWUsQ0FBQ2lCLFVBQVU7WUFDakQsSUFBSUUsa0JBQWtCNUIsVUFBVTtnQkFDOUIsTUFBTWtOLGFBQWEzQixvQkFBb0J2TCxVQUFVaU4saUJBQWlCLENBQUMsRUFBRSxDQUFDdEwsS0FBSyxFQUFFQyxlQUFlcFcsTUFBTTtnQkFDbEcsSUFBSSxDQUFDMGhCLGVBQWUsUUFBUUEsZUFBZSxLQUFLLElBQUksS0FBSyxJQUFJQSxXQUFXN2YsSUFBSSxNQUFNLFNBQVM7b0JBQ3pGLE9BQU9vZCxpQ0FBaUNDLHdCQUF3QndDLFdBQVcvVixPQUFPO2dCQUNwRjtZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsa0JBQWtCLEdBQ2xCZ1csV0FBV0MsS0FBSyxHQUFHO0lBQ2pCQyxRQUFRO0FBQ1Y7QUFFQTs7K0NBRStDLEdBRS9DLGdDQUFnQztBQUVoQyxJQUFJQyxRQUFRSDtBQUVaOzs7Ozs7O0NBT0MsR0FDRCxJQUFJQyxRQUFRLFNBQVVFLEtBQUs7SUFDekIsc0JBQXNCO0lBQ3RCLElBQUlDLE9BQU87SUFDWCxJQUFJQyxXQUFXO0lBRWYsbUNBQW1DO0lBQ25DLElBQUlDLG1CQUFtQixDQUFDO0lBQ3hCLElBQUl2SCxJQUFJO1FBQ047Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBb0JDLEdBQ0RtSCxRQUFRQyxNQUFNRixLQUFLLElBQUlFLE1BQU1GLEtBQUssQ0FBQ0MsTUFBTTtRQUN6Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FvQkMsR0FDREssNkJBQTZCSixNQUFNRixLQUFLLElBQUlFLE1BQU1GLEtBQUssQ0FBQ00sMkJBQTJCO1FBQ25GOzs7Ozs7OztLQVFDLEdBQ0RDLE1BQU07WUFDSnZmLFFBQVEsU0FBU0EsT0FBT3dmLE1BQU07Z0JBQzVCLElBQUlBLGtCQUFrQkMsT0FBTztvQkFDM0IsT0FBTyxJQUFJQSxNQUFNRCxPQUFPeGIsSUFBSSxFQUFFaEUsT0FBT3dmLE9BQU9oZ0IsT0FBTyxHQUFHZ2dCLE9BQU9FLEtBQUs7Z0JBQ3BFLE9BQU8sSUFBSTlSLE1BQU0rRCxPQUFPLENBQUM2TixTQUFTO29CQUNoQyxPQUFPQSxPQUFPcmQsR0FBRyxDQUFDbkM7Z0JBQ3BCLE9BQU87b0JBQ0wsT0FBT3dmLE9BQU9wakIsT0FBTyxDQUFDLE1BQU0sU0FBU0EsT0FBTyxDQUFDLE1BQU0sUUFBUUEsT0FBTyxDQUFDLFdBQVc7Z0JBQ2hGO1lBQ0Y7WUFDQTs7Ozs7Ozs7Ozs7Ozs7O09BZUMsR0FDRDRILE1BQU0sU0FBVTJiLENBQUM7Z0JBQ2YsT0FBT2hhLE9BQU9pYSxTQUFTLENBQUN4YyxRQUFRLENBQUN5YyxJQUFJLENBQUNGLEdBQUc5ZSxLQUFLLENBQUMsR0FBRyxDQUFDO1lBQ3JEO1lBQ0E7Ozs7O09BS0MsR0FDRGlmLE9BQU8sU0FBVXZXLEdBQUc7Z0JBQ2xCLElBQUksQ0FBQ0EsR0FBRyxDQUFDLE9BQU8sRUFBRTtvQkFDaEI1RCxPQUFPb2EsY0FBYyxDQUFDeFcsS0FBSyxRQUFRO3dCQUNqQzVFLE9BQU8sRUFBRXlhO29CQUNYO2dCQUNGO2dCQUNBLE9BQU83VixHQUFHLENBQUMsT0FBTztZQUNwQjtZQUNBOzs7Ozs7Ozs7T0FTQyxHQUNEeVcsT0FBTyxTQUFTQyxVQUFVTixDQUFDLEVBQUVPLE9BQU87Z0JBQ2xDQSxVQUFVQSxXQUFXLENBQUM7Z0JBQ3RCLElBQUlGO2dCQUNKLElBQUlqUjtnQkFDSixPQUFRK0ksRUFBRXlILElBQUksQ0FBQ3ZiLElBQUksQ0FBQzJiO29CQUNsQixLQUFLO3dCQUNINVEsS0FBSytJLEVBQUV5SCxJQUFJLENBQUNPLEtBQUssQ0FBQ0g7d0JBQ2xCLElBQUlPLE9BQU8sQ0FBQ25SLEdBQUcsRUFBRTs0QkFDZixPQUFPbVIsT0FBTyxDQUFDblIsR0FBRzt3QkFDcEI7d0JBQ0FpUixRQUFRLGdDQUFnQyxHQUFFLENBQUM7d0JBQzNDRSxPQUFPLENBQUNuUixHQUFHLEdBQUdpUjt3QkFDZCxJQUFLLElBQUk3Z0IsT0FBT3dnQixFQUFHOzRCQUNqQixJQUFJQSxFQUFFUSxjQUFjLENBQUNoaEIsTUFBTTtnQ0FDekI2Z0IsS0FBSyxDQUFDN2dCLElBQUksR0FBRzhnQixVQUFVTixDQUFDLENBQUN4Z0IsSUFBSSxFQUFFK2dCOzRCQUNqQzt3QkFDRjt3QkFDQSxPQUFRLGdCQUFnQixHQUFFRjtvQkFFNUIsS0FBSzt3QkFDSGpSLEtBQUsrSSxFQUFFeUgsSUFBSSxDQUFDTyxLQUFLLENBQUNIO3dCQUNsQixJQUFJTyxPQUFPLENBQUNuUixHQUFHLEVBQUU7NEJBQ2YsT0FBT21SLE9BQU8sQ0FBQ25SLEdBQUc7d0JBQ3BCO3dCQUNBaVIsUUFBUSxFQUFFO3dCQUNWRSxPQUFPLENBQUNuUixHQUFHLEdBQUdpUjt3QkFDZCxrQkFBa0IsR0FBRyxnQkFBZ0IsR0FBRUwsRUFBRVMsT0FBTyxDQUFDLFNBQVVDLENBQUMsRUFBRXpjLENBQUM7NEJBQzdEb2MsS0FBSyxDQUFDcGMsRUFBRSxHQUFHcWMsVUFBVUksR0FBR0g7d0JBQzFCO3dCQUNBLE9BQVEsZ0JBQWdCLEdBQUVGO29CQUU1Qjt3QkFDRSxPQUFPTDtnQkFDWDtZQUNGO1lBQ0E7Ozs7Ozs7T0FPQyxHQUNEVyxhQUFhLFNBQVU3YSxPQUFPO2dCQUM1QixNQUFPQSxRQUFTO29CQUNkLElBQUk4YSxJQUFJcEIsS0FBS3FCLElBQUksQ0FBQy9hLFFBQVFnYixTQUFTO29CQUNuQyxJQUFJRixHQUFHO3dCQUNMLE9BQU9BLENBQUMsQ0FBQyxFQUFFLENBQUNHLFdBQVc7b0JBQ3pCO29CQUNBamIsVUFBVUEsUUFBUWtiLGFBQWE7Z0JBQ2pDO2dCQUNBLE9BQU87WUFDVDtZQUNBOzs7Ozs7T0FNQyxHQUNEQyxhQUFhLFNBQVVuYixPQUFPLEVBQUU4TSxRQUFRO2dCQUN0QyxxQ0FBcUM7Z0JBQ3JDLDRDQUE0QztnQkFDNUM5TSxRQUFRZ2IsU0FBUyxHQUFHaGIsUUFBUWdiLFNBQVMsQ0FBQ3JrQixPQUFPLENBQUN5a0IsT0FBTzFCLE1BQU0sT0FBTztnQkFFbEUsb0NBQW9DO2dCQUNwQyxnRUFBZ0U7Z0JBQ2hFMVosUUFBUXFiLFNBQVMsQ0FBQ3RiLEdBQUcsQ0FBQyxjQUFjK007WUFDdEM7WUFDQTs7Ozs7O09BTUMsR0FDRHdPLGVBQWU7Z0JBQ2IsSUFBSSxPQUFPQyxhQUFhLGFBQWE7b0JBQ25DLE9BQU87Z0JBQ1Q7Z0JBQ0EsSUFBSSxtQkFBbUJBLFlBQVksSUFBSSxFQUFFLGtDQUFrQyxLQUFJO29CQUM3RSxPQUFRLGdCQUFnQixHQUFFQSxTQUFTRCxhQUFhO2dCQUVsRDtnQkFFQSxrQkFBa0I7Z0JBQ2xCLDhFQUE4RTtnQkFDOUUsd0NBQXdDO2dCQUV4QyxJQUFJO29CQUNGLE1BQU0sSUFBSWxrQjtnQkFDWixFQUFFLE9BQU9pVSxLQUFLO29CQUNaLHlGQUF5RjtvQkFDekYsK0JBQStCO29CQUMvQixFQUFFO29CQUNGLFFBQVE7b0JBQ1IsK0VBQStFO29CQUMvRSxzRUFBc0U7b0JBRXRFLElBQUlpQyxNQUFNLENBQUMscUNBQXFDeU4sSUFBSSxDQUFDMVAsSUFBSW1RLEtBQUssS0FBSyxFQUFFLENBQUMsQ0FBQyxFQUFFO29CQUN6RSxJQUFJbE8sS0FBSzt3QkFDUCxJQUFJL0wsVUFBVWdhLFNBQVNFLG9CQUFvQixDQUFDO3dCQUM1QyxJQUFLLElBQUl0ZCxLQUFLb0QsUUFBUzs0QkFDckIsSUFBSUEsT0FBTyxDQUFDcEQsRUFBRSxDQUFDbVAsR0FBRyxJQUFJQSxLQUFLO2dDQUN6QixPQUFPL0wsT0FBTyxDQUFDcEQsRUFBRTs0QkFDbkI7d0JBQ0Y7b0JBQ0Y7b0JBQ0EsT0FBTztnQkFDVDtZQUNGO1lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQWtCQyxHQUNEdWQsVUFBVSxTQUFVMWIsT0FBTyxFQUFFZ2IsU0FBUyxFQUFFVyxpQkFBaUI7Z0JBQ3ZELElBQUlDLEtBQUssUUFBUVo7Z0JBQ2pCLE1BQU9oYixRQUFTO29CQUNkLElBQUlxYixZQUFZcmIsUUFBUXFiLFNBQVM7b0JBQ2pDLElBQUlBLFVBQVVRLFFBQVEsQ0FBQ2IsWUFBWTt3QkFDakMsT0FBTztvQkFDVDtvQkFDQSxJQUFJSyxVQUFVUSxRQUFRLENBQUNELEtBQUs7d0JBQzFCLE9BQU87b0JBQ1Q7b0JBQ0E1YixVQUFVQSxRQUFRa2IsYUFBYTtnQkFDakM7Z0JBQ0EsT0FBTyxDQUFDLENBQUNTO1lBQ1g7UUFDRjtRQUNBOzs7Ozs7S0FNQyxHQUNERyxXQUFXO1lBQ1Q7O09BRUMsR0FDREMsT0FBT25DO1lBQ1BvQyxXQUFXcEM7WUFDWDNPLE1BQU0yTztZQUNOcUMsS0FBS3JDO1lBQ0w7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTJCQyxHQUNEc0MsUUFBUSxTQUFVNVMsRUFBRSxFQUFFNlMsS0FBSztnQkFDekIsSUFBSXpDLE9BQU9ySCxFQUFFeUgsSUFBSSxDQUFDUyxLQUFLLENBQUNsSSxFQUFFeUosU0FBUyxDQUFDeFMsR0FBRztnQkFDdkMsSUFBSyxJQUFJNVAsT0FBT3lpQixNQUFPO29CQUNyQnpDLElBQUksQ0FBQ2hnQixJQUFJLEdBQUd5aUIsS0FBSyxDQUFDemlCLElBQUk7Z0JBQ3hCO2dCQUNBLE9BQU9nZ0I7WUFDVDtZQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTBFQyxHQUNEMEMsY0FBYyxTQUFVQyxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsTUFBTSxFQUFFemhCLElBQUk7Z0JBQ2xEQSxPQUFPQSxRQUFRLGdCQUFnQixHQUFFdVgsRUFBRXlKLFNBQVM7Z0JBQzVDLElBQUlVLFVBQVUxaEIsSUFBSSxDQUFDdWhCLE9BQU87Z0JBQzFCLG9CQUFvQixHQUNwQixJQUFJSSxNQUFNLENBQUM7Z0JBQ1gsSUFBSyxJQUFJQyxTQUFTRixRQUFTO29CQUN6QixJQUFJQSxRQUFROUIsY0FBYyxDQUFDZ0MsUUFBUTt3QkFDakMsSUFBSUEsU0FBU0osUUFBUTs0QkFDbkIsSUFBSyxJQUFJSyxZQUFZSixPQUFRO2dDQUMzQixJQUFJQSxPQUFPN0IsY0FBYyxDQUFDaUMsV0FBVztvQ0FDbkNGLEdBQUcsQ0FBQ0UsU0FBUyxHQUFHSixNQUFNLENBQUNJLFNBQVM7Z0NBQ2xDOzRCQUNGO3dCQUNGO3dCQUVBLDREQUE0RDt3QkFDNUQsSUFBSSxDQUFDSixPQUFPN0IsY0FBYyxDQUFDZ0MsUUFBUTs0QkFDakNELEdBQUcsQ0FBQ0MsTUFBTSxHQUFHRixPQUFPLENBQUNFLE1BQU07d0JBQzdCO29CQUNGO2dCQUNGO2dCQUNBLElBQUlFLE1BQU05aEIsSUFBSSxDQUFDdWhCLE9BQU87Z0JBQ3RCdmhCLElBQUksQ0FBQ3VoQixPQUFPLEdBQUdJO2dCQUVmLGtEQUFrRDtnQkFDbERwSyxFQUFFeUosU0FBUyxDQUFDZSxHQUFHLENBQUN4SyxFQUFFeUosU0FBUyxFQUFFLFNBQVVwaUIsR0FBRyxFQUFFd0YsS0FBSztvQkFDL0MsSUFBSUEsVUFBVTBkLE9BQU9sakIsT0FBTzJpQixRQUFRO3dCQUNsQyxJQUFJLENBQUMzaUIsSUFBSSxHQUFHK2lCO29CQUNkO2dCQUNGO2dCQUNBLE9BQU9BO1lBQ1Q7WUFDQSx5REFBeUQ7WUFDekRJLEtBQUssU0FBU0EsSUFBSTNDLENBQUMsRUFBRTRDLFFBQVEsRUFBRXZlLElBQUksRUFBRWtjLE9BQU87Z0JBQzFDQSxVQUFVQSxXQUFXLENBQUM7Z0JBQ3RCLElBQUlKLFFBQVFoSSxFQUFFeUgsSUFBSSxDQUFDTyxLQUFLO2dCQUN4QixJQUFLLElBQUlsYyxLQUFLK2IsRUFBRztvQkFDZixJQUFJQSxFQUFFUSxjQUFjLENBQUN2YyxJQUFJO3dCQUN2QjJlLFNBQVMxQyxJQUFJLENBQUNGLEdBQUcvYixHQUFHK2IsQ0FBQyxDQUFDL2IsRUFBRSxFQUFFSSxRQUFRSjt3QkFDbEMsSUFBSTRlLFdBQVc3QyxDQUFDLENBQUMvYixFQUFFO3dCQUNuQixJQUFJNmUsZUFBZTNLLEVBQUV5SCxJQUFJLENBQUN2YixJQUFJLENBQUN3ZTt3QkFDL0IsSUFBSUMsaUJBQWlCLFlBQVksQ0FBQ3ZDLE9BQU8sQ0FBQ0osTUFBTTBDLFVBQVUsRUFBRTs0QkFDMUR0QyxPQUFPLENBQUNKLE1BQU0wQyxVQUFVLEdBQUc7NEJBQzNCRixJQUFJRSxVQUFVRCxVQUFVLE1BQU1yQzt3QkFDaEMsT0FBTyxJQUFJdUMsaUJBQWlCLFdBQVcsQ0FBQ3ZDLE9BQU8sQ0FBQ0osTUFBTTBDLFVBQVUsRUFBRTs0QkFDaEV0QyxPQUFPLENBQUNKLE1BQU0wQyxVQUFVLEdBQUc7NEJBQzNCRixJQUFJRSxVQUFVRCxVQUFVM2UsR0FBR3NjO3dCQUM3QjtvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7UUFDQXdDLFNBQVMsQ0FBQztRQUNWOzs7Ozs7Ozs7OztLQVdDLEdBQ0RDLGNBQWMsU0FBVUMsS0FBSyxFQUFFTCxRQUFRO1lBQ3JDekssRUFBRStLLGlCQUFpQixDQUFDN0IsVUFBVTRCLE9BQU9MO1FBQ3ZDO1FBQ0E7Ozs7Ozs7Ozs7Ozs7O0tBY0MsR0FDRE0sbUJBQW1CLFNBQVVDLFNBQVMsRUFBRUYsS0FBSyxFQUFFTCxRQUFRO1lBQ3JELElBQUlRLE1BQU07Z0JBQ1JSLFVBQVVBO2dCQUNWTyxXQUFXQTtnQkFDWEUsVUFBVTtZQUNaO1lBQ0FsTCxFQUFFbUwsS0FBSyxDQUFDQyxHQUFHLENBQUMsdUJBQXVCSDtZQUNuQ0EsSUFBSUksUUFBUSxHQUFHdlYsTUFBTWdTLFNBQVMsQ0FBQy9lLEtBQUssQ0FBQ3VpQixLQUFLLENBQUNMLElBQUlELFNBQVMsQ0FBQ08sZ0JBQWdCLENBQUNOLElBQUlDLFFBQVE7WUFDdEZsTCxFQUFFbUwsS0FBSyxDQUFDQyxHQUFHLENBQUMsaUNBQWlDSDtZQUM3QyxJQUFLLElBQUluZixJQUFJLEdBQUc2QixTQUFTQSxVQUFVc2QsSUFBSUksUUFBUSxDQUFDdmYsSUFBSSxFQUFHO2dCQUNyRGtVLEVBQUV3TCxnQkFBZ0IsQ0FBQzdkLFNBQVNtZCxVQUFVLE1BQU1HLElBQUlSLFFBQVE7WUFDMUQ7UUFDRjtRQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0EyQkMsR0FDRGUsa0JBQWtCLFNBQVU3ZCxPQUFPLEVBQUVtZCxLQUFLLEVBQUVMLFFBQVE7WUFDbEQsZ0JBQWdCO1lBQ2hCLElBQUloUSxXQUFXdUYsRUFBRXlILElBQUksQ0FBQ2UsV0FBVyxDQUFDN2E7WUFDbEMsSUFBSXdjLFVBQVVuSyxFQUFFeUosU0FBUyxDQUFDaFAsU0FBUztZQUVuQyw4Q0FBOEM7WUFDOUN1RixFQUFFeUgsSUFBSSxDQUFDcUIsV0FBVyxDQUFDbmIsU0FBUzhNO1lBRTVCLDBDQUEwQztZQUMxQyxJQUFJdUIsU0FBU3JPLFFBQVFrYixhQUFhO1lBQ2xDLElBQUk3TSxVQUFVQSxPQUFPeVAsUUFBUSxDQUFDN0MsV0FBVyxPQUFPLE9BQU87Z0JBQ3JENUksRUFBRXlILElBQUksQ0FBQ3FCLFdBQVcsQ0FBQzlNLFFBQVF2QjtZQUM3QjtZQUNBLElBQUlkLE9BQU9oTSxRQUFRK2QsV0FBVztZQUM5QixJQUFJVCxNQUFNO2dCQUNSdGQsU0FBU0E7Z0JBQ1Q4TSxVQUFVQTtnQkFDVjBQLFNBQVNBO2dCQUNUeFEsTUFBTUE7WUFDUjtZQUNBLFNBQVNnUyxzQkFBc0JDLGVBQWU7Z0JBQzVDWCxJQUFJVyxlQUFlLEdBQUdBO2dCQUN0QjVMLEVBQUVtTCxLQUFLLENBQUNDLEdBQUcsQ0FBQyxpQkFBaUJIO2dCQUM3QkEsSUFBSXRkLE9BQU8sQ0FBQ2tlLFNBQVMsR0FBR1osSUFBSVcsZUFBZTtnQkFDM0M1TCxFQUFFbUwsS0FBSyxDQUFDQyxHQUFHLENBQUMsbUJBQW1CSDtnQkFDL0JqTCxFQUFFbUwsS0FBSyxDQUFDQyxHQUFHLENBQUMsWUFBWUg7Z0JBQ3hCUixZQUFZQSxTQUFTMUMsSUFBSSxDQUFDa0QsSUFBSXRkLE9BQU87WUFDdkM7WUFDQXFTLEVBQUVtTCxLQUFLLENBQUNDLEdBQUcsQ0FBQyx1QkFBdUJIO1lBRW5DLDRDQUE0QztZQUM1Q2pQLFNBQVNpUCxJQUFJdGQsT0FBTyxDQUFDa2IsYUFBYTtZQUNsQyxJQUFJN00sVUFBVUEsT0FBT3lQLFFBQVEsQ0FBQzdDLFdBQVcsT0FBTyxTQUFTLENBQUM1TSxPQUFPOFAsWUFBWSxDQUFDLGFBQWE7Z0JBQ3pGOVAsT0FBTytQLFlBQVksQ0FBQyxZQUFZO1lBQ2xDO1lBQ0EsSUFBSSxDQUFDZCxJQUFJdFIsSUFBSSxFQUFFO2dCQUNicUcsRUFBRW1MLEtBQUssQ0FBQ0MsR0FBRyxDQUFDLFlBQVlIO2dCQUN4QlIsWUFBWUEsU0FBUzFDLElBQUksQ0FBQ2tELElBQUl0ZCxPQUFPO2dCQUNyQztZQUNGO1lBQ0FxUyxFQUFFbUwsS0FBSyxDQUFDQyxHQUFHLENBQUMsb0JBQW9CSDtZQUNoQyxJQUFJLENBQUNBLElBQUlkLE9BQU8sRUFBRTtnQkFDaEJ3QixzQkFBc0IzTCxFQUFFeUgsSUFBSSxDQUFDdmYsTUFBTSxDQUFDK2lCLElBQUl0UixJQUFJO2dCQUM1QztZQUNGO1lBQ0EsSUFBSW1SLFNBQVMxRCxNQUFNNEUsTUFBTSxFQUFFO2dCQUN6QixJQUFJQyxTQUFTLElBQUlELE9BQU9oTSxFQUFFakIsUUFBUTtnQkFDbENrTixPQUFPQyxTQUFTLEdBQUcsU0FBVUMsR0FBRztvQkFDOUJSLHNCQUFzQlEsSUFBSXJsQixJQUFJO2dCQUNoQztnQkFDQW1sQixPQUFPRyxXQUFXLENBQUNoWSxLQUFLQyxTQUFTLENBQUM7b0JBQ2hDb0csVUFBVXdRLElBQUl4USxRQUFRO29CQUN0QmQsTUFBTXNSLElBQUl0UixJQUFJO29CQUNkMFMsZ0JBQWdCO2dCQUNsQjtZQUNGLE9BQU87Z0JBQ0xWLHNCQUFzQjNMLEVBQUVzTSxTQUFTLENBQUNyQixJQUFJdFIsSUFBSSxFQUFFc1IsSUFBSWQsT0FBTyxFQUFFYyxJQUFJeFEsUUFBUTtZQUN2RTtRQUNGO1FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FtQkMsR0FDRDZSLFdBQVcsU0FBVTFULElBQUksRUFBRXVSLE9BQU8sRUFBRTFQLFFBQVE7WUFDMUMsSUFBSXdRLE1BQU07Z0JBQ1J0UixNQUFNZjtnQkFDTnVSLFNBQVNBO2dCQUNUMVAsVUFBVUE7WUFDWjtZQUNBdUYsRUFBRW1MLEtBQUssQ0FBQ0MsR0FBRyxDQUFDLG1CQUFtQkg7WUFDL0IsSUFBSSxDQUFDQSxJQUFJZCxPQUFPLEVBQUU7Z0JBQ2hCLE1BQU0sSUFBSXBsQixNQUFNLG1CQUFtQmttQixJQUFJeFEsUUFBUSxHQUFHO1lBQ3BEO1lBQ0F3USxJQUFJdkQsTUFBTSxHQUFHMUgsRUFBRXVNLFFBQVEsQ0FBQ3RCLElBQUl0UixJQUFJLEVBQUVzUixJQUFJZCxPQUFPO1lBQzdDbkssRUFBRW1MLEtBQUssQ0FBQ0MsR0FBRyxDQUFDLGtCQUFrQkg7WUFDOUIsT0FBT3RELE1BQU10VCxTQUFTLENBQUMyTCxFQUFFeUgsSUFBSSxDQUFDdmYsTUFBTSxDQUFDK2lCLElBQUl2RCxNQUFNLEdBQUd1RCxJQUFJeFEsUUFBUTtRQUNoRTtRQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXVCQyxHQUNEOFIsVUFBVSxTQUFVM1QsSUFBSSxFQUFFdVIsT0FBTztZQUMvQixJQUFJelAsT0FBT3lQLFFBQVF6UCxJQUFJO1lBQ3ZCLElBQUlBLE1BQU07Z0JBQ1IsSUFBSyxJQUFJMlAsU0FBUzNQLEtBQU07b0JBQ3RCeVAsT0FBTyxDQUFDRSxNQUFNLEdBQUczUCxJQUFJLENBQUMyUCxNQUFNO2dCQUM5QjtnQkFDQSxPQUFPRixRQUFRelAsSUFBSTtZQUNyQjtZQUNBLElBQUk4UixZQUFZLElBQUlDO1lBQ3BCQyxTQUFTRixXQUFXQSxVQUFVeEssSUFBSSxFQUFFcEo7WUFDcEMrVCxhQUFhL1QsTUFBTTRULFdBQVdyQyxTQUFTcUMsVUFBVXhLLElBQUksRUFBRTtZQUN2RCxPQUFPNEssUUFBUUo7UUFDakI7UUFDQTs7OztLQUlDLEdBQ0RyQixPQUFPO1lBQ0wwQixLQUFLLENBQUM7WUFDTjs7Ozs7Ozs7Ozs7T0FXQyxHQUNEbmYsS0FBSyxTQUFVcEQsSUFBSSxFQUFFbWdCLFFBQVE7Z0JBQzNCLElBQUlVLFFBQVFuTCxFQUFFbUwsS0FBSyxDQUFDMEIsR0FBRztnQkFDdkIxQixLQUFLLENBQUM3Z0IsS0FBSyxHQUFHNmdCLEtBQUssQ0FBQzdnQixLQUFLLElBQUksRUFBRTtnQkFDL0I2Z0IsS0FBSyxDQUFDN2dCLEtBQUssQ0FBQzZELElBQUksQ0FBQ3NjO1lBQ25CO1lBQ0E7Ozs7Ozs7O09BUUMsR0FDRFcsS0FBSyxTQUFVOWdCLElBQUksRUFBRTJnQixHQUFHO2dCQUN0QixJQUFJNkIsWUFBWTlNLEVBQUVtTCxLQUFLLENBQUMwQixHQUFHLENBQUN2aUIsS0FBSztnQkFDakMsSUFBSSxDQUFDd2lCLGFBQWEsQ0FBQ0EsVUFBVTNrQixNQUFNLEVBQUU7b0JBQ25DO2dCQUNGO2dCQUNBLElBQUssSUFBSTJELElBQUksR0FBRzJlLFVBQVVBLFdBQVdxQyxTQUFTLENBQUNoaEIsSUFBSSxFQUFHO29CQUNwRDJlLFNBQVNRO2dCQUNYO1lBQ0Y7UUFDRjtRQUNBdEQsT0FBT0E7SUFDVDtJQUNBUCxNQUFNRixLQUFLLEdBQUdsSDtJQUVkLG1CQUFtQjtJQUNuQiwrREFBK0Q7SUFDL0QsRUFBRTtJQUNGLG1FQUFtRTtJQUVuRTs7Ozs7Ozs7OztHQVVDLEdBQ0QsU0FBUzJILE1BQU16YixJQUFJLEVBQUV4RSxPQUFPLEVBQUVrZ0IsS0FBSyxFQUFFbUYsVUFBVTtRQUM3Qzs7Ozs7Ozs7S0FRQyxHQUNELElBQUksQ0FBQzdnQixJQUFJLEdBQUdBO1FBQ1o7Ozs7Ozs7S0FPQyxHQUNELElBQUksQ0FBQ3hFLE9BQU8sR0FBR0E7UUFDZjs7Ozs7O0tBTUMsR0FDRCxJQUFJLENBQUNrZ0IsS0FBSyxHQUFHQTtRQUNiLHNEQUFzRDtRQUN0RCxJQUFJLENBQUN6ZixNQUFNLEdBQUcsQ0FBQzRrQixjQUFjLEVBQUMsRUFBRzVrQixNQUFNLEdBQUc7SUFDNUM7SUFFQTs7Ozs7Ozs7Ozs7Ozs7R0FjQyxHQUVEOzs7Ozs7Ozs7OztHQVdDLEdBQ0R3ZixNQUFNdFQsU0FBUyxHQUFHLFNBQVNBLFVBQVV3VCxDQUFDLEVBQUVwTixRQUFRO1FBQzlDLElBQUksT0FBT29OLEtBQUssVUFBVTtZQUN4QixPQUFPQTtRQUNUO1FBQ0EsSUFBSS9SLE1BQU0rRCxPQUFPLENBQUNnTyxJQUFJO1lBQ3BCLElBQUluRixJQUFJO1lBQ1JtRixFQUFFUyxPQUFPLENBQUMsU0FBVTBFLENBQUM7Z0JBQ25CdEssS0FBS3JPLFVBQVUyWSxHQUFHdlM7WUFDcEI7WUFDQSxPQUFPaUk7UUFDVDtRQUNBLElBQUl1SSxNQUFNO1lBQ1IvZSxNQUFNMmIsRUFBRTNiLElBQUk7WUFDWnhFLFNBQVMyTSxVQUFVd1QsRUFBRW5nQixPQUFPLEVBQUUrUztZQUM5QmIsS0FBSztZQUNMcVQsU0FBUztnQkFBQztnQkFBU3BGLEVBQUUzYixJQUFJO2FBQUM7WUFDMUJ3TixZQUFZLENBQUM7WUFDYmUsVUFBVUE7UUFDWjtRQUNBLElBQUl5UyxVQUFVckYsRUFBRUQsS0FBSztRQUNyQixJQUFJc0YsU0FBUztZQUNYLElBQUlwWCxNQUFNK0QsT0FBTyxDQUFDcVQsVUFBVTtnQkFDMUJwWCxNQUFNZ1MsU0FBUyxDQUFDM1osSUFBSSxDQUFDbWQsS0FBSyxDQUFDTCxJQUFJZ0MsT0FBTyxFQUFFQztZQUMxQyxPQUFPO2dCQUNMakMsSUFBSWdDLE9BQU8sQ0FBQzllLElBQUksQ0FBQytlO1lBQ25CO1FBQ0Y7UUFDQWxOLEVBQUVtTCxLQUFLLENBQUNDLEdBQUcsQ0FBQyxRQUFRSDtRQUNwQixJQUFJdlIsYUFBYTtRQUNqQixJQUFLLElBQUlwUCxRQUFRMmdCLElBQUl2UixVQUFVLENBQUU7WUFDL0JBLGNBQWMsTUFBTXBQLE9BQU8sT0FBTyxDQUFDMmdCLElBQUl2UixVQUFVLENBQUNwUCxLQUFLLElBQUksRUFBQyxFQUFHaEcsT0FBTyxDQUFDLE1BQU0sWUFBWTtRQUMzRjtRQUNBLE9BQU8sTUFBTTJtQixJQUFJclIsR0FBRyxHQUFHLGFBQWFxUixJQUFJZ0MsT0FBTyxDQUFDOWYsSUFBSSxDQUFDLE9BQU8sTUFBTXVNLGFBQWEsTUFBTXVSLElBQUl2akIsT0FBTyxHQUFHLE9BQU91akIsSUFBSXJSLEdBQUcsR0FBRztJQUN0SDtJQUVBOzs7Ozs7R0FNQyxHQUNELFNBQVN1VCxhQUFhQyxPQUFPLEVBQUVDLEdBQUcsRUFBRXpVLElBQUksRUFBRTBVLFVBQVU7UUFDbERGLFFBQVFHLFNBQVMsR0FBR0Y7UUFDcEIsSUFBSXZHLFFBQVFzRyxRQUFRMUUsSUFBSSxDQUFDOVA7UUFDekIsSUFBSWtPLFNBQVN3RyxjQUFjeEcsS0FBSyxDQUFDLEVBQUUsRUFBRTtZQUNuQyw0RUFBNEU7WUFDNUUsSUFBSTBHLG1CQUFtQjFHLEtBQUssQ0FBQyxFQUFFLENBQUMzZSxNQUFNO1lBQ3RDMmUsTUFBTTFCLEtBQUssSUFBSW9JO1lBQ2YxRyxLQUFLLENBQUMsRUFBRSxHQUFHQSxLQUFLLENBQUMsRUFBRSxDQUFDL2QsS0FBSyxDQUFDeWtCO1FBQzVCO1FBQ0EsT0FBTzFHO0lBQ1Q7SUFFQTs7Ozs7Ozs7Ozs7OztHQWFDLEdBQ0QsU0FBUzZGLGFBQWEvVCxJQUFJLEVBQUU0VCxTQUFTLEVBQUVyQyxPQUFPLEVBQUVzRCxTQUFTLEVBQUVDLFFBQVEsRUFBRUMsT0FBTztRQUMxRSxJQUFLLElBQUl0RCxTQUFTRixRQUFTO1lBQ3pCLElBQUksQ0FBQ0EsUUFBUTlCLGNBQWMsQ0FBQ2dDLFVBQVUsQ0FBQ0YsT0FBTyxDQUFDRSxNQUFNLEVBQUU7Z0JBQ3JEO1lBQ0Y7WUFDQSxJQUFJdUQsV0FBV3pELE9BQU8sQ0FBQ0UsTUFBTTtZQUM3QnVELFdBQVc5WCxNQUFNK0QsT0FBTyxDQUFDK1QsWUFBWUEsV0FBVztnQkFBQ0E7YUFBUztZQUMxRCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUQsU0FBU3psQixNQUFNLEVBQUUsRUFBRTBsQixFQUFHO2dCQUN4QyxJQUFJRixXQUFXQSxRQUFRRyxLQUFLLElBQUl6RCxRQUFRLE1BQU13RCxHQUFHO29CQUMvQztnQkFDRjtnQkFDQSxJQUFJRSxhQUFhSCxRQUFRLENBQUNDLEVBQUU7Z0JBQzVCLElBQUk3RCxTQUFTK0QsV0FBVy9ELE1BQU07Z0JBQzlCLElBQUlzRCxhQUFhLENBQUMsQ0FBQ1MsV0FBV1QsVUFBVTtnQkFDeEMsSUFBSVUsU0FBUyxDQUFDLENBQUNELFdBQVdDLE1BQU07Z0JBQ2hDLElBQUlwRyxRQUFRbUcsV0FBV25HLEtBQUs7Z0JBQzVCLElBQUlvRyxVQUFVLENBQUNELFdBQVdYLE9BQU8sQ0FBQ2EsTUFBTSxFQUFFO29CQUN4QyxnREFBZ0Q7b0JBQ2hELElBQUlDLFFBQVFILFdBQVdYLE9BQU8sQ0FBQzloQixRQUFRLEdBQUd3YixLQUFLLENBQUMsWUFBWSxDQUFDLEVBQUU7b0JBQy9EaUgsV0FBV1gsT0FBTyxHQUFHckUsT0FBT2dGLFdBQVdYLE9BQU8sQ0FBQ2UsTUFBTSxFQUFFRCxRQUFRO2dCQUNqRTtnQkFFQSxtQkFBbUIsR0FDbkIsSUFBSWQsVUFBVVcsV0FBV1gsT0FBTyxJQUFJVztnQkFDcEMsSUFDQSw2RUFBNkU7Z0JBQzdFLElBQUlLLGNBQWNYLFVBQVVZLElBQUksRUFBRWhCLE1BQU1LLFVBQVVVLGdCQUFnQjVCLFVBQVU4QixJQUFJLEVBQUVqQixPQUFPZSxZQUFZdmhCLEtBQUssQ0FBQzFFLE1BQU0sRUFBRWltQixjQUFjQSxZQUFZQyxJQUFJLENBQUU7b0JBQ2pKLElBQUlWLFdBQVdOLE9BQU9NLFFBQVFZLEtBQUssRUFBRTt3QkFDbkM7b0JBQ0Y7b0JBQ0EsSUFBSTNpQixNQUFNd2lCLFlBQVl2aEIsS0FBSztvQkFDM0IsSUFBSTJmLFVBQVVya0IsTUFBTSxHQUFHeVEsS0FBS3pRLE1BQU0sRUFBRTt3QkFDbEMsK0NBQStDO3dCQUMvQztvQkFDRjtvQkFDQSxJQUFJeUQsZUFBZStiLE9BQU87d0JBQ3hCO29CQUNGO29CQUNBLElBQUk2RyxjQUFjLEdBQUcsNENBQTRDO29CQUNqRSxJQUFJMUg7b0JBQ0osSUFBSWtILFFBQVE7d0JBQ1ZsSCxRQUFRcUcsYUFBYUMsU0FBU0MsS0FBS3pVLE1BQU0wVTt3QkFDekMsSUFBSSxDQUFDeEcsU0FBU0EsTUFBTTFCLEtBQUssSUFBSXhNLEtBQUt6USxNQUFNLEVBQUU7NEJBQ3hDO3dCQUNGO3dCQUNBLElBQUl3TCxPQUFPbVQsTUFBTTFCLEtBQUs7d0JBQ3RCLElBQUlPLEtBQUttQixNQUFNMUIsS0FBSyxHQUFHMEIsS0FBSyxDQUFDLEVBQUUsQ0FBQzNlLE1BQU07d0JBQ3RDLElBQUlzZSxJQUFJNEc7d0JBRVIsd0NBQXdDO3dCQUN4QzVHLEtBQUsySCxZQUFZdmhCLEtBQUssQ0FBQzFFLE1BQU07d0JBQzdCLE1BQU93TCxRQUFROFMsRUFBRzs0QkFDaEIySCxjQUFjQSxZQUFZQyxJQUFJOzRCQUM5QjVILEtBQUsySCxZQUFZdmhCLEtBQUssQ0FBQzFFLE1BQU07d0JBQy9CO3dCQUNBLHFCQUFxQjt3QkFDckJzZSxLQUFLMkgsWUFBWXZoQixLQUFLLENBQUMxRSxNQUFNO3dCQUM3QmtsQixNQUFNNUc7d0JBRU4sNEZBQTRGO3dCQUM1RixJQUFJMkgsWUFBWXZoQixLQUFLLFlBQVk4YSxPQUFPOzRCQUN0Qzt3QkFDRjt3QkFFQSxxREFBcUQ7d0JBQ3JELElBQUssSUFBSThHLElBQUlMLGFBQWFLLE1BQU1qQyxVQUFVOEIsSUFBSSxJQUFLN0gsQ0FBQUEsSUFBSWQsTUFBTSxPQUFPOEksRUFBRTVoQixLQUFLLEtBQUssUUFBTyxHQUFJNGhCLElBQUlBLEVBQUVKLElBQUksQ0FBRTs0QkFDckdHOzRCQUNBL0gsS0FBS2dJLEVBQUU1aEIsS0FBSyxDQUFDMUUsTUFBTTt3QkFDckI7d0JBQ0FxbUI7d0JBRUEsNkJBQTZCO3dCQUM3QjVpQixNQUFNZ04sS0FBSzdQLEtBQUssQ0FBQ3NrQixLQUFLNUc7d0JBQ3RCSyxNQUFNMUIsS0FBSyxJQUFJaUk7b0JBQ2pCLE9BQU87d0JBQ0x2RyxRQUFRcUcsYUFBYUMsU0FBUyxHQUFHeGhCLEtBQUswaEI7d0JBQ3RDLElBQUksQ0FBQ3hHLE9BQU87NEJBQ1Y7d0JBQ0Y7b0JBQ0Y7b0JBRUEsd0NBQXdDO29CQUN4QyxJQUFJblQsT0FBT21ULE1BQU0xQixLQUFLO29CQUN0QixJQUFJc0osV0FBVzVILEtBQUssQ0FBQyxFQUFFO29CQUN2QixJQUFJbUQsU0FBU3JlLElBQUk3QyxLQUFLLENBQUMsR0FBRzRLO29CQUMxQixJQUFJZ2IsUUFBUS9pQixJQUFJN0MsS0FBSyxDQUFDNEssT0FBTythLFNBQVN2bUIsTUFBTTtvQkFDNUMsSUFBSW9tQixRQUFRbEIsTUFBTXpoQixJQUFJekQsTUFBTTtvQkFDNUIsSUFBSXdsQixXQUFXWSxRQUFRWixRQUFRWSxLQUFLLEVBQUU7d0JBQ3BDWixRQUFRWSxLQUFLLEdBQUdBO29CQUNsQjtvQkFDQSxJQUFJSyxhQUFhUixZQUFZUyxJQUFJO29CQUNqQyxJQUFJNUUsUUFBUTt3QkFDVjJFLGFBQWFsQyxTQUFTRixXQUFXb0MsWUFBWTNFO3dCQUM3Q29ELE9BQU9wRCxPQUFPOWhCLE1BQU07b0JBQ3RCO29CQUNBMm1CLFlBQVl0QyxXQUFXb0MsWUFBWUo7b0JBQ25DLElBQUlPLFVBQVUsSUFBSXBILE1BQU0wQyxPQUFPTCxTQUFTaEssRUFBRXVNLFFBQVEsQ0FBQ21DLFVBQVUxRSxVQUFVMEUsVUFBVTlHLE9BQU84RztvQkFDeEZOLGNBQWMxQixTQUFTRixXQUFXb0MsWUFBWUc7b0JBQzlDLElBQUlKLE9BQU87d0JBQ1RqQyxTQUFTRixXQUFXNEIsYUFBYU87b0JBQ25DO29CQUNBLElBQUlILGNBQWMsR0FBRzt3QkFDbkIsMEVBQTBFO3dCQUMxRSx3REFBd0Q7d0JBRXhELDJCQUEyQixHQUMzQixJQUFJUSxnQkFBZ0I7NEJBQ2xCbEIsT0FBT3pELFFBQVEsTUFBTXdEOzRCQUNyQlUsT0FBT0E7d0JBQ1Q7d0JBQ0E1QixhQUFhL1QsTUFBTTRULFdBQVdyQyxTQUFTaUUsWUFBWVMsSUFBSSxFQUFFeEIsS0FBSzJCO3dCQUU5RCwrREFBK0Q7d0JBQy9ELElBQUlyQixXQUFXcUIsY0FBY1QsS0FBSyxHQUFHWixRQUFRWSxLQUFLLEVBQUU7NEJBQ2xEWixRQUFRWSxLQUFLLEdBQUdTLGNBQWNULEtBQUs7d0JBQ3JDO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0lBRUE7Ozs7Ozs7R0FPQyxHQUVEOzs7R0FHQyxHQUNELFNBQVM5QjtRQUNQLDhCQUE4QixHQUM5QixJQUFJekssT0FBTztZQUNUblYsT0FBTztZQUNQZ2lCLE1BQU07WUFDTlIsTUFBTTtRQUNSO1FBQ0EsOEJBQThCLEdBQzlCLElBQUlDLE9BQU87WUFDVHpoQixPQUFPO1lBQ1BnaUIsTUFBTTdNO1lBQ05xTSxNQUFNO1FBQ1I7UUFDQXJNLEtBQUtxTSxJQUFJLEdBQUdDO1FBRVosOEJBQThCLEdBQzlCLElBQUksQ0FBQ3RNLElBQUksR0FBR0E7UUFDWiw4QkFBOEIsR0FDOUIsSUFBSSxDQUFDc00sSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ25tQixNQUFNLEdBQUc7SUFDaEI7SUFFQTs7Ozs7Ozs7R0FRQyxHQUNELFNBQVN1a0IsU0FBUzVSLElBQUksRUFBRWxTLElBQUksRUFBRWlFLEtBQUs7UUFDakMsdURBQXVEO1FBQ3ZELElBQUl3aEIsT0FBT3psQixLQUFLeWxCLElBQUk7UUFDcEIsSUFBSVksVUFBVTtZQUNacGlCLE9BQU9BO1lBQ1BnaUIsTUFBTWptQjtZQUNOeWxCLE1BQU1BO1FBQ1I7UUFDQXpsQixLQUFLeWxCLElBQUksR0FBR1k7UUFDWlosS0FBS1EsSUFBSSxHQUFHSTtRQUNablUsS0FBSzNTLE1BQU07UUFDWCxPQUFPOG1CO0lBQ1Q7SUFDQTs7Ozs7OztHQU9DLEdBQ0QsU0FBU0gsWUFBWWhVLElBQUksRUFBRWxTLElBQUksRUFBRW9JLEtBQUs7UUFDcEMsSUFBSXFkLE9BQU96bEIsS0FBS3lsQixJQUFJO1FBQ3BCLElBQUssSUFBSXZpQixJQUFJLEdBQUdBLElBQUlrRixTQUFTcWQsU0FBU3ZULEtBQUt3VCxJQUFJLEVBQUV4aUIsSUFBSztZQUNwRHVpQixPQUFPQSxLQUFLQSxJQUFJO1FBQ2xCO1FBQ0F6bEIsS0FBS3lsQixJQUFJLEdBQUdBO1FBQ1pBLEtBQUtRLElBQUksR0FBR2ptQjtRQUNaa1MsS0FBSzNTLE1BQU0sSUFBSTJEO0lBQ2pCO0lBQ0E7Ozs7R0FJQyxHQUNELFNBQVM4Z0IsUUFBUTlSLElBQUk7UUFDbkIsSUFBSTFTLFFBQVEsRUFBRTtRQUNkLElBQUlRLE9BQU9rUyxLQUFLa0gsSUFBSSxDQUFDcU0sSUFBSTtRQUN6QixNQUFPemxCLFNBQVNrUyxLQUFLd1QsSUFBSSxDQUFFO1lBQ3pCbG1CLE1BQU0rRixJQUFJLENBQUN2RixLQUFLaUUsS0FBSztZQUNyQmpFLE9BQU9BLEtBQUt5bEIsSUFBSTtRQUNsQjtRQUNBLE9BQU9qbUI7SUFDVDtJQUNBLElBQUksQ0FBQ2dmLE1BQU04QixRQUFRLEVBQUU7UUFDbkIsSUFBSSxDQUFDOUIsTUFBTThILGdCQUFnQixFQUFFO1lBQzNCLGFBQWE7WUFDYixPQUFPbFA7UUFDVDtRQUNBLElBQUksQ0FBQ0EsRUFBRXdILDJCQUEyQixFQUFFO1lBQ2xDLFlBQVk7WUFDWkosTUFBTThILGdCQUFnQixDQUFDLFdBQVcsU0FBVS9DLEdBQUc7Z0JBQzdDLElBQUlyWCxVQUFVVixLQUFLa0IsS0FBSyxDQUFDNlcsSUFBSXJsQixJQUFJO2dCQUNqQyxJQUFJdWdCLE9BQU92UyxRQUFRMkYsUUFBUTtnQkFDM0IsSUFBSWQsT0FBTzdFLFFBQVE2RSxJQUFJO2dCQUN2QixJQUFJMFMsaUJBQWlCdlgsUUFBUXVYLGNBQWM7Z0JBQzNDakYsTUFBTWdGLFdBQVcsQ0FBQ3BNLEVBQUVzTSxTQUFTLENBQUMzUyxNQUFNcUcsRUFBRXlKLFNBQVMsQ0FBQ3BDLEtBQUssRUFBRUE7Z0JBQ3ZELElBQUlnRixnQkFBZ0I7b0JBQ2xCakYsTUFBTStILEtBQUs7Z0JBQ2I7WUFDRixHQUFHO1FBQ0w7UUFDQSxPQUFPblA7SUFDVDtJQUVBLG1DQUFtQztJQUNuQyxJQUFJb1AsU0FBU3BQLEVBQUV5SCxJQUFJLENBQUN3QixhQUFhO0lBQ2pDLElBQUltRyxRQUFRO1FBQ1ZwUCxFQUFFakIsUUFBUSxHQUFHcVEsT0FBT25VLEdBQUc7UUFDdkIsSUFBSW1VLE9BQU90RCxZQUFZLENBQUMsZ0JBQWdCO1lBQ3RDOUwsRUFBRW1ILE1BQU0sR0FBRztRQUNiO0lBQ0Y7SUFDQSxTQUFTa0k7UUFDUCxJQUFJLENBQUNyUCxFQUFFbUgsTUFBTSxFQUFFO1lBQ2JuSCxFQUFFNkssWUFBWTtRQUNoQjtJQUNGO0lBQ0EsSUFBSSxDQUFDN0ssRUFBRW1ILE1BQU0sRUFBRTtRQUNiLHVFQUF1RTtRQUN2RSxzR0FBc0c7UUFDdEcsaUhBQWlIO1FBQ2pILGtIQUFrSDtRQUNsSCxpR0FBaUc7UUFDakcsbURBQW1EO1FBQ25ELElBQUltSSxhQUFhcEcsU0FBU29HLFVBQVU7UUFDcEMsSUFBSUEsZUFBZSxhQUFhQSxlQUFlLGlCQUFpQkYsVUFBVUEsT0FBT0csS0FBSyxFQUFFO1lBQ3RGckcsU0FBU2dHLGdCQUFnQixDQUFDLG9CQUFvQkc7UUFDaEQsT0FBTztZQUNMLElBQUk3YSxPQUFPZ2IscUJBQXFCLEVBQUU7Z0JBQ2hDaGIsT0FBT2diLHFCQUFxQixDQUFDSDtZQUMvQixPQUFPO2dCQUNMN2EsT0FBT2liLFVBQVUsQ0FBQ0osZ0NBQWdDO1lBQ3BEO1FBQ0Y7SUFDRjtJQUNBLE9BQU9yUDtBQUNULEVBQUVvSDtBQUVGLHNDQUFzQztBQUV0Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUVEOzs7Ozs7Q0FNQyxHQUVEOzs7Ozs7OztDQVFDLEdBRUQ7Ozs7OztDQU1DLEdBRUQ7OytDQUUrQyxHQUUvQ0YsTUFBTXVDLFNBQVMsQ0FBQ2lHLE1BQU0sR0FBRztJQUN2QixXQUFXO1FBQ1R0QyxTQUFTO1FBQ1RZLFFBQVE7SUFDVjtJQUNBLFVBQVU7UUFDUlosU0FBUztRQUNUWSxRQUFRO0lBQ1Y7SUFDQSxXQUFXO1FBQ1QsNENBQTRDO1FBQzVDWixTQUFTO1FBQ1RZLFFBQVE7UUFDUmhFLFFBQVE7WUFDTixtQkFBbUI7Z0JBQ2pCb0QsU0FBUztnQkFDVEUsWUFBWTtnQkFDWlUsUUFBUTtnQkFDUmhFLFFBQVEsS0FBSyxZQUFZO1lBQzNCO1lBRUEsVUFBVTtnQkFDUm9ELFNBQVM7Z0JBQ1RZLFFBQVE7WUFDVjtZQUNBLGVBQWU7WUFDZixlQUFlO1lBQ2YsUUFBUTtRQUNWO0lBQ0Y7SUFDQSxTQUFTO1FBQ1BaLFNBQVM7UUFDVFksUUFBUTtJQUNWO0lBQ0EsT0FBTztRQUNMWixTQUFTO1FBQ1RZLFFBQVE7UUFDUmhFLFFBQVE7WUFDTixPQUFPO2dCQUNMb0QsU0FBUztnQkFDVHBELFFBQVE7b0JBQ04sZUFBZTtvQkFDZixhQUFhO2dCQUNmO1lBQ0Y7WUFDQSxnQkFBZ0IsRUFBRTtZQUNsQixjQUFjO2dCQUNab0QsU0FBUztnQkFDVHBELFFBQVE7b0JBQ04sZUFBZTt3QkFBQzs0QkFDZG9ELFNBQVM7NEJBQ1R4RixPQUFPO3dCQUNUO3dCQUFHOzRCQUNEd0YsU0FBUzs0QkFDVEUsWUFBWTt3QkFDZDtxQkFBRTtnQkFDSjtZQUNGO1lBQ0EsZUFBZTtZQUNmLGFBQWE7Z0JBQ1hGLFNBQVM7Z0JBQ1RwRCxRQUFRO29CQUNOLGFBQWE7Z0JBQ2Y7WUFDRjtRQUNGO0lBQ0Y7SUFDQSxVQUFVO1FBQUM7WUFDVG9ELFNBQVM7WUFDVHhGLE9BQU87UUFDVDtRQUFHO0tBQXFCO0FBQzFCO0FBQ0FWLE1BQU11QyxTQUFTLENBQUNpRyxNQUFNLENBQUMsTUFBTSxDQUFDMUYsTUFBTSxDQUFDLGFBQWEsQ0FBQ0EsTUFBTSxDQUFDLFNBQVMsR0FBRzlDLE1BQU11QyxTQUFTLENBQUNpRyxNQUFNLENBQUMsU0FBUztBQUN0R3hJLE1BQU11QyxTQUFTLENBQUNpRyxNQUFNLENBQUMsVUFBVSxDQUFDMUYsTUFBTSxDQUFDLGtCQUFrQixDQUFDQSxNQUFNLEdBQUc5QyxNQUFNdUMsU0FBUyxDQUFDaUcsTUFBTTtBQUUzRiwwRUFBMEU7QUFDMUV4SSxNQUFNaUUsS0FBSyxDQUFDemQsR0FBRyxDQUFDLFFBQVEsU0FBVXVkLEdBQUc7SUFDbkMsSUFBSUEsSUFBSS9lLElBQUksS0FBSyxVQUFVO1FBQ3pCK2UsSUFBSXZSLFVBQVUsQ0FBQyxRQUFRLEdBQUd1UixJQUFJdmpCLE9BQU8sQ0FBQ3BELE9BQU8sQ0FBQyxTQUFTO0lBQ3pEO0FBQ0Y7QUFDQXVKLE9BQU9vYSxjQUFjLENBQUNmLE1BQU11QyxTQUFTLENBQUNpRyxNQUFNLENBQUM5VixHQUFHLEVBQUUsY0FBYztJQUM5RDs7Ozs7Ozs7OztHQVVDLEdBQ0QvTSxPQUFPLFNBQVM4aUIsV0FBV0MsT0FBTyxFQUFFdkksSUFBSTtRQUN0QyxJQUFJd0ksc0JBQXNCLENBQUM7UUFDM0JBLG1CQUFtQixDQUFDLGNBQWN4SSxLQUFLLEdBQUc7WUFDeEMrRixTQUFTO1lBQ1RFLFlBQVk7WUFDWnRELFFBQVE5QyxNQUFNdUMsU0FBUyxDQUFDcEMsS0FBSztRQUMvQjtRQUNBd0ksbUJBQW1CLENBQUMsUUFBUSxHQUFHO1FBQy9CLElBQUk3RixTQUFTO1lBQ1gsa0JBQWtCO2dCQUNoQm9ELFNBQVM7Z0JBQ1RwRCxRQUFRNkY7WUFDVjtRQUNGO1FBQ0E3RixNQUFNLENBQUMsY0FBYzNDLEtBQUssR0FBRztZQUMzQitGLFNBQVM7WUFDVHBELFFBQVE5QyxNQUFNdUMsU0FBUyxDQUFDcEMsS0FBSztRQUMvQjtRQUNBLElBQUl5SSxNQUFNLENBQUM7UUFDWEEsR0FBRyxDQUFDRixRQUFRLEdBQUc7WUFDYnhDLFNBQVNyRSxPQUFPLHdGQUF3Rm9GLE1BQU0sQ0FBQzdwQixPQUFPLENBQUMsT0FBTztnQkFDNUgsT0FBT3NyQjtZQUNULElBQUk7WUFDSnRDLFlBQVk7WUFDWlUsUUFBUTtZQUNSaEUsUUFBUUE7UUFDVjtRQUNBOUMsTUFBTXVDLFNBQVMsQ0FBQ00sWUFBWSxDQUFDLFVBQVUsU0FBUytGO0lBQ2xEO0FBQ0Y7QUFDQWppQixPQUFPb2EsY0FBYyxDQUFDZixNQUFNdUMsU0FBUyxDQUFDaUcsTUFBTSxDQUFDOVYsR0FBRyxFQUFFLGdCQUFnQjtJQUNoRTs7Ozs7Ozs7OztHQVVDLEdBQ0QvTSxPQUFPLFNBQVVrakIsUUFBUSxFQUFFMUksSUFBSTtRQUM3QkgsTUFBTXVDLFNBQVMsQ0FBQ2lHLE1BQU0sQ0FBQzlWLEdBQUcsQ0FBQ29RLE1BQU0sQ0FBQyxlQUFlLENBQUM3YixJQUFJLENBQUM7WUFDckRpZixTQUFTckUsT0FBTyxhQUFhb0YsTUFBTSxHQUFHLFFBQVE0QixXQUFXLE1BQU0saURBQWlENUIsTUFBTSxFQUFFO1lBQ3hIYixZQUFZO1lBQ1p0RCxRQUFRO2dCQUNOLGFBQWE7Z0JBQ2IsY0FBYztvQkFDWm9ELFNBQVM7b0JBQ1RwRCxRQUFRO3dCQUNOLFNBQVM7NEJBQ1BvRCxTQUFTOzRCQUNURSxZQUFZOzRCQUNaMUYsT0FBTztnQ0FBQ1A7Z0NBQU0sY0FBY0E7NkJBQUs7NEJBQ2pDMkMsUUFBUTlDLE1BQU11QyxTQUFTLENBQUNwQyxLQUFLO3dCQUMvQjt3QkFDQSxlQUFlOzRCQUFDO2dDQUNkK0YsU0FBUztnQ0FDVHhGLE9BQU87NEJBQ1Q7NEJBQUc7eUJBQU07b0JBQ1g7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7QUFDRjtBQUNBVixNQUFNdUMsU0FBUyxDQUFDdUcsSUFBSSxHQUFHOUksTUFBTXVDLFNBQVMsQ0FBQ2lHLE1BQU07QUFDN0N4SSxNQUFNdUMsU0FBUyxDQUFDd0csTUFBTSxHQUFHL0ksTUFBTXVDLFNBQVMsQ0FBQ2lHLE1BQU07QUFDL0N4SSxNQUFNdUMsU0FBUyxDQUFDeUcsR0FBRyxHQUFHaEosTUFBTXVDLFNBQVMsQ0FBQ2lHLE1BQU07QUFDNUN4SSxNQUFNdUMsU0FBUyxDQUFDMEcsR0FBRyxHQUFHakosTUFBTXVDLFNBQVMsQ0FBQ0ksTUFBTSxDQUFDLFVBQVUsQ0FBQztBQUN4RDNDLE1BQU11QyxTQUFTLENBQUMyRyxJQUFJLEdBQUdsSixNQUFNdUMsU0FBUyxDQUFDMEcsR0FBRztBQUMxQ2pKLE1BQU11QyxTQUFTLENBQUM0RyxJQUFJLEdBQUduSixNQUFNdUMsU0FBUyxDQUFDMEcsR0FBRztBQUMxQ2pKLE1BQU11QyxTQUFTLENBQUM2RyxHQUFHLEdBQUdwSixNQUFNdUMsU0FBUyxDQUFDMEcsR0FBRztBQUV6Qzs7K0NBRStDLEdBRTlDLFVBQVVqSixLQUFLO0lBQ2QsSUFBSXFKLFNBQVM7SUFDYnJKLE1BQU11QyxTQUFTLENBQUMrRyxHQUFHLEdBQUc7UUFDcEIsV0FBVztRQUNYLFVBQVU7WUFDUnBELFNBQVNyRSxPQUFPLGVBQWUsc0JBQXNCb0YsTUFBTSxHQUFHLE1BQU1vQyxPQUFPcEMsTUFBTSxHQUFHLFFBQVEsa0JBQWtCQSxNQUFNO1lBQ3BIbkUsUUFBUTtnQkFDTixRQUFRO2dCQUNSLDhCQUE4QjtvQkFDNUJvRCxTQUFTO29CQUNURSxZQUFZO29CQUNaMUYsT0FBTztnQkFDVDtnQkFDQSxXQUFXO29CQUNUd0YsU0FBUztvQkFDVEUsWUFBWTtnQkFDZDtZQUVGO1FBQ0Y7UUFFQSxPQUFPO1lBQ0wsOENBQThDO1lBQzlDRixTQUFTckUsT0FBTyxpQkFBaUJ3SCxPQUFPcEMsTUFBTSxHQUFHLE1BQU0sOEJBQThCQSxNQUFNLEdBQUcsUUFBUTtZQUN0R0gsUUFBUTtZQUNSaEUsUUFBUTtnQkFDTixZQUFZO2dCQUNaLGVBQWU7Z0JBQ2YsVUFBVTtvQkFDUm9ELFNBQVNyRSxPQUFPLE1BQU13SCxPQUFPcEMsTUFBTSxHQUFHO29CQUN0Q3ZHLE9BQU87Z0JBQ1Q7WUFDRjtRQUNGO1FBQ0EsWUFBWTtZQUNWd0YsU0FBU3JFLE9BQU8sdURBQXVEd0gsT0FBT3BDLE1BQU0sR0FBRztZQUN2RmIsWUFBWTtRQUNkO1FBQ0EsVUFBVTtZQUNSRixTQUFTbUQ7WUFDVHZDLFFBQVE7UUFDVjtRQUNBLFlBQVk7WUFDVlosU0FBUztZQUNURSxZQUFZO1FBQ2Q7UUFDQSxhQUFhO1FBQ2IsWUFBWTtZQUNWRixTQUFTO1lBQ1RFLFlBQVk7UUFDZDtRQUNBLGVBQWU7SUFDakI7SUFDQXBHLE1BQU11QyxTQUFTLENBQUMrRyxHQUFHLENBQUMsU0FBUyxDQUFDeEcsTUFBTSxDQUFDdFAsSUFBSSxHQUFHd00sTUFBTXVDLFNBQVMsQ0FBQytHLEdBQUc7SUFDL0QsSUFBSWQsU0FBU3hJLE1BQU11QyxTQUFTLENBQUNpRyxNQUFNO0lBQ25DLElBQUlBLFFBQVE7UUFDVkEsT0FBTzlWLEdBQUcsQ0FBQytWLFVBQVUsQ0FBQyxTQUFTO1FBQy9CRCxPQUFPOVYsR0FBRyxDQUFDNlcsWUFBWSxDQUFDLFNBQVM7SUFDbkM7QUFDRixHQUFHdko7QUFFSDs7K0NBRStDLEdBRS9DQSxNQUFNdUMsU0FBUyxDQUFDaUgsS0FBSyxHQUFHO0lBQ3RCLFdBQVc7UUFBQztZQUNWdEQsU0FBUztZQUNURSxZQUFZO1lBQ1pVLFFBQVE7UUFDVjtRQUFHO1lBQ0RaLFNBQVM7WUFDVEUsWUFBWTtZQUNaVSxRQUFRO1FBQ1Y7S0FBRTtJQUNGLFVBQVU7UUFDUlosU0FBUztRQUNUWSxRQUFRO0lBQ1Y7SUFDQSxjQUFjO1FBQ1paLFNBQVM7UUFDVEUsWUFBWTtRQUNadEQsUUFBUTtZQUNOLGVBQWU7UUFDakI7SUFDRjtJQUNBLFdBQVc7SUFDWCxXQUFXO0lBQ1gsWUFBWTtJQUNaLFVBQVU7SUFDVixZQUFZO0lBQ1osZUFBZTtBQUNqQjtBQUVBOzsrQ0FFK0MsR0FFL0M5QyxNQUFNdUMsU0FBUyxDQUFDa0gsVUFBVSxHQUFHekosTUFBTXVDLFNBQVMsQ0FBQ0ksTUFBTSxDQUFDLFNBQVM7SUFDM0QsY0FBYztRQUFDM0MsTUFBTXVDLFNBQVMsQ0FBQ2lILEtBQUssQ0FBQyxhQUFhO1FBQUU7WUFDbER0RCxTQUFTO1lBQ1RFLFlBQVk7UUFDZDtLQUFFO0lBQ0YsV0FBVztRQUFDO1lBQ1ZGLFNBQVM7WUFDVEUsWUFBWTtRQUNkO1FBQUc7WUFDREYsU0FBUztZQUNURSxZQUFZO1FBQ2Q7S0FBRTtJQUNGLDhFQUE4RTtJQUM5RSxZQUFZO0lBQ1osVUFBVTtRQUNSRixTQUFTckUsT0FBTyxhQUFhb0YsTUFBTSxHQUFHLFFBQ3RDLFdBQVc7UUFDWCxnQkFBZUEsTUFBTSxHQUFHLE1BQ3hCLGlCQUFpQjtRQUNqQiwwQkFBMEJBLE1BQU0sR0FBRyxNQUNuQyxnQkFBZ0I7UUFDaEIsNEJBQTRCQSxNQUFNLEdBQUcsTUFDckMsc0JBQXNCO1FBQ3RCLHNDQUFzQ0EsTUFBTSxHQUFHLE1BQy9DLGlCQUFpQjtRQUNqQixnQkFBZ0JBLE1BQU0sR0FBRyxNQUN6QixrREFBa0Q7UUFDbEQsb0ZBQW9GQSxNQUFNLElBQUksTUFBTSxZQUFZQSxNQUFNO1FBQ3RIYixZQUFZO0lBQ2Q7SUFDQSxZQUFZO0FBQ2Q7QUFDQXBHLE1BQU11QyxTQUFTLENBQUNrSCxVQUFVLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQ3ZELE9BQU8sR0FBRztBQUN0RGxHLE1BQU11QyxTQUFTLENBQUNNLFlBQVksQ0FBQyxjQUFjLFdBQVc7SUFDcEQsU0FBUztRQUNQcUQsU0FBU3JFLE9BQ1QsYUFBYTtRQUNiLHFFQUFxRTtRQUNyRSwwREFBMERvRixNQUFNLEdBQ2hFLGlCQUFpQjtRQUNqQix1R0FBdUc7UUFDdkcsdUdBQXVHO1FBQ3ZHLHlFQUF5RTtRQUN6RSxLQUFLQSxNQUFNLEdBQUcsUUFBUSxpRUFBaUVBLE1BQU0sR0FBRyxNQUNoRyx1RUFBdUU7UUFDdkUscUlBQXFJQSxNQUFNLEdBQUcsTUFDOUksWUFBWTtRQUNaLGtFQUFrRUEsTUFBTTtRQUN4RWIsWUFBWTtRQUNaVSxRQUFRO1FBQ1JoRSxRQUFRO1lBQ04sZ0JBQWdCO2dCQUNkb0QsU0FBUztnQkFDVEUsWUFBWTtnQkFDWjFGLE9BQU87Z0JBQ1BvQyxRQUFROUMsTUFBTXVDLFNBQVMsQ0FBQ21ILEtBQUs7WUFDL0I7WUFDQSxtQkFBbUI7WUFDbkIsZUFBZTtRQUNqQjtJQUNGO0lBQ0EseUZBQXlGO0lBQ3pGLHFCQUFxQjtRQUNuQnhELFNBQVM7UUFDVHhGLE9BQU87SUFDVDtJQUNBLGFBQWE7UUFBQztZQUNad0YsU0FBUztZQUNURSxZQUFZO1lBQ1p0RCxRQUFROUMsTUFBTXVDLFNBQVMsQ0FBQ2tILFVBQVU7UUFDcEM7UUFBRztZQUNEdkQsU0FBUztZQUNURSxZQUFZO1lBQ1p0RCxRQUFROUMsTUFBTXVDLFNBQVMsQ0FBQ2tILFVBQVU7UUFDcEM7UUFBRztZQUNEdkQsU0FBUztZQUNURSxZQUFZO1lBQ1p0RCxRQUFROUMsTUFBTXVDLFNBQVMsQ0FBQ2tILFVBQVU7UUFDcEM7UUFBRztZQUNEdkQsU0FBUztZQUNURSxZQUFZO1lBQ1p0RCxRQUFROUMsTUFBTXVDLFNBQVMsQ0FBQ2tILFVBQVU7UUFDcEM7S0FBRTtJQUNGLFlBQVk7QUFDZDtBQUNBekosTUFBTXVDLFNBQVMsQ0FBQ00sWUFBWSxDQUFDLGNBQWMsVUFBVTtJQUNuRCxZQUFZO1FBQ1ZxRCxTQUFTO1FBQ1RZLFFBQVE7UUFDUnBHLE9BQU87SUFDVDtJQUNBLG1CQUFtQjtRQUNqQndGLFNBQVM7UUFDVFksUUFBUTtRQUNSaEUsUUFBUTtZQUNOLHdCQUF3QjtnQkFDdEJvRCxTQUFTO2dCQUNUeEYsT0FBTztZQUNUO1lBQ0EsaUJBQWlCO2dCQUNmd0YsU0FBUztnQkFDVEUsWUFBWTtnQkFDWnRELFFBQVE7b0JBQ04sNkJBQTZCO3dCQUMzQm9ELFNBQVM7d0JBQ1R4RixPQUFPO29CQUNUO29CQUNBbE4sTUFBTXdNLE1BQU11QyxTQUFTLENBQUNrSCxVQUFVO2dCQUNsQztZQUNGO1lBQ0EsVUFBVTtRQUNaO0lBQ0Y7SUFDQSxtQkFBbUI7UUFDakJ2RCxTQUFTO1FBQ1RFLFlBQVk7UUFDWlUsUUFBUTtRQUNScEcsT0FBTztJQUNUO0FBQ0Y7QUFDQVYsTUFBTXVDLFNBQVMsQ0FBQ00sWUFBWSxDQUFDLGNBQWMsWUFBWTtJQUNyRCxvQkFBb0I7UUFDbEJxRCxTQUFTO1FBQ1RFLFlBQVk7UUFDWjFGLE9BQU87SUFDVDtBQUNGO0FBQ0EsSUFBSVYsTUFBTXVDLFNBQVMsQ0FBQ2lHLE1BQU0sRUFBRTtJQUMxQnhJLE1BQU11QyxTQUFTLENBQUNpRyxNQUFNLENBQUM5VixHQUFHLENBQUMrVixVQUFVLENBQUMsVUFBVTtJQUVoRCw0Q0FBNEM7SUFDNUMsc0VBQXNFO0lBQ3RFekksTUFBTXVDLFNBQVMsQ0FBQ2lHLE1BQU0sQ0FBQzlWLEdBQUcsQ0FBQzZXLFlBQVksQ0FBQyx5TkFBeU50QyxNQUFNLEVBQUU7QUFDM1E7QUFDQWpILE1BQU11QyxTQUFTLENBQUNvSCxFQUFFLEdBQUczSixNQUFNdUMsU0FBUyxDQUFDa0gsVUFBVTtBQUUvQzs7K0NBRStDLEdBRTlDO0lBQ0MsSUFBSSxPQUFPekosVUFBVSxlQUFlLE9BQU9nQyxhQUFhLGFBQWE7UUFDbkU7SUFDRjtJQUVBLDRFQUE0RTtJQUM1RSxJQUFJLENBQUNubUIsUUFBUStrQixTQUFTLENBQUNnSixPQUFPLEVBQUU7UUFDOUIvdEIsUUFBUStrQixTQUFTLENBQUNnSixPQUFPLEdBQUcvdEIsUUFBUStrQixTQUFTLENBQUNpSixpQkFBaUIsSUFBSWh1QixRQUFRK2tCLFNBQVMsQ0FBQ2tKLHFCQUFxQjtJQUM1RztJQUNBLElBQUlDLGtCQUFrQjtJQUN0QixJQUFJQyxrQkFBa0IsU0FBVUMsTUFBTSxFQUFFcmMsT0FBTztRQUM3QyxPQUFPLGFBQWFxYyxTQUFTLDJCQUEyQnJjO0lBQzFEO0lBQ0EsSUFBSXNjLHdCQUF3QjtJQUM1QixJQUFJQyxhQUFhO1FBQ2YsTUFBTTtRQUNOLE1BQU07UUFDTixNQUFNO1FBQ04sT0FBTztRQUNQLFFBQVE7UUFDUixNQUFNO1FBQ04sT0FBTztRQUNQLEtBQUs7UUFDTCxPQUFPO0lBQ1Q7SUFDQSxJQUFJQyxjQUFjO0lBQ2xCLElBQUlDLGlCQUFpQjtJQUNyQixJQUFJQyxnQkFBZ0I7SUFDcEIsSUFBSUMsZ0JBQWdCO0lBQ3BCLElBQUlDLFdBQVcsd0JBQXdCSixjQUFjLE9BQU9FLGdCQUFnQixRQUFRLFdBQVdGLGNBQWMsT0FBT0MsaUJBQWlCO0lBRXJJOzs7Ozs7R0FNQyxHQUNELFNBQVNJLFNBQVMxVyxHQUFHLEVBQUUyVyxPQUFPLEVBQUVDLEtBQUs7UUFDbkMsSUFBSUMsTUFBTSxJQUFJQztRQUNkRCxJQUFJRSxJQUFJLENBQUMsT0FBTy9XLEtBQUs7UUFDckI2VyxJQUFJRyxrQkFBa0IsR0FBRztZQUN2QixJQUFJSCxJQUFJeEMsVUFBVSxJQUFJLEdBQUc7Z0JBQ3ZCLElBQUl3QyxJQUFJWCxNQUFNLEdBQUcsT0FBT1csSUFBSUksWUFBWSxFQUFFO29CQUN4Q04sUUFBUUUsSUFBSUksWUFBWTtnQkFDMUIsT0FBTztvQkFDTCxJQUFJSixJQUFJWCxNQUFNLElBQUksS0FBSzt3QkFDckJVLE1BQU1YLGdCQUFnQlksSUFBSVgsTUFBTSxFQUFFVyxJQUFJSyxVQUFVO29CQUNsRCxPQUFPO3dCQUNMTixNQUFNVDtvQkFDUjtnQkFDRjtZQUNGO1FBQ0Y7UUFDQVUsSUFBSU0sSUFBSSxDQUFDO0lBQ1g7SUFFQTs7Ozs7OztHQU9DLEdBQ0QsU0FBU0MsV0FBVzlMLEtBQUs7UUFDdkIsSUFBSWtDLElBQUksd0NBQXdDQyxJQUFJLENBQUNuQyxTQUFTO1FBQzlELElBQUlrQyxHQUFHO1lBQ0wsSUFBSTFjLFFBQVF1bUIsT0FBTzdKLENBQUMsQ0FBQyxFQUFFO1lBQ3ZCLElBQUk4SixRQUFROUosQ0FBQyxDQUFDLEVBQUU7WUFDaEIsSUFBSXZMLE1BQU11TCxDQUFDLENBQUMsRUFBRTtZQUNkLElBQUksQ0FBQzhKLE9BQU87Z0JBQ1YsT0FBTztvQkFBQ3htQjtvQkFBT0E7aUJBQU07WUFDdkI7WUFDQSxJQUFJLENBQUNtUixLQUFLO2dCQUNSLE9BQU87b0JBQUNuUjtvQkFBTzlFO2lCQUFVO1lBQzNCO1lBQ0EsT0FBTztnQkFBQzhFO2dCQUFPdW1CLE9BQU9wVjthQUFLO1FBQzdCO1FBQ0EsT0FBT2pXO0lBQ1Q7SUFDQWlnQixNQUFNaUUsS0FBSyxDQUFDemQsR0FBRyxDQUFDLHVCQUF1QixTQUFVdWQsR0FBRztRQUNsREEsSUFBSUMsUUFBUSxJQUFJLE9BQU93RztJQUN6QjtJQUNBeEssTUFBTWlFLEtBQUssQ0FBQ3pkLEdBQUcsQ0FBQyx1QkFBdUIsU0FBVXVkLEdBQUc7UUFDbEQsSUFBSXVILE1BQU0sMkJBQTJCLEdBQUV2SCxJQUFJdGQsT0FBTztRQUNsRCxJQUFJNmtCLElBQUkxQixPQUFPLENBQUNZLFdBQVc7WUFDekJ6RyxJQUFJdFIsSUFBSSxHQUFHLElBQUksK0NBQStDO1lBRTlENlksSUFBSXpHLFlBQVksQ0FBQ3VGLGFBQWFDLGlCQUFpQixrQkFBa0I7WUFFakUsd0NBQXdDO1lBQ3hDLElBQUk1WCxPQUFPNlksSUFBSUMsV0FBVyxDQUFDdkosU0FBU3dKLGFBQWEsQ0FBQztZQUNsRC9ZLEtBQUsrUixXQUFXLEdBQUd1RjtZQUNuQixJQUFJaFcsTUFBTXVYLElBQUlHLFlBQVksQ0FBQztZQUMzQixJQUFJbFksV0FBV3dRLElBQUl4USxRQUFRO1lBQzNCLElBQUlBLGFBQWEsUUFBUTtnQkFDdkIsaUVBQWlFO2dCQUNqRSw2REFBNkQ7Z0JBQzdELElBQUkzSCxZQUFZLENBQUMsV0FBVzRWLElBQUksQ0FBQ3pOLFFBQVE7O29CQUFHO2lCQUFPLENBQUMsQ0FBQyxFQUFFO2dCQUN2RFIsV0FBVzRXLFVBQVUsQ0FBQ3ZlLFVBQVUsSUFBSUE7WUFDdEM7WUFFQSx1QkFBdUI7WUFDdkJvVSxNQUFNTyxJQUFJLENBQUNxQixXQUFXLENBQUNuUCxNQUFNYztZQUM3QnlNLE1BQU1PLElBQUksQ0FBQ3FCLFdBQVcsQ0FBQzBKLEtBQUsvWDtZQUU1Qix1QkFBdUI7WUFDdkIsSUFBSW1ZLGFBQWExTCxNQUFNMEQsT0FBTyxDQUFDZ0ksVUFBVTtZQUN6QyxJQUFJQSxZQUFZO2dCQUNkQSxXQUFXQyxhQUFhLENBQUNwWTtZQUMzQjtZQUVBLFlBQVk7WUFDWmtYLFNBQVMxVyxLQUFLLFNBQVVyQyxJQUFJO2dCQUMxQixpQkFBaUI7Z0JBQ2pCNFosSUFBSXpHLFlBQVksQ0FBQ3VGLGFBQWFFO2dCQUU5QixvQkFBb0I7Z0JBQ3BCLElBQUlqTCxRQUFROEwsV0FBV0csSUFBSUcsWUFBWSxDQUFDO2dCQUN4QyxJQUFJcE0sT0FBTztvQkFDVCxJQUFJdU0sUUFBUWxhLEtBQUtqUSxLQUFLLENBQUM7b0JBRXZCLG9EQUFvRDtvQkFDcEQsSUFBSW9ELFFBQVF3YSxLQUFLLENBQUMsRUFBRTtvQkFDcEIsSUFBSXJKLE1BQU1xSixLQUFLLENBQUMsRUFBRSxJQUFJLE9BQU91TSxNQUFNM3FCLE1BQU0sR0FBR29lLEtBQUssQ0FBQyxFQUFFO29CQUNwRCxJQUFJeGEsUUFBUSxHQUFHO3dCQUNiQSxTQUFTK21CLE1BQU0zcUIsTUFBTTtvQkFDdkI7b0JBQ0E0RCxRQUFRZ25CLEtBQUt4USxHQUFHLENBQUMsR0FBR3dRLEtBQUt6USxHQUFHLENBQUN2VyxRQUFRLEdBQUcrbUIsTUFBTTNxQixNQUFNO29CQUNwRCxJQUFJK1UsTUFBTSxHQUFHO3dCQUNYQSxPQUFPNFYsTUFBTTNxQixNQUFNO29CQUNyQjtvQkFDQStVLE1BQU02VixLQUFLeFEsR0FBRyxDQUFDLEdBQUd3USxLQUFLelEsR0FBRyxDQUFDcEYsS0FBSzRWLE1BQU0zcUIsTUFBTTtvQkFDNUN5USxPQUFPa2EsTUFBTS9wQixLQUFLLENBQUNnRCxPQUFPbVIsS0FBSy9QLElBQUksQ0FBQztvQkFFcEMsa0NBQWtDO29CQUNsQyxJQUFJLENBQUNxbEIsSUFBSTFHLFlBQVksQ0FBQyxlQUFlO3dCQUNuQzBHLElBQUl6RyxZQUFZLENBQUMsY0FBY2lILE9BQU9qbkIsUUFBUTtvQkFDaEQ7Z0JBQ0Y7Z0JBRUEsaUJBQWlCO2dCQUNqQjROLEtBQUsrUixXQUFXLEdBQUc5UztnQkFDbkJzTyxNQUFNc0UsZ0JBQWdCLENBQUM3UjtZQUN6QixHQUFHLFNBQVVrWSxLQUFLO2dCQUNoQixpQkFBaUI7Z0JBQ2pCVyxJQUFJekcsWUFBWSxDQUFDdUYsYUFBYUc7Z0JBQzlCOVgsS0FBSytSLFdBQVcsR0FBR21HO1lBQ3JCO1FBQ0Y7SUFDRjtJQUNBM0ssTUFBTTBELE9BQU8sQ0FBQ3FJLGFBQWEsR0FBRztRQUM1Qjs7Ozs7O0tBTUMsR0FDRDNHLFdBQVcsU0FBU0EsVUFBVXRCLFNBQVM7WUFDckMsSUFBSUssV0FBVyxDQUFDTCxhQUFhOUIsUUFBTyxFQUFHcUMsZ0JBQWdCLENBQUNtRztZQUN4RCxJQUFLLElBQUk1bEIsSUFBSSxHQUFHNkIsU0FBU0EsVUFBVTBkLFFBQVEsQ0FBQ3ZmLElBQUksRUFBRztnQkFDakRvYixNQUFNc0UsZ0JBQWdCLENBQUM3ZDtZQUN6QjtRQUNGO0lBQ0Y7SUFDQSxJQUFJdWxCLFNBQVM7SUFDYixxRUFBcUUsR0FDckVoTSxNQUFNK0wsYUFBYSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0MsUUFBUTtZQUNYQyxRQUFRQyxJQUFJLENBQUM7WUFDYkYsU0FBUztRQUNYO1FBQ0FoTSxNQUFNMEQsT0FBTyxDQUFDcUksYUFBYSxDQUFDM0csU0FBUyxDQUFDaEIsS0FBSyxDQUFDLElBQUksRUFBRStIO0lBQ3BEO0FBQ0Y7QUFDQW5NLE1BQU11QyxTQUFTLENBQUNpSCxLQUFLLEdBQUc7SUFDdEIsV0FBVztRQUFDO1lBQ1Z0RCxTQUFTO1lBQ1RFLFlBQVk7WUFDWlUsUUFBUTtRQUNWO1FBQUc7WUFDRFosU0FBUztZQUNURSxZQUFZO1lBQ1pVLFFBQVE7UUFDVjtLQUFFO0lBQ0YsVUFBVTtRQUNSWixTQUFTO1FBQ1RZLFFBQVE7SUFDVjtJQUNBLGNBQWM7UUFDWlosU0FBUztRQUNURSxZQUFZO1FBQ1p0RCxRQUFRO1lBQ04sZUFBZTtRQUNqQjtJQUNGO0lBQ0EsV0FBVztJQUNYLFdBQVc7SUFDWCxZQUFZO0lBQ1osVUFBVTtJQUNWLFlBQVk7SUFDWixlQUFlO0FBQ2pCO0FBQ0E5QyxNQUFNdUMsU0FBUyxDQUFDNkosQ0FBQyxHQUFHcE0sTUFBTXVDLFNBQVMsQ0FBQ0ksTUFBTSxDQUFDLFNBQVM7SUFDbEQsV0FBVztRQUNUdUQsU0FBUztRQUNUWSxRQUFRO0lBQ1Y7SUFDQSxVQUFVO1FBQ1IsMERBQTBEO1FBQzFEWixTQUFTO1FBQ1RZLFFBQVE7SUFDVjtJQUNBLGNBQWM7UUFDWlosU0FBUztRQUNURSxZQUFZO0lBQ2Q7SUFDQSxXQUFXO0lBQ1gsWUFBWTtJQUNaLFVBQVU7SUFDVixZQUFZO0FBQ2Q7QUFDQXBHLE1BQU11QyxTQUFTLENBQUNNLFlBQVksQ0FBQyxLQUFLLFVBQVU7SUFDMUMsUUFBUTtRQUNOLDhEQUE4RDtRQUM5RHFELFNBQVM7UUFDVFksUUFBUTtJQUNWO0FBQ0Y7QUFDQTlHLE1BQU11QyxTQUFTLENBQUNNLFlBQVksQ0FBQyxLQUFLLFVBQVU7SUFDMUMsU0FBUztRQUNQLHdDQUF3QztRQUN4QyxxREFBcUQ7UUFDckRxRCxTQUFTO1FBQ1RFLFlBQVk7UUFDWlUsUUFBUTtRQUNScEcsT0FBTztRQUNQb0MsUUFBUTtZQUNOLFVBQVU7Z0JBQUM7b0JBQ1QsMERBQTBEO29CQUMxRG9ELFNBQVM7b0JBQ1RFLFlBQVk7Z0JBQ2Q7Z0JBQUdwRyxNQUFNdUMsU0FBUyxDQUFDNkosQ0FBQyxDQUFDLFNBQVM7YUFBQztZQUMvQixRQUFRcE0sTUFBTXVDLFNBQVMsQ0FBQzZKLENBQUMsQ0FBQyxPQUFPO1lBQ2pDLFdBQVdwTSxNQUFNdUMsU0FBUyxDQUFDNkosQ0FBQyxDQUFDLFVBQVU7WUFDdkMsY0FBYztnQkFBQztvQkFDYmxHLFNBQVM7b0JBQ1RFLFlBQVk7Z0JBQ2Q7Z0JBQUc7b0JBQ0RGLFNBQVM7b0JBQ1RFLFlBQVk7b0JBQ1oxRixPQUFPO2dCQUNUO2FBQUU7WUFDRix5Q0FBeUM7WUFDekMsYUFBYTtnQkFDWHdGLFNBQVM7Z0JBQ1RFLFlBQVk7Z0JBQ1oxRixPQUFPO1lBQ1Q7WUFDQSxrQkFBa0I7WUFDbEIsZUFBZTtZQUNmLGNBQWM7Z0JBQ1p3RixTQUFTO2dCQUNUcEQsUUFBUTlDLE1BQU11QyxTQUFTLENBQUM2SixDQUFDO1lBQzNCO1FBQ0Y7SUFDRjtBQUNGO0FBQ0FwTSxNQUFNdUMsU0FBUyxDQUFDTSxZQUFZLENBQUMsS0FBSyxZQUFZO0lBQzVDLDJDQUEyQztJQUMzQyxZQUFZO0FBQ2Q7QUFDQSxPQUFPN0MsTUFBTXVDLFNBQVMsQ0FBQzZKLENBQUMsQ0FBQyxVQUFVO0FBQ2xDLFVBQVVwTSxLQUFLO0lBQ2QsSUFBSXFNLFVBQVU7SUFDZCxJQUFJQyxVQUFVLHVDQUF1Q3JGLE1BQU0sQ0FBQzdwQixPQUFPLENBQUMsY0FBYztRQUNoRixPQUFPaXZCLFFBQVFwRixNQUFNO0lBQ3ZCO0lBQ0FqSCxNQUFNdUMsU0FBUyxDQUFDZ0ssR0FBRyxHQUFHdk0sTUFBTXVDLFNBQVMsQ0FBQ0ksTUFBTSxDQUFDLEtBQUs7UUFDaEQsY0FBYztZQUFDO2dCQUNidUQsU0FBU3JFLE9BQU8sZ0VBQWdFb0YsTUFBTSxDQUFDN3BCLE9BQU8sQ0FBQyxjQUFjO29CQUMzRyxPQUFPaXZCLFFBQVFwRixNQUFNO2dCQUN2QjtnQkFDQWIsWUFBWTtZQUNkO1lBQ0EsNkVBQTZFO1lBQzdFLDZCQUE2QjtZQUM3QiwwR0FBMEc7WUFDMUcscUZBQXFGO1lBQ3JGO1lBQ0EsNERBQTREO1lBQzVELG1CQUFtQjtZQUNuQjtZQUNBLHdHQUF3RztZQUN4Ryw4RUFBOEU7WUFDOUU7U0FBaUU7UUFDakUsV0FBV2lHO1FBQ1gsVUFBVTtZQUNSbkcsU0FBUztZQUNUWSxRQUFRO1FBQ1Y7UUFDQSxZQUFZO1FBQ1osV0FBVztJQUNiO0lBQ0E5RyxNQUFNdUMsU0FBUyxDQUFDTSxZQUFZLENBQUMsT0FBTyxVQUFVO1FBQzVDLFVBQVU7WUFDUixxREFBcUQ7WUFDckRxRCxTQUFTckUsT0FBTywyQkFBMkJvRixNQUFNLEdBQUcsUUFDcEQsY0FBYztZQUNkLG1EQUFtREEsTUFBTSxHQUFHLE1BQzVELG1DQUFtQztZQUNuQyxrREFBa0RBLE1BQU0sQ0FBQzdwQixPQUFPLENBQUMsZUFBZTtnQkFDOUUsT0FBT2t2QjtZQUNULEtBQUs7WUFDTGxHLFlBQVk7WUFDWlUsUUFBUTtZQUNSaEUsUUFBUTtnQkFDTixVQUFVO2dCQUNWLFlBQVk7Z0JBQ1osZUFBZTtZQUNqQjtRQUNGO1FBQ0EsY0FBYztZQUNab0QsU0FBUztZQUNUeEYsT0FBTztZQUNQb0csUUFBUTtRQUNWO0lBQ0Y7SUFDQTlHLE1BQU11QyxTQUFTLENBQUNNLFlBQVksQ0FBQyxPQUFPLFdBQVc7UUFDN0Msb0JBQW9CO1lBQ2xCcUQsU0FBUztZQUNUcEQsUUFBUTtnQkFDTixZQUFZO2dCQUNaLFdBQVc7b0JBQ1RvRCxTQUFTO29CQUNUeEYsT0FBTztvQkFDUG9DLFFBQVE5QyxNQUFNdUMsU0FBUyxDQUFDZ0ssR0FBRztnQkFDN0I7WUFDRjtRQUNGO0lBQ0Y7SUFDQXZNLE1BQU11QyxTQUFTLENBQUNNLFlBQVksQ0FBQyxPQUFPLFlBQVk7UUFDOUMsZ0JBQWdCO1lBQ2RxRCxTQUFTO1lBQ1R4RixPQUFPO1FBQ1Q7SUFDRjtJQUNBVixNQUFNdUMsU0FBUyxDQUFDTSxZQUFZLENBQUMsT0FBTyxjQUFjO1FBQ2hELHdEQUF3RDtRQUN4RCxtREFBbUQ7UUFDbkQsZUFBZTtZQUNicUQsU0FBUztZQUNURSxZQUFZO1lBQ1pVLFFBQVE7WUFDUmhFLFFBQVE5QyxNQUFNdUMsU0FBUyxDQUFDSSxNQUFNLENBQUMsT0FBTyxDQUFDO1FBQ3pDO0lBQ0Y7SUFDQTNDLE1BQU11QyxTQUFTLENBQUNNLFlBQVksQ0FBQyxVQUFVLGdCQUFnQjtRQUNyRCxzRUFBc0U7UUFDdEUsY0FBYztJQUNoQixHQUFHN0MsTUFBTXVDLFNBQVMsQ0FBQ2dLLEdBQUcsQ0FBQyxjQUFjO0FBQ3ZDLEdBQUd2TTtBQUNIQSxNQUFNdUMsU0FBUyxDQUFDaUssT0FBTyxHQUFHeE0sTUFBTXVDLFNBQVMsQ0FBQ0ksTUFBTSxDQUFDLE9BQU87SUFDdEQsV0FBVztJQUNYLFlBQVk7SUFDWixXQUFXO0FBQ2I7QUFDQTNDLE1BQU11QyxTQUFTLENBQUNrSyxHQUFHLEdBQUd6TSxNQUFNdUMsU0FBUyxDQUFDaUssT0FBTztBQUM1QyxVQUFVeE0sS0FBSztJQUNkLGtFQUFrRTtJQUNsRSxvQ0FBb0M7SUFDcEMsMERBQTBEO0lBQzFELHlCQUF5QjtJQUN6QixJQUFJME0sVUFBVTtJQUNkLElBQUlDLHNCQUFzQjtRQUN4QnpHLFNBQVM7UUFDVEUsWUFBWTtRQUNaMUYsT0FBTztRQUNQLDJDQUEyQztRQUMzQ29DLFFBQVEsS0FBSyxZQUFZO0lBQzNCO0lBRUEsSUFBSThKLGVBQWU7UUFDakIsUUFBUUQ7UUFDUixlQUFlO1lBQ2J6RyxTQUFTckUsT0FBTyxRQUFRNks7WUFDeEJoTSxPQUFPO1FBQ1Q7UUFDQSxZQUFZO1lBQ1osOEJBQThCO1lBQzlCO2dCQUNFd0YsU0FBUztnQkFDVFksUUFBUTtnQkFDUmhFLFFBQVE7b0JBQ04seUVBQXlFO29CQUN6RSxZQUFZO3dCQUFDOzRCQUNYb0QsU0FBUzs0QkFDVEUsWUFBWTt3QkFDZDt3QkFBRztxQkFBVTtvQkFDYixVQUFVO29CQUNWLGdHQUFnRztvQkFDaEcsWUFBWTtvQkFDWiw0RUFBNEU7b0JBQzVFLGVBQWU7Z0JBQ2pCO1lBQ0Y7WUFDQSw0QkFBNEI7WUFDNUI7Z0JBQ0VGLFNBQVM7Z0JBQ1RZLFFBQVE7Z0JBQ1JoRSxRQUFRO29CQUNOLFlBQVk7Z0JBQ2Q7WUFDRjtZQUNBLHVCQUF1QjtZQUN2QjtnQkFDRW9ELFNBQVM7Z0JBQ1RZLFFBQVE7Z0JBQ1JoRSxRQUFRO29CQUNOLFlBQVk7b0JBQ1osZUFBZTtvQkFDZixlQUFlO3dCQUNib0QsU0FBU3JFLE9BQU8sVUFBVTZLO3dCQUMxQnRHLFlBQVk7d0JBQ1oxRixPQUFPO29CQUNUO2dCQUNGO1lBQ0Y7WUFBRztTQUFxQjtRQUN4Qix1RUFBdUU7UUFDdkUsVUFBVTtJQUNaO0lBQ0FWLE1BQU11QyxTQUFTLENBQUNzSyxJQUFJLEdBQUc7UUFDckIsV0FBVztZQUNUM0csU0FBUztZQUNUeEYsT0FBTztRQUNUO1FBQ0EsV0FBVztZQUNUd0YsU0FBUztZQUNURSxZQUFZO1FBQ2Q7UUFDQSxpQkFBaUI7WUFDakIsb0JBQW9CO1lBQ3BCLGFBQWE7WUFDYixzQkFBc0I7WUFDdEIsa0JBQWtCO1lBQ2xCO2dCQUNFLFlBQVk7Z0JBQ1pGLFNBQVM7Z0JBQ1RFLFlBQVk7Z0JBQ1oxRixPQUFPO1lBQ1Q7WUFBRztnQkFDRCxLQUFLO2dCQUNMd0YsU0FBUztnQkFDVHhGLE9BQU87WUFDVDtTQUFFO1FBQ0Ysc0VBQXNFO1FBQ3RFLGlCQUFpQjtZQUNmd0YsU0FBUztZQUNUeEYsT0FBTztZQUNQMEYsWUFBWTtRQUNkO1FBQ0EsOERBQThEO1FBQzlELGlDQUFpQztRQUNqQyxlQUFlO1lBQ2JGLFNBQVM7WUFDVHBELFFBQVE7Z0JBQ04sZUFBZTtvQkFDYm9ELFNBQVNyRSxPQUFPLHlCQUF5QjZLO29CQUN6Q3RHLFlBQVk7b0JBQ1oxRixPQUFPO2dCQUNUO1lBQ0Y7WUFDQUEsT0FBTztZQUNQMEYsWUFBWTtRQUNkO1FBQ0EseUNBQXlDO1FBQ3pDLGFBQWE7WUFDWEYsU0FBUztZQUNUeEYsT0FBTztZQUNQMEYsWUFBWTtRQUNkO1FBQ0EsVUFBVTtZQUNWLHlFQUF5RTtZQUN6RTtnQkFDRUYsU0FBUztnQkFDVEUsWUFBWTtnQkFDWlUsUUFBUTtnQkFDUmhFLFFBQVE4SjtZQUNWO1lBQ0EsMkNBQTJDO1lBQzNDLG1DQUFtQztZQUNuQztnQkFDRTFHLFNBQVM7Z0JBQ1RFLFlBQVk7Z0JBQ1pVLFFBQVE7Z0JBQ1JoRSxRQUFRO29CQUNOLFFBQVE2SjtnQkFDVjtZQUNGO1lBQ0Esa0JBQWtCO1lBQ2xCO2dCQUNFLHdFQUF3RTtnQkFDeEV6RyxTQUFTO2dCQUNURSxZQUFZO2dCQUNaVSxRQUFRO2dCQUNSaEUsUUFBUThKO1lBQ1Y7WUFBRztnQkFDRCx3RUFBd0U7Z0JBQ3hFMUcsU0FBUztnQkFDVEUsWUFBWTtnQkFDWlUsUUFBUTtZQUNWO1lBQUc7Z0JBQ0QsNkVBQTZFO2dCQUM3RVosU0FBUztnQkFDVFksUUFBUTtnQkFDUmhFLFFBQVE7b0JBQ04sVUFBVThKLGFBQWFFLE1BQU07Z0JBQy9CO1lBQ0Y7U0FBRTtRQUNGLGVBQWU7WUFDYjVHLFNBQVNyRSxPQUFPLFNBQVM2SztZQUN6QmhNLE9BQU87UUFDVDtRQUNBLFlBQVlrTSxhQUFhRyxRQUFRO1FBQ2pDLFlBQVk7WUFDVjdHLFNBQVM7WUFDVEUsWUFBWTtRQUNkO1FBQ0EsV0FBVztZQUNURixTQUFTO1lBQ1RFLFlBQVk7UUFDZDtRQUNBLGlGQUFpRjtRQUNqRixXQUFXO1lBQ1RGLFNBQVM7WUFDVEUsWUFBWTtZQUNaLGdFQUFnRTtZQUNoRTFGLE9BQU87UUFDVDtRQUNBLFdBQVc7WUFDVHdGLFNBQVM7WUFDVEUsWUFBWTtRQUNkO1FBQ0EsbUJBQW1CO1lBQ2pCRixTQUFTO1lBQ1R4RixPQUFPO1FBQ1Q7UUFDQSxZQUFZO1lBQ1YsZ0RBQWdEO1lBQ2hEd0YsU0FBUztZQUNUcEQsUUFBUTtnQkFDTixtQkFBbUI7b0JBQ2pCb0QsU0FBUztvQkFDVHhGLE9BQU87Z0JBQ1Q7WUFDRjtRQUNGO1FBQ0EsZUFBZTtRQUNmLFVBQVU7WUFDUndGLFNBQVM7WUFDVEUsWUFBWTtRQUNkO0lBQ0Y7SUFDQXVHLG9CQUFvQjdKLE1BQU0sR0FBRzlDLE1BQU11QyxTQUFTLENBQUNzSyxJQUFJO0lBRWpELHFDQUFxQyxHQUNyQyxJQUFJRyxhQUFhO1FBQUM7UUFBVztRQUFpQjtRQUFpQjtRQUFlO1FBQWE7UUFBVTtRQUFlO1FBQVk7UUFBVztRQUFXO1FBQVc7UUFBbUI7UUFBWTtRQUFlO0tBQVM7SUFDeE4sSUFBSWxLLFNBQVM4SixhQUFhRyxRQUFRLENBQUMsRUFBRSxDQUFDakssTUFBTTtJQUM1QyxJQUFLLElBQUlsZSxJQUFJLEdBQUdBLElBQUlvb0IsV0FBVy9yQixNQUFNLEVBQUUyRCxJQUFLO1FBQzFDa2UsTUFBTSxDQUFDa0ssVUFBVSxDQUFDcG9CLEVBQUUsQ0FBQyxHQUFHb2IsTUFBTXVDLFNBQVMsQ0FBQ3NLLElBQUksQ0FBQ0csVUFBVSxDQUFDcG9CLEVBQUUsQ0FBQztJQUM3RDtJQUNBb2IsTUFBTXVDLFNBQVMsQ0FBQzBLLEVBQUUsR0FBR2pOLE1BQU11QyxTQUFTLENBQUNzSyxJQUFJO0lBQ3pDN00sTUFBTXVDLFNBQVMsQ0FBQzJLLEtBQUssR0FBR2xOLE1BQU11QyxTQUFTLENBQUNzSyxJQUFJO0FBQzlDLEdBQUc3TTtBQUNGLFVBQVVBLEtBQUs7SUFDZDs7Ozs7Ozs7O0dBU0MsR0FDRCxTQUFTNWlCLFFBQVE4b0IsT0FBTyxFQUFFaUgsWUFBWTtRQUNwQyxPQUFPakgsUUFBUTlvQixPQUFPLENBQUMsY0FBYyxTQUFVbWtCLENBQUMsRUFBRXJELEtBQUs7WUFDckQsT0FBTyxRQUFRaVAsWUFBWSxDQUFDLENBQUNqUCxNQUFNLEdBQUc7UUFDeEM7SUFDRjtJQUNBOzs7OztHQUtDLEdBQ0QsU0FBU2tQLEdBQUdsSCxPQUFPLEVBQUVpSCxZQUFZLEVBQUVuRyxLQUFLO1FBQ3RDLE9BQU9uRixPQUFPemtCLFFBQVE4b0IsU0FBU2lILGVBQWVuRyxTQUFTO0lBQ3pEO0lBRUE7Ozs7OztHQU1DLEdBQ0QsU0FBU3FHLE9BQU9uSCxPQUFPLEVBQUVvSCxTQUFTO1FBQ2hDLElBQUssSUFBSTFvQixJQUFJLEdBQUdBLElBQUkwb0IsV0FBVzFvQixJQUFLO1lBQ2xDc2hCLFVBQVVBLFFBQVE5b0IsT0FBTyxDQUFDLGFBQWE7Z0JBQ3JDLE9BQU8sUUFBUThvQixVQUFVO1lBQzNCO1FBQ0Y7UUFDQSxPQUFPQSxRQUFROW9CLE9BQU8sQ0FBQyxhQUFhO0lBQ3RDO0lBRUEsOEVBQThFO0lBQzlFLElBQUltd0IsZUFBZTtRQUNqQixxREFBcUQ7UUFDckR2b0IsTUFBTTtRQUNOLDRDQUE0QztRQUM1Q3dvQixpQkFBaUI7UUFDakIsc0JBQXNCO1FBQ3RCLHFFQUFxRTtRQUNyRUMsWUFBWTtRQUNaLHFCQUFxQjtRQUNyQmhWLE9BQU87SUFDVDtJQUVBLFdBQVc7SUFDWCxTQUFTaVYsa0JBQWtCQyxLQUFLO1FBQzlCLE9BQU8sV0FBV0EsTUFBTUMsSUFBSSxHQUFHeHdCLE9BQU8sQ0FBQyxNQUFNLE9BQU87SUFDdEQ7SUFDQSxJQUFJeXdCLDBCQUEwQkgsa0JBQWtCSCxhQUFhQyxlQUFlO0lBQzVFLElBQUlNLFdBQVdqTSxPQUFPNkwsa0JBQWtCSCxhQUFhdm9CLElBQUksR0FBRyxNQUFNdW9CLGFBQWFDLGVBQWUsR0FBRyxNQUFNRCxhQUFhRSxVQUFVLEdBQUcsTUFBTUYsYUFBYTlVLEtBQUs7SUFDekosSUFBSXNWLGtCQUFrQkwsa0JBQWtCSCxhQUFhQyxlQUFlLEdBQUcsTUFBTUQsYUFBYUUsVUFBVSxHQUFHLE1BQU1GLGFBQWE5VSxLQUFLO0lBQy9ILElBQUl1Vix3QkFBd0JOLGtCQUFrQkgsYUFBYXZvQixJQUFJLEdBQUcsTUFBTXVvQixhQUFhQyxlQUFlLEdBQUcsTUFBTUQsYUFBYTlVLEtBQUs7SUFFL0gsUUFBUTtJQUNSLElBQUl3VixVQUFVWixPQUFPLG1DQUFtQ3BHLE1BQU0sRUFBRSxJQUFJLHVHQUF1RztJQUMzSyxJQUFJaUgsY0FBY2IsT0FBTywwQkFBMEJwRyxNQUFNLEVBQUU7SUFDM0QsSUFBSTdqQixPQUFPLHFCQUFxQjZqQixNQUFNO0lBQ3RDLElBQUlrSCxjQUFjL3dCLFFBQVEscUJBQXFCNnBCLE1BQU0sRUFBRTtRQUFDN2pCO1FBQU02cUI7S0FBUTtJQUN0RSxJQUFJRyxhQUFhaHhCLFFBQVEsbUNBQW1DNnBCLE1BQU0sRUFBRTtRQUFDOEc7UUFBaUJJO0tBQVk7SUFDbEcsSUFBSWp0QixRQUFRLG1CQUFtQitsQixNQUFNO0lBQ3JDLElBQUlvSCw2QkFBNkJqeEIsUUFBUSx5Q0FBeUM2cEIsTUFBTSxFQUFFO1FBQUNtSDtRQUFZbHRCO0tBQU07SUFDN0csSUFBSW90QixlQUFlbHhCLFFBQVEsMkNBQTJDNnBCLE1BQU0sRUFBRTtRQUFDZ0g7UUFBU0M7UUFBYWh0QjtLQUFNO0lBQzNHLElBQUlxdEIsUUFBUW54QixRQUFRLHlCQUF5QjZwQixNQUFNLEVBQUU7UUFBQ3FIO0tBQWE7SUFDbkUsSUFBSUUsaUJBQWlCcHhCLFFBQVEsbURBQW1ENnBCLE1BQU0sRUFBRTtRQUFDc0g7UUFBT0g7UUFBWWx0QjtLQUFNO0lBQ2xILElBQUl1dEIsYUFBYTtRQUNmLFdBQVdYO1FBQ1gsZUFBZTtJQUNqQjtJQUVBLHVCQUF1QjtJQUN2QixnSUFBZ0k7SUFDaEksNkhBQTZIO0lBQzdILElBQUlsWSxZQUFZLDhDQUE4Q3FSLE1BQU0sRUFBRSxxQkFBcUI7SUFDM0YsSUFBSXlILGdCQUFnQix3QkFBd0J6SCxNQUFNO0lBQ2xELElBQUkwSCxpQkFBaUIsa0NBQWtDMUgsTUFBTTtJQUM3RGpILE1BQU11QyxTQUFTLENBQUNxTSxNQUFNLEdBQUc1TyxNQUFNdUMsU0FBUyxDQUFDSSxNQUFNLENBQUMsU0FBUztRQUN2RCxVQUFVO1lBQUM7Z0JBQ1R1RCxTQUFTa0gsR0FBRyxrQkFBa0JuRyxNQUFNLEVBQUU7b0JBQUMwSDtpQkFBZTtnQkFDdER2SSxZQUFZO2dCQUNaVSxRQUFRO1lBQ1Y7WUFBRztnQkFDRFosU0FBU2tILEdBQUcsbUJBQW1CbkcsTUFBTSxFQUFFO29CQUFDeUg7aUJBQWM7Z0JBQ3REdEksWUFBWTtnQkFDWlUsUUFBUTtZQUNWO1NBQUU7UUFDRixjQUFjO1lBQUM7Z0JBQ2IsZUFBZTtnQkFDZiw0QkFBNEI7Z0JBQzVCWixTQUFTa0gsR0FBRyxxQ0FBcUNuRyxNQUFNLEVBQUU7b0JBQUNtSDtpQkFBVztnQkFDckVoSSxZQUFZO2dCQUNadEQsUUFBUTJMO1lBQ1Y7WUFBRztnQkFDRCxxQkFBcUI7Z0JBQ3JCLHdDQUF3QztnQkFDeEN2SSxTQUFTa0gsR0FBRyx3Q0FBd0NuRyxNQUFNLEVBQUU7b0JBQUM3akI7b0JBQU1vckI7aUJBQWU7Z0JBQ2xGcEksWUFBWTtnQkFDWnRELFFBQVEyTDtZQUNWO1lBQUc7Z0JBQ0Qsc0JBQXNCO2dCQUN0Qix3Q0FBd0M7Z0JBQ3hDdkksU0FBU2tILEdBQUcsNEJBQTRCbkcsTUFBTSxFQUFFO29CQUFDN2pCO2lCQUFLO2dCQUN0RGdqQixZQUFZO1lBQ2Q7WUFBRztnQkFDRCxvQkFBb0I7Z0JBQ3BCLGtCQUFrQjtnQkFDbEIsMEJBQTBCO2dCQUMxQkYsU0FBU2tILEdBQUcsb0JBQW9CbkcsTUFBTSxFQUFFO29CQUFDNEc7b0JBQXlCTTtpQkFBWTtnQkFDOUUvSCxZQUFZO2dCQUNadEQsUUFBUTJMO1lBQ1Y7WUFBRztnQkFDRCxxQ0FBcUM7Z0JBQ3JDLGFBQWE7Z0JBQ2IsZ0VBQWdFO2dCQUNoRXZJLFNBQVNrSCxHQUFHLHlCQUF5Qm5HLE1BQU0sRUFBRTtvQkFBQ21IO2lCQUFXO2dCQUN6RGhJLFlBQVk7Z0JBQ1p0RCxRQUFRMkw7WUFDVjtZQUFHO2dCQUNELG9EQUFvRDtnQkFDcEQsb0JBQW9CO2dCQUNwQnZJLFNBQVNrSCxHQUFHLG9CQUFvQm5HLE1BQU0sRUFBRTtvQkFBQzdqQjtpQkFBSztnQkFDOUNnakIsWUFBWTtZQUNkO1lBQUc7Z0JBQ0Qsa0NBQWtDO2dCQUNsQyx1QkFBdUI7Z0JBQ3ZCLGtFQUFrRTtnQkFDbEVGLFNBQVNrSCxHQUFHLG1DQUFtQ25HLE1BQU0sRUFBRTtvQkFBQ29IO2lCQUEyQjtnQkFDbkZqSSxZQUFZO2dCQUNadEQsUUFBUTJMO1lBQ1Y7WUFBRztnQkFDRCw0Q0FBNEM7Z0JBQzVDLDZEQUE2RDtnQkFDN0R2SSxTQUFTa0gsR0FBRywyRUFBMkVuRyxNQUFNLEVBQUU7b0JBQUN1SDtvQkFBZ0JSO29CQUF1QjVxQjtpQkFBSztnQkFDNUkwZixRQUFRMkw7WUFDVjtTQUFFO1FBQ0YsV0FBV1g7UUFDWCxzSEFBc0g7UUFDdEgsVUFBVTtRQUNWLFlBQVk7UUFDWixlQUFlO0lBQ2pCO0lBQ0E5TixNQUFNdUMsU0FBUyxDQUFDTSxZQUFZLENBQUMsVUFBVSxVQUFVO1FBQy9DLFNBQVM7WUFDUHFELFNBQVM7WUFDVHhGLE9BQU87UUFDVDtJQUNGO0lBQ0FWLE1BQU11QyxTQUFTLENBQUNNLFlBQVksQ0FBQyxVQUFVLGVBQWU7UUFDcEQsbUJBQW1CO1lBQ2pCcUQsU0FBU2tILEdBQUcseUJBQXlCbkcsTUFBTSxFQUFFO2dCQUFDN2pCO2FBQUs7WUFDbkRnakIsWUFBWTtZQUNaMUYsT0FBTztRQUNUO0lBQ0Y7SUFDQVYsTUFBTXVDLFNBQVMsQ0FBQ00sWUFBWSxDQUFDLFVBQVUsY0FBYztRQUNuRCxhQUFhO1lBQ1gsdUJBQXVCO1lBQ3ZCLGlCQUFpQjtZQUNqQnFELFNBQVNrSCxHQUFHLCtEQUErRG5HLE1BQU0sRUFBRTtnQkFBQzdqQjthQUFLO1lBQ3pGZ2pCLFlBQVk7WUFDWnRELFFBQVE7Z0JBQ04sZUFBZTtZQUNqQjtRQUNGO1FBQ0EsbUJBQW1CO1lBQ2pCLDhDQUE4QztZQUM5Q29ELFNBQVNrSCxHQUFHLGtGQUFrRm5HLE1BQU0sRUFBRTtnQkFBQ2lIO2FBQVk7WUFDbkg5SCxZQUFZO1lBQ1oxRixPQUFPO1lBQ1BvQyxRQUFRMkw7UUFDVjtRQUNBLGVBQWU7WUFDYix5Q0FBeUM7WUFDekMsK0VBQStFO1lBQy9FLDBDQUEwQztZQUMxQ3ZJLFNBQVNrSCxHQUFHLCtEQUErRG5HLE1BQU0sRUFBRTtnQkFBQ3VIO2dCQUFnQko7YUFBVztZQUMvR3RMLFFBQVEyTDtZQUNSL04sT0FBTztRQUNUO1FBQ0EsMEJBQTBCO1lBQ3hCLDJCQUEyQjtZQUMzQndGLFNBQVNrSCxHQUFHLDhCQUE4Qm5HLE1BQU0sRUFBRTtnQkFBQ3VIO2FBQWU7WUFDbEVwSSxZQUFZO1lBQ1p0RCxRQUFRMkw7WUFDUi9OLE9BQU87UUFDVDtRQUNBOzs7OztNQUtFLEdBQ0Ysa0JBQWtCO1lBQ2hCLGFBQWE7WUFDYndGLFNBQVNrSCxHQUFHLHlCQUF5Qm5HLE1BQU0sRUFBRTtnQkFBQzdqQjtnQkFBTTZxQjthQUFRO1lBQzVEbkwsUUFBUTtnQkFDTixZQUFZc0ssR0FBRyxTQUFTbkcsTUFBTSxFQUFFO29CQUFDN2pCO2lCQUFLO2dCQUN0QyxXQUFXO29CQUNUOGlCLFNBQVNyRSxPQUFPb007b0JBQ2hCdk4sT0FBTztvQkFDUG9DLFFBQVEyTDtnQkFDVjtZQUNGO1FBQ0Y7UUFDQSxhQUFhO1lBQ1gsd0RBQXdEO1lBQ3hELG9DQUFvQztZQUNwQyw0QkFBNEI7WUFDNUJ2SSxTQUFTa0gsR0FBRyxrS0FBa0tuRyxNQUFNLEVBQUU7Z0JBQUM0RztnQkFBeUJNO2dCQUFhL3FCO2dCQUFNb3JCO2dCQUFnQlYsU0FBUzdHLE1BQU07Z0JBQUVpSDtnQkFBYSxrQkFBa0JqSCxNQUFNO2FBQUM7WUFDMVNiLFlBQVk7WUFDWnRELFFBQVE7Z0JBQ04sb0JBQW9CO29CQUNsQm9ELFNBQVNrSCxHQUFHLCtCQUErQm5HLE1BQU0sRUFBRTt3QkFBQ2tIO3dCQUFhRDtxQkFBWTtvQkFDN0U5SCxZQUFZO29CQUNaVSxRQUFRO29CQUNSaEUsUUFBUTlDLE1BQU11QyxTQUFTLENBQUNxTSxNQUFNO2dCQUNoQztnQkFDQSxXQUFXZDtnQkFDWCxjQUFjO29CQUNaNUgsU0FBU3JFLE9BQU8yTTtvQkFDaEIxSCxRQUFRO29CQUNSaEUsUUFBUTJMO2dCQUNWO2dCQUNBLGVBQWU7WUFDakI7UUFDRjtRQUNBLGdCQUFnQjtZQUNkdkksU0FBUztZQUNURSxZQUFZO1lBQ1oxRixPQUFPO1lBQ1BvQyxRQUFRO2dCQUNOLGdEQUFnRDtnQkFDaEQsYUFBYTtvQkFDWG9ELFNBQVM7b0JBQ1RFLFlBQVk7b0JBQ1oxRixPQUFPO2dCQUNUO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsYUFBYTtJQUNiLElBQUltTywyQkFBMkJILGdCQUFnQixNQUFNOVk7SUFDckQsSUFBSWtaLGtDQUFrQzF4QixRQUFRLGlFQUFpRTZwQixNQUFNLEVBQUU7UUFBQzRIO0tBQXlCO0lBQ2pKLElBQUlFLGtCQUFrQjFCLE9BQU9qd0IsUUFBUSwrQkFBK0I2cEIsTUFBTSxFQUFFO1FBQUM2SDtLQUFnQyxHQUFHO0lBRWhILDBHQUEwRztJQUMxRyxJQUFJRSxhQUFhLHdFQUF3RS9ILE1BQU07SUFDL0YsSUFBSWdJLE9BQU83eEIsUUFBUSwwQkFBMEI2cEIsTUFBTSxFQUFFO1FBQUNtSDtRQUFZVztLQUFnQjtJQUNsRi9PLE1BQU11QyxTQUFTLENBQUNNLFlBQVksQ0FBQyxVQUFVLGNBQWM7UUFDbkQsYUFBYTtZQUNYLGFBQWE7WUFDYix3RkFBd0Y7WUFDeEZxRCxTQUFTa0gsR0FBRyw2RUFBNkVuRyxNQUFNLEVBQUU7Z0JBQUMrSDtnQkFBWUM7YUFBSztZQUNuSDdJLFlBQVk7WUFDWlUsUUFBUTtZQUNSaEUsUUFBUTtnQkFDTixVQUFVO29CQUNSb0QsU0FBU2tILEdBQUcsaUJBQWlCbkcsTUFBTSxFQUFFO3dCQUFDK0g7cUJBQVc7b0JBQ2pEdE8sT0FBTztnQkFDVDtnQkFDQSx1QkFBdUI7b0JBQ3JCd0YsU0FBU2tILEdBQUcsYUFBYW5HLE1BQU0sRUFBRTt3QkFBQzhIO3FCQUFnQjtvQkFDbERqTSxRQUFROUMsTUFBTXVDLFNBQVMsQ0FBQ3FNLE1BQU07Z0JBQ2hDO2dCQUNBLGNBQWM7b0JBQ1oxSSxTQUFTckUsT0FBT3VNO29CQUNoQnRMLFFBQVE7d0JBQ04sZUFBZTtvQkFDakI7Z0JBQ0Y7Z0JBQ0EsZUFBZTtZQUNqQjtRQUNGO0lBQ0Y7SUFFQSx1QkFBdUI7SUFDdkIsSUFBSW9NLGVBQWUsYUFBYWpJLE1BQU07SUFDdEMsYUFBYTtJQUNiLElBQUlrSSxzQkFBc0I5QixPQUFPandCLFFBQVEsK0JBQStCNnBCLE1BQU0sRUFBRTtRQUFDNkg7S0FBZ0MsR0FBRztJQUNwSCxJQUFJTSxpQkFBaUJoeUIsUUFBUSxxQ0FBcUM2cEIsTUFBTSxFQUFFO1FBQUNrSTtRQUFxQkQ7S0FBYTtJQUM3RyxjQUFjO0lBQ2QsSUFBSUcsc0JBQXNCaEMsT0FBT2p3QixRQUFRLG1FQUFtRTZwQixNQUFNLEVBQUU7UUFBQzRIO0tBQXlCLEdBQUc7SUFDakosSUFBSVMsaUJBQWlCbHlCLFFBQVEscUNBQXFDNnBCLE1BQU0sRUFBRTtRQUFDb0k7UUFBcUJIO0tBQWE7SUFDN0csU0FBU0ssMEJBQTBCQyxhQUFhLEVBQUVDLGtCQUFrQjtRQUNsRSxPQUFPO1lBQ0wsaUJBQWlCO2dCQUNmdkosU0FBU2tILEdBQUcsNkJBQTZCbkcsTUFBTSxFQUFFO29CQUFDdUk7aUJBQWM7Z0JBQ2hFcEosWUFBWTtnQkFDWnRELFFBQVE7b0JBQ04saUJBQWlCO3dCQUNmb0QsU0FBU2tILEdBQUcsc0NBQXNDbkcsTUFBTSxFQUFFOzRCQUFDd0k7NEJBQW9CUDt5QkFBYTt3QkFDNUY5SSxZQUFZO3dCQUNadEQsUUFBUTs0QkFDTixlQUFlO3dCQUNqQjtvQkFDRjtvQkFDQSxlQUFlO29CQUNmLGNBQWM7d0JBQ1pvRCxTQUFTO3dCQUNUeEYsT0FBTzt3QkFDUG9DLFFBQVE5QyxNQUFNdUMsU0FBUyxDQUFDcU0sTUFBTTtvQkFDaEM7Z0JBQ0Y7WUFDRjtZQUNBLFVBQVU7UUFDWjtJQUNGO0lBQ0E1TyxNQUFNdUMsU0FBUyxDQUFDTSxZQUFZLENBQUMsVUFBVSxVQUFVO1FBQy9DLHdCQUF3QjtZQUFDO2dCQUN2QnFELFNBQVNrSCxHQUFHLDREQUE0RG5HLE1BQU0sRUFBRTtvQkFBQ21JO2lCQUFlO2dCQUNoR2hKLFlBQVk7Z0JBQ1pVLFFBQVE7Z0JBQ1JoRSxRQUFReU0sMEJBQTBCSCxnQkFBZ0JEO1lBQ3BEO1lBQUc7Z0JBQ0RqSixTQUFTa0gsR0FBRyw0Q0FBNENuRyxNQUFNLEVBQUU7b0JBQUNxSTtpQkFBZTtnQkFDaEZsSixZQUFZO2dCQUNaVSxRQUFRO2dCQUNSaEUsUUFBUXlNLDBCQUEwQkQsZ0JBQWdCRDtZQUNwRDtTQUFFO1FBQ0YsUUFBUTtZQUNObkosU0FBU3JFLE9BQU9qTTtZQUNoQmtSLFFBQVE7UUFDVjtJQUNGO0lBQ0E5RyxNQUFNdUMsU0FBUyxDQUFDbU4sTUFBTSxHQUFHMVAsTUFBTXVDLFNBQVMsQ0FBQ29OLEVBQUUsR0FBRzNQLE1BQU11QyxTQUFTLENBQUNxTSxNQUFNO0FBQ3RFLEdBQUc1TztBQUNIQSxNQUFNdUMsU0FBUyxDQUFDaUcsTUFBTSxHQUFHO0lBQ3ZCLFdBQVc7UUFDVHRDLFNBQVM7UUFDVFksUUFBUTtJQUNWO0lBQ0EsVUFBVTtRQUNSWixTQUFTO1FBQ1RZLFFBQVE7SUFDVjtJQUNBLFdBQVc7UUFDVCw0Q0FBNEM7UUFDNUNaLFNBQVM7UUFDVFksUUFBUTtRQUNSaEUsUUFBUTtZQUNOLG1CQUFtQjtnQkFDakJvRCxTQUFTO2dCQUNURSxZQUFZO2dCQUNaVSxRQUFRO2dCQUNSaEUsUUFBUSxLQUFLLFlBQVk7WUFDM0I7WUFFQSxVQUFVO2dCQUNSb0QsU0FBUztnQkFDVFksUUFBUTtZQUNWO1lBQ0EsZUFBZTtZQUNmLGVBQWU7WUFDZixRQUFRO1FBQ1Y7SUFDRjtJQUNBLFNBQVM7UUFDUFosU0FBUztRQUNUWSxRQUFRO0lBQ1Y7SUFDQSxPQUFPO1FBQ0xaLFNBQVM7UUFDVFksUUFBUTtRQUNSaEUsUUFBUTtZQUNOLE9BQU87Z0JBQ0xvRCxTQUFTO2dCQUNUcEQsUUFBUTtvQkFDTixlQUFlO29CQUNmLGFBQWE7Z0JBQ2Y7WUFDRjtZQUNBLGdCQUFnQixFQUFFO1lBQ2xCLGNBQWM7Z0JBQ1pvRCxTQUFTO2dCQUNUcEQsUUFBUTtvQkFDTixlQUFlO3dCQUFDOzRCQUNkb0QsU0FBUzs0QkFDVHhGLE9BQU87d0JBQ1Q7d0JBQUc7NEJBQ0R3RixTQUFTOzRCQUNURSxZQUFZO3dCQUNkO3FCQUFFO2dCQUNKO1lBQ0Y7WUFDQSxlQUFlO1lBQ2YsYUFBYTtnQkFDWEYsU0FBUztnQkFDVHBELFFBQVE7b0JBQ04sYUFBYTtnQkFDZjtZQUNGO1FBQ0Y7SUFDRjtJQUNBLFVBQVU7UUFBQztZQUNUb0QsU0FBUztZQUNUeEYsT0FBTztRQUNUO1FBQUc7S0FBcUI7QUFDMUI7QUFDQVYsTUFBTXVDLFNBQVMsQ0FBQ2lHLE1BQU0sQ0FBQyxNQUFNLENBQUMxRixNQUFNLENBQUMsYUFBYSxDQUFDQSxNQUFNLENBQUMsU0FBUyxHQUFHOUMsTUFBTXVDLFNBQVMsQ0FBQ2lHLE1BQU0sQ0FBQyxTQUFTO0FBQ3RHeEksTUFBTXVDLFNBQVMsQ0FBQ2lHLE1BQU0sQ0FBQyxVQUFVLENBQUMxRixNQUFNLENBQUMsa0JBQWtCLENBQUNBLE1BQU0sR0FBRzlDLE1BQU11QyxTQUFTLENBQUNpRyxNQUFNO0FBRTNGLDBFQUEwRTtBQUMxRXhJLE1BQU1pRSxLQUFLLENBQUN6ZCxHQUFHLENBQUMsUUFBUSxTQUFVdWQsR0FBRztJQUNuQyxJQUFJQSxJQUFJL2UsSUFBSSxLQUFLLFVBQVU7UUFDekIrZSxJQUFJdlIsVUFBVSxDQUFDLFFBQVEsR0FBR3VSLElBQUl2akIsT0FBTyxDQUFDcEQsT0FBTyxDQUFDLFNBQVM7SUFDekQ7QUFDRjtBQUNBdUosT0FBT29hLGNBQWMsQ0FBQ2YsTUFBTXVDLFNBQVMsQ0FBQ2lHLE1BQU0sQ0FBQzlWLEdBQUcsRUFBRSxjQUFjO0lBQzlEOzs7Ozs7Ozs7O0dBVUMsR0FDRC9NLE9BQU8sU0FBUzhpQixXQUFXQyxPQUFPLEVBQUV2SSxJQUFJO1FBQ3RDLElBQUl3SSxzQkFBc0IsQ0FBQztRQUMzQkEsbUJBQW1CLENBQUMsY0FBY3hJLEtBQUssR0FBRztZQUN4QytGLFNBQVM7WUFDVEUsWUFBWTtZQUNadEQsUUFBUTlDLE1BQU11QyxTQUFTLENBQUNwQyxLQUFLO1FBQy9CO1FBQ0F3SSxtQkFBbUIsQ0FBQyxRQUFRLEdBQUc7UUFDL0IsSUFBSTdGLFNBQVM7WUFDWCxrQkFBa0I7Z0JBQ2hCb0QsU0FBUztnQkFDVHBELFFBQVE2RjtZQUNWO1FBQ0Y7UUFDQTdGLE1BQU0sQ0FBQyxjQUFjM0MsS0FBSyxHQUFHO1lBQzNCK0YsU0FBUztZQUNUcEQsUUFBUTlDLE1BQU11QyxTQUFTLENBQUNwQyxLQUFLO1FBQy9CO1FBQ0EsSUFBSXlJLE1BQU0sQ0FBQztRQUNYQSxHQUFHLENBQUNGLFFBQVEsR0FBRztZQUNieEMsU0FBU3JFLE9BQU8sd0ZBQXdGb0YsTUFBTSxDQUFDN3BCLE9BQU8sQ0FBQyxPQUFPO2dCQUM1SCxPQUFPc3JCO1lBQ1QsSUFBSTtZQUNKdEMsWUFBWTtZQUNaVSxRQUFRO1lBQ1JoRSxRQUFRQTtRQUNWO1FBQ0E5QyxNQUFNdUMsU0FBUyxDQUFDTSxZQUFZLENBQUMsVUFBVSxTQUFTK0Y7SUFDbEQ7QUFDRjtBQUNBamlCLE9BQU9vYSxjQUFjLENBQUNmLE1BQU11QyxTQUFTLENBQUNpRyxNQUFNLENBQUM5VixHQUFHLEVBQUUsZ0JBQWdCO0lBQ2hFOzs7Ozs7Ozs7O0dBVUMsR0FDRC9NLE9BQU8sU0FBVWtqQixRQUFRLEVBQUUxSSxJQUFJO1FBQzdCSCxNQUFNdUMsU0FBUyxDQUFDaUcsTUFBTSxDQUFDOVYsR0FBRyxDQUFDb1EsTUFBTSxDQUFDLGVBQWUsQ0FBQzdiLElBQUksQ0FBQztZQUNyRGlmLFNBQVNyRSxPQUFPLGFBQWFvRixNQUFNLEdBQUcsUUFBUTRCLFdBQVcsTUFBTSxpREFBaUQ1QixNQUFNLEVBQUU7WUFDeEhiLFlBQVk7WUFDWnRELFFBQVE7Z0JBQ04sYUFBYTtnQkFDYixjQUFjO29CQUNab0QsU0FBUztvQkFDVHBELFFBQVE7d0JBQ04sU0FBUzs0QkFDUG9ELFNBQVM7NEJBQ1RFLFlBQVk7NEJBQ1oxRixPQUFPO2dDQUFDUDtnQ0FBTSxjQUFjQTs2QkFBSzs0QkFDakMyQyxRQUFROUMsTUFBTXVDLFNBQVMsQ0FBQ3BDLEtBQUs7d0JBQy9CO3dCQUNBLGVBQWU7NEJBQUM7Z0NBQ2QrRixTQUFTO2dDQUNUeEYsT0FBTzs0QkFDVDs0QkFBRzt5QkFBTTtvQkFDWDtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBQ0FWLE1BQU11QyxTQUFTLENBQUN1RyxJQUFJLEdBQUc5SSxNQUFNdUMsU0FBUyxDQUFDaUcsTUFBTTtBQUM3Q3hJLE1BQU11QyxTQUFTLENBQUN3RyxNQUFNLEdBQUcvSSxNQUFNdUMsU0FBUyxDQUFDaUcsTUFBTTtBQUMvQ3hJLE1BQU11QyxTQUFTLENBQUN5RyxHQUFHLEdBQUdoSixNQUFNdUMsU0FBUyxDQUFDaUcsTUFBTTtBQUM1Q3hJLE1BQU11QyxTQUFTLENBQUMwRyxHQUFHLEdBQUdqSixNQUFNdUMsU0FBUyxDQUFDSSxNQUFNLENBQUMsVUFBVSxDQUFDO0FBQ3hEM0MsTUFBTXVDLFNBQVMsQ0FBQzJHLElBQUksR0FBR2xKLE1BQU11QyxTQUFTLENBQUMwRyxHQUFHO0FBQzFDakosTUFBTXVDLFNBQVMsQ0FBQzRHLElBQUksR0FBR25KLE1BQU11QyxTQUFTLENBQUMwRyxHQUFHO0FBQzFDakosTUFBTXVDLFNBQVMsQ0FBQzZHLEdBQUcsR0FBR3BKLE1BQU11QyxTQUFTLENBQUMwRyxHQUFHO0FBQ3hDLFVBQVVqSixLQUFLO0lBQ2QsSUFBSXFKLFNBQVM7SUFDYnJKLE1BQU11QyxTQUFTLENBQUMrRyxHQUFHLEdBQUc7UUFDcEIsV0FBVztRQUNYLFVBQVU7WUFDUnBELFNBQVNyRSxPQUFPLGVBQWUsc0JBQXNCb0YsTUFBTSxHQUFHLE1BQU1vQyxPQUFPcEMsTUFBTSxHQUFHLFFBQVEsa0JBQWtCQSxNQUFNO1lBQ3BIbkUsUUFBUTtnQkFDTixRQUFRO2dCQUNSLDhCQUE4QjtvQkFDNUJvRCxTQUFTO29CQUNURSxZQUFZO29CQUNaMUYsT0FBTztnQkFDVDtnQkFDQSxXQUFXO29CQUNUd0YsU0FBUztvQkFDVEUsWUFBWTtnQkFDZDtZQUVGO1FBQ0Y7UUFFQSxPQUFPO1lBQ0wsOENBQThDO1lBQzlDRixTQUFTckUsT0FBTyxpQkFBaUJ3SCxPQUFPcEMsTUFBTSxHQUFHLE1BQU0sOEJBQThCQSxNQUFNLEdBQUcsUUFBUTtZQUN0R0gsUUFBUTtZQUNSaEUsUUFBUTtnQkFDTixZQUFZO2dCQUNaLGVBQWU7Z0JBQ2YsVUFBVTtvQkFDUm9ELFNBQVNyRSxPQUFPLE1BQU13SCxPQUFPcEMsTUFBTSxHQUFHO29CQUN0Q3ZHLE9BQU87Z0JBQ1Q7WUFDRjtRQUNGO1FBQ0EsWUFBWTtZQUNWd0YsU0FBU3JFLE9BQU8sdURBQXVEd0gsT0FBT3BDLE1BQU0sR0FBRztZQUN2RmIsWUFBWTtRQUNkO1FBQ0EsVUFBVTtZQUNSRixTQUFTbUQ7WUFDVHZDLFFBQVE7UUFDVjtRQUNBLFlBQVk7WUFDVlosU0FBUztZQUNURSxZQUFZO1FBQ2Q7UUFDQSxhQUFhO1FBQ2IsWUFBWTtZQUNWRixTQUFTO1lBQ1RFLFlBQVk7UUFDZDtRQUNBLGVBQWU7SUFDakI7SUFDQXBHLE1BQU11QyxTQUFTLENBQUMrRyxHQUFHLENBQUMsU0FBUyxDQUFDeEcsTUFBTSxDQUFDdFAsSUFBSSxHQUFHd00sTUFBTXVDLFNBQVMsQ0FBQytHLEdBQUc7SUFDL0QsSUFBSWQsU0FBU3hJLE1BQU11QyxTQUFTLENBQUNpRyxNQUFNO0lBQ25DLElBQUlBLFFBQVE7UUFDVkEsT0FBTzlWLEdBQUcsQ0FBQytWLFVBQVUsQ0FBQyxTQUFTO1FBQy9CRCxPQUFPOVYsR0FBRyxDQUFDNlcsWUFBWSxDQUFDLFNBQVM7SUFDbkM7QUFDRixHQUFHdko7QUFDRixVQUFVQSxLQUFLO0lBQ2RBLE1BQU11QyxTQUFTLENBQUNxTixJQUFJLEdBQUc7UUFDckIsU0FBUztZQUNULHNFQUFzRTtZQUN0RTtZQUNBLGlEQUFpRDtZQUNqRDtZQUNBLDJEQUEyRDtZQUMzRDtTQUFVO0lBR1o7SUFFQTs7OztHQUlDLEdBQ0QsSUFBSUMsV0FBVztRQUNiLGdCQUFnQjtRQUNoQixpQkFBaUI7UUFDakIsaUJBQWlCO1FBQ2pCLGtCQUFrQjtRQUNsQixhQUFhO1FBQ2IsUUFBUTtJQUNWO0lBRUEsOEJBQThCO0lBQzlCbHBCLE9BQU93SSxJQUFJLENBQUMwZ0IsVUFBVXpPLE9BQU8sQ0FBQyxTQUFVaGUsSUFBSTtRQUMxQyxJQUFJNkksU0FBUzRqQixRQUFRLENBQUN6c0IsS0FBSztRQUMzQixJQUFJc2QsUUFBUSxFQUFFO1FBQ2QsSUFBSSxDQUFDLFFBQVE5aUIsSUFBSSxDQUFDd0YsT0FBTztZQUN2Qiw4QkFBOEI7WUFDOUJzZCxNQUFNelosSUFBSSxDQUFDLE1BQU11YSxJQUFJLENBQUNwZSxLQUFLLENBQUMsRUFBRTtRQUNoQztRQUNBLElBQUlBLFNBQVMsUUFBUTtZQUNuQnNkLE1BQU16WixJQUFJLENBQUM7UUFDYjtRQUNBK1ksTUFBTXVDLFNBQVMsQ0FBQ3FOLElBQUksQ0FBQ3hzQixLQUFLLEdBQUc7WUFDM0I4aUIsU0FBU3JFLE9BQU8sVUFBVTVWLFNBQVMsa0NBQWtDO1lBQ3JFeVUsT0FBT0E7WUFDUG9DLFFBQVE7Z0JBQ04sUUFBUTtvQkFDTm9ELFNBQVM7b0JBQ1RFLFlBQVk7Z0JBQ2Q7Z0JBQ0EsVUFBVTtvQkFDUkYsU0FBUztvQkFDVHhGLE9BQU8sTUFBTWMsSUFBSSxDQUFDcGUsS0FBSyxDQUFDLEVBQUU7Z0JBQzVCO1lBQ0Y7UUFDRjtJQUNGO0lBRUEseUNBQXlDO0lBQ3pDdUQsT0FBT29hLGNBQWMsQ0FBQ2YsTUFBTXVDLFNBQVMsQ0FBQ3FOLElBQUksRUFBRSxZQUFZO1FBQ3REanFCLE9BQU9rcUI7SUFDVDtBQUNGLEdBQUc3UDtBQUNIQSxNQUFNdUMsU0FBUyxDQUFDdU4sRUFBRSxHQUFHOVAsTUFBTXVDLFNBQVMsQ0FBQ0ksTUFBTSxDQUFDLFNBQVM7SUFDbkQsVUFBVTtRQUNSdUQsU0FBUztRQUNURSxZQUFZO1FBQ1pVLFFBQVE7SUFDVjtJQUNBLFdBQVc7SUFDWCxXQUFXO0lBQ1gsVUFBVTtRQUNWLDRCQUE0QjtRQUM1QjtRQUNBLGtDQUFrQztRQUNsQztRQUNBLDhCQUE4QjtRQUM5QjtLQUFxRTtJQUNyRSxZQUFZO0lBQ1osV0FBVztBQUNiO0FBQ0E5RyxNQUFNdUMsU0FBUyxDQUFDTSxZQUFZLENBQUMsTUFBTSxVQUFVO0lBQzNDLFFBQVE7UUFDTnFELFNBQVM7UUFDVFksUUFBUTtJQUNWO0FBQ0Y7QUFDQSxPQUFPOUcsTUFBTXVDLFNBQVMsQ0FBQ3VOLEVBQUUsQ0FBQyxhQUFhO0FBQ3ZDOVAsTUFBTXVDLFNBQVMsQ0FBQ3dOLEdBQUcsR0FBRztJQUNwQjs7OztHQUlDLEdBRUQsV0FBVztRQUNUN0osU0FBUztRQUNURSxZQUFZO0lBQ2Q7SUFDQSxXQUFXO1FBQ1RGLFNBQVM7UUFDVEUsWUFBWTtRQUNadEQsUUFBUTtZQUNOLGdCQUFnQjtnQkFDZG9ELFNBQVM7Z0JBQ1RFLFlBQVk7Z0JBQ1oxRixPQUFPO1lBQ1Q7WUFDQSxlQUFlO1FBQ2pCO0lBQ0Y7SUFDQSxPQUFPO1FBQ0x3RixTQUFTO1FBQ1RFLFlBQVk7UUFDWjFGLE9BQU87SUFDVDtJQUNBLFNBQVM7UUFDUHdGLFNBQVM7UUFDVEUsWUFBWTtRQUNaMUYsT0FBTztRQUNQb0MsUUFBUTtZQUNOLGVBQWU7Z0JBQ2JvRCxTQUFTO2dCQUNURSxZQUFZO1lBQ2Q7UUFDRjtJQUNGO0lBQ0EsZUFBZTtBQUNqQjtBQUNDLFVBQVVwRyxLQUFLO0lBQ2QsSUFBSThOLFdBQVc7SUFFZixzREFBc0Q7SUFDdEQsSUFBSWtDLGtCQUFrQiw2Q0FBNkMvSSxNQUFNO0lBRXpFLHVDQUF1QztJQUN2QyxJQUFJeEYsWUFBWTtRQUNkeUUsU0FBU3JFLE9BQU8sYUFBYW9GLE1BQU0sR0FBRytJLGtCQUFrQixnQ0FBZ0MvSSxNQUFNO1FBQzlGYixZQUFZO1FBQ1p0RCxRQUFRO1lBQ04sYUFBYTtnQkFDWG9ELFNBQVM7Z0JBQ1RwRCxRQUFRO29CQUNOLGVBQWU7Z0JBQ2pCO1lBQ0Y7WUFDQSxlQUFlO1FBQ2pCO0lBQ0Y7SUFDQTlDLE1BQU11QyxTQUFTLENBQUMwTixJQUFJLEdBQUdqUSxNQUFNdUMsU0FBUyxDQUFDSSxNQUFNLENBQUMsU0FBUztRQUNyRCxVQUFVO1lBQ1J1RCxTQUFTO1lBQ1RFLFlBQVk7WUFDWlUsUUFBUTtRQUNWO1FBQ0EsY0FBYztZQUFDckY7WUFBVztnQkFDeEIsb0RBQW9EO2dCQUNwRCx3SEFBd0g7Z0JBQ3hIeUUsU0FBU3JFLE9BQU8sYUFBYW9GLE1BQU0sR0FBRytJLGtCQUFrQiwrREFBK0QvSSxNQUFNO2dCQUM3SGIsWUFBWTtnQkFDWnRELFFBQVFyQixVQUFVcUIsTUFBTTtZQUMxQjtZQUFHO2dCQUNELCtCQUErQjtnQkFDL0Isd0hBQXdIO2dCQUN4SG9ELFNBQVNyRSxPQUFPLGtGQUFrRm9GLE1BQU0sR0FBRytJLGtCQUFrQixhQUFhL0ksTUFBTTtnQkFDaEpiLFlBQVk7Z0JBQ1p0RCxRQUFRckIsVUFBVXFCLE1BQU07WUFDMUI7U0FBRTtRQUNGLFdBQVdnTDtRQUNYLFlBQVk7WUFBQzlOLE1BQU11QyxTQUFTLENBQUNpSCxLQUFLLENBQUMwRyxRQUFRO1lBQUU7Z0JBQzNDaEssU0FBUztnQkFDVEUsWUFBWTtZQUNkO1NBQUU7UUFDRixVQUFVO1FBQ1YsWUFBWTtZQUNWRixTQUFTO1lBQ1RFLFlBQVk7UUFDZDtRQUNBLFlBQVk7SUFDZDtJQUNBcEcsTUFBTXVDLFNBQVMsQ0FBQ00sWUFBWSxDQUFDLFFBQVEsVUFBVTtRQUM3Qyx3QkFBd0I7WUFDdEIsK0NBQStDO1lBQy9DcUQsU0FBUztZQUNUWSxRQUFRO1lBQ1JwRyxPQUFPO1FBQ1Q7UUFDQSxRQUFRO1lBQ053RixTQUFTO1lBQ1RZLFFBQVE7UUFDVjtJQUNGO0lBQ0E5RyxNQUFNdUMsU0FBUyxDQUFDTSxZQUFZLENBQUMsUUFBUSxjQUFjO1FBQ2pELGNBQWM7WUFDWnFELFNBQVM7WUFDVEUsWUFBWTtZQUNaMUYsT0FBTztRQUNUO1FBQ0EsWUFBWTtZQUNWd0YsU0FBUztZQUNUcEQsUUFBUTtnQkFDTixjQUFjckI7Z0JBQ2QsV0FBV3FNO2dCQUNYLGVBQWU7Z0JBQ2YsWUFBWTtZQUNkO1FBQ0Y7UUFDQSxVQUFVO1lBQUM7Z0JBQ1Q1SCxTQUFTckUsT0FBTyxnQkFBZ0JvRixNQUFNLEdBQUcrSSxrQkFBa0IsMEJBQTBCL0ksTUFBTTtnQkFDM0ZiLFlBQVk7Z0JBQ1p0RCxRQUFRO29CQUNOLGFBQWFyQixVQUFVcUIsTUFBTSxDQUFDcU4sU0FBUztvQkFDdkMsZUFBZTtvQkFDZixZQUFZO29CQUNaLGNBQWM7Z0JBQ2hCO1lBQ0Y7WUFBRztnQkFDRGpLLFNBQVNyRSxPQUFPLHlCQUF5Qm9GLE1BQU0sR0FBRytJLGtCQUFrQixxQkFBcUIvSSxNQUFNO2dCQUMvRmIsWUFBWTtnQkFDWjFGLE9BQU87Z0JBQ1BvQyxRQUFRO29CQUNOLGFBQWFyQixVQUFVcUIsTUFBTSxDQUFDcU4sU0FBUztvQkFDdkMsVUFBVTtvQkFDVixlQUFlO29CQUNmLFlBQVk7b0JBQ1osY0FBYztnQkFDaEI7WUFDRjtTQUFFO1FBQ0YsYUFBYTtZQUNYakssU0FBU3JFLE9BQU8scUpBQXFKb0YsTUFBTSxDQUFDN3BCLE9BQU8sQ0FBQyxjQUFjO2dCQUNoTSxPQUFPMHdCLFNBQVM3RyxNQUFNO1lBQ3hCO1lBQ0FiLFlBQVk7WUFDWnRELFFBQVE7Z0JBQ04sZUFBZTtZQUNqQjtRQUNGO0lBQ0Y7QUFDRixHQUFHOUM7QUFDRixVQUFVQSxLQUFLO0lBQ2QsSUFBSW9RLGdCQUFnQjtRQUNsQmxLLFNBQVM7UUFDVHhGLE9BQU87SUFDVDtJQUNBLElBQUkyUCxTQUFTO0lBQ2IsSUFBSUMsVUFBVTtRQUNacEssU0FBUztRQUNUeEYsT0FBTztJQUNUO0lBQ0EsSUFBSTZQLG9CQUFvQjtRQUN0QnJLLFNBQVM7UUFDVHhGLE9BQU87SUFDVDtJQUNBLElBQUk4UCxZQUFZLGlCQUFpQkgsT0FBT3BKLE1BQU0sR0FBRztJQUNqRCxJQUFJNUgsUUFBUXdDLE9BQU8yTyxZQUFZLE1BQU1BO0lBRXJDLGdDQUFnQztJQUNoQyxJQUFJQyxZQUFZO1FBQ2R2SyxTQUFTO1FBQ1RFLFlBQVk7UUFDWjFGLE9BQU87SUFDVDtJQUNBVixNQUFNdUMsU0FBUyxDQUFDbUgsS0FBSyxHQUFHO1FBQ3RCLGNBQWM7WUFDWnhELFNBQVM7WUFDVEUsWUFBWTtZQUNadEQsUUFBUTtnQkFDTix1QkFBdUI7b0JBQ3JCb0QsU0FBUztvQkFDVEUsWUFBWTtvQkFDWjFGLE9BQU87Z0JBQ1Q7Z0JBQ0EsMEJBQTBCO29CQUN4QndGLFNBQVM7b0JBQ1R4RixPQUFPO2dCQUNUO2dCQUNBLFNBQVM7b0JBQ1B3RixTQUFTN0c7b0JBQ1R5RCxRQUFRO3dCQUNOLFVBQVV1Tjt3QkFDVixxQkFBcUI7NEJBQ25CbkssU0FBUzs0QkFDVHhGLE9BQU87d0JBQ1Q7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0Esa0JBQWtCMFA7Z0JBQ2xCLFlBQVlHO2dCQUNaLFVBQVVGO1lBQ1o7UUFDRjtRQUNBLGtCQUFrQkQ7UUFDbEIsWUFBWUU7UUFDWixpQkFBaUI7WUFBQztnQkFDaEIsK0NBQStDO2dCQUMvQ3BLLFNBQVM7Z0JBQ1R4RixPQUFPO1lBQ1Q7WUFBRztnQkFDRHdGLFNBQVM7Z0JBQ1R4RixPQUFPO2dCQUNQb0MsUUFBUTtvQkFDTixjQUFjMk47Z0JBQ2hCO1lBQ0Y7U0FBRTtRQUNGLFVBQVU7WUFDUnZLLFNBQVM7WUFDVHhGLE9BQU87UUFDVDtRQUNBLFVBQVUyUDtRQUNWLFNBQVM7WUFBQztnQkFDUiwwRUFBMEU7Z0JBQzFFLHNKQUFzSjtnQkFFdEosbUZBQW1GO2dCQUNuRm5LLFNBQVM7Z0JBQ1R4RixPQUFPO2dCQUNQb0MsUUFBUTtvQkFDTixjQUFjMk47Z0JBQ2hCO1lBQ0Y7WUFBRztnQkFDRHZLLFNBQVM7Z0JBQ1R4RixPQUFPO1lBQ1Q7U0FBRTtRQUNGLGNBQWM7WUFDWndGLFNBQVM7WUFDVHhGLE9BQU87UUFDVDtRQUNBLGVBQWU7WUFDYndGLFNBQVM7WUFDVHhGLE9BQU87UUFDVDtJQUNGO0FBQ0YsR0FBR1Y7QUFDSEEsTUFBTXVDLFNBQVMsQ0FBQ2tILFVBQVUsR0FBR3pKLE1BQU11QyxTQUFTLENBQUNJLE1BQU0sQ0FBQyxTQUFTO0lBQzNELGNBQWM7UUFBQzNDLE1BQU11QyxTQUFTLENBQUNpSCxLQUFLLENBQUMsYUFBYTtRQUFFO1lBQ2xEdEQsU0FBUztZQUNURSxZQUFZO1FBQ2Q7S0FBRTtJQUNGLFdBQVc7UUFBQztZQUNWRixTQUFTO1lBQ1RFLFlBQVk7UUFDZDtRQUFHO1lBQ0RGLFNBQVM7WUFDVEUsWUFBWTtRQUNkO0tBQUU7SUFDRiw4RUFBOEU7SUFDOUUsWUFBWTtJQUNaLFVBQVU7UUFDUkYsU0FBU3JFLE9BQU8sYUFBYW9GLE1BQU0sR0FBRyxRQUN0QyxXQUFXO1FBQ1gsZ0JBQWVBLE1BQU0sR0FBRyxNQUN4QixpQkFBaUI7UUFDakIsMEJBQTBCQSxNQUFNLEdBQUcsTUFDbkMsZ0JBQWdCO1FBQ2hCLDRCQUE0QkEsTUFBTSxHQUFHLE1BQ3JDLHNCQUFzQjtRQUN0QixzQ0FBc0NBLE1BQU0sR0FBRyxNQUMvQyxpQkFBaUI7UUFDakIsZ0JBQWdCQSxNQUFNLEdBQUcsTUFDekIsa0RBQWtEO1FBQ2xELG9GQUFvRkEsTUFBTSxJQUFJLE1BQU0sWUFBWUEsTUFBTTtRQUN0SGIsWUFBWTtJQUNkO0lBQ0EsWUFBWTtBQUNkO0FBQ0FwRyxNQUFNdUMsU0FBUyxDQUFDa0gsVUFBVSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUN2RCxPQUFPLEdBQUc7QUFDdERsRyxNQUFNdUMsU0FBUyxDQUFDTSxZQUFZLENBQUMsY0FBYyxXQUFXO0lBQ3BELFNBQVM7UUFDUHFELFNBQVNyRSxPQUNULGFBQWE7UUFDYixxRUFBcUU7UUFDckUsMERBQTBEb0YsTUFBTSxHQUNoRSxpQkFBaUI7UUFDakIsdUdBQXVHO1FBQ3ZHLHVHQUF1RztRQUN2Ryx5RUFBeUU7UUFDekUsS0FBS0EsTUFBTSxHQUFHLFFBQVEsaUVBQWlFQSxNQUFNLEdBQUcsTUFDaEcsdUVBQXVFO1FBQ3ZFLHFJQUFxSUEsTUFBTSxHQUFHLE1BQzlJLFlBQVk7UUFDWixrRUFBa0VBLE1BQU07UUFDeEViLFlBQVk7UUFDWlUsUUFBUTtRQUNSaEUsUUFBUTtZQUNOLGdCQUFnQjtnQkFDZG9ELFNBQVM7Z0JBQ1RFLFlBQVk7Z0JBQ1oxRixPQUFPO2dCQUNQb0MsUUFBUTlDLE1BQU11QyxTQUFTLENBQUNtSCxLQUFLO1lBQy9CO1lBQ0EsbUJBQW1CO1lBQ25CLGVBQWU7UUFDakI7SUFDRjtJQUNBLHlGQUF5RjtJQUN6RixxQkFBcUI7UUFDbkJ4RCxTQUFTO1FBQ1R4RixPQUFPO0lBQ1Q7SUFDQSxhQUFhO1FBQUM7WUFDWndGLFNBQVM7WUFDVEUsWUFBWTtZQUNadEQsUUFBUTlDLE1BQU11QyxTQUFTLENBQUNrSCxVQUFVO1FBQ3BDO1FBQUc7WUFDRHZELFNBQVM7WUFDVEUsWUFBWTtZQUNadEQsUUFBUTlDLE1BQU11QyxTQUFTLENBQUNrSCxVQUFVO1FBQ3BDO1FBQUc7WUFDRHZELFNBQVM7WUFDVEUsWUFBWTtZQUNadEQsUUFBUTlDLE1BQU11QyxTQUFTLENBQUNrSCxVQUFVO1FBQ3BDO1FBQUc7WUFDRHZELFNBQVM7WUFDVEUsWUFBWTtZQUNadEQsUUFBUTlDLE1BQU11QyxTQUFTLENBQUNrSCxVQUFVO1FBQ3BDO0tBQUU7SUFDRixZQUFZO0FBQ2Q7QUFDQXpKLE1BQU11QyxTQUFTLENBQUNNLFlBQVksQ0FBQyxjQUFjLFVBQVU7SUFDbkQsWUFBWTtRQUNWcUQsU0FBUztRQUNUWSxRQUFRO1FBQ1JwRyxPQUFPO0lBQ1Q7SUFDQSxtQkFBbUI7UUFDakJ3RixTQUFTO1FBQ1RZLFFBQVE7UUFDUmhFLFFBQVE7WUFDTix3QkFBd0I7Z0JBQ3RCb0QsU0FBUztnQkFDVHhGLE9BQU87WUFDVDtZQUNBLGlCQUFpQjtnQkFDZndGLFNBQVM7Z0JBQ1RFLFlBQVk7Z0JBQ1p0RCxRQUFRO29CQUNOLDZCQUE2Qjt3QkFDM0JvRCxTQUFTO3dCQUNUeEYsT0FBTztvQkFDVDtvQkFDQWxOLE1BQU13TSxNQUFNdUMsU0FBUyxDQUFDa0gsVUFBVTtnQkFDbEM7WUFDRjtZQUNBLFVBQVU7UUFDWjtJQUNGO0lBQ0EsbUJBQW1CO1FBQ2pCdkQsU0FBUztRQUNURSxZQUFZO1FBQ1pVLFFBQVE7UUFDUnBHLE9BQU87SUFDVDtBQUNGO0FBQ0FWLE1BQU11QyxTQUFTLENBQUNNLFlBQVksQ0FBQyxjQUFjLFlBQVk7SUFDckQsb0JBQW9CO1FBQ2xCcUQsU0FBUztRQUNURSxZQUFZO1FBQ1oxRixPQUFPO0lBQ1Q7QUFDRjtBQUNBLElBQUlWLE1BQU11QyxTQUFTLENBQUNpRyxNQUFNLEVBQUU7SUFDMUJ4SSxNQUFNdUMsU0FBUyxDQUFDaUcsTUFBTSxDQUFDOVYsR0FBRyxDQUFDK1YsVUFBVSxDQUFDLFVBQVU7SUFFaEQsNENBQTRDO0lBQzVDLHNFQUFzRTtJQUN0RXpJLE1BQU11QyxTQUFTLENBQUNpRyxNQUFNLENBQUM5VixHQUFHLENBQUM2VyxZQUFZLENBQUMseU5BQXlOdEMsTUFBTSxFQUFFO0FBQzNRO0FBQ0FqSCxNQUFNdUMsU0FBUyxDQUFDb0gsRUFBRSxHQUFHM0osTUFBTXVDLFNBQVMsQ0FBQ2tILFVBQVU7QUFDOUMsVUFBVXpKLEtBQUs7SUFDZCxJQUFJeUosYUFBYXpKLE1BQU1PLElBQUksQ0FBQ1MsS0FBSyxDQUFDaEIsTUFBTXVDLFNBQVMsQ0FBQ2tILFVBQVU7SUFDNUQsSUFBSTFtQixRQUFRLCtDQUErQ2trQixNQUFNO0lBQ2pFLElBQUl5SixTQUFTLCtDQUErQ3pKLE1BQU07SUFDbEUsSUFBSTBKLFNBQVMsdUNBQXVDMUosTUFBTTtJQUUxRDs7O0dBR0MsR0FDRCxTQUFTbUcsR0FBR25HLE1BQU0sRUFBRUQsS0FBSztRQUN2QkMsU0FBU0EsT0FBTzdwQixPQUFPLENBQUMsUUFBUTtZQUM5QixPQUFPMkY7UUFDVCxHQUFHM0YsT0FBTyxDQUFDLGFBQWE7WUFDdEIsT0FBT3N6QjtRQUNULEdBQUd0ekIsT0FBTyxDQUFDLGFBQWE7WUFDdEIsT0FBT3V6QjtRQUNUO1FBQ0EsT0FBTzlPLE9BQU9vRixRQUFRRDtJQUN4QjtJQUNBMkosU0FBU3ZELEdBQUd1RCxRQUFRMUosTUFBTTtJQUMxQmpILE1BQU11QyxTQUFTLENBQUN2bEIsR0FBRyxHQUFHZ2pCLE1BQU11QyxTQUFTLENBQUNJLE1BQU0sQ0FBQyxVQUFVOEc7SUFDdkR6SixNQUFNdUMsU0FBUyxDQUFDdmxCLEdBQUcsQ0FBQzBWLEdBQUcsQ0FBQ3dULE9BQU8sR0FBR2tILEdBQUcsd0lBQXdJbkcsTUFBTTtJQUNuTGpILE1BQU11QyxTQUFTLENBQUN2bEIsR0FBRyxDQUFDMFYsR0FBRyxDQUFDb1EsTUFBTSxDQUFDLE1BQU0sQ0FBQ29ELE9BQU8sR0FBRztJQUNoRGxHLE1BQU11QyxTQUFTLENBQUN2bEIsR0FBRyxDQUFDMFYsR0FBRyxDQUFDb1EsTUFBTSxDQUFDLGFBQWEsQ0FBQ29ELE9BQU8sR0FBRztJQUN2RGxHLE1BQU11QyxTQUFTLENBQUN2bEIsR0FBRyxDQUFDMFYsR0FBRyxDQUFDb1EsTUFBTSxDQUFDLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLGFBQWEsR0FBRztJQUM3RDlDLE1BQU11QyxTQUFTLENBQUN2bEIsR0FBRyxDQUFDMFYsR0FBRyxDQUFDb1EsTUFBTSxDQUFDLFVBQVUsR0FBRzJHLFVBQVUsQ0FBQyxVQUFVO0lBQ2pFekosTUFBTXVDLFNBQVMsQ0FBQ00sWUFBWSxDQUFDLFVBQVUsYUFBYTtRQUNsRCxVQUFVO1lBQ1JxRCxTQUFTa0gsR0FBRyxXQUFXbkcsTUFBTTtZQUM3Qm5FLFFBQVE5QyxNQUFNdUMsU0FBUyxDQUFDdmxCLEdBQUc7UUFDN0I7SUFDRixHQUFHZ2pCLE1BQU11QyxTQUFTLENBQUN2bEIsR0FBRyxDQUFDMFYsR0FBRztJQUMxQnNOLE1BQU11QyxTQUFTLENBQUNNLFlBQVksQ0FBQyxVQUFVLGdCQUFnQjtRQUNyRCxVQUFVO1lBQ1Isa0NBQWtDO1lBQ2xDcUQsU0FBU2tILEdBQUcsWUFBWW5HLE1BQU07WUFDOUJ2RyxPQUFPO1lBQ1BvQyxRQUFRO2dCQUNOLHNCQUFzQjtvQkFDcEJvRCxTQUFTO29CQUNUeEYsT0FBTztnQkFDVDtnQkFDQWxOLE1BQU13TSxNQUFNdUMsU0FBUyxDQUFDdmxCLEdBQUc7WUFDM0I7UUFDRjtJQUNGLEdBQUdnakIsTUFBTXVDLFNBQVMsQ0FBQ3ZsQixHQUFHLENBQUMwVixHQUFHO0lBRTFCLG1EQUFtRDtJQUNuRCxJQUFJa2UsaUJBQWlCLFNBQVV6TixLQUFLO1FBQ2xDLElBQUksQ0FBQ0EsT0FBTztZQUNWLE9BQU87UUFDVDtRQUNBLElBQUksT0FBT0EsVUFBVSxVQUFVO1lBQzdCLE9BQU9BO1FBQ1Q7UUFDQSxJQUFJLE9BQU9BLE1BQU0zaUIsT0FBTyxLQUFLLFVBQVU7WUFDckMsT0FBTzJpQixNQUFNM2lCLE9BQU87UUFDdEI7UUFDQSxPQUFPMmlCLE1BQU0zaUIsT0FBTyxDQUFDMkMsR0FBRyxDQUFDeXRCLGdCQUFnQjNxQixJQUFJLENBQUM7SUFDaEQ7SUFDQSxJQUFJNHFCLGFBQWEsU0FBVXJRLE1BQU07UUFDL0IsSUFBSXNRLGFBQWEsRUFBRTtRQUNuQixJQUFLLElBQUlsc0IsSUFBSSxHQUFHQSxJQUFJNGIsT0FBT3ZmLE1BQU0sRUFBRTJELElBQUs7WUFDdEMsSUFBSXVlLFFBQVEzQyxNQUFNLENBQUM1YixFQUFFO1lBQ3JCLElBQUltc0IsaUJBQWlCO1lBQ3JCLElBQUksT0FBTzVOLFVBQVUsVUFBVTtnQkFDN0IsSUFBSUEsTUFBTW5lLElBQUksS0FBSyxTQUFTbWUsTUFBTTNpQixPQUFPLENBQUMsRUFBRSxJQUFJMmlCLE1BQU0zaUIsT0FBTyxDQUFDLEVBQUUsQ0FBQ3dFLElBQUksS0FBSyxPQUFPO29CQUMvRSxvQ0FBb0M7b0JBRXBDLElBQUltZSxNQUFNM2lCLE9BQU8sQ0FBQyxFQUFFLENBQUNBLE9BQU8sQ0FBQyxFQUFFLENBQUNBLE9BQU8sS0FBSyxNQUFNO3dCQUNoRCxjQUFjO3dCQUNkLElBQUlzd0IsV0FBVzd2QixNQUFNLEdBQUcsS0FBSzZ2QixVQUFVLENBQUNBLFdBQVc3dkIsTUFBTSxHQUFHLEVBQUUsQ0FBQ3luQixPQUFPLEtBQUtrSSxlQUFlek4sTUFBTTNpQixPQUFPLENBQUMsRUFBRSxDQUFDQSxPQUFPLENBQUMsRUFBRSxHQUFHOzRCQUN0SCwyQkFBMkI7NEJBQzNCc3dCLFdBQVdFLEdBQUc7d0JBQ2hCO29CQUNGLE9BQU87d0JBQ0wsSUFBSTdOLE1BQU0zaUIsT0FBTyxDQUFDMmlCLE1BQU0zaUIsT0FBTyxDQUFDUyxNQUFNLEdBQUcsRUFBRSxDQUFDVCxPQUFPLEtBQUs7NkJBQWE7NEJBQ25FLGNBQWM7NEJBQ2Rzd0IsV0FBVzdwQixJQUFJLENBQUM7Z0NBQ2R5aEIsU0FBU2tJLGVBQWV6TixNQUFNM2lCLE9BQU8sQ0FBQyxFQUFFLENBQUNBLE9BQU8sQ0FBQyxFQUFFO2dDQUNuRHl3QixjQUFjOzRCQUNoQjt3QkFDRjtvQkFDRjtnQkFDRixPQUFPLElBQUlILFdBQVc3dkIsTUFBTSxHQUFHLEtBQUtraUIsTUFBTW5lLElBQUksS0FBSyxpQkFBaUJtZSxNQUFNM2lCLE9BQU8sS0FBSyxLQUFLO29CQUN6Rix3REFBd0Q7b0JBQ3hEc3dCLFVBQVUsQ0FBQ0EsV0FBVzd2QixNQUFNLEdBQUcsRUFBRSxDQUFDZ3dCLFlBQVk7Z0JBQ2hELE9BQU8sSUFBSUgsV0FBVzd2QixNQUFNLEdBQUcsS0FBSzZ2QixVQUFVLENBQUNBLFdBQVc3dkIsTUFBTSxHQUFHLEVBQUUsQ0FBQ2d3QixZQUFZLEdBQUcsS0FBSzlOLE1BQU1uZSxJQUFJLEtBQUssaUJBQWlCbWUsTUFBTTNpQixPQUFPLEtBQUssS0FBSztvQkFDL0kscURBQXFEO29CQUNyRHN3QixVQUFVLENBQUNBLFdBQVc3dkIsTUFBTSxHQUFHLEVBQUUsQ0FBQ2d3QixZQUFZO2dCQUNoRCxPQUFPO29CQUNMRixpQkFBaUI7Z0JBQ25CO1lBQ0Y7WUFDQSxJQUFJQSxrQkFBa0IsT0FBTzVOLFVBQVUsVUFBVTtnQkFDL0MsSUFBSTJOLFdBQVc3dkIsTUFBTSxHQUFHLEtBQUs2dkIsVUFBVSxDQUFDQSxXQUFXN3ZCLE1BQU0sR0FBRyxFQUFFLENBQUNnd0IsWUFBWSxLQUFLLEdBQUc7b0JBQ2pGLDBEQUEwRDtvQkFDMUQsOENBQThDO29CQUM5QyxJQUFJQyxZQUFZTixlQUFlek47b0JBRS9CLG9DQUFvQztvQkFDcEMsSUFBSXZlLElBQUk0YixPQUFPdmYsTUFBTSxHQUFHLEtBQU0sUUFBT3VmLE1BQU0sQ0FBQzViLElBQUksRUFBRSxLQUFLLFlBQVk0YixNQUFNLENBQUM1YixJQUFJLEVBQUUsQ0FBQ0ksSUFBSSxLQUFLLFlBQVcsR0FBSTt3QkFDdkdrc0IsYUFBYU4sZUFBZXBRLE1BQU0sQ0FBQzViLElBQUksRUFBRTt3QkFDekM0YixPQUFPMlEsTUFBTSxDQUFDdnNCLElBQUksR0FBRztvQkFDdkI7b0JBQ0EsSUFBSUEsSUFBSSxLQUFNLFFBQU80YixNQUFNLENBQUM1YixJQUFJLEVBQUUsS0FBSyxZQUFZNGIsTUFBTSxDQUFDNWIsSUFBSSxFQUFFLENBQUNJLElBQUksS0FBSyxZQUFXLEdBQUk7d0JBQ3ZGa3NCLFlBQVlOLGVBQWVwUSxNQUFNLENBQUM1YixJQUFJLEVBQUUsSUFBSXNzQjt3QkFDNUMxUSxPQUFPMlEsTUFBTSxDQUFDdnNCLElBQUksR0FBRzt3QkFDckJBO29CQUNGO29CQUNBNGIsTUFBTSxDQUFDNWIsRUFBRSxHQUFHLElBQUlvYixNQUFNUyxLQUFLLENBQUMsY0FBY3lRLFdBQVcsTUFBTUE7Z0JBQzdEO1lBQ0Y7WUFDQSxJQUFJL04sTUFBTTNpQixPQUFPLElBQUksT0FBTzJpQixNQUFNM2lCLE9BQU8sS0FBSyxVQUFVO2dCQUN0RHF3QixXQUFXMU4sTUFBTTNpQixPQUFPO1lBQzFCO1FBQ0Y7SUFDRjtJQUNBd2YsTUFBTWlFLEtBQUssQ0FBQ3pkLEdBQUcsQ0FBQyxrQkFBa0IsU0FBVXVkLEdBQUc7UUFDN0MsSUFBSUEsSUFBSXhRLFFBQVEsS0FBSyxTQUFTd1EsSUFBSXhRLFFBQVEsS0FBSyxPQUFPO1lBQ3BEO1FBQ0Y7UUFDQXNkLFdBQVc5TSxJQUFJdkQsTUFBTTtJQUN2QjtBQUNGLEdBQUdSO0FBRUgsb0NBQW9DO0FBQ3BDQSxNQUFNdUMsU0FBUyxDQUFDNk8sSUFBSSxHQUFHO0lBQ3JCLFlBQVk7UUFDVmxMLFNBQVM7UUFDVEUsWUFBWTtRQUNaVSxRQUFRO0lBQ1Y7SUFDQSxVQUFVO1FBQ1JaLFNBQVM7UUFDVEUsWUFBWTtRQUNaVSxRQUFRO0lBQ1Y7SUFDQSxXQUFXO1FBQ1RaLFNBQVM7UUFDVFksUUFBUTtJQUNWO0lBQ0EsVUFBVTtJQUNWLGVBQWU7SUFDZixZQUFZO0lBQ1osV0FBVztJQUNYLFFBQVE7UUFDTlosU0FBUztRQUNUeEYsT0FBTztJQUNUO0FBQ0Y7QUFDQVYsTUFBTXVDLFNBQVMsQ0FBQzhPLFdBQVcsR0FBR3JSLE1BQU11QyxTQUFTLENBQUM2TyxJQUFJO0FBQ2pELFVBQVVwUixLQUFLO0lBQ2RBLE1BQU11QyxTQUFTLENBQUMrTyxNQUFNLEdBQUd0UixNQUFNdUMsU0FBUyxDQUFDSSxNQUFNLENBQUMsU0FBUztRQUN2RCxXQUFXO1lBQ1QsMkVBQTJFO1lBQzNFdUQsU0FBUztZQUNURSxZQUFZO1FBQ2Q7UUFDQSxZQUFZO1lBQUM7Z0JBQ1hGLFNBQVM7Z0JBQ1RZLFFBQVE7WUFDVjtZQUFHO2dCQUNEWixTQUFTO2dCQUNURSxZQUFZO2dCQUNaVSxRQUFRO1lBQ1Y7U0FBRTtRQUNGLFVBQVU7UUFDVixZQUFZO0lBQ2Q7SUFDQSxPQUFPOUcsTUFBTXVDLFNBQVMsQ0FBQytPLE1BQU0sQ0FBQyxhQUFhO0lBQzNDLElBQUlDLHNCQUFzQjtRQUN4Qiw2QkFBNkI7WUFDM0JyTCxTQUFTO1lBQ1R4RixPQUFPO1FBQ1Q7UUFDQSxjQUFjO1lBQ1p3RixTQUFTO1lBQ1RwRCxRQUFROUMsTUFBTXVDLFNBQVMsQ0FBQytPLE1BQU07UUFDaEM7SUFDRjtJQUNBdFIsTUFBTXVDLFNBQVMsQ0FBQ00sWUFBWSxDQUFDLFVBQVUsVUFBVTtRQUMvQyxnRkFBZ0Y7UUFDaEYsa0JBQWtCO1lBQUM7Z0JBQ2pCcUQsU0FBUztnQkFDVHhGLE9BQU87Z0JBQ1BvQyxRQUFRO29CQUNOLGlCQUFpQjt3QkFDZm9ELFNBQVM7d0JBQ1RwRCxRQUFReU87b0JBQ1Y7b0JBQ0EsVUFBVTtnQkFDWjtZQUNGO1lBQUc7Z0JBQ0RyTCxTQUFTO2dCQUNUeEYsT0FBTztnQkFDUG9DLFFBQVE7b0JBQ04saUJBQWlCO3dCQUNmb0QsU0FBUzt3QkFDVEUsWUFBWTt3QkFDWnRELFFBQVF5TztvQkFDVjtvQkFDQSxVQUFVO2dCQUNaO1lBQ0Y7U0FBRTtRQUNGLFFBQVE7WUFDTixrRUFBa0U7WUFDbEVyTCxTQUFTO1lBQ1RZLFFBQVE7UUFDVjtJQUNGO0lBQ0EsT0FBTzlHLE1BQU11QyxTQUFTLENBQUMrTyxNQUFNLENBQUMsU0FBUztJQUN2Q3RSLE1BQU11QyxTQUFTLENBQUNNLFlBQVksQ0FBQyxVQUFVLFdBQVc7UUFDaEQsY0FBYztZQUNacUQsU0FBUztZQUNUeEYsT0FBTztRQUNUO0lBQ0Y7SUFDQVYsTUFBTXVDLFNBQVMsQ0FBQ00sWUFBWSxDQUFDLFVBQVUsWUFBWTtRQUNqRCxTQUFTO1lBQ1BxRCxTQUFTO1lBQ1R4RixPQUFPO1FBQ1Q7SUFDRjtJQUNBVixNQUFNdUMsU0FBUyxDQUFDaVAsRUFBRSxHQUFHeFIsTUFBTXVDLFNBQVMsQ0FBQytPLE1BQU07SUFDM0N0UixNQUFNdUMsU0FBUyxDQUFDa1AsR0FBRyxHQUFHelIsTUFBTXVDLFNBQVMsQ0FBQytPLE1BQU07QUFDOUMsR0FBR3RSO0FBRUg7Ozs7OztDQU1DLEdBRURBLE1BQU11QyxTQUFTLENBQUNtUCxJQUFJLEdBQUcxUixNQUFNdUMsU0FBUyxDQUFDSSxNQUFNLENBQUMsT0FBTztJQUNuRCxXQUFXO1FBQUM7UUFBb0I7WUFDOUJ1RCxTQUFTO1lBQ1RFLFlBQVk7UUFDZDtLQUFFO0lBQ0YsVUFBVTtRQUNSRixTQUFTO1FBQ1RwRCxRQUFRO1lBQ04sZUFBZTtRQUNqQjtJQUNGO0lBQ0EsK0NBQStDO0lBQy9DLFlBQVk7UUFDVm9ELFNBQVM7UUFDVHBELFFBQVE7WUFDTixtQkFBbUI7WUFDbkIsWUFBWTtRQUNkO0lBQ0Y7SUFDQSxZQUFZO0lBQ1osWUFBWTtBQUNkO0FBQ0E5QyxNQUFNdUMsU0FBUyxDQUFDTSxZQUFZLENBQUMsUUFBUSxZQUFZO0lBQy9DLFlBQVk7UUFDWixxREFBcUQ7UUFDckQ7WUFDRXFELFNBQVM7WUFDVHBELFFBQVE7Z0JBQ04sZUFBZTtZQUNqQjtRQUNGO1FBQ0EsaUJBQWlCO1FBQ2pCO0tBQVk7SUFDWixlQUFlO1FBQ2JvRCxTQUFTO1FBQ1RFLFlBQVk7UUFDWjFGLE9BQU87SUFDVDtBQUNGO0FBQ0FWLE1BQU11QyxTQUFTLENBQUNvUCxHQUFHLEdBQUc7SUFDcEIsV0FBVztJQUNYLDZDQUE2QztJQUM3QyxVQUFVO1FBQ1J6TCxTQUFTO1FBQ1RZLFFBQVE7SUFDVjtJQUNBLFVBQVU7SUFDVixXQUFXO0lBQ1gsWUFBWTtJQUNaLFlBQVk7UUFBQztRQUF5QztZQUNwRCxtQ0FBbUM7WUFDbkNaLFNBQVM7WUFDVEUsWUFBWTtRQUNkO0tBQUU7SUFDRixlQUFlO0FBQ2pCO0FBQ0FwRyxNQUFNdUMsU0FBUyxDQUFDcVAsUUFBUSxHQUFHO0lBQ3pCLFdBQVc7UUFDVDFMLFNBQVM7UUFDVEUsWUFBWTtJQUNkO0lBQ0EsVUFBVTtRQUNSRixTQUFTO1FBQ1RZLFFBQVE7SUFDVjtJQUNBLGtCQUFrQjtRQUNoQlosU0FBUztRQUNUeEYsT0FBTztJQUNUO0lBQ0EsVUFBVTtRQUNSd0YsU0FBUztRQUNUeEYsT0FBTztRQUNQb0MsUUFBUTtZQUNOLFlBQVk7UUFDZDtJQUNGO0lBQ0EsWUFBWTtJQUNaLGFBQWE7SUFDYixXQUFXO0lBQ1gsWUFBWTtRQUNWb0QsU0FBUztRQUNURSxZQUFZO0lBQ2Q7SUFDQSxZQUFZO0lBQ1osZUFBZTtBQUNqQjtBQUNDLFVBQVVwRyxLQUFLO0lBQ2QsMkRBQTJEO0lBQzNELHNEQUFzRDtJQUN0RCxJQUFJNlIsZ0JBQWdCO0lBQ3BCLHdEQUF3RDtJQUN4RCxJQUFJbmYsTUFBTTtJQUNWLDJEQUEyRDtJQUMzRCxJQUFJb2YsYUFBYSxRQUFRcGYsSUFBSXVVLE1BQU0sR0FBRyxhQUFjNEssY0FBYzVLLE1BQU0sR0FBRyxRQUFRNEssY0FBYzVLLE1BQU0sR0FBRyxhQUFjdlUsSUFBSXVVLE1BQU0sR0FBRztJQUNySSxvREFBb0Q7SUFDcEQsMkVBQTJFO0lBQzNFLHVGQUF1RjtJQUN2RixJQUFJOEssV0FBVyxrSkFBa0o5SyxNQUFNLENBQUM3cEIsT0FBTyxDQUFDLFlBQVk7UUFDMUwsT0FBTywyRUFBMkU2cEIsTUFBTTtJQUMxRjtJQUNBLElBQUlvQyxTQUFTLDhDQUE4Q3BDLE1BQU07SUFFakU7Ozs7O0dBS0MsR0FDRCxTQUFTK0ssbUJBQW1CcnNCLEtBQUssRUFBRXFoQixLQUFLO1FBQ3RDQSxRQUFRLENBQUNBLFNBQVMsRUFBQyxFQUFHNXBCLE9BQU8sQ0FBQyxNQUFNLE1BQU0sS0FBSyxhQUFhO1FBQzVELElBQUk4b0IsVUFBVSx5RkFBeUZlLE1BQU0sQ0FBQzdwQixPQUFPLENBQUMsYUFBYTtZQUNqSSxPQUFPMDBCO1FBQ1QsR0FBRzEwQixPQUFPLENBQUMsY0FBYztZQUN2QixPQUFPdUk7UUFDVDtRQUNBLE9BQU9rYyxPQUFPcUUsU0FBU2M7SUFDekI7SUFDQWhILE1BQU11QyxTQUFTLENBQUMwUCxJQUFJLEdBQUc7UUFDckIsVUFBVTtZQUNSL0wsU0FBU3JFLE9BQU8sNkZBQTZGb0YsTUFBTSxDQUFDN3BCLE9BQU8sQ0FBQyxhQUFhO2dCQUN2SSxPQUFPMDBCO1lBQ1Q7WUFDQTFMLFlBQVk7WUFDWjFGLE9BQU87UUFDVDtRQUNBLFdBQVc7UUFDWCxPQUFPO1lBQ0x3RixTQUFTckUsT0FBTyxrRUFBa0VvRixNQUFNLENBQUM3cEIsT0FBTyxDQUFDLGFBQWE7Z0JBQzVHLE9BQU8wMEI7WUFDVCxHQUFHMTBCLE9BQU8sQ0FBQyxZQUFZO2dCQUNyQixPQUFPLFFBQVEyMEIsV0FBVyxNQUFNMUksU0FBUztZQUMzQztZQUNBakQsWUFBWTtZQUNaVSxRQUFRO1lBQ1JwRyxPQUFPO1FBQ1Q7UUFDQSxhQUFhO1lBQ1h3RixTQUFTO1lBQ1RFLFlBQVk7WUFDWjFGLE9BQU87UUFDVDtRQUNBLFlBQVk7WUFDVndGLFNBQVM4TCxtQkFBbUIsc0pBQXNKL0ssTUFBTTtZQUN4TGIsWUFBWTtZQUNaMUYsT0FBTztRQUNUO1FBQ0EsV0FBVztZQUNUd0YsU0FBUzhMLG1CQUFtQixhQUFhL0ssTUFBTSxFQUFFO1lBQ2pEYixZQUFZO1lBQ1oxRixPQUFPO1FBQ1Q7UUFDQSxRQUFRO1lBQ053RixTQUFTOEwsbUJBQW1CLFNBQVMvSyxNQUFNLEVBQUU7WUFDN0NiLFlBQVk7WUFDWjFGLE9BQU87UUFDVDtRQUNBLFVBQVU7WUFDUndGLFNBQVM4TCxtQkFBbUIzSTtZQUM1QmpELFlBQVk7WUFDWlUsUUFBUTtRQUNWO1FBQ0EsVUFBVTtZQUNSWixTQUFTOEwsbUJBQW1CLGlGQUFpRi9LLE1BQU0sRUFBRTtZQUNySGIsWUFBWTtRQUNkO1FBQ0EsT0FBTzFUO1FBQ1AsYUFBYW1mO1FBQ2IsZUFBZTtJQUNqQjtJQUNBN1IsTUFBTXVDLFNBQVMsQ0FBQzJQLEdBQUcsR0FBR2xTLE1BQU11QyxTQUFTLENBQUMwUCxJQUFJO0FBQzVDLEdBQUdqUztBQUNGLFVBQVVBLEtBQUs7SUFDZCw0QkFBNEI7SUFDNUIsSUFBSW1TLFFBQVEsMkNBQTJDbEwsTUFBTTtJQUU3RDs7Ozs7Ozs7O0dBU0MsR0FDRCxTQUFTbUwsYUFBYWxNLE9BQU87UUFDM0JBLFVBQVVBLFFBQVE5b0IsT0FBTyxDQUFDLFlBQVk7WUFDcEMsT0FBTyswQjtRQUNUO1FBQ0EsT0FBT3RRLE9BQU8sMEJBQTBCb0YsTUFBTSxHQUFHLFFBQVFmLFVBQVU7SUFDckU7SUFDQSxJQUFJbU0sWUFBWSw0REFBNERwTCxNQUFNO0lBQ2xGLElBQUlxTCxXQUFXLCtDQUErQ3JMLE1BQU0sQ0FBQzdwQixPQUFPLENBQUMsT0FBTztRQUNsRixPQUFPaTFCO0lBQ1Q7SUFDQSxJQUFJRSxZQUFZLHNFQUFzRXRMLE1BQU07SUFDNUZqSCxNQUFNdUMsU0FBUyxDQUFDaVEsUUFBUSxHQUFHeFMsTUFBTXVDLFNBQVMsQ0FBQ0ksTUFBTSxDQUFDLFVBQVUsQ0FBQztJQUM3RDNDLE1BQU11QyxTQUFTLENBQUNNLFlBQVksQ0FBQyxZQUFZLFVBQVU7UUFDakQsc0JBQXNCO1lBQ3BCcUQsU0FBUztZQUNURSxZQUFZO1lBQ1pVLFFBQVE7WUFDUmhFLFFBQVE7Z0JBQ04sZUFBZTtnQkFDZixnQkFBZ0I7b0JBQ2RvRCxTQUFTO29CQUNUeEYsT0FBTzt3QkFBQzt3QkFBUTtxQkFBZ0I7b0JBQ2hDb0MsUUFBUTlDLE1BQU11QyxTQUFTLENBQUMwUCxJQUFJO2dCQUM5QjtZQUNGO1FBQ0Y7UUFDQSxjQUFjO1lBQ1osUUFBUTtZQUNSL0wsU0FBUztZQUNUeEYsT0FBTztRQUNUO1FBQ0EsU0FBUztZQUNQd0YsU0FBU3JFLE9BQU8sTUFBTXlRLFdBQVdDLFlBQVksUUFBUUQsV0FBVyxNQUFNO1lBQ3RFeFAsUUFBUTtnQkFDTixtQkFBbUI7b0JBQ2pCb0QsU0FBU3JFLE9BQU8sT0FBT3lRLFdBQVdDLFlBQVksU0FBU0QsV0FBVztvQkFDbEVsTSxZQUFZO29CQUNadEQsUUFBUTt3QkFDTixjQUFjOzRCQUNab0QsU0FBU3JFLE9BQU93UTs0QkFDaEJ2UCxRQUFROUMsTUFBTXVDLFNBQVMsQ0FBQ2lRLFFBQVE7d0JBQ2xDO3dCQUNBLGVBQWU7b0JBQ2pCO2dCQUNGO2dCQUNBLGNBQWM7b0JBQ1p0TSxTQUFTckUsT0FBTyxPQUFPeVEsV0FBVyxNQUFNQyxZQUFZO29CQUNwRG5NLFlBQVk7b0JBQ1p0RCxRQUFRO3dCQUNOLGVBQWU7b0JBQ2pCO2dCQUNGO2dCQUNBLG9CQUFvQjtvQkFDbEJvRCxTQUFTckUsT0FBTyxNQUFNeVEsV0FBVztvQkFDakN4UCxRQUFRO3dCQUNOLGdCQUFnQjs0QkFDZG9ELFNBQVNyRSxPQUFPd1E7NEJBQ2hCM1IsT0FBTzs0QkFDUG9DLFFBQVE5QyxNQUFNdUMsU0FBUyxDQUFDaVEsUUFBUTt3QkFDbEM7d0JBQ0EsZUFBZTtvQkFDakI7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0EsUUFBUTtZQUFDO2dCQUNQLDhEQUE4RDtnQkFDOUR0TSxTQUFTO2dCQUNURSxZQUFZO2dCQUNaMUYsT0FBTztZQUNUO1lBQUc7Z0JBQ0QsdUJBQXVCO2dCQUN2QixhQUFhO2dCQUNiLE1BQU07Z0JBQ053RixTQUFTO2dCQUNUWSxRQUFRO2dCQUNSaEUsUUFBUTtvQkFDTixjQUFjO3dCQUNab0QsU0FBUzt3QkFDVEUsWUFBWTtvQkFDZDtvQkFDQSxpQkFBaUI7d0JBQ2ZGLFNBQVM7d0JBQ1RFLFlBQVk7b0JBQ2Q7b0JBQ0EsZUFBZTtnQkFDakI7WUFDRjtTQUFFO1FBQ0YsU0FBUztZQUFDO2dCQUNSLFVBQVU7Z0JBQ1YsVUFBVTtnQkFFVixVQUFVO2dCQUNWLFVBQVU7Z0JBQ1ZGLFNBQVM7Z0JBQ1R4RixPQUFPO2dCQUNQb0MsUUFBUTtvQkFDTjJQLGFBQWE7Z0JBQ2Y7WUFDRjtZQUFHO2dCQUNELFlBQVk7Z0JBQ1osaUJBQWlCO2dCQUNqQnZNLFNBQVM7Z0JBQ1RFLFlBQVk7Z0JBQ1oxRixPQUFPO2dCQUNQb0MsUUFBUTtvQkFDTjJQLGFBQWE7Z0JBQ2Y7WUFDRjtTQUFFO1FBQ0YsTUFBTTtZQUNKLE1BQU07WUFDTixNQUFNO1lBQ04sUUFBUTtZQUNSLGNBQWM7WUFDZHZNLFNBQVM7WUFDVEUsWUFBWTtZQUNaMUYsT0FBTztRQUNUO1FBQ0EsUUFBUTtZQUNOLFNBQVM7WUFDVCxTQUFTO1lBQ1QsU0FBUztZQUNULFVBQVU7WUFDVndGLFNBQVM7WUFDVEUsWUFBWTtZQUNaMUYsT0FBTztRQUNUO1FBQ0EsaUJBQWlCO1lBQ2YsNENBQTRDO1lBQzVDLDRDQUE0QztZQUM1Qyw0Q0FBNEM7WUFDNUMsOENBQThDO1lBQzlDd0YsU0FBUztZQUNUcEQsUUFBUTtnQkFDTixZQUFZO29CQUNWb0QsU0FBUztvQkFDVEUsWUFBWTtnQkFDZDtnQkFDQSxVQUFVO2dCQUNWLGVBQWU7WUFDakI7WUFDQTFGLE9BQU87UUFDVDtRQUNBLFFBQVE7WUFDTixhQUFhO1lBQ2IsYUFBYTtZQUViLG9FQUFvRTtZQUNwRXdGLFNBQVNrTSxhQUFhLGtHQUFrR25MLE1BQU07WUFDOUhiLFlBQVk7WUFDWlUsUUFBUTtZQUNSaEUsUUFBUTtnQkFDTixXQUFXO29CQUNUb0QsU0FBUztvQkFDVEUsWUFBWTtvQkFDWnRELFFBQVEsQ0FBQyxFQUFFLFlBQVk7Z0JBQ3pCO2dCQUVBLGVBQWU7WUFDakI7UUFDRjtRQUNBLFVBQVU7WUFDUixPQUFPO1lBQ1AsT0FBTztZQUVQLGtFQUFrRTtZQUNsRW9ELFNBQVNrTSxhQUFhLGtHQUFrR25MLE1BQU07WUFDOUhiLFlBQVk7WUFDWlUsUUFBUTtZQUNSaEUsUUFBUTtnQkFDTixXQUFXO29CQUNUb0QsU0FBUztvQkFDVEUsWUFBWTtvQkFDWnRELFFBQVEsQ0FBQyxFQUFFLFlBQVk7Z0JBQ3pCO2dCQUVBLGVBQWU7WUFDakI7UUFDRjtRQUNBLFVBQVU7WUFDUixxQkFBcUI7WUFDckIsV0FBVztZQUNYLHlDQUF5QztZQUN6Q29ELFNBQVNrTSxhQUFhLDJCQUEyQm5MLE1BQU07WUFDdkRiLFlBQVk7WUFDWlUsUUFBUTtZQUNSaEUsUUFBUTtnQkFDTixXQUFXO29CQUNUb0QsU0FBUztvQkFDVEUsWUFBWTtvQkFDWnRELFFBQVEsQ0FBQyxFQUFFLFlBQVk7Z0JBQ3pCO2dCQUVBLGVBQWU7WUFDakI7UUFDRjtRQUNBLGdCQUFnQjtZQUNkLFNBQVM7WUFDVCxXQUFXO1lBQ1hvRCxTQUFTO1lBQ1RFLFlBQVk7WUFDWlUsUUFBUTtZQUNScEcsT0FBTztnQkFBQztnQkFBUTthQUFVO1FBQzVCO1FBQ0EsT0FBTztZQUNMLGlEQUFpRDtZQUNqRCxnQkFBZ0I7WUFDaEIsaUJBQWlCO1lBQ2pCd0YsU0FBU2tNLGFBQWEsbUdBQW1HbkwsTUFBTTtZQUMvSGIsWUFBWTtZQUNaVSxRQUFRO1lBQ1JoRSxRQUFRO2dCQUNOLFlBQVk7Z0JBQ1osV0FBVztvQkFDVG9ELFNBQVM7b0JBQ1RFLFlBQVk7b0JBQ1p0RCxRQUFRLENBQUMsRUFBRSxZQUFZO2dCQUN6QjtnQkFFQSxZQUFZO29CQUNWb0QsU0FBUztvQkFDVEUsWUFBWTtnQkFDZDtnQkFDQSxPQUFPO29CQUNMRixTQUFTO29CQUNURSxZQUFZO2dCQUNkO2dCQUNBLFVBQVU7b0JBQ1JGLFNBQVM7b0JBQ1RFLFlBQVk7Z0JBQ2Q7WUFDRjtRQUNGO0lBQ0Y7SUFDQTtRQUFDO1FBQU87UUFBUTtRQUFVO0tBQVMsQ0FBQ2hGLE9BQU8sQ0FBQyxTQUFVK0IsS0FBSztRQUN6RDtZQUFDO1lBQU87WUFBUTtZQUFVO1lBQVU7U0FBZSxDQUFDL0IsT0FBTyxDQUFDLFNBQVUwQixNQUFNO1lBQzFFLElBQUlLLFVBQVVMLFFBQVE7Z0JBQ3BCOUMsTUFBTXVDLFNBQVMsQ0FBQ2lRLFFBQVEsQ0FBQ3JQLE1BQU0sQ0FBQ0wsTUFBTSxDQUFDdGlCLE9BQU8sQ0FBQ3NpQixNQUFNLENBQUNBLE9BQU8sR0FBRzlDLE1BQU11QyxTQUFTLENBQUNpUSxRQUFRLENBQUMxUCxPQUFPO1lBQ2xHO1FBQ0Y7SUFDRjtJQUNBOUMsTUFBTWlFLEtBQUssQ0FBQ3pkLEdBQUcsQ0FBQyxrQkFBa0IsU0FBVXVkLEdBQUc7UUFDN0MsSUFBSUEsSUFBSXhRLFFBQVEsS0FBSyxjQUFjd1EsSUFBSXhRLFFBQVEsS0FBSyxNQUFNO1lBQ3hEO1FBQ0Y7UUFDQSxTQUFTc2QsV0FBV3JRLE1BQU07WUFDeEIsSUFBSSxDQUFDQSxVQUFVLE9BQU9BLFdBQVcsVUFBVTtnQkFDekM7WUFDRjtZQUNBLElBQUssSUFBSTViLElBQUksR0FBRzh0QixJQUFJbFMsT0FBT3ZmLE1BQU0sRUFBRTJELElBQUk4dEIsR0FBRzl0QixJQUFLO2dCQUM3QyxJQUFJdWUsUUFBUTNDLE1BQU0sQ0FBQzViLEVBQUU7Z0JBQ3JCLElBQUl1ZSxNQUFNbmUsSUFBSSxLQUFLLFFBQVE7b0JBQ3pCNnJCLFdBQVcxTixNQUFNM2lCLE9BQU87b0JBQ3hCO2dCQUNGO2dCQUVBOzs7Ozs7Ozs7Ozs7U0FZQyxHQUVELElBQUlteUIsV0FBV3hQLE1BQU0zaUIsT0FBTyxDQUFDLEVBQUU7Z0JBQy9CLElBQUlveUIsWUFBWXpQLE1BQU0zaUIsT0FBTyxDQUFDLEVBQUU7Z0JBQ2hDLElBQUlteUIsWUFBWUMsYUFBYUQsU0FBUzN0QixJQUFJLEtBQUssbUJBQW1CNHRCLFVBQVU1dEIsSUFBSSxLQUFLLGdCQUFnQixPQUFPMnRCLFNBQVNueUIsT0FBTyxLQUFLLFVBQVU7b0JBQ3pJLHVEQUF1RDtvQkFFdkQsa0RBQWtEO29CQUNsRCxJQUFJMmYsT0FBT3dTLFNBQVNueUIsT0FBTyxDQUFDcEQsT0FBTyxDQUFDLFFBQVEsU0FBU0EsT0FBTyxDQUFDLFdBQVc7b0JBQ3hFLDBCQUEwQjtvQkFDMUIraUIsT0FBTyxDQUFDLGVBQWVxQixJQUFJLENBQUNyQixTQUFTO3dCQUFDO3FCQUFHLENBQUMsQ0FBQyxFQUFFLENBQUN1QixXQUFXO29CQUN6RCxJQUFJaEIsUUFBUSxjQUFjUDtvQkFFMUIsWUFBWTtvQkFDWixJQUFJLENBQUN5UyxVQUFVbFMsS0FBSyxFQUFFO3dCQUNwQmtTLFVBQVVsUyxLQUFLLEdBQUc7NEJBQUNBO3lCQUFNO29CQUMzQixPQUFPLElBQUksT0FBT2tTLFVBQVVsUyxLQUFLLEtBQUssVUFBVTt3QkFDOUNrUyxVQUFVbFMsS0FBSyxHQUFHOzRCQUFDa1MsVUFBVWxTLEtBQUs7NEJBQUVBO3lCQUFNO29CQUM1QyxPQUFPO3dCQUNMa1MsVUFBVWxTLEtBQUssQ0FBQ3paLElBQUksQ0FBQ3laO29CQUN2QjtnQkFDRjtZQUNGO1FBQ0Y7UUFDQW1RLFdBQVc5TSxJQUFJdkQsTUFBTTtJQUN2QjtJQUNBUixNQUFNaUUsS0FBSyxDQUFDemQsR0FBRyxDQUFDLFFBQVEsU0FBVXVkLEdBQUc7UUFDbkMsSUFBSUEsSUFBSS9lLElBQUksS0FBSyxjQUFjO1lBQzdCO1FBQ0Y7UUFDQSxJQUFJMnRCLFdBQVc7UUFDZixJQUFLLElBQUkvdEIsSUFBSSxHQUFHOHRCLElBQUkzTyxJQUFJZ0MsT0FBTyxDQUFDOWtCLE1BQU0sRUFBRTJELElBQUk4dEIsR0FBRzl0QixJQUFLO1lBQ2xELElBQUlpdUIsTUFBTTlPLElBQUlnQyxPQUFPLENBQUNuaEIsRUFBRTtZQUN4QixJQUFJZ2IsUUFBUSxnQkFBZ0I0QixJQUFJLENBQUNxUjtZQUNqQyxJQUFJalQsT0FBTztnQkFDVCtTLFdBQVcvUyxLQUFLLENBQUMsRUFBRTtnQkFDbkI7WUFDRjtRQUNGO1FBQ0EsSUFBSXFELFVBQVVqRCxNQUFNdUMsU0FBUyxDQUFDb1EsU0FBUztRQUN2QyxJQUFJLENBQUMxUCxTQUFTO1lBQ1osSUFBSTBQLFlBQVlBLGFBQWEsVUFBVTNTLE1BQU0wRCxPQUFPLENBQUNnSSxVQUFVLEVBQUU7Z0JBQy9ELElBQUkzYixLQUFLLFFBQVEsSUFBSStpQixPQUFPQyxPQUFPLEtBQUssTUFBTWxILEtBQUttSCxLQUFLLENBQUNuSCxLQUFLb0gsTUFBTSxLQUFLO2dCQUN6RWxQLElBQUl2UixVQUFVLENBQUMsS0FBSyxHQUFHekM7Z0JBQ3ZCaVEsTUFBTTBELE9BQU8sQ0FBQ2dJLFVBQVUsQ0FBQ0MsYUFBYSxDQUFDZ0gsVUFBVTtvQkFDL0MsSUFBSU8sTUFBTWxSLFNBQVNtUixjQUFjLENBQUNwakI7b0JBQ2xDLElBQUltakIsS0FBSzt3QkFDUEEsSUFBSXZPLFNBQVMsR0FBRzNFLE1BQU1vRixTQUFTLENBQUM4TixJQUFJMU8sV0FBVyxFQUFFeEUsTUFBTXVDLFNBQVMsQ0FBQ29RLFNBQVMsRUFBRUE7b0JBQzlFO2dCQUNGO1lBQ0Y7UUFDRixPQUFPO1lBQ0w1TyxJQUFJdmpCLE9BQU8sR0FBR3dmLE1BQU1vRixTQUFTLENBQUNaLFlBQVlULElBQUl2akIsT0FBTyxHQUFHeWlCLFNBQVMwUDtRQUNuRTtJQUNGO0lBQ0EsSUFBSVMsYUFBYXZSLE9BQU83QixNQUFNdUMsU0FBUyxDQUFDaUcsTUFBTSxDQUFDOVYsR0FBRyxDQUFDd1QsT0FBTyxDQUFDZSxNQUFNLEVBQUU7SUFFbkU7Ozs7OztHQU1DLEdBQ0QsSUFBSW9NLHFCQUFxQjtRQUN2QixPQUFPO1FBQ1AsTUFBTTtRQUNOLE1BQU07UUFDTixRQUFRO0lBQ1Y7SUFFQSwrQ0FBK0M7SUFDL0MsSUFBSUMsZ0JBQWdCeEgsT0FBT3dILGFBQWEsSUFBSXhILE9BQU95SCxZQUFZO0lBRS9EOzs7OztHQUtDLEdBQ0QsU0FBUy9PLFlBQVlzRSxJQUFJO1FBQ3ZCLGtCQUFrQjtRQUNsQixJQUFJcFgsT0FBT29YLEtBQUsxckIsT0FBTyxDQUFDZzJCLFlBQVk7UUFFcEMsd0JBQXdCO1FBQ3hCMWhCLE9BQU9BLEtBQUt0VSxPQUFPLENBQUMsaUNBQWlDLFNBQVVta0IsQ0FBQyxFQUFFOU8sSUFBSTtZQUNwRUEsT0FBT0EsS0FBS2lQLFdBQVc7WUFDdkIsSUFBSWpQLElBQUksQ0FBQyxFQUFFLEtBQUssS0FBSztnQkFDbkIsSUFBSTlNO2dCQUNKLElBQUk4TSxJQUFJLENBQUMsRUFBRSxLQUFLLEtBQUs7b0JBQ25COU0sUUFBUWIsU0FBUzJOLEtBQUs1USxLQUFLLENBQUMsSUFBSTtnQkFDbEMsT0FBTztvQkFDTDhELFFBQVF5bEIsT0FBTzNZLEtBQUs1USxLQUFLLENBQUM7Z0JBQzVCO2dCQUNBLE9BQU95eEIsY0FBYzN0QjtZQUN2QixPQUFPO2dCQUNMLElBQUk2dEIsUUFBUUgsa0JBQWtCLENBQUM1Z0IsS0FBSztnQkFDcEMsSUFBSStnQixPQUFPO29CQUNULE9BQU9BO2dCQUNUO2dCQUVBLG1CQUFtQjtnQkFDbkIsT0FBT2pTO1lBQ1Q7UUFDRjtRQUNBLE9BQU83UDtJQUNUO0lBQ0FzTyxNQUFNdUMsU0FBUyxDQUFDa1IsRUFBRSxHQUFHelQsTUFBTXVDLFNBQVMsQ0FBQ2lRLFFBQVE7QUFDL0MsR0FBR3hTO0FBQ0hBLE1BQU11QyxTQUFTLENBQUNtUixVQUFVLEdBQUcxVCxNQUFNdUMsU0FBUyxDQUFDSSxNQUFNLENBQUMsS0FBSztJQUN2RCxVQUFVO1FBQ1J1RCxTQUFTO1FBQ1RZLFFBQVE7SUFDVjtJQUNBLFdBQVc7SUFDWCxZQUFZO0FBQ2Q7QUFDQSxPQUFPOUcsTUFBTXVDLFNBQVMsQ0FBQ21SLFVBQVUsQ0FBQyxhQUFhO0FBQy9DMVQsTUFBTXVDLFNBQVMsQ0FBQ29SLElBQUksR0FBRzNULE1BQU11QyxTQUFTLENBQUNtUixVQUFVO0FBQ2hELFVBQVUxVCxLQUFLO0lBQ2QsSUFBSTRULFdBQVcsNkdBQTZHM00sTUFBTTtJQUNsSWpILE1BQU11QyxTQUFTLENBQUNzUixJQUFJLEdBQUc7UUFDckIsV0FBVztZQUFDO2dCQUNWLE1BQU07Z0JBQ04zTixTQUFTO2dCQUNURSxZQUFZO2dCQUNaVSxRQUFRO1lBQ1Y7WUFBRztnQkFDRFosU0FBUztnQkFDVEUsWUFBWTtnQkFDWlUsUUFBUTtZQUNWO1NBQUU7UUFDRiw0Q0FBNEM7UUFDNUMsVUFBVTtZQUFDO2dCQUNUWixTQUFTckUsT0FBTyxxQ0FBcUNvRixNQUFNLEdBQUcsUUFBUTtvQkFDdEUsU0FBUztvQkFDVCxtREFBbURBLE1BQU07b0JBQ3pELFVBQVU7b0JBQ1YseUNBQXlDO29CQUN6QywyQ0FBMkNBLE1BQU07b0JBQ2pELFNBQVM7b0JBQ1QsU0FBUztvQkFDVCxTQUFTO29CQUNULFNBQVM7b0JBQ1QyTTtpQkFBUyxDQUFDM3RCLElBQUksQ0FBQyxPQUFPO2dCQUN0QjZnQixRQUFRO1lBQ1Y7WUFDQSxlQUFlO1lBQ2Y7Z0JBQ0VaLFNBQVM7Z0JBQ1RZLFFBQVE7WUFDVjtZQUNBLFFBQVE7WUFDUixzR0FBc0c7WUFDdEc7Z0JBQ0VaLFNBQVM7Z0JBQ1RZLFFBQVE7WUFDVjtTQUFFO1FBQ0YsU0FBUztZQUFDO2dCQUNSWixTQUFTckUsT0FBTywrQkFBK0JvRixNQUFNLEdBQUcsUUFBUTtvQkFDaEUsU0FBUztvQkFDVCxtREFBbURBLE1BQU07b0JBQ3pELFVBQVU7b0JBQ1YseUNBQXlDO29CQUN6QywyQ0FBMkNBLE1BQU07b0JBQ2pELFNBQVM7b0JBQ1QsU0FBUztvQkFDVCxTQUFTO29CQUNULFNBQVM7b0JBQ1QyTTtpQkFBUyxDQUFDM3RCLElBQUksQ0FBQyxPQUFPLE1BQU0sbUJBQW1CZ2hCLE1BQU07Z0JBQ3JESCxRQUFRO1lBQ1Y7WUFDQSwyQ0FBMkM7WUFDM0M7Z0JBQ0VaLFNBQVNyRSxPQUFPLHlDQUF5Q29GLE1BQU0sR0FBRyxRQUFRO29CQUMxRSxhQUFhO29CQUNiLHlDQUF5QztvQkFDekMsOEVBQThFQSxNQUFNO29CQUNwRixjQUFjO29CQUNkLHlDQUF5QztvQkFDekMsc0VBQXNFQSxNQUFNO29CQUM1RSxjQUFjO29CQUNkLGNBQWM7b0JBQ2QsY0FBYztvQkFDZCxjQUFjO29CQUNkLGNBQWM7b0JBQ2QyTSxXQUFXLE1BQU0zTSxNQUFNLEdBQUcyTTtpQkFBUyxDQUFDM3RCLElBQUksQ0FBQyxPQUFPLE1BQU0scUJBQXFCZ2hCLE1BQU07Z0JBQ2pGYixZQUFZO2dCQUNaVSxRQUFRO1lBQ1Y7WUFDQSxRQUFRO1lBQ1IsbURBQW1EO1lBQ25ELGlEQUFpRDtZQUNqRCwwQ0FBMEM7WUFDMUM7Z0JBQ0VaLFNBQVM7Z0JBQ1RZLFFBQVE7WUFDVjtTQUFFO1FBQ0Ysb0RBQW9EO1FBQ3BELFlBQVk7WUFDWixnQkFBZ0I7WUFDaEI7WUFDQSxNQUFNO1lBQ047WUFDQSxTQUFTO1lBQ1Q7WUFDQSxPQUFPO1lBQ1A7WUFDQSxLQUFLO1lBQ0w7WUFDQSxhQUFhO1lBQ2IsZ0VBQWdFO1lBQ2hFO1NBQW9EO1FBQ3BELGNBQWM7WUFDWixlQUFlO1lBQ2ZaLFNBQVM7WUFDVHhGLE9BQU87UUFDVDtRQUNBLFlBQVk7WUFDVixjQUFjO1lBQ2R3RixTQUFTO1lBQ1R4RixPQUFPO1FBQ1Q7UUFDQSxZQUFZO1lBQ1Z3RixTQUFTO1lBQ1RFLFlBQVk7UUFDZDtRQUNBLFdBQVc7UUFDWCxVQUFVO1FBQ1YsWUFBWTtRQUNaLGVBQWU7SUFDakI7QUFDRixHQUFHcEc7QUFDRixVQUFVQSxLQUFLO0lBQ2Q7Ozs7OztHQU1DLEdBQ0QsU0FBUzhULGVBQWV2Z0IsUUFBUSxFQUFFMkssS0FBSztRQUNyQyxPQUFPLFFBQVEzSyxTQUFTd2dCLFdBQVcsS0FBSzdWLFFBQVE7SUFDbEQ7SUFDQXZYLE9BQU9xdEIsZ0JBQWdCLENBQUNoVSxNQUFNdUMsU0FBUyxDQUFDLG9CQUFvQixHQUFHLENBQUMsR0FBRztRQUNqRTBSLG1CQUFtQjtZQUNqQjs7Ozs7Ozs7OztPQVVDLEdBQ0R0dUIsT0FBTyxTQUFVb2UsR0FBRyxFQUFFeFEsUUFBUSxFQUFFMmdCLGtCQUFrQixFQUFFQyxhQUFhO2dCQUMvRCxJQUFJcFEsSUFBSXhRLFFBQVEsS0FBS0EsVUFBVTtvQkFDN0I7Z0JBQ0Y7Z0JBQ0EsSUFBSTZnQixhQUFhclEsSUFBSXFRLFVBQVUsR0FBRyxFQUFFO2dCQUNwQ3JRLElBQUl0UixJQUFJLEdBQUdzUixJQUFJdFIsSUFBSSxDQUFDclYsT0FBTyxDQUFDODJCLG9CQUFvQixTQUFVdFUsS0FBSztvQkFDN0QsSUFBSSxPQUFPdVUsa0JBQWtCLGNBQWMsQ0FBQ0EsY0FBY3ZVLFFBQVE7d0JBQ2hFLE9BQU9BO29CQUNUO29CQUNBLElBQUloYixJQUFJd3ZCLFdBQVduekIsTUFBTTtvQkFDekIsSUFBSW96QjtvQkFFSiw2QkFBNkI7b0JBQzdCLE1BQU90USxJQUFJdFIsSUFBSSxDQUFDNmhCLE9BQU8sQ0FBQ0QsY0FBY1AsZUFBZXZnQixVQUFVM08sUUFBUSxDQUFDLEVBQUc7d0JBQ3pFLEVBQUVBO29CQUNKO29CQUVBLHdCQUF3QjtvQkFDeEJ3dkIsVUFBVSxDQUFDeHZCLEVBQUUsR0FBR2diO29CQUNoQixPQUFPeVU7Z0JBQ1Q7Z0JBRUEsK0JBQStCO2dCQUMvQnRRLElBQUlkLE9BQU8sR0FBR2pELE1BQU11QyxTQUFTLENBQUNpRyxNQUFNO1lBQ3RDO1FBQ0Y7UUFDQStMLHNCQUFzQjtZQUNwQjs7Ozs7T0FLQyxHQUNENXVCLE9BQU8sU0FBVW9lLEdBQUcsRUFBRXhRLFFBQVE7Z0JBQzVCLElBQUl3USxJQUFJeFEsUUFBUSxLQUFLQSxZQUFZLENBQUN3USxJQUFJcVEsVUFBVSxFQUFFO29CQUNoRDtnQkFDRjtnQkFFQSwwQkFBMEI7Z0JBQzFCclEsSUFBSWQsT0FBTyxHQUFHakQsTUFBTXVDLFNBQVMsQ0FBQ2hQLFNBQVM7Z0JBQ3ZDLElBQUlvVCxJQUFJO2dCQUNSLElBQUl4WCxPQUFPeEksT0FBT3dJLElBQUksQ0FBQzRVLElBQUlxUSxVQUFVO2dCQUNyQyxTQUFTdkQsV0FBV3JRLE1BQU07b0JBQ3hCLElBQUssSUFBSTViLElBQUksR0FBR0EsSUFBSTRiLE9BQU92ZixNQUFNLEVBQUUyRCxJQUFLO3dCQUN0Qyx3Q0FBd0M7d0JBQ3hDLElBQUkraEIsS0FBS3hYLEtBQUtsTyxNQUFNLEVBQUU7NEJBQ3BCO3dCQUNGO3dCQUNBLElBQUlraUIsUUFBUTNDLE1BQU0sQ0FBQzViLEVBQUU7d0JBQ3JCLElBQUksT0FBT3VlLFVBQVUsWUFBWUEsTUFBTTNpQixPQUFPLElBQUksT0FBTzJpQixNQUFNM2lCLE9BQU8sS0FBSyxVQUFVOzRCQUNuRixJQUFJK21CLElBQUlwWSxJQUFJLENBQUN3WCxFQUFFOzRCQUNmLElBQUk2TixJQUFJelEsSUFBSXFRLFVBQVUsQ0FBQzdNLEVBQUU7NEJBQ3pCLElBQUkvTCxJQUFJLE9BQU8ySCxVQUFVLFdBQVdBLFFBQVFBLE1BQU0zaUIsT0FBTzs0QkFDekQsSUFBSTZ6QixjQUFjUCxlQUFldmdCLFVBQVVnVTs0QkFDM0MsSUFBSXJKLFFBQVExQyxFQUFFOFksT0FBTyxDQUFDRDs0QkFDdEIsSUFBSW5XLFFBQVEsQ0FBQyxHQUFHO2dDQUNkLEVBQUV5STtnQ0FDRixJQUFJNUQsU0FBU3ZILEVBQUVpWixTQUFTLENBQUMsR0FBR3ZXO2dDQUM1QixJQUFJd1csU0FBUyxJQUFJMVUsTUFBTVMsS0FBSyxDQUFDbE4sVUFBVXlNLE1BQU1xRixRQUFRLENBQUNtUCxHQUFHelEsSUFBSWQsT0FBTyxHQUFHLGNBQWMxUCxVQUFVaWhCO2dDQUMvRixJQUFJL00sUUFBUWpNLEVBQUVpWixTQUFTLENBQUN2VyxRQUFRbVcsWUFBWXB6QixNQUFNO2dDQUNsRCxJQUFJMHpCLGNBQWMsRUFBRTtnQ0FDcEIsSUFBSTVSLFFBQVE7b0NBQ1Y0UixZQUFZMXRCLElBQUksQ0FBQ21kLEtBQUssQ0FBQ3VRLGFBQWE5RCxXQUFXO3dDQUFDOU47cUNBQU87Z0NBQ3pEO2dDQUNBNFIsWUFBWTF0QixJQUFJLENBQUN5dEI7Z0NBQ2pCLElBQUlqTixPQUFPO29DQUNUa04sWUFBWTF0QixJQUFJLENBQUNtZCxLQUFLLENBQUN1USxhQUFhOUQsV0FBVzt3Q0FBQ3BKO3FDQUFNO2dDQUN4RDtnQ0FDQSxJQUFJLE9BQU90RSxVQUFVLFVBQVU7b0NBQzdCM0MsT0FBTzJRLE1BQU0sQ0FBQy9NLEtBQUssQ0FBQzVELFFBQVE7d0NBQUM1Yjt3Q0FBRztxQ0FBRSxDQUFDb0IsTUFBTSxDQUFDMnVCO2dDQUM1QyxPQUFPO29DQUNMeFIsTUFBTTNpQixPQUFPLEdBQUdtMEI7Z0NBQ2xCOzRCQUNGO3dCQUNGLE9BQU8sSUFBSXhSLE1BQU0zaUIsT0FBTyxDQUFDLHdDQUF3QyxLQUFJOzRCQUNuRXF3QixXQUFXMU4sTUFBTTNpQixPQUFPO3dCQUMxQjtvQkFDRjtvQkFDQSxPQUFPZ2dCO2dCQUNUO2dCQUNBcVEsV0FBVzlNLElBQUl2RCxNQUFNO1lBQ3ZCO1FBQ0Y7SUFDRjtBQUNGLEdBQUdSO0FBRUg7Ozs7OztDQU1DLEdBQ0EsVUFBVUEsS0FBSztJQUNkLElBQUk0VSxVQUFVO0lBQ2QsSUFBSUMsV0FBVztRQUFDO1lBQ2QzTyxTQUFTO1lBQ1R4RixPQUFPO1FBQ1Q7UUFBRztZQUNEd0YsU0FBUztZQUNUWSxRQUFRO1lBQ1JWLFlBQVk7UUFDZDtRQUFHO1lBQ0RGLFNBQVM7WUFDVFksUUFBUTtZQUNSVixZQUFZO1FBQ2Q7UUFBRztRQUFpQjtLQUFnQztJQUNwRCxJQUFJME8sU0FBUztJQUNiLElBQUlDLFdBQVc7SUFDZixJQUFJdEMsY0FBYztJQUNsQnpTLE1BQU11QyxTQUFTLENBQUN5UyxHQUFHLEdBQUc7UUFDcEIsYUFBYTtZQUNYOU8sU0FBUztZQUNUeEYsT0FBTztRQUNUO1FBQ0EsV0FBV2tVO1FBQ1gsWUFBWTtRQUNaLFdBQVc7WUFDVDFPLFNBQVM7WUFDVEUsWUFBWTtZQUNadEQsUUFBUTtnQkFDTixlQUFlO1lBQ2pCO1FBQ0Y7UUFDQSx5QkFBeUI7WUFDdkJvRCxTQUFTO1lBQ1RFLFlBQVk7WUFDWjFGLE9BQU87UUFDVDtRQUNBLHVCQUF1QjtZQUNyQndGLFNBQVM7WUFDVEUsWUFBWTtZQUNaMUYsT0FBTztRQUNUO1FBQ0EsV0FBVztZQUFDO2dCQUNWd0YsU0FBUztnQkFDVHhGLE9BQU87Z0JBQ1BvRyxRQUFRO2dCQUNSVixZQUFZO1lBQ2Q7WUFBRztnQkFDREYsU0FBUztnQkFDVHhGLE9BQU87Z0JBQ1BvRyxRQUFRO2dCQUNSVixZQUFZO1lBQ2Q7WUFBRztnQkFDREYsU0FBUztnQkFDVHhGLE9BQU87Z0JBQ1BvRyxRQUFRO2dCQUNSVixZQUFZO1lBQ2Q7WUFBRztnQkFDREYsU0FBUztnQkFDVHhGLE9BQU87Z0JBQ1BvRyxRQUFRO1lBQ1Y7WUFBRztnQkFDRFosU0FBUztnQkFDVHhGLE9BQU87Z0JBQ1BvRyxRQUFRO2dCQUNSVixZQUFZO1lBQ2Q7WUFBRztnQkFDREYsU0FBUztnQkFDVHhGLE9BQU87Z0JBQ1BvRyxRQUFRO1lBQ1Y7WUFBRztnQkFDRCxhQUFhO2dCQUNiWixTQUFTO2dCQUNURSxZQUFZO1lBQ2Q7WUFDQSxvREFBb0Q7WUFDcEQ7WUFBYztnQkFDWixzREFBc0Q7Z0JBQ3RELEVBQUU7Z0JBQ0Ysc0NBQXNDO2dCQUN0QyxtREFBbUQ7Z0JBQ25ERixTQUFTO2dCQUNURSxZQUFZO1lBQ2Q7U0FBRTtRQUNGLGlCQUFpQjtZQUNmRixTQUFTO1lBQ1RFLFlBQVk7UUFDZDtRQUNBLGNBQWM7WUFBQztnQkFDYkYsU0FBUztnQkFDVFksUUFBUTtnQkFDUlYsWUFBWTtZQUNkO1lBQUc7Z0JBQ0RGLFNBQVM7Z0JBQ1RZLFFBQVE7Z0JBQ1JWLFlBQVk7WUFDZDtZQUFHO2dCQUNERixTQUFTO2dCQUNUWSxRQUFRO1lBQ1Y7WUFBRztnQkFDRFosU0FBUztnQkFDVHhGLE9BQU87Z0JBQ1BvRyxRQUFRO2dCQUNSVixZQUFZO2dCQUNadEQsUUFBUTtvQkFDTixlQUFlO2dCQUNqQjtZQUNGO1lBQUc7Z0JBQ0RvRCxTQUFTO2dCQUNUeEYsT0FBTztnQkFDUG9HLFFBQVE7Z0JBQ1JoRSxRQUFRO29CQUNOLGVBQWU7Z0JBQ2pCO1lBQ0Y7WUFBRztnQkFDRG9ELFNBQVM7Z0JBQ1R4RixPQUFPO2dCQUNQb0csUUFBUTtnQkFDUlYsWUFBWTtnQkFDWnRELFFBQVE7b0JBQ04sZUFBZTtnQkFDakI7WUFDRjtZQUFHO2dCQUNEb0QsU0FBUztnQkFDVHhGLE9BQU87Z0JBQ1BvRyxRQUFRO1lBQ1Y7WUFBRztnQkFDRFosU0FBUztnQkFDVHhGLE9BQU87b0JBQUM7b0JBQThCO2lCQUFtQjtnQkFDekRvRyxRQUFRO2dCQUNSaEUsUUFBUTtvQkFDTixlQUFlO2dCQUNqQjtZQUNGO1lBQUc7Z0JBQ0RvRCxTQUFTO2dCQUNUeEYsT0FBTztnQkFDUG9HLFFBQVE7WUFDVjtZQUFHO2dCQUNEWixTQUFTO2dCQUNUeEYsT0FBTztvQkFBQztvQkFBOEI7aUJBQWlCO2dCQUN2RG9HLFFBQVE7Z0JBQ1JoRSxRQUFRO29CQUNOLGVBQWU7Z0JBQ2pCO1lBQ0Y7WUFBRztnQkFDRG9ELFNBQVM7Z0JBQ1R4RixPQUFPO2dCQUNQb0csUUFBUTtnQkFDUlYsWUFBWTtZQUNkO1lBQUc7Z0JBQ0RGLFNBQVM7Z0JBQ1R4RixPQUFPO29CQUFDO29CQUE4QjtpQkFBWTtnQkFDbERvRyxRQUFRO2dCQUNSVixZQUFZO2dCQUNadEQsUUFBUTtvQkFDTixlQUFlO2dCQUNqQjtZQUNGO1lBQUc7Z0JBQ0RvRCxTQUFTO2dCQUNUeEYsT0FBTztnQkFDUG9HLFFBQVE7Z0JBQ1JWLFlBQVk7WUFDZDtZQUFHO2dCQUNERixTQUFTO2dCQUNUeEYsT0FBTztvQkFBQztvQkFBOEI7aUJBQWM7Z0JBQ3BEb0csUUFBUTtnQkFDUlYsWUFBWTtnQkFDWnRELFFBQVE7b0JBQ04sZUFBZTtnQkFDakI7WUFDRjtTQUFFO1FBQ0YsWUFBWStSO1FBQ1osWUFBWTtZQUNWM08sU0FBUztZQUNURSxZQUFZO1lBQ1p0RCxRQUFRO2dCQUNOLGVBQWU7WUFDakI7UUFDRjtRQUNBLFlBQVk7WUFDVm9ELFNBQVM7WUFDVEUsWUFBWTtRQUNkO1FBQ0EsVUFBVTBPO1FBQ1YsWUFBWUM7UUFDWixlQUFldEM7SUFDakI7SUFDQSxJQUFJd0MsdUJBQXVCO1FBQ3pCL08sU0FBUztRQUNURSxZQUFZO1FBQ1p0RCxRQUFROUMsTUFBTXVDLFNBQVMsQ0FBQ3lTLEdBQUc7SUFDN0I7SUFDQSxJQUFJM0wsU0FBUztRQUFDO1lBQ1puRCxTQUFTO1lBQ1R4RixPQUFPO1lBQ1BvRyxRQUFRO1lBQ1JoRSxRQUFRO2dCQUNOLGFBQWE7b0JBQ1hvRCxTQUFTO29CQUNUeEYsT0FBTztvQkFDUG9DLFFBQVE7d0JBQ04sZUFBZTtvQkFDakI7Z0JBQ0Y7WUFDRjtRQUNGO1FBQUc7WUFDRG9ELFNBQVM7WUFDVHhGLE9BQU87WUFDUG9HLFFBQVE7WUFDUmhFLFFBQVE7Z0JBQ04sYUFBYTtvQkFDWG9ELFNBQVM7b0JBQ1R4RixPQUFPO29CQUNQb0MsUUFBUTt3QkFDTixlQUFlO29CQUNqQjtnQkFDRjtnQkFDQSxpQkFBaUJtUztZQUNuQjtRQUNGO1FBQUc7WUFDRC9PLFNBQVM7WUFDVHhGLE9BQU87WUFDUG9HLFFBQVE7UUFDVjtRQUFHO1lBQ0RaLFNBQVM7WUFDVHhGLE9BQU87WUFDUG9HLFFBQVE7UUFDVjtRQUFHO1lBQ0RaLFNBQVM7WUFDVHhGLE9BQU87WUFDUG9HLFFBQVE7WUFDUmhFLFFBQVE7Z0JBQ04saUJBQWlCbVM7WUFDbkI7UUFDRjtLQUFFO0lBQ0ZqVixNQUFNdUMsU0FBUyxDQUFDTSxZQUFZLENBQUMsT0FBTyxZQUFZO1FBQzlDLFVBQVV3RztRQUNWLGFBQWE7WUFDWG5ELFNBQVM7WUFDVFksUUFBUTtZQUNSaEUsUUFBUTtnQkFDTixxQkFBcUI7b0JBQ25Cb0QsU0FBUztvQkFDVEUsWUFBWTtvQkFDWixrQ0FBa0M7b0JBQ2xDdEQsUUFBUTt3QkFDTixXQUFXOFI7d0JBQ1gsVUFBVXZMO3dCQUNWLHdCQUF3Qjs0QkFBQztnQ0FDdkJuRCxTQUFTO2dDQUNUeEYsT0FBTztnQ0FDUG9HLFFBQVE7Z0NBQ1JWLFlBQVk7NEJBQ2Q7NEJBQUc7Z0NBQ0RGLFNBQVM7Z0NBQ1R4RixPQUFPO29DQUFDO29DQUFjO2lDQUE2QjtnQ0FDbkRvRyxRQUFRO2dDQUNSVixZQUFZO2dDQUNadEQsUUFBUTtvQ0FDTixlQUFlO2dDQUNqQjs0QkFDRjt5QkFBRTt3QkFDRixZQUFZK1I7d0JBQ1osVUFBVUM7d0JBQ1YsWUFBWUM7d0JBQ1osZUFBZXRDO29CQUNqQjtnQkFDRjtnQkFDQSxhQUFhO29CQUNYdk0sU0FBUztvQkFDVHhGLE9BQU87Z0JBQ1Q7WUFDRjtRQUNGO0lBQ0Y7SUFDQVYsTUFBTWlFLEtBQUssQ0FBQ3pkLEdBQUcsQ0FBQyxtQkFBbUIsU0FBVXVkLEdBQUc7UUFDOUMsSUFBSSxDQUFDLE1BQU1ubUIsSUFBSSxDQUFDbW1CLElBQUl0UixJQUFJLEdBQUc7WUFDekI7UUFDRjtRQUNBLElBQUl5aUIsYUFBYTtRQUNqQmxWLE1BQU11QyxTQUFTLENBQUMsb0JBQW9CLENBQUMwUixpQkFBaUIsQ0FBQ2xRLEtBQUssT0FBT21SO0lBQ3JFO0lBQ0FsVixNQUFNaUUsS0FBSyxDQUFDemQsR0FBRyxDQUFDLGtCQUFrQixTQUFVdWQsR0FBRztRQUM3Qy9ELE1BQU11QyxTQUFTLENBQUMsb0JBQW9CLENBQUNnUyxvQkFBb0IsQ0FBQ3hRLEtBQUs7SUFDakU7QUFDRixHQUFHL0Q7QUFDSEEsTUFBTXVDLFNBQVMsQ0FBQzRTLE1BQU0sR0FBRztJQUN2QixXQUFXO1FBQ1RqUCxTQUFTO1FBQ1RFLFlBQVk7UUFDWlUsUUFBUTtJQUNWO0lBQ0Esd0JBQXdCO1FBQ3RCWixTQUFTO1FBQ1RZLFFBQVE7UUFDUmhFLFFBQVE7WUFDTixpQkFBaUI7Z0JBQ2Ysc0ZBQXNGO2dCQUN0Rm9ELFNBQVM7Z0JBQ1RFLFlBQVk7Z0JBQ1p0RCxRQUFRO29CQUNOLGVBQWU7d0JBQ2JvRCxTQUFTO3dCQUNURSxZQUFZO29CQUNkO29CQUNBLHFCQUFxQjt3QkFDbkJGLFNBQVM7d0JBQ1R4RixPQUFPO29CQUNUO29CQUNBbE4sTUFBTTtnQkFDUjtZQUNGO1lBQ0EsVUFBVTtRQUNaO0lBQ0Y7SUFDQSx3QkFBd0I7UUFDdEIwUyxTQUFTO1FBQ1RZLFFBQVE7UUFDUnBHLE9BQU87SUFDVDtJQUNBLFVBQVU7UUFDUndGLFNBQVM7UUFDVFksUUFBUTtJQUNWO0lBQ0EsWUFBWTtRQUNWWixTQUFTO1FBQ1RFLFlBQVk7SUFDZDtJQUNBLGNBQWM7UUFDWkYsU0FBUztRQUNURSxZQUFZO0lBQ2Q7SUFDQSxhQUFhO1FBQ1hGLFNBQVM7UUFDVEUsWUFBWTtRQUNaMUYsT0FBTztZQUFDO1lBQWM7U0FBYztRQUNwQ29DLFFBQVE7WUFDTixlQUFlO1FBQ2pCO0lBQ0Y7SUFDQSxXQUFXO0lBQ1gsV0FBVztJQUNYLFdBQVc7SUFDWCxVQUFVO0lBQ1YsWUFBWTtJQUNaLGVBQWU7QUFDakI7QUFDQTlDLE1BQU11QyxTQUFTLENBQUM0UyxNQUFNLENBQUMsdUJBQXVCLENBQUNyUyxNQUFNLENBQUMsZ0JBQWdCLENBQUNBLE1BQU0sQ0FBQ3RQLElBQUksR0FBR3dNLE1BQU11QyxTQUFTLENBQUM0UyxNQUFNO0FBQzNHblYsTUFBTXVDLFNBQVMsQ0FBQzZTLEVBQUUsR0FBR3BWLE1BQU11QyxTQUFTLENBQUM0UyxNQUFNO0FBQzNDblYsTUFBTXVDLFNBQVMsQ0FBQzhTLENBQUMsR0FBRztJQUNsQixXQUFXO0lBQ1gsVUFBVTtRQUNSblAsU0FBUztRQUNUWSxRQUFRO0lBQ1Y7SUFDQSxvQkFBb0I7UUFDbEIsa0NBQWtDO1FBQ2xDLG1DQUFtQztRQUNuQ1osU0FBUztRQUNUeEYsT0FBTztJQUNUO0lBQ0EsV0FBVztJQUNYLFlBQVk7SUFDWixVQUFVO1FBQUM7UUFBbUI7S0FBZ0Y7SUFDOUcsV0FBVztJQUNYLFlBQVk7SUFDWixlQUFlO0FBQ2pCO0FBRUE7Ozs7O0NBS0MsR0FDQSxVQUFVVixLQUFLO0lBQ2RBLE1BQU11QyxTQUFTLENBQUMrUyxJQUFJLEdBQUd0VixNQUFNdUMsU0FBUyxDQUFDSSxNQUFNLENBQUMsU0FBUztRQUNyRCxXQUFXO1lBQ1R1RCxTQUFTO1lBQ1RZLFFBQVE7UUFDVjtRQUNBLGNBQWM7WUFDWlosU0FBUztZQUNURSxZQUFZO1lBQ1p0RCxRQUFRO2dCQUNOLGVBQWU7WUFDakI7UUFDRjtRQUNBLFdBQVc7UUFDWCxZQUFZO1FBQ1osZUFBZTtJQUNqQjtJQUNBOUMsTUFBTXVDLFNBQVMsQ0FBQ00sWUFBWSxDQUFDLFFBQVEsWUFBWTtRQUMvQyxnQkFBZ0I7WUFDZHFELFNBQVM7WUFDVHhGLE9BQU87UUFDVDtJQUNGO0lBQ0EsSUFBSThPLGdCQUFnQjtRQUNsQnRKLFNBQVM7UUFDVEUsWUFBWTtRQUNadEQsUUFBUTtZQUNOLFdBQVc7Z0JBQ1RvRCxTQUFTO2dCQUNURSxZQUFZO2dCQUNadEQsUUFBUTlDLE1BQU11QyxTQUFTLENBQUMrUyxJQUFJO1lBQzlCO1lBQ0EsYUFBYTtnQkFDWHBQLFNBQVM7Z0JBQ1R4RixPQUFPO1lBQ1Q7UUFDRjtJQUNGO0lBQ0EsT0FBT1YsTUFBTXVDLFNBQVMsQ0FBQytTLElBQUksQ0FBQ3BGLFFBQVE7SUFDcEMsSUFBSXFGLG9CQUFvQixRQUFRO1FBQUMsb0RBQW9EdE8sTUFBTTtRQUFFLHNEQUFzREEsTUFBTTtRQUFFLHNEQUFzREEsTUFBTTtRQUFFLDBEQUEwREEsTUFBTTtRQUFFLGtEQUFrREEsTUFBTTtLQUFDLENBQUNoaEIsSUFBSSxDQUFDLE9BQU87SUFDalcsSUFBSXV2QixhQUFhLHNFQUFzRXZPLE1BQU07SUFDN0ZqSCxNQUFNdUMsU0FBUyxDQUFDTSxZQUFZLENBQUMsUUFBUSxXQUFXO1FBQzlDLGlCQUFpQjtZQUFDO2dCQUNoQnFELFNBQVNyRSxPQUFPLEtBQUtvRixNQUFNLEdBQUdzTyxvQkFBb0IsbUJBQW1CdE8sTUFBTTtnQkFDM0VILFFBQVE7Z0JBQ1JoRSxRQUFRO29CQUNOLGlCQUFpQjBNO29CQUNqQixTQUFTO2dCQUNYO1lBQ0Y7WUFBRztnQkFDRHRKLFNBQVM7Z0JBQ1RFLFlBQVk7Z0JBQ1pVLFFBQVE7Z0JBQ1JoRSxRQUFRO29CQUNOLGlCQUFpQjBNO29CQUNqQixTQUFTO2dCQUNYO1lBQ0Y7U0FBRTtRQUNGLFlBQVk7UUFDWixVQUFVO1lBQUM7Z0JBQ1R0SixTQUFTckUsT0FBTyxZQUFZb0YsTUFBTSxHQUFHdU87Z0JBQ3JDcFAsWUFBWTtnQkFDWlUsUUFBUTtZQUNWO1lBQUc7Z0JBQ0RaLFNBQVNyRSxPQUFPLG9CQUFvQm9GLE1BQU0sR0FBR3VPLGFBQWEsYUFBYXZPLE1BQU07Z0JBQzdFYixZQUFZO2dCQUNaVSxRQUFRO1lBQ1Y7U0FBRTtRQUNGLHFCQUFxQjtZQUNuQlosU0FBUztZQUNURSxZQUFZO1lBQ1p0RCxRQUFRO2dCQUNOLFlBQVk7Z0JBQ1osV0FBVztnQkFDWCxjQUFjO2dCQUNkLGVBQWU7WUFDakI7UUFDRjtJQUNGO0lBQ0E5QyxNQUFNdUMsU0FBUyxDQUFDTSxZQUFZLENBQUMsUUFBUSxVQUFVO1FBQzdDLGtCQUFrQjtZQUFDO2dCQUNqQnFELFNBQVNyRSxPQUFPLGNBQWNvRixNQUFNLEdBQUdzTztnQkFDdkN6TyxRQUFRO2dCQUNSaEUsUUFBUTtvQkFDTixpQkFBaUIwTTtvQkFDakIsVUFBVTtnQkFDWjtZQUNGO1lBQUc7Z0JBQ0R0SixTQUFTO2dCQUNUWSxRQUFRO2dCQUNSaEUsUUFBUTtvQkFDTixpQkFBaUIwTTtvQkFDakIsVUFBVTtnQkFDWjtZQUNGO1lBQUc7Z0JBQ0R0SixTQUFTO2dCQUNUeEYsT0FBTztnQkFDUG9HLFFBQVE7Z0JBQ1JoRSxRQUFRO29CQUNOLGFBQWE7d0JBQ1hvRCxTQUFTO3dCQUNUcEQsUUFBUTs0QkFDTixVQUFVOzRCQUNWLGVBQWU7d0JBQ2pCO29CQUNGO29CQUNBLGlCQUFpQjBNO29CQUNqQixVQUFVO2dCQUNaO1lBQ0Y7WUFBRztnQkFDRHRKLFNBQVM7Z0JBQ1R4RixPQUFPO2dCQUNQb0csUUFBUTtnQkFDUmhFLFFBQVE7b0JBQ04sYUFBYTt3QkFDWG9ELFNBQVM7d0JBQ1RwRCxRQUFROzRCQUNOLFVBQVU7NEJBQ1YsZUFBZTt3QkFDakI7b0JBQ0Y7b0JBQ0EsVUFBVTtnQkFDWjtZQUNGO1NBQUU7UUFDRixtQkFBbUI7WUFBQztnQkFDbEJvRCxTQUFTckUsT0FBTyxLQUFLb0YsTUFBTSxHQUFHc087Z0JBQzlCek8sUUFBUTtnQkFDUmhFLFFBQVE7b0JBQ04saUJBQWlCME07b0JBQ2pCLFdBQVc7d0JBQ1R0SixTQUFTO3dCQUNUeEYsT0FBTztvQkFDVDtnQkFDRjtZQUNGO1lBQUc7Z0JBQ0R3RixTQUFTO2dCQUNUWSxRQUFRO2dCQUNSaEUsUUFBUTtvQkFDTixpQkFBaUIwTTtvQkFDakIsV0FBVzt3QkFDVHRKLFNBQVM7d0JBQ1R4RixPQUFPO29CQUNUO2dCQUNGO1lBQ0Y7U0FBRTtJQUNKO0lBQ0EsT0FBT1YsTUFBTXVDLFNBQVMsQ0FBQytTLElBQUksQ0FBQ2pNLE1BQU07SUFDbENySixNQUFNdUMsU0FBUyxDQUFDTSxZQUFZLENBQUMsUUFBUSxVQUFVO1FBQzdDLFdBQVc7UUFDWCxZQUFZO0lBQ2Q7SUFDQTdDLE1BQU11QyxTQUFTLENBQUNrVCxFQUFFLEdBQUd6VixNQUFNdUMsU0FBUyxDQUFDK1MsSUFBSTtBQUMzQyxHQUFHdFY7QUFDRixVQUFVQSxLQUFLO0lBQ2QsSUFBSTBWLG1CQUFtQiw4Q0FBOEN6TyxNQUFNO0lBQzNFLElBQUssSUFBSXJpQixJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFBSztRQUMxQixzQ0FBc0M7UUFDdEM4d0IsbUJBQW1CQSxpQkFBaUJ0NEIsT0FBTyxDQUFDLFdBQVc7WUFDckQsT0FBT3M0QjtRQUNUO0lBQ0Y7SUFDQUEsbUJBQW1CQSxpQkFBaUJ0NEIsT0FBTyxDQUFDLFdBQVc7UUFDckQsT0FBTyxVQUFVNnBCLE1BQU07SUFDekI7SUFDQWpILE1BQU11QyxTQUFTLENBQUNvVCxJQUFJLEdBQUc7UUFDckIsV0FBVztZQUFDO2dCQUNWelAsU0FBU3JFLE9BQU8sWUFBWW9GLE1BQU0sR0FBR3lPO2dCQUNyQ3RQLFlBQVk7Z0JBQ1pVLFFBQVE7WUFDVjtZQUFHO2dCQUNEWixTQUFTO2dCQUNURSxZQUFZO2dCQUNaVSxRQUFRO1lBQ1Y7U0FBRTtRQUNGLFVBQVU7WUFDUlosU0FBUztZQUNUWSxRQUFRO1FBQ1Y7UUFDQSxRQUFRO1lBQ05aLFNBQVM7WUFDVFksUUFBUTtRQUNWO1FBQ0EsYUFBYTtZQUNYWixTQUFTO1lBQ1RZLFFBQVE7WUFDUnBHLE9BQU87WUFDUG9DLFFBQVE7Z0JBQ04sVUFBVSxLQUFLLFlBQVk7WUFDN0I7UUFDRjtRQUVBLDBEQUEwRDtRQUMxRCxrQkFBa0I7WUFDaEJvRCxTQUFTO1lBQ1RFLFlBQVk7WUFDWlUsUUFBUTtZQUNSaEUsUUFBUTtnQkFDTix1QkFBdUI7b0JBQ3JCb0QsU0FBUztvQkFDVHhGLE9BQU87Z0JBQ1Q7Z0JBQ0FsTixNQUFNLEtBQUssWUFBWTtZQUN6QjtRQUNGO1FBRUEsdUJBQXVCO1lBQ3JCMFMsU0FBUztZQUNUeEYsT0FBTztRQUNUO1FBQ0Esc0JBQXNCO1lBQ3BCd0YsU0FBUztZQUNURSxZQUFZO1lBQ1oxRixPQUFPO1FBQ1Q7UUFDQSxZQUFZO1FBQ1osdUJBQXVCO1lBQ3JCd0YsU0FBUztZQUNURSxZQUFZO1lBQ1oxRixPQUFPO1FBQ1Q7UUFDQSxtQkFBbUI7WUFDakJ3RixTQUFTO1lBQ1RFLFlBQVk7WUFDWjFGLE9BQU87UUFDVDtRQUNBLHNCQUFzQjtZQUFDO2dCQUNyQndGLFNBQVM7Z0JBQ1RFLFlBQVk7Z0JBQ1oxRixPQUFPO1lBQ1Q7WUFBRztnQkFDRHdGLFNBQVM7Z0JBQ1RFLFlBQVk7Z0JBQ1oxRixPQUFPO2dCQUNQb0MsUUFBUTtvQkFDTixlQUFlO2dCQUNqQjtZQUNGO1NBQUU7UUFDRixXQUFXO1lBQ1gscUVBQXFFO1lBQ3JFO1lBQ0EscUJBQXFCO1lBQ3JCLG1FQUFtRTtZQUNuRTtTQUErRDtRQUMvRCw4R0FBOEc7UUFDOUcsNkRBQTZEO1FBQzdELGlFQUFpRTtRQUNqRSxZQUFZO1FBQ1osU0FBUztZQUNQb0QsU0FBUztZQUNUeEYsT0FBTztRQUNUO1FBQ0EsWUFBWTtRQUNaLGNBQWM7UUFDZCxhQUFhO1lBQ1h3RixTQUFTO1lBQ1RwRCxRQUFRO2dCQUNOLGVBQWU7WUFDakI7UUFDRjtRQUNBLG9FQUFvRTtRQUNwRSxVQUFVO1FBQ1YsV0FBVztRQUNYLGVBQWU7UUFDZixZQUFZO0lBQ2Q7SUFDQTlDLE1BQU11QyxTQUFTLENBQUNvVCxJQUFJLENBQUMsaUJBQWlCLENBQUM3UyxNQUFNLENBQUN0UCxJQUFJLEdBQUd3TSxNQUFNdUMsU0FBUyxDQUFDb1QsSUFBSTtJQUN6RTNWLE1BQU11QyxTQUFTLENBQUNvVCxJQUFJLENBQUMsWUFBWSxDQUFDN1MsTUFBTSxDQUFDLFNBQVMsR0FBRzlDLE1BQU11QyxTQUFTLENBQUNvVCxJQUFJLENBQUMsU0FBUztBQUNyRixHQUFHM1Y7QUFDRixVQUFVQSxLQUFLO0lBQ2RBLE1BQU11QyxTQUFTLENBQUNxVCxJQUFJLEdBQUc1VixNQUFNdUMsU0FBUyxDQUFDSSxNQUFNLENBQUMsT0FBTztRQUNuRCx1REFBdUQ7UUFDdkQsV0FBVztZQUNUdUQsU0FBUztZQUNURSxZQUFZO1lBQ1pVLFFBQVE7UUFDVjtJQUNGO0lBQ0E5RyxNQUFNdUMsU0FBUyxDQUFDTSxZQUFZLENBQUMsUUFBUSxVQUFVO1FBQzdDLG9DQUFvQztRQUNwQyxlQUFlO1lBQ2IseUNBQXlDO1lBQ3pDcUQsU0FBUztZQUNUWSxRQUFRO1lBQ1JoRSxRQUFRO2dCQUNOLFVBQVU7WUFDWjtRQUNGO0lBQ0Y7SUFDQSxPQUFPOUMsTUFBTXVDLFNBQVMsQ0FBQ3FULElBQUksQ0FBQ0MsTUFBTTtJQUNsQyxJQUFJOUksV0FBVztJQUNmLElBQUlnSSxXQUFXO1FBQUM7UUFBNEM7WUFDMUQ3TyxTQUFTO1lBQ1RFLFlBQVk7UUFDZDtLQUFFO0lBQ0ZwRyxNQUFNdUMsU0FBUyxDQUFDTSxZQUFZLENBQUMsUUFBUSxZQUFZO1FBQy9DLG9DQUFvQztRQUNwQyxpQkFBaUI7WUFDZnFELFNBQVM7WUFDVFksUUFBUTtZQUNSaEUsUUFBUTtnQkFDTixlQUFlO2dCQUNmLFlBQVlpSztnQkFDWixZQUFZZ0k7WUFDZDtRQUNGO1FBQ0Esb0NBQW9DO1FBQ3BDLGlCQUFpQjtZQUNmN08sU0FBUztZQUNUWSxRQUFRO1lBQ1JoRSxRQUFRO2dCQUNOLFlBQVk7b0JBQUM7b0JBQW1CO3dCQUM5Qm9ELFNBQVM7d0JBQ1RFLFlBQVk7b0JBQ2Q7aUJBQUU7Z0JBQ0YsZUFBZTtnQkFDZixZQUFZMkc7Z0JBQ1osWUFBWWdJO2dCQUNaLGFBQWEvVSxNQUFNdUMsU0FBUyxDQUFDcVQsSUFBSSxDQUFDRSxTQUFTO1lBQzdDO1FBQ0Y7SUFDRjtJQUNBLE9BQU85VixNQUFNdUMsU0FBUyxDQUFDcVQsSUFBSSxDQUFDcFMsUUFBUTtJQUNwQyxPQUFPeEQsTUFBTXVDLFNBQVMsQ0FBQ3FULElBQUksQ0FBQ0UsU0FBUztJQUVyQyx3REFBd0Q7SUFDeEQsa0NBQWtDO0lBQ2xDOVYsTUFBTXVDLFNBQVMsQ0FBQ00sWUFBWSxDQUFDLFFBQVEsZUFBZTtRQUNsRCxZQUFZO1lBQ1ZxRCxTQUFTO1lBQ1RFLFlBQVk7WUFDWlUsUUFBUTtRQUNWO0lBQ0Y7QUFDRixHQUFHOUc7QUFDSEEsTUFBTXVDLFNBQVMsQ0FBQ3dULElBQUksR0FBRy9WLE1BQU11QyxTQUFTLENBQUNJLE1BQU0sQ0FBQyxPQUFPO0lBQ25ELFdBQVc7UUFDVHVELFNBQVM7UUFDVEUsWUFBWTtJQUNkO0lBQ0EsVUFBVTtRQUNSRixTQUFTO1FBQ1RwRCxRQUFRO1lBQ04sUUFBUTtRQUVWO0lBQ0Y7SUFFQSxvQkFBb0I7SUFDcEIsT0FBTztJQUNQLGlEQUFpRDtJQUNqRCxtRUFBbUU7SUFDbkUsa0dBQWtHO0lBQ2xHLHVJQUF1STtJQUN2SSxtSUFBbUk7SUFDbkksaURBQWlEO0lBQ2pELHdFQUF3RTtJQUN4RSxZQUFZO1FBQ1Ysb0VBQW9FO1FBQ3BFb0QsU0FBUztRQUNUcEQsUUFBUTtZQUNOLFVBQVU7Z0JBQ1JvRCxTQUFTO2dCQUNUeEYsT0FBTztZQUNUO1lBQ0EsZUFBZTtZQUNmLFlBQVk7UUFDZDtJQUNGO0lBQ0EsWUFBWTtRQUNWd0YsU0FBUztRQUNUcEQsUUFBUTtZQUNOLFlBQVk7UUFDZDtJQUNGO0FBQ0Y7QUFDQTlDLE1BQU11QyxTQUFTLENBQUNNLFlBQVksQ0FBQyxRQUFRLFVBQVU7SUFDN0MsV0FBVztRQUFDO1FBQXFIO1lBQy9IcUQsU0FBUztZQUNURSxZQUFZO1FBQ2Q7S0FBRTtBQUNKO0FBQ0FwRyxNQUFNdUMsU0FBUyxDQUFDTSxZQUFZLENBQUMsUUFBUSxhQUFhO0lBQ2hELDRCQUE0QjtJQUM1QixZQUFZO0FBQ2Q7QUFDQTdDLE1BQU11QyxTQUFTLENBQUNNLFlBQVksQ0FBQyxRQUFRLFlBQVk7SUFDL0MsbUJBQW1CO1FBQ2pCcUQsU0FBUztRQUNUeEYsT0FBTztJQUNUO0lBQ0EsZUFBZTtRQUNid0YsU0FBUztRQUNUeEYsT0FBTztJQUNUO0lBQ0EsYUFBYTtRQUNYd0YsU0FBUztRQUNUeEYsT0FBTztJQUNUO0lBQ0EsV0FBVztJQUNYLFFBQVE7UUFDTndGLFNBQVM7UUFDVHhGLE9BQU87SUFDVDtJQUNBLFlBQVk7UUFDVndGLFNBQVM7UUFDVEUsWUFBWTtJQUNkO0FBQ0Y7QUFDQXBHLE1BQU11QyxTQUFTLENBQUN3VCxJQUFJLENBQUMsU0FBUyxDQUFDalQsTUFBTSxDQUFDdFAsSUFBSSxHQUFHd00sTUFBTXVDLFNBQVMsQ0FBQ3dULElBQUk7QUFDakUvVixNQUFNdUMsU0FBUyxDQUFDeVQsR0FBRyxHQUFHO0lBQ3BCLFdBQVc7UUFDVDlQLFNBQVM7UUFDVEUsWUFBWTtJQUNkO0lBQ0EsWUFBWTtRQUFDO1lBQ1hGLFNBQVM7WUFDVFksUUFBUTtRQUNWO1FBQUc7S0FBVztJQUNkLFVBQVU7UUFDUlosU0FBUztRQUNUWSxRQUFRO1FBQ1JWLFlBQVk7SUFDZDtJQUNBLGNBQWM7UUFDWkYsU0FBUztRQUNUWSxRQUFRO1FBQ1JWLFlBQVk7UUFDWnRELFFBQVE7WUFDTixlQUFlO1FBQ2pCO0lBQ0Y7SUFDQSxZQUFZO0lBQ1osa0RBQWtEO0lBQ2xELFdBQVc7SUFDWCxXQUFXO0lBQ1gsVUFBVTtJQUNWLFlBQVk7SUFDWixlQUFlO0FBQ2pCO0FBQ0E5QyxNQUFNdUMsU0FBUyxDQUFDMFQsS0FBSyxHQUFHO0lBQ3RCLFdBQVc7UUFDVCwrQ0FBK0M7UUFDL0MvUCxTQUFTO1FBQ1RFLFlBQVk7UUFDWlUsUUFBUTtJQUNWO0lBQ0Esa0JBQWtCO1FBQ2xCLDRFQUE0RTtRQUM1RTtZQUNFWixTQUFTckUsT0FBTyxZQUFZb0YsTUFBTSxHQUFHLFFBRW5DLDhEQUE4REEsTUFBTSxHQUFHLE1BRXZFLGlFQUFpRUEsTUFBTSxHQUFHLE1BQU0sV0FBV0EsTUFBTTtZQUNuR2IsWUFBWTtZQUNaVSxRQUFRO1lBQ1JoRSxRQUFRO2dCQUNOLGlCQUFpQjtvQkFDZm9ELFNBQVM7b0JBQ1RFLFlBQVk7b0JBQ1p0RCxRQUFRLEtBQUssWUFBWTtnQkFDM0I7Z0JBRUEsNkJBQTZCO29CQUMzQm9ELFNBQVM7b0JBQ1R4RixPQUFPO2dCQUNUO2dCQUNBLGVBQWU7Z0JBQ2YsVUFBVTtZQUNaO1FBQ0Y7UUFBRztZQUNEd0YsU0FBU3JFLE9BQU8sZ0JBQWdCb0YsTUFBTSxHQUFHLFFBRXZDLGdFQUFnRUEsTUFBTSxHQUFHLE1BRXpFLDJEQUEyREEsTUFBTSxHQUFHLE1BQU07WUFDNUViLFlBQVk7WUFDWlUsUUFBUTtZQUNSaEUsUUFBUTtnQkFDTixpQkFBaUI7b0JBQ2ZvRCxTQUFTO29CQUNURSxZQUFZO29CQUNadEQsUUFBUSxLQUFLLFlBQVk7Z0JBQzNCO2dCQUVBLDZCQUE2QjtvQkFDM0JvRCxTQUFTO29CQUNUeEYsT0FBTztnQkFDVDtnQkFDQSxVQUFVO1lBQ1o7UUFDRjtLQUFFO0lBQ0YsYUFBYTtRQUNYLDZCQUE2QjtRQUM3QndGLFNBQVNyRSxPQUFPLElBQUlvRixNQUFNLEdBQUcsUUFBUyxtQkFBa0JBLE1BQU0sR0FBRyxhQUkvRCw4R0FBOEdBLE1BQU0sR0FBRyxJQUFHLElBQUssTUFBTSxtQkFBbUJBLE1BQU0sR0FBRztRQUNuS3ZHLE9BQU87UUFDUG9DLFFBQVE7WUFDTixrQkFBa0I7WUFDbEIsV0FBVztZQUNYLFVBQVU7WUFDVixZQUFZO1lBQ1osZUFBZTtRQUNqQjtJQUNGO0lBQ0EsV0FBVztRQUNUb0QsU0FBUztRQUNUeEYsT0FBTztJQUNUO0lBQ0EsbUJBQW1CO1FBQ2pCd0YsU0FBUztRQUNUeEYsT0FBTztJQUNUO0lBQ0EsYUFBYTtRQUNYd0YsU0FBUztRQUNUeEYsT0FBTztJQUNUO0lBQ0EsdUJBQXVCO1FBQ3JCd0YsU0FBUztRQUNURSxZQUFZO1FBQ1oxRixPQUFPO0lBQ1Q7SUFDQSxTQUFTO1FBQ1AseUVBQXlFO1FBQ3pFd0YsU0FBUztRQUNURSxZQUFZO1FBQ1oxRixPQUFPO0lBQ1Q7SUFDQSxXQUFXO0lBQ1gsV0FBVztJQUNYLE9BQU87UUFDTHdGLFNBQVM7UUFDVHhGLE9BQU87SUFDVDtJQUNBLGtCQUFrQjtJQUNsQixRQUFRO1FBQ053RixTQUFTO1FBQ1R4RixPQUFPO0lBQ1Q7SUFDQSxVQUFVO0lBQ1YsZ0hBQWdIO0lBQ2hILGNBQWM7SUFDZCxZQUFZO0lBQ1osWUFBWTtJQUNaLHVGQUF1RjtJQUN2RixxRkFBcUY7SUFDckYsNENBQTRDO0lBQzVDLFlBQVk7SUFDWixlQUFlO0FBQ2pCO0FBQ0FWLE1BQU11QyxTQUFTLENBQUMwVCxLQUFLLENBQUMsaUJBQWlCLENBQUM3VSxPQUFPLENBQUMsU0FBVThVLElBQUk7SUFDNURBLEtBQUtwVCxNQUFNLENBQUMsZ0JBQWdCLENBQUNBLE1BQU0sR0FBRzlDLE1BQU11QyxTQUFTLENBQUMwVCxLQUFLO0FBQzdEO0FBQ0MsVUFBVWpXLEtBQUs7SUFDZEEsTUFBTXVDLFNBQVMsQ0FBQ3BaLFVBQVUsR0FBRzZXLE1BQU11QyxTQUFTLENBQUNJLE1BQU0sQ0FBQyxjQUFjO1FBQ2hFLGNBQWM7WUFDWnVELFNBQVM7WUFDVEUsWUFBWTtZQUNaVSxRQUFRO1lBQ1JoRSxRQUFRLEtBQUssWUFBWTtRQUMzQjtRQUVBLFdBQVc7SUFDYjtJQUVBLDZDQUE2QztJQUM3QzlDLE1BQU11QyxTQUFTLENBQUNwWixVQUFVLENBQUNrakIsT0FBTyxDQUFDcGxCLElBQUksQ0FBQyxzREFDeEMscURBQXFEO0lBQ3JELDRGQUNBLGtDQUFrQztJQUNsQztJQUVBLGlEQUFpRDtJQUNqRCxPQUFPK1ksTUFBTXVDLFNBQVMsQ0FBQ3BaLFVBQVUsQ0FBQyxZQUFZO0lBQzlDLE9BQU82VyxNQUFNdUMsU0FBUyxDQUFDcFosVUFBVSxDQUFDLG1CQUFtQjtJQUVyRCw4REFBOEQ7SUFDOUQsSUFBSXNsQixhQUFhek8sTUFBTXVDLFNBQVMsQ0FBQ0ksTUFBTSxDQUFDLGNBQWMsQ0FBQztJQUN2RCxPQUFPOEwsVUFBVSxDQUFDLGFBQWE7SUFDL0J6TyxNQUFNdUMsU0FBUyxDQUFDcFosVUFBVSxDQUFDLGFBQWEsQ0FBQzJaLE1BQU0sR0FBRzJMO0lBQ2xEek8sTUFBTXVDLFNBQVMsQ0FBQ00sWUFBWSxDQUFDLGNBQWMsWUFBWTtRQUNyRCxhQUFhO1lBQ1hxRCxTQUFTO1lBQ1RwRCxRQUFRO2dCQUNOLE1BQU07b0JBQ0pvRCxTQUFTO29CQUNUeEYsT0FBTztnQkFDVDtnQkFDQSxZQUFZO1lBQ2Q7UUFDRjtRQUNBLG9CQUFvQjtZQUNsQix5Q0FBeUM7WUFDekN3RixTQUFTO1lBQ1RZLFFBQVE7WUFDUmhFLFFBQVE7Z0JBQ04sWUFBWTtnQkFDWixXQUFXO29CQUNUb0QsU0FBUztvQkFDVCwrQkFBK0I7b0JBQy9CeEYsT0FBTztvQkFDUG9DLFFBQVEyTDtnQkFDVjtZQUNGO1FBQ0Y7SUFDRjtJQUNBek8sTUFBTXVDLFNBQVMsQ0FBQzRULEVBQUUsR0FBR25XLE1BQU11QyxTQUFTLENBQUNwWixVQUFVO0FBQ2pELEdBQUc2VztBQUNGLFVBQVVBLEtBQUs7SUFDZCxJQUFJN1csYUFBYTZXLE1BQU1PLElBQUksQ0FBQ1MsS0FBSyxDQUFDaEIsTUFBTXVDLFNBQVMsQ0FBQ3BaLFVBQVU7SUFDNUQ2VyxNQUFNdUMsU0FBUyxDQUFDclosR0FBRyxHQUFHOFcsTUFBTXVDLFNBQVMsQ0FBQ0ksTUFBTSxDQUFDLE9BQU94WjtJQUVwRCxpREFBaUQ7SUFDakQsT0FBTzZXLE1BQU11QyxTQUFTLENBQUNyWixHQUFHLENBQUMsWUFBWTtJQUN2QyxPQUFPOFcsTUFBTXVDLFNBQVMsQ0FBQ3JaLEdBQUcsQ0FBQyxtQkFBbUI7SUFFOUMsc0VBQXNFO0lBQ3RFLHVDQUF1QztJQUN2QyxrRkFBa0Y7SUFDbEYsSUFBSXdKLE1BQU1zTixNQUFNdUMsU0FBUyxDQUFDclosR0FBRyxDQUFDd0osR0FBRztJQUNqQ0EsSUFBSXdULE9BQU8sR0FBR3JFLE9BQU8scUJBQXFCb0YsTUFBTSxHQUFHLFFBQVF2VSxJQUFJd1QsT0FBTyxDQUFDZSxNQUFNLEdBQUcsS0FBS3ZVLElBQUl3VCxPQUFPLENBQUNjLEtBQUs7SUFDdEd0VSxJQUFJMFQsVUFBVSxHQUFHO0FBQ25CLEdBQUdwRztBQUNIQSxNQUFNdUMsU0FBUyxDQUFDNlQsS0FBSyxHQUFHO0lBQ3RCLFdBQVc7UUFDVGxRLFNBQVM7UUFDVHBELFFBQVE7WUFDTixXQUFXO1FBQ2I7SUFDRjtJQUNBLFVBQVU7UUFDUm9ELFNBQVM7UUFDVFksUUFBUTtJQUNWO0lBQ0EsVUFBVTtJQUNWLFdBQVc7SUFDWCxZQUFZO0lBQ1osWUFBWTtJQUNaLGVBQWU7QUFDakI7QUFDQTlHLE1BQU11QyxTQUFTLENBQUM4VCxLQUFLLEdBQUdyVyxNQUFNdUMsU0FBUyxDQUFDSSxNQUFNLENBQUMsU0FBUztJQUN0RCxXQUFXO1FBQUM7WUFDVnVELFNBQVM7WUFDVHBELFFBQVE7Z0JBQ04sV0FBVztZQUNiO1FBQ0Y7UUFBRztZQUNEb0QsU0FBUztZQUNURSxZQUFZO1lBQ1pVLFFBQVE7UUFDVjtLQUFFO0lBQ0YsVUFBVTtRQUNSWixTQUFTO1FBQ1RFLFlBQVk7UUFDWlUsUUFBUTtJQUNWO0lBQ0EsV0FBVztJQUNYLGVBQWU7QUFDakI7QUFFQSxNQUFNdkUsWUFBWTtJQUFDO1FBQ2pCeFUsT0FBTztRQUNQcEksT0FBTztJQUNUO0lBQUc7UUFDRG9JLE9BQU87UUFDUHBJLE9BQU87SUFDVDtJQUFHO1FBQ0RvSSxPQUFPO1FBQ1BwSSxPQUFPO0lBQ1Q7SUFBRztRQUNEb0ksT0FBTztRQUNQcEksT0FBTztJQUNUO0lBQUc7UUFDRG9JLE9BQU87UUFDUHBJLE9BQU87SUFDVDtJQUFHO1FBQ0RvSSxPQUFPO1FBQ1BwSSxPQUFPO0lBQ1Q7SUFBRztRQUNEb0ksT0FBTztRQUNQcEksT0FBTztJQUNUO0lBQUc7UUFDRG9JLE9BQU87UUFDUHBJLE9BQU87SUFDVDtJQUFHO1FBQ0RvSSxPQUFPO1FBQ1BwSSxPQUFPO0lBQ1Q7SUFBRztRQUNEb0ksT0FBTztRQUNQcEksT0FBTztJQUNUO0lBQUc7UUFDRG9JLE9BQU87UUFDUHBJLE9BQU87SUFDVDtJQUFHO1FBQ0RvSSxPQUFPO1FBQ1BwSSxPQUFPO0lBQ1Q7SUFBRztRQUNEb0ksT0FBTztRQUNQcEksT0FBTztJQUNUO0lBQUc7UUFDRG9JLE9BQU87UUFDUHBJLE9BQU87SUFDVDtJQUFHO1FBQ0RvSSxPQUFPO1FBQ1BwSSxPQUFPO0lBQ1Q7SUFBRztRQUNEb0ksT0FBTztRQUNQcEksT0FBTztJQUNUO0lBQUc7UUFDRG9JLE9BQU87UUFDUHBJLE9BQU87SUFDVDtJQUFHO1FBQ0RvSSxPQUFPO1FBQ1BwSSxPQUFPO0lBQ1Q7SUFBRztRQUNEb0ksT0FBTztRQUNQcEksT0FBTztJQUNUO0lBQUc7UUFDRG9JLE9BQU87UUFDUHBJLE9BQU87SUFDVDtJQUFHO1FBQ0RvSSxPQUFPO1FBQ1BwSSxPQUFPO0lBQ1Q7SUFBRztRQUNEb0ksT0FBTztRQUNQcEksT0FBTztJQUNUO0lBQUc7UUFDRG9JLE9BQU87UUFDUHBJLE9BQU87SUFDVDtJQUFHO1FBQ0RvSSxPQUFPO1FBQ1BwSSxPQUFPO0lBQ1Q7SUFBRztRQUNEb0ksT0FBTztRQUNQcEksT0FBTztJQUNUO0lBQUc7UUFDRG9JLE9BQU87UUFDUHBJLE9BQU87SUFDVDtJQUFHO1FBQ0RvSSxPQUFPO1FBQ1BwSSxPQUFPO0lBQ1Q7SUFBRztRQUNEb0ksT0FBTztRQUNQcEksT0FBTztJQUNUO0lBQUc7UUFDRG9JLE9BQU87UUFDUHBJLE9BQU87SUFDVDtJQUFHO1FBQ0RvSSxPQUFPO1FBQ1BwSSxPQUFPO0lBQ1Q7SUFBRztRQUNEb0ksT0FBTztRQUNQcEksT0FBTztJQUNUO0lBQUc7UUFDRG9JLE9BQU87UUFDUHBJLE9BQU87SUFDVDtJQUFHO1FBQ0RvSSxPQUFPO1FBQ1BwSSxPQUFPO0lBQ1Q7Q0FBRTtBQUNGLE1BQU0yd0IsdUJBQXVCLElBQUlwMEIsSUFBSXFnQixVQUFVcGYsR0FBRyxDQUFDc0MsQ0FBQUEsSUFBSztRQUFDQSxFQUFFRSxLQUFLO1FBQUVGLEVBQUVzSSxLQUFLO0tBQUM7QUFDMUUsSUFBSTdMLElBQUlxZ0IsVUFBVXBmLEdBQUcsQ0FBQ3NDLENBQUFBLElBQUs7UUFBQ0EsRUFBRXNJLEtBQUs7UUFBRXRJLEVBQUVFLEtBQUs7S0FBQztBQUM3QyxNQUFNNHdCLDBCQUEwQixJQUFJcjBCLElBQUlxZ0IsVUFBVXBmLEdBQUcsQ0FBQ2dkLENBQUFBLE9BQVE7UUFBQ0gsTUFBTXVDLFNBQVMsQ0FBQ3BDLEtBQUt4YSxLQUFLLENBQUM7UUFBRXdhLEtBQUt4YSxLQUFLO0tBQUM7QUFDdkcsTUFBTTZ3Qix5QkFBeUIsSUFBSXQwQixJQUFJeUUsT0FBT3dJLElBQUksQ0FBQzZRLE1BQU11QyxTQUFTLEVBQUV6ZSxPQUFPLENBQUNxYyxDQUFBQTtJQUMxRSxNQUFNc1csZ0JBQWdCRix3QkFBd0I1MEIsR0FBRyxDQUFDcWUsTUFBTXVDLFNBQVMsQ0FBQ3BDLEtBQUs7SUFDdkUsSUFBSXNXLGtCQUFrQjEyQixXQUFXO1FBQy9CLE9BQU8sRUFBRTtJQUNYO0lBQ0EsT0FBTztRQUFDO1lBQUNvZ0I7WUFBTXNXO1NBQWM7S0FBQztBQUNoQztBQUNBLE1BQU1DLHFCQUFxQixJQUFJeDBCLElBQUlxZ0IsVUFBVXBmLEdBQUcsQ0FBQ2dkLENBQUFBLE9BQVE7UUFBQ0EsS0FBS3hhLEtBQUs7UUFBRSxFQUFFO0tBQUM7QUFDekUsS0FBSyxNQUFNLENBQUMrYSxPQUFPK1YsY0FBYyxJQUFJRCx1QkFBd0I7SUFDM0RFLG1CQUFtQi8wQixHQUFHLENBQUM4MEIsZUFBZXh2QixJQUFJLENBQUN5WjtBQUM3QztBQUNBO0lBQUM7UUFDQzNTLE9BQU87UUFDUHBJLE9BQU87UUFDUHFnQixTQUFTLEVBQUU7SUFDYjtPQUFNO1dBQUkwUTtLQUFtQixDQUFDdnpCLEdBQUcsQ0FBQyxDQUFDLENBQUNzekIsZUFBZXpRLFFBQVEsR0FBTTtZQUMvRGpZLE9BQU91b0IscUJBQXFCMzBCLEdBQUcsQ0FBQzgwQjtZQUNoQzl3QixPQUFPOHdCO1lBQ1B6UTtRQUNGO0NBQUk7QUFDSixJQUFJOWpCLElBQUk7T0FBSXMwQjtDQUF1QixDQUFDcnpCLEdBQUcsQ0FBQyxDQUFDLENBQUN1ZCxPQUFPK1YsY0FBYyxHQUFLO1FBQUMvVjtRQUFPNFYscUJBQXFCMzBCLEdBQUcsQ0FBQzgwQjtLQUFlO0FBRXBILE1BQU1FLDJCQUEyQjtBQUNqQyxTQUFTQyxjQUFjMWYsZ0JBQWdCLEVBQUU3RCxlQUFlLEVBQUU0QixNQUFNO0lBQzlELE1BQU0sRUFDSjRoQixXQUFXLEVBQ1gxZixhQUFhLEVBQ2JwQixVQUFVLEVBQ1gsR0FBR2Q7SUFDSixTQUFTNmhCLGtCQUFrQkMsS0FBSztRQUM5QixJQUFJQztRQUNKLElBQUksQ0FBQ0QsVUFBVSxRQUFRQSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUssQ0FBQyxFQUFFLENBQUMveEIsSUFBSSxNQUFNLGVBQWUreEIsS0FBSyxDQUFDLEVBQUUsQ0FBQ2oxQixRQUFRLENBQUNiLE1BQU0sS0FBSyxLQUFLODFCLEtBQUssQ0FBQyxFQUFFLENBQUNqMUIsUUFBUSxDQUFDLEVBQUUsQ0FBQ2tELElBQUksS0FBS2pGLFdBQVc7WUFDOUosT0FBTztRQUNUO1FBQ0EsTUFBTTZmLFFBQVErVyx5QkFBeUJuVixJQUFJLENBQUN1VixLQUFLLENBQUMsRUFBRSxDQUFDajFCLFFBQVEsQ0FBQyxFQUFFLENBQUM0UCxJQUFJO1FBQ3JFLElBQUksQ0FBQ2tPLE9BQU87WUFDVixPQUFPO1FBQ1Q7UUFDQSxNQUFNcVgsMkJBQTJCeFgsK0NBQStDeEssUUFBUWlDLGtCQUFrQjdEO1FBQzFHLElBQUk0akIsNEJBQTZCQSxDQUFBQSx5QkFBeUJoM0IsSUFBSSxLQUFLLFlBQVksQ0FBQ2czQix5QkFBeUIvZixnQkFBZ0IsQ0FBQ2YsVUFBVSxDQUFDUyxVQUFVLENBQUNuRSxJQUFJLEdBQUc7WUFDckosT0FBTztRQUNUO1FBRUEsdUNBQXVDO1FBQ3ZDd0MsT0FBT2lpQixPQUFPLENBQUNDLEtBQUssQ0FBQ2x3QixJQUFJLENBQUM7WUFDeEJtd0IsWUFBWSxFQUFFO1lBQ2RDLGlCQUFpQnBpQixPQUFPcWlCLFNBQVM7UUFDbkM7UUFDQXY3Qiw2Q0FBVUEsQ0FBQ3c3QixNQUFNLENBQUN0aUIsUUFBUThoQixLQUFLLENBQUMsRUFBRTtRQUNsQ2g3Qiw2Q0FBVUEsQ0FBQzZKLE1BQU0sQ0FBQ3FQO1FBQ2xCbFosNkNBQVVBLENBQUN5N0IsU0FBUyxDQUFDdmlCLFFBQVE7WUFDM0JqUSxNQUFNO1lBQ04sR0FBSTRhLEtBQUssQ0FBQyxFQUFFLEdBQUc7Z0JBQ2JyTSxVQUFVLENBQUN5akIsd0JBQXdCUix1QkFBdUI3MEIsR0FBRyxDQUFDaWUsS0FBSyxDQUFDLEVBQUUsQ0FBQzhCLFdBQVcsR0FBRSxNQUFPLFFBQVFzViwwQkFBMEIsS0FBSyxJQUFJQSx3QkFBd0JwWCxLQUFLLENBQUMsRUFBRTtZQUN4SyxJQUFJLENBQUMsQ0FBQztZQUNOOWQsVUFBVSxFQUFFO1FBQ2QsR0FBRztZQUNEOGQsT0FBT2xlLENBQUFBLE9BQVFBLEtBQUtzRCxJQUFJLEtBQUs7UUFDL0I7UUFDQSxPQUFPO0lBQ1Q7SUFDQWlRLE9BQU80aEIsV0FBVyxHQUFHO1FBQ25CLE1BQU1FLFFBQVEvNkIseUNBQU1BLENBQUMyakIsS0FBSyxDQUFDMUssUUFBUTtZQUNqQzJLLE9BQU94QztRQUNUO1FBQ0EsSUFBSSxDQUFDMlosVUFBVSxRQUFRQSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUssQ0FBQyxFQUFFLENBQUMveEIsSUFBSSxNQUFNLFVBQVVwSix1Q0FBSUEsQ0FBQ3diLE1BQU0sQ0FBQzJmLEtBQUssQ0FBQyxFQUFFLENBQUNqMUIsUUFBUSxDQUFDLEVBQUUsR0FBRztZQUNqSCxNQUFNNFAsT0FBT3FsQixLQUFLLENBQUMsRUFBRSxDQUFDajFCLFFBQVEsQ0FBQyxFQUFFLENBQUM0UCxJQUFJO1lBQ3RDLElBQUlBLElBQUksQ0FBQ0EsS0FBS3pRLE1BQU0sR0FBRyxFQUFFLEtBQUssUUFBUWdVLE9BQU9xaUIsU0FBUyxJQUFJbjdCLHdDQUFLQSxDQUFDczdCLFdBQVcsQ0FBQ3hpQixPQUFPcWlCLFNBQVMsS0FBS2w3Qix3Q0FBS0EsQ0FBQ3M3QixNQUFNLENBQUMxN0IseUNBQU1BLENBQUNnYSxHQUFHLENBQUNmLFFBQVE4aEIsS0FBSyxDQUFDLEVBQUUsR0FBRzloQixPQUFPcWlCLFNBQVMsQ0FBQ3JZLE1BQU0sR0FBRztnQkFDcEs0WDtnQkFDQTk2Qiw2Q0FBVUEsQ0FBQzQ3QixRQUFRLENBQUMxaUIsUUFBUTtvQkFDMUJqUSxNQUFNO29CQUNObEQsVUFBVSxFQUFFO2dCQUNkO2dCQUNBL0YsNkNBQVVBLENBQUM2SixNQUFNLENBQUNxUCxRQUFRO29CQUN4QitKLFVBQVU7b0JBQ1Z6SixJQUFJO3dCQUNGcFksTUFBTTsrQkFBSTQ1QixLQUFLLENBQUMsRUFBRTs0QkFBRTt5QkFBRTt3QkFDdEJ0eUIsUUFBUWlOLEtBQUt6USxNQUFNLEdBQUc7b0JBQ3hCO2dCQUNGO2dCQUNBO1lBQ0Y7WUFDQWdVLE9BQU9jLFVBQVUsQ0FBQztZQUNsQjtRQUNGO1FBQ0EsSUFBSWQsT0FBT3FpQixTQUFTLElBQUluN0Isd0NBQUtBLENBQUNzN0IsV0FBVyxDQUFDeGlCLE9BQU9xaUIsU0FBUyxLQUFLUixrQkFBa0JDLFFBQVE7WUFDdkY7UUFDRjtRQUNBRjtJQUNGO0lBQ0E1aEIsT0FBT2MsVUFBVSxHQUFHckUsQ0FBQUE7UUFDbEJxRSxXQUFXckU7UUFDWCxJQUFJQSxTQUFTLE9BQU91RCxPQUFPcWlCLFNBQVMsSUFBSW43Qix3Q0FBS0EsQ0FBQ3M3QixXQUFXLENBQUN4aUIsT0FBT3FpQixTQUFTLEdBQUc7WUFDM0VSLGtCQUFrQjk2Qix5Q0FBTUEsQ0FBQzJqQixLQUFLLENBQUMxSyxRQUFRO2dCQUNyQzJLLE9BQU94QztZQUNUO1FBQ0Y7SUFDRjtJQUNBbkksT0FBT2tDLGFBQWEsR0FBRyxDQUFDLENBQUN6VixNQUFNdkUsS0FBSztRQUNsQyxJQUFJdUUsS0FBS3NELElBQUksS0FBSyxVQUFVbEosMENBQVNBLENBQUN1YixTQUFTLENBQUMzVixPQUFPO1lBQ3JELEtBQUssTUFBTSxDQUFDd2MsT0FBTzBaLFVBQVUsSUFBSWwyQixLQUFLSSxRQUFRLENBQUNvQixPQUFPLEdBQUk7Z0JBQ3hELElBQUksQ0FBQ3RILHVDQUFJQSxDQUFDd2IsTUFBTSxDQUFDd2dCLFlBQVk7b0JBQzNCLElBQUkzaUIsT0FBTzhGLE1BQU0sQ0FBQzZjLFlBQVk7d0JBQzVCNzdCLDZDQUFVQSxDQUFDaWIsV0FBVyxDQUFDL0IsUUFBUTs0QkFDN0JNLElBQUk7bUNBQUlwWTtnQ0FBTStnQjs2QkFBTTt3QkFDdEI7b0JBQ0YsT0FBTzt3QkFDTG5pQiw2Q0FBVUEsQ0FBQ2thLFdBQVcsQ0FBQ2hCLFFBQVE7NEJBQzdCTSxJQUFJO21DQUFJcFk7Z0NBQU0rZ0I7NkJBQU07d0JBQ3RCO29CQUNGO29CQUNBO2dCQUNGO2dCQUNBLE1BQU14RSxRQUFRL1MsT0FBT3dJLElBQUksQ0FBQ3lvQixXQUFXdmlCLE1BQU0sQ0FBQzVQLENBQUFBLElBQUtBLE1BQU07Z0JBQ3ZELElBQUlpVSxNQUFNelksTUFBTSxFQUFFO29CQUNoQmxGLDZDQUFVQSxDQUFDdVosVUFBVSxDQUFDTCxRQUFReUUsT0FBTzt3QkFDbkNuRSxJQUFJOytCQUFJcFk7NEJBQU0rZ0I7eUJBQU07b0JBQ3RCO29CQUNBO2dCQUNGO1lBQ0Y7UUFDRjtRQUNBL0csY0FBYztZQUFDelY7WUFBTXZFO1NBQUs7SUFDNUI7SUFDQSxPQUFPOFg7QUFDVDtBQUVBLFNBQVM0aUIsMEJBQTBCbHlCLEtBQUssRUFBRXZILE1BQU0sRUFBRWpCLElBQUk7SUFDcEQsT0FBUWlCLE9BQU82QixJQUFJO1FBQ2pCLEtBQUs7WUFDSCxPQUFPLEVBQUU7UUFDWCxLQUFLO1lBQ0gsT0FBTztnQkFBQztvQkFDTjlDLE1BQU1BO29CQUNONE0sU0FBUzNMLE9BQU8yTCxPQUFPO2dCQUN6QjthQUFFO1FBQ0osS0FBSztZQUNILE9BQU84dEIsMEJBQTBCbHlCLE1BQU1BLEtBQUssRUFBRXZILE9BQU9vSCxNQUFNLENBQUNHLE1BQU11SixZQUFZLENBQUMsRUFBRS9SLEtBQUs2SSxNQUFNLENBQUM7UUFDL0YsS0FBSztZQUNIO2dCQUNFLE1BQU1tTSxRQUFRLEVBQUU7Z0JBQ2hCeEwsT0FBT3dJLElBQUksQ0FBQy9RLE9BQU93SSxNQUFNLEVBQUV3YSxPQUFPLENBQUNqaEIsQ0FBQUE7b0JBQ2pDZ1MsTUFBTWxMLElBQUksSUFBSTR3QiwwQkFBMEJseUIsS0FBSyxDQUFDeEYsSUFBSSxFQUFFL0IsT0FBT3dJLE1BQU0sQ0FBQ3pHLElBQUksRUFBRWhELEtBQUs2SSxNQUFNLENBQUM3RjtnQkFDdEY7Z0JBQ0EsT0FBT2dTO1lBQ1Q7UUFDRixLQUFLO1lBQ0g7Z0JBQ0UsTUFBTUEsUUFBUSxFQUFFO2dCQUNoQnhNLE1BQU15YixPQUFPLENBQUMsQ0FBQ2pkLEtBQUtTO29CQUNsQnVOLE1BQU1sTCxJQUFJLElBQUk0d0IsMEJBQTBCMXpCLEtBQUsvRixPQUFPcUksT0FBTyxFQUFFdEosS0FBSzZJLE1BQU0sQ0FBQ3BCO2dCQUMzRTtnQkFDQSxPQUFPdU47WUFDVDtJQUNKO0FBQ0Y7QUFDQSxTQUFTMmxCLG1CQUFtQm55QixLQUFLLEVBQUU0TyxLQUFLO0lBQ3RDLE1BQU13akIsWUFBWUYsMEJBQTBCbHlCLE9BQU87UUFDakQxRixNQUFNO1FBQ04yRyxRQUFRMk47SUFDVixHQUFHLEVBQUU7SUFDTCxJQUFJLENBQUN3akIsVUFBVTkyQixNQUFNLEVBQUU7UUFDckIsT0FBTztZQUFDO2dCQUNOOUQsTUFBTTRDO2dCQUNOZ0ssU0FBUztvQkFDUDlKLE1BQU07b0JBQ05vMEIsYUFBYTtnQkFDZjtZQUNGO1NBQUU7SUFDSjtJQUNBLE9BQU8wRDtBQUNUO0FBRUEsU0FBU0MsMEJBQTBCL2lCLE1BQU07SUFDdkMsSUFBSUEsT0FBT3FpQixTQUFTLEVBQUU7UUFDcEIsTUFBTVcsZ0JBQWdCajhCLHlDQUFNQSxDQUFDMmpCLEtBQUssQ0FBQzFLLFFBQVE7WUFDekMySyxPQUFPbGUsQ0FBQUEsT0FBUTBiLFFBQVExYixTQUFTQSxLQUFLc0QsSUFBSSxLQUFLO1FBQ2hEO1FBQ0EsSUFBSWl6QixpQkFBa0JBLENBQUFBLGFBQWEsQ0FBQyxFQUFFLENBQUNqekIsSUFBSSxLQUFLLDBCQUEwQml6QixhQUFhLENBQUMsRUFBRSxDQUFDanpCLElBQUksS0FBSyx1QkFBc0IsR0FBSTtZQUM1SCxPQUFPO2dCQUNMa3pCLFVBQVU7Z0JBQ1YxakIsZ0JBQWdCeFkseUNBQU1BLENBQUM4WSxNQUFNLENBQUNHLFFBQVFnakIsYUFBYSxDQUFDLEVBQUU7Z0JBQ3RERSxNQUFNRjtZQUNSO1FBQ0Y7SUFDRjtJQUNBLE9BQU87UUFDTEMsVUFBVTtJQUNaO0FBQ0Y7QUFDQSxNQUFNRSwwQkFBMEIsSUFBSTNwQjtBQUNwQyxTQUFTNHBCLGlDQUFpQyxDQUFDMzJCLE1BQU12RSxLQUFLLEVBQUU4WCxNQUFNLEVBQUVxakIsWUFBWTtJQUMxRSxJQUFJQyx5QkFBeUJILHdCQUF3QnoyQixHQUFHLENBQUMyMkI7SUFDekQsSUFBSSxDQUFDQyx3QkFBd0I7UUFDM0JBLHlCQUF5QixJQUFJQztRQUM3Qkosd0JBQXdCLzJCLEdBQUcsQ0FBQ2kzQixjQUFjQztJQUM1QztJQUNBLElBQUlBLHVCQUF1QnQyQixHQUFHLENBQUNQLE9BQU87UUFDcEMsT0FBTztJQUNUO0lBQ0EsSUFBSSsyQixtQkFBbUI7SUFDdkIsSUFBSUgsYUFBYXBqQixXQUFXLEtBQUssYUFBYXRaLHVDQUFJQSxDQUFDd2IsTUFBTSxDQUFDMVYsT0FBTztRQUMvRCsyQixtQkFBbUJ6akIsNkNBQTZDO1lBQUN0VDtZQUFNdkU7U0FBSyxFQUFFOFgsUUFBUXFqQixhQUFhcGpCLFdBQVcsRUFBRW9qQixhQUFhbmpCLFVBQVU7SUFDekk7SUFDQSxJQUFJclosMENBQVNBLENBQUN1YixTQUFTLENBQUMzVixPQUFPO1FBQzdCLElBQUlnM0IscUJBQXFCaDNCLEtBQUtJLFFBQVEsQ0FBQ3FCLEdBQUcsQ0FBQyxDQUFDekIsTUFBTWtELElBQU15ekIsaUNBQWlDO2dCQUFDMzJCO2dCQUFNO3VCQUFJdkU7b0JBQU15SDtpQkFBRTthQUFDLEVBQUVxUSxRQUFRcWpCLGNBQ3ZILHNEQUFzRDtTQUNyRGptQixJQUFJLENBQUM1TSxDQUFBQSxJQUFLQTtRQUNYLElBQUk2eUIsYUFBYXI0QixJQUFJLEtBQUssU0FBUztZQUNqQyxJQUFJeUIsS0FBS3NELElBQUksS0FBSyxtQkFBbUI7Z0JBQ25DLElBQUksQ0FBQ3N6QixhQUFhamxCLGVBQWUsRUFBRTtvQkFDakN0WCw2Q0FBVUEsQ0FBQ2thLFdBQVcsQ0FBQ2hCLFFBQVE7d0JBQzdCTSxJQUFJcFk7b0JBQ047b0JBQ0FzN0IsbUJBQW1CO2dCQUNyQjtZQUNGLE9BQU87Z0JBQ0xBLG1CQUFtQnZpQix3Q0FBd0M7b0JBQUN4VTtvQkFBTXZFO2lCQUFLLEVBQUU4WCxRQUFRcWpCLGFBQWFwaEIsZ0JBQWdCLEtBQUt3aEI7WUFDckg7UUFDRixPQUFPO1lBQ0xELG1CQUFtQjVpQiw0QkFBNEI7Z0JBQUNuVTtnQkFBTXZFO2FBQUssRUFBRThYLFFBQVFxakIsYUFBYXBoQixnQkFBZ0IsQ0FBQ3BCLEtBQUs7UUFDMUc7SUFDRjtJQUNBLElBQUkyaUIscUJBQXFCLE9BQU87UUFDOUJGLHVCQUF1Qi94QixHQUFHLENBQUM5RTtJQUM3QjtJQUNBLE9BQU8rMkI7QUFDVDtBQUNBLFNBQVNFLDJCQUEyQnZnQixVQUFVO0lBQzVDLE1BQU13Z0IsUUFBUSxJQUFJN3hCLElBQUk7UUFBQ3FSO0tBQVc7SUFDbEMsS0FBSyxNQUFNaGEsVUFBVXc2QixNQUFPO1FBQzFCLElBQUl4NkIsT0FBTzZCLElBQUksS0FBSzthQUFlLElBQUk3QixPQUFPNkIsSUFBSSxLQUFLLFNBQVM7WUFDOUQsT0FBTztRQUNULE9BQU8sSUFBSTdCLE9BQU82QixJQUFJLEtBQUssU0FBUztZQUNsQzI0QixNQUFNcHlCLEdBQUcsQ0FBQ3BJLE9BQU9xSSxPQUFPO1FBQzFCLE9BQU8sSUFBSXJJLE9BQU82QixJQUFJLEtBQUssVUFBVTtZQUNuQyxLQUFLLE1BQU00NEIsYUFBYWx5QixPQUFPbkIsTUFBTSxDQUFDcEgsT0FBT3dJLE1BQU0sRUFBRztnQkFDcERneUIsTUFBTXB5QixHQUFHLENBQUNxeUI7WUFDWjtRQUNGLE9BQU8sSUFBSXo2QixPQUFPNkIsSUFBSSxLQUFLLGVBQWU7WUFDeEMsS0FBSyxNQUFNNDRCLGFBQWFseUIsT0FBT25CLE1BQU0sQ0FBQ3BILE9BQU9vSCxNQUFNLEVBQUc7Z0JBQ3BEb3pCLE1BQU1weUIsR0FBRyxDQUFDcXlCO1lBQ1o7UUFDRixPQUFPO1lBQ0x2OEIsa0RBQVdBLENBQUM4QjtRQUNkO0lBQ0Y7SUFDQSxPQUFPO0FBQ1Q7QUFDQSxTQUFTMDZCLDJDQUEyQzFnQixVQUFVO0lBQzVELE1BQU13Z0IsUUFBUSxJQUFJN3hCLElBQUk7UUFBQ3FSO0tBQVc7SUFDbEMsSUFBSTJnQixxQkFBcUI7SUFDekIsS0FBSyxNQUFNMzZCLFVBQVV3NkIsTUFBTztRQUMxQixJQUFJeDZCLE9BQU82QixJQUFJLEtBQUs7YUFBZSxJQUFJN0IsT0FBTzZCLElBQUksS0FBSyxTQUFTO1lBQzlELElBQUk4NEIsb0JBQW9CO2dCQUN0QixPQUFPO1lBQ1Q7WUFDQUEscUJBQXFCO1FBQ3ZCLE9BQU8sSUFBSTM2QixPQUFPNkIsSUFBSSxLQUFLLFNBQVM7WUFDbEMsSUFBSTA0QiwyQkFBMkJ2NkIsT0FBT3FJLE9BQU8sR0FBRztnQkFDOUMsT0FBTztZQUNUO1FBQ0YsT0FBTyxJQUFJckksT0FBTzZCLElBQUksS0FBSyxVQUFVO1lBQ25DLEtBQUssTUFBTTQ0QixhQUFhbHlCLE9BQU9uQixNQUFNLENBQUNwSCxPQUFPd0ksTUFBTSxFQUFHO2dCQUNwRGd5QixNQUFNcHlCLEdBQUcsQ0FBQ3F5QjtZQUNaO1FBQ0YsT0FBTyxJQUFJejZCLE9BQU82QixJQUFJLEtBQUssZUFBZTtZQUN4QyxLQUFLLE1BQU00NEIsYUFBYWx5QixPQUFPbkIsTUFBTSxDQUFDcEgsT0FBT29ILE1BQU0sRUFBRztnQkFDcERvekIsTUFBTXB5QixHQUFHLENBQUNxeUI7WUFDWjtRQUNGLE9BQU87WUFDTHY4QixrREFBV0EsQ0FBQzhCO1FBQ2Q7SUFDRjtJQUNBLE9BQU8yNkI7QUFDVDtBQUNBLFNBQVNDLG9DQUFvQzU2QixNQUFNLEVBQUV1SCxLQUFLO0lBQ3hELE1BQU1veUIsWUFBWSxFQUFFO0lBQ3BCNW5CLGNBQWMvUixRQUFRdUgsT0FBTyxDQUFDdkgsUUFBUXVILE9BQU94STtRQUMzQyxJQUFJaUIsT0FBTzZCLElBQUksS0FBSyxXQUFXNjRCLDJDQUEyQzE2QixPQUFPcUksT0FBTyxHQUFHO1lBQ3pGc3hCLFVBQVU5d0IsSUFBSSxDQUFDO2dCQUFDOUo7Z0JBQU1pQjthQUFPO1FBQy9CO0lBQ0Y7SUFDQSxPQUFPMjVCO0FBQ1Q7QUFDQSxTQUFTa0Isc0JBQXNCeHlCLE9BQU87SUFDcEMsTUFBTXl5QixhQUFhenlCLFFBQVEzRSxRQUFRLENBQUMsRUFBRTtJQUN0QyxPQUFPMkUsUUFBUTNFLFFBQVEsQ0FBQ2IsTUFBTSxLQUFLLEtBQU13RixDQUFBQSxRQUFRekIsSUFBSSxLQUFLLDJCQUEyQmswQixXQUFXbDBCLElBQUksS0FBS2pGLGFBQWFtNUIsV0FBV3huQixJQUFJLEtBQUssTUFBTWpMLFFBQVF6QixJQUFJLEtBQUssMEJBQTBCazBCLFdBQVdsMEIsSUFBSSxLQUFLLGVBQWVrMEIsV0FBV3AzQixRQUFRLENBQUNiLE1BQU0sS0FBSyxLQUFLaTRCLFdBQVdwM0IsUUFBUSxDQUFDLEVBQUUsQ0FBQ2tELElBQUksS0FBS2pGLGFBQWFtNUIsV0FBV3AzQixRQUFRLENBQUMsRUFBRSxDQUFDNFAsSUFBSSxLQUFLLEVBQUM7QUFDbFY7QUFDQSxTQUFTeW5CLG9CQUFvQkMsZUFBZSxFQUFFOWIsc0JBQXNCLEVBQUVySSxNQUFNO0lBQzFFLDJEQUEyRDtJQUMzRCxpRUFBaUU7SUFDakUsTUFBTW9rQiwyQ0FBMkNwOEIsaUVBQVdBLENBQUM4TSxDQUFBQTtRQUMzRCxPQUFPc1QsaUNBQWlDQyx3QkFBd0J2VDtJQUNsRTtJQUNBLE1BQU0sRUFDSm9OLGFBQWEsRUFDYm1pQixjQUFjLEVBQ2R6QyxXQUFXLEVBQ1osR0FBRzVoQjtJQUNKQSxPQUFPcWtCLGNBQWMsR0FBR0MsQ0FBQUE7UUFDdEIsSUFBSXRrQixPQUFPcWlCLFNBQVMsRUFBRTtZQUNwQixNQUFNa0MseUJBQXlCeEIsMEJBQTBCL2lCO1lBQ3pELElBQUl1a0IsdUJBQXVCdEIsUUFBUSxJQUFJLzdCLHdDQUFLQSxDQUFDczdCLFdBQVcsQ0FBQ3hpQixPQUFPcWlCLFNBQVMsS0FBS3Q3Qix5Q0FBTUEsQ0FBQ3k5QixPQUFPLENBQUN4a0IsUUFBUUEsT0FBT3FpQixTQUFTLENBQUNyWSxNQUFNLEVBQUV1YSx1QkFBdUJyQixJQUFJLENBQUMsRUFBRSxLQUFLcUIsdUJBQXVCckIsSUFBSSxDQUFDLEVBQUUsQ0FBQ3FCLHVCQUF1QnJCLElBQUksQ0FBQyxFQUFFLENBQUNsM0IsTUFBTSxHQUFHLEVBQUUsS0FBSyxHQUFHO2dCQUNoUGxGLDZDQUFVQSxDQUFDa2EsV0FBVyxDQUFDaEIsUUFBUTtvQkFDN0JNLElBQUlpa0IsdUJBQXVCaGxCLGNBQWMsQ0FBQyxFQUFFO2dCQUM5QztnQkFDQTtZQUNGO1FBQ0Y7UUFDQThrQixlQUFlQztJQUNqQjtJQUNBdGtCLE9BQU80aEIsV0FBVyxHQUFHO1FBQ25CLE1BQU0yQyx5QkFBeUJ4QiwwQkFBMEIvaUI7UUFDekQsSUFBSUEsT0FBT3FpQixTQUFTLElBQUlrQyx1QkFBdUJ0QixRQUFRLEVBQUU7WUFDdkQsTUFBTSxFQUNKQyxNQUFNLENBQUN1QixtQkFBbUJDLGtCQUFrQixFQUM1Q25sQixnQkFBZ0IsQ0FBQ29sQixvQkFBb0JDLG1CQUFtQixFQUN6RCxHQUFHTDtZQUNKLE1BQU1NLGFBQWFILGlCQUFpQixDQUFDQSxrQkFBa0IxNEIsTUFBTSxHQUFHLEVBQUUsS0FBSzI0QixtQkFBbUI5M0IsUUFBUSxDQUFDYixNQUFNLEdBQUc7WUFDNUcsSUFBSXk0QixrQkFBa0IxMEIsSUFBSSxLQUFLLHdCQUF3QjtnQkFDckQsTUFBTSxDQUFDLENBQUMrMEIsZUFBZUMsY0FBYyxDQUFDLEdBQUdoK0IseUNBQU1BLENBQUMrVyxLQUFLLENBQUNrQyxRQUFRO29CQUM1RDJLLE9BQU9sZSxDQUFBQSxPQUFRQSxLQUFLc0QsSUFBSSxLQUFLO2dCQUMvQjtnQkFDQSxNQUFNaTFCLGtCQUFrQkQsYUFBYSxDQUFDQSxjQUFjLzRCLE1BQU0sR0FBRyxFQUFFLEtBQUt5NEIsa0JBQWtCNTNCLFFBQVEsQ0FBQ2IsTUFBTSxHQUFHO2dCQUN4RyxJQUFJaEYsdUNBQUlBLENBQUNvdEIsTUFBTSxDQUFDMFEsbUJBQW1CLE1BQU1FLGlCQUFpQjtvQkFDeEQsSUFBSUgsWUFBWTt3QkFDZC85Qiw2Q0FBVUEsQ0FBQytpQixTQUFTLENBQUM3SixRQUFROzRCQUMzQk0sSUFBSXlrQjs0QkFDSnZiLElBQUl2aUIsdUNBQUlBLENBQUNpckIsSUFBSSxDQUFDcVMsdUJBQXVCaGxCLGNBQWMsQ0FBQyxFQUFFO3dCQUN4RDtvQkFDRixPQUFPO3dCQUNMelksNkNBQVVBLENBQUNtK0IsSUFBSSxDQUFDamxCLFFBQVE7NEJBQ3RCK0osVUFBVTs0QkFDVnVhLE1BQU07d0JBQ1I7d0JBQ0F4OUIsNkNBQVVBLENBQUNpYixXQUFXLENBQUMvQixRQUFROzRCQUM3Qk0sSUFBSXlrQjt3QkFDTjtvQkFDRjtvQkFDQTtnQkFDRjtZQUNGO1lBQ0EsSUFBSU4sa0JBQWtCMTBCLElBQUksS0FBSyx5QkFBeUI7Z0JBQ3REaEoseUNBQU1BLENBQUNtK0Isa0JBQWtCLENBQUNsbEIsUUFBUTtvQkFDaEMsTUFBTVQsaUJBQWlCNGtCLGVBQWUsQ0FBQ1EsbUJBQW1CdGxCLFNBQVMsQ0FBQztvQkFDcEUsSUFBSW9sQixrQkFBa0I5bUIsUUFBUSxLQUFLN1MsYUFBYXlVLG1CQUFtQnpVLFdBQVc7d0JBQzVFLE1BQU1xWSxhQUFhOzRCQUNqQm5ZLE1BQU07NEJBQ04yRyxRQUFRNE4sZUFBZXBXLE1BQU07d0JBQy9CO3dCQUNBLE1BQU1nOEIsaUJBQWlCaGMsbUJBQW1CaEcsWUFBWXNoQixrQkFBa0I5bUIsUUFBUSxFQUFFZ25CLG1CQUFtQnJsQixLQUFLO3dCQUMxRyxNQUFNakUsTUFBTTsrQkFBSThwQjt5QkFBZSxDQUFDQyxPQUFPLEdBQUdDLFNBQVMsQ0FBQ0MsQ0FBQUEsT0FBUUEsS0FBS3Q2QixJQUFJLEtBQUs7d0JBQzFFLElBQUlxUSxRQUFRLENBQUMsR0FBRzs0QkFDZCxNQUFNa3FCLGdCQUFnQkosZUFBZW41QixNQUFNLEdBQUcsSUFBSXFQOzRCQUNsRCxNQUFNbXFCLGFBQWFMLGNBQWMsQ0FBQ0ksY0FBYzs0QkFDaERoK0IsNkNBQU1BLENBQUNpK0IsV0FBV3g2QixJQUFJLEtBQUs7NEJBQzNCLE1BQU1rRSxNQUFNNkwsbUJBQW1CNHBCLG1CQUFtQnJsQixLQUFLLEVBQUVtbEIsa0JBQWtCOW1CLFFBQVEsQ0FBQy9RLEtBQUssQ0FBQyxHQUFHMjRCOzRCQUM3RixJQUFJMUIsMkNBQTJDMkIsV0FBV2gwQixPQUFPLEdBQUc7Z0NBQ2xFLElBQUl4Syx1Q0FBSUEsQ0FBQ290QixNQUFNLENBQUNxUSx1QkFBdUIsTUFBTXYxQixJQUFJbEQsTUFBTSxHQUFHLE1BQU15NEIsa0JBQWtCOW1CLFFBQVEsQ0FBQzRuQixjQUFjLEVBQUU7b0NBQ3pHeitCLDZDQUFVQSxDQUFDaWIsV0FBVyxDQUFDL0IsUUFBUTt3Q0FDN0JNLElBQUlva0I7b0NBQ047b0NBQ0EsSUFBSUcsWUFBWTt3Q0FDZC85Qiw2Q0FBVUEsQ0FBQzIrQixXQUFXLENBQUN6bEIsUUFBUTs0Q0FDN0JqUSxNQUFNOzRDQUNObEQsVUFBVTtnREFBQztvREFDVDRQLE1BQU07Z0RBQ1I7NkNBQUU7d0NBQ0osR0FBRzs0Q0FDRDZELElBQUlyWix1Q0FBSUEsQ0FBQ2lyQixJQUFJLENBQUMwUzt3Q0FDaEI7d0NBQ0E5OUIsNkNBQVVBLENBQUN3N0IsTUFBTSxDQUFDdGlCLFFBQVEvWSx1Q0FBSUEsQ0FBQ2lyQixJQUFJLENBQUMwUztvQ0FDdEMsT0FBTzt3Q0FDTDk5Qiw2Q0FBVUEsQ0FBQ20rQixJQUFJLENBQUNqbEIsUUFBUTs0Q0FDdEIrSixVQUFVOzRDQUNWdWEsTUFBTTt3Q0FDUjtvQ0FDRjtnQ0FDRixPQUFPO29DQUNMMUM7Z0NBQ0Y7Z0NBQ0E7NEJBQ0Y7d0JBQ0Y7b0JBQ0Y7b0JBQ0E5NkIsNkNBQVVBLENBQUM0K0IsVUFBVSxDQUFDMWxCLFFBQVE7d0JBQzVCMmxCLFFBQVE7b0JBQ1Y7b0JBQ0EsTUFBTUMsZ0JBQWdCMytCLHVDQUFJQSxDQUFDaXJCLElBQUksQ0FBQ3dTO29CQUNoQyxJQUFJRyxZQUFZO3dCQUNkLzlCLDZDQUFVQSxDQUFDK2lCLFNBQVMsQ0FBQzdKLFFBQVE7NEJBQzNCTSxJQUFJc2xCOzRCQUNKcGMsSUFBSXZpQix1Q0FBSUEsQ0FBQ2lyQixJQUFJLENBQUMwUzt3QkFDaEI7b0JBQ0YsT0FBTzt3QkFDTHJiLGFBQWF2SixRQUFRNGxCLGVBQWU7K0JBQUkzK0IsdUNBQUlBLENBQUNpckIsSUFBSSxDQUFDMFQ7NEJBQWdCO3lCQUFFO3dCQUNwRTkrQiw2Q0FBVUEsQ0FBQ2liLFdBQVcsQ0FBQy9CLFFBQVE7NEJBQzdCTSxJQUFJc2xCO3dCQUNOO29CQUNGO2dCQUNGO2dCQUNBO1lBQ0Y7UUFDRjtRQUNBaEU7SUFDRjtJQUNBNWhCLE9BQU9rQyxhQUFhLEdBQUc3VCxDQUFBQTtRQUNyQixNQUFNLENBQUM1QixNQUFNdkUsS0FBSyxHQUFHbUc7UUFDckIsSUFBSTVCLEtBQUtzRCxJQUFJLEtBQUssMkJBQTJCLENBQUN0RCxLQUFLa1IsUUFBUSxJQUFLbFIsQ0FBQUEsS0FBS0ksUUFBUSxDQUFDYixNQUFNLEtBQUssS0FBSyxDQUFDckYsdUNBQUlBLENBQUN3YixNQUFNLENBQUMxVixLQUFLSSxRQUFRLENBQUMsRUFBRSxLQUFLSixLQUFLSSxRQUFRLENBQUMsRUFBRSxDQUFDNFAsSUFBSSxLQUFLLEVBQUMsR0FBSTtZQUM3SjNWLDZDQUFVQSxDQUFDaWIsV0FBVyxDQUFDL0IsUUFBUTtnQkFDN0JNLElBQUlwWTtZQUNOO1lBQ0E7UUFDRjtRQUNBLElBQUl1RSxLQUFLc0QsSUFBSSxLQUFLLG1CQUFtQjtZQUNuQyxNQUFNd1AsaUJBQWlCNGtCLGVBQWUsQ0FBQzEzQixLQUFLNFMsU0FBUyxDQUFDO1lBQ3RELElBQUlFLGdCQUFnQjtnQkFDbEIsTUFBTTRELGFBQWE7b0JBQ2pCblksTUFBTTtvQkFDTjJHLFFBQVE0TixlQUFlcFcsTUFBTTtnQkFDL0I7Z0JBQ0EsTUFBTTA4QixlQUFlQyxpQkFBaUJyNUIsS0FBSzZTLEtBQUssRUFBRTZEO2dCQUNsRCxJQUFJMGlCLGlCQUFpQnA1QixLQUFLNlMsS0FBSyxFQUFFO29CQUMvQnhZLDZDQUFVQSxDQUFDNDdCLFFBQVEsQ0FBQzFpQixRQUFRO3dCQUMxQlYsT0FBT3VtQjtvQkFDVCxHQUFHO3dCQUNEdmxCLElBQUlwWTtvQkFDTjtvQkFDQTtnQkFDRjtnQkFDQSxLQUFLLE1BQU0sQ0FBQ3lWLFVBQVU2bkIsV0FBVyxJQUFJekIsb0NBQW9DNWdCLFlBQVkxVyxLQUFLNlMsS0FBSyxFQUFHO29CQUNoRyxJQUFJN1MsS0FBS0ksUUFBUSxDQUFDYixNQUFNLEtBQUssS0FBS1MsS0FBS0ksUUFBUSxDQUFDLEVBQUUsQ0FBQ2tELElBQUksS0FBSywyQkFBMkJ0RCxLQUFLSSxRQUFRLENBQUMsRUFBRSxDQUFDOFEsUUFBUSxLQUFLN1MsV0FBVzt3QkFDOUg7b0JBQ0Y7b0JBQ0EsTUFBTWk3QixjQUFjLEVBQUU7b0JBQ3RCLEtBQUssTUFBTSxDQUFDMXFCLEtBQUtzbkIsVUFBVSxJQUFJbDJCLEtBQUtJLFFBQVEsQ0FBQ29CLE9BQU8sR0FBSTt3QkFDdEQsSUFBSSxDQUFDMDBCLFVBQVU1eUIsSUFBSSxLQUFLLDBCQUEwQjR5QixVQUFVNXlCLElBQUksS0FBSyx1QkFBc0IsS0FBTTR5QixVQUFVaGxCLFFBQVEsS0FBSzdTLFdBQVc7NEJBQ2pJLE1BQU1rN0IsVUFBVXJELFVBQVVobEIsUUFBUSxDQUFDNU0sTUFBTTs0QkFDekMsTUFBT2kxQixRQUFRaDZCLE1BQU0sQ0FBRTtnQ0FDckIsSUFBSSxPQUFPZzZCLFFBQVFqSyxHQUFHLE9BQU8sVUFBVTs0QkFDekM7NEJBQ0EsSUFBSWpjLGVBQWVuQyxVQUFVcW9CLFVBQVU7Z0NBQ3JDRCxZQUFZL3pCLElBQUksQ0FBQztvQ0FBQ3FKO29DQUFLc25CO2lDQUFVOzRCQUNuQzt3QkFDRjtvQkFDRjtvQkFDQSxNQUFNc0QsU0FBU2xyQixtQkFBbUJ0TyxLQUFLNlMsS0FBSyxFQUFFM0I7b0JBQzlDLE1BQU0vQyxXQUFXbEIscUJBQXFCdXNCO29CQUN0QyxNQUFNQyxjQUFjLElBQUlwMEIsSUFBSThJO29CQUM1QixNQUFNdXJCLHNCQUFzQixJQUFJcjBCO29CQUNoQyxNQUFNMkksU0FBUyxFQUFFO29CQUNqQixNQUFNMnJCLFVBQVUsRUFBRTtvQkFDbEIsTUFBTUMsWUFBWTt3QkFDaEIsSUFBSW43QixNQUFNME87d0JBQ1YsTUFBT3NzQixZQUFZbDVCLEdBQUcsQ0FBQzlCLEtBQU07NEJBQzNCQSxNQUFNME87d0JBQ1I7d0JBQ0EsT0FBTzFPO29CQUNUO29CQUNBLEtBQUssTUFBTSxHQUFHdUIsS0FBSyxJQUFJczVCLFlBQWE7d0JBQ2xDLE1BQU1PLGVBQWU3NUIsS0FBS2tSLFFBQVEsQ0FBQ0EsU0FBUzNSLE1BQU0sQ0FBQzt3QkFDbkR6RSw2Q0FBTUEsQ0FBQyxPQUFPKytCLGlCQUFpQjt3QkFDL0IsSUFBSUwsT0FBT2o2QixNQUFNLElBQUlzNkIsZ0JBQWdCSCxvQkFBb0JuNUIsR0FBRyxDQUFDczVCLGlCQUFpQnRDLHNCQUFzQnYzQixPQUFPOzRCQUN6R2dPLE9BQU96SSxJQUFJLENBQUMrSCxxQkFBcUJ5ckIsV0FBV2gwQixPQUFPOzRCQUNuRDQwQixRQUFRcDBCLElBQUksQ0FBQ3EwQjt3QkFDZixPQUFPOzRCQUNMRixvQkFBb0I1MEIsR0FBRyxDQUFDKzBCOzRCQUN4QjdyQixPQUFPekksSUFBSSxDQUFDaTBCLE1BQU0sQ0FBQ0ssYUFBYTs0QkFDaENGLFFBQVFwMEIsSUFBSSxDQUFDbTBCLG9CQUFvQm41QixHQUFHLENBQUNzNUIsZ0JBQWdCRCxjQUFjenJCLFFBQVEsQ0FBQzByQixhQUFhO3dCQUMzRjtvQkFDRjtvQkFDQXpzQixxQkFBcUJZLFFBQVEyckI7b0JBQzdCLElBQUksQ0FBQ3RtQixlQUFlbW1CLFFBQVF4ckIsU0FBUzt3QkFDbkMsTUFBTThyQixtQkFBbUI1cUIsdUJBQXVCd0gsWUFBWTFXLEtBQUs2UyxLQUFLLEVBQUU3RSxRQUFRa0Q7d0JBQ2hGN1csNkNBQVVBLENBQUM0N0IsUUFBUSxDQUFDMWlCLFFBQVE7NEJBQzFCVixPQUFPaW5CO3dCQUNULEdBQUc7NEJBQ0RqbUIsSUFBSXBZO3dCQUNOO3dCQUNBLEtBQUssTUFBTSxDQUFDbVQsS0FBSyxDQUFDbXJCLHNCQUFzQkMsV0FBVyxDQUFDLElBQUlWLFlBQVk5M0IsT0FBTyxHQUFJOzRCQUM3RSxNQUFNeTRCLGNBQWM7bUNBQUlELFdBQVc5b0IsUUFBUTs2QkFBQzs0QkFDNUMrb0IsV0FBVyxDQUFDL29CLFNBQVMzUixNQUFNLENBQUMsR0FBR3FQOzRCQUMvQnZVLDZDQUFVQSxDQUFDNDdCLFFBQVEsQ0FBQzFpQixRQUFRO2dDQUMxQnJDLFVBQVUrb0I7NEJBQ1osR0FBRztnQ0FDRHBtQixJQUFJO3VDQUFJcFk7b0NBQU1zK0I7aUNBQXFCOzRCQUNyQzt3QkFDRjt3QkFDQTtvQkFDRjtnQkFDRjtnQkFDQSxNQUFNRyxjQUFjLElBQUkxNUIsSUFBSTQxQixtQkFBbUJwMkIsS0FBSzZTLEtBQUssRUFBRUMsZUFBZXBXLE1BQU0sRUFBRStFLEdBQUcsQ0FBQ3NDLENBQUFBLElBQUs7d0JBQUN5SCxLQUFLQyxTQUFTLENBQUMxSCxFQUFFdEksSUFBSTt3QkFBR3NJLEVBQUVzRSxPQUFPLENBQUM5SixJQUFJO3FCQUFDO2dCQUNuSXlCLEtBQUtJLFFBQVEsQ0FBQ3NmLE9BQU8sQ0FBQzFmLENBQUFBO29CQUNwQmxGLDZDQUFNQSxDQUFDa0YsS0FBS3NELElBQUksS0FBSywwQkFBMEJ0RCxLQUFLc0QsSUFBSSxLQUFLO29CQUM3RDQyQixZQUFZaDJCLE1BQU0sQ0FBQ3NILEtBQUtDLFNBQVMsQ0FBQ3pMLEtBQUtrUixRQUFRO2dCQUNqRDtnQkFDQSxJQUFJZ3BCLFlBQVkxMkIsSUFBSSxFQUFFO29CQUNwQm5KLDZDQUFVQSxDQUFDMitCLFdBQVcsQ0FBQ3psQixRQUFROzJCQUFJMm1CO3FCQUFZLENBQUN6NEIsR0FBRyxDQUFDLENBQUMsQ0FBQ2cxQixNQUFNbDRCLEtBQUssR0FBTTs0QkFDckUrRSxNQUFNLENBQUMsVUFBVSxFQUFFL0UsS0FBSyxLQUFLLENBQUM7NEJBQzlCMlMsVUFBVXVsQixPQUFPanJCLEtBQUtrQixLQUFLLENBQUMrcEIsUUFBUUE7NEJBQ3BDcjJCLFVBQVU7Z0NBQUM7b0NBQ1Q0UCxNQUFNO2dDQUNSOzZCQUFFO3dCQUNKLEtBQUs7d0JBQ0g2RCxJQUFJOytCQUFJcFk7NEJBQU11RSxLQUFLSSxRQUFRLENBQUNiLE1BQU07eUJBQUM7b0JBQ3JDO29CQUNBO2dCQUNGO2dCQUNBLE1BQU00NkIsYUFBYSxJQUFJOTBCO2dCQUN2QixNQUFNKzBCLDZCQUE2QixDQUFDO2dCQUNwQ2hFLG1CQUFtQnAyQixLQUFLNlMsS0FBSyxFQUFFNmtCLGVBQWUsQ0FBQzEzQixLQUFLNFMsU0FBUyxDQUFDLENBQUNsVyxNQUFNLEVBQUVnakIsT0FBTyxDQUFDLENBQUMzYixHQUFHeVk7b0JBQ2pGNGQsMEJBQTBCLENBQUM1dUIsS0FBS0MsU0FBUyxDQUFDMUgsRUFBRXRJLElBQUksRUFBRSxHQUFHO3dCQUNuRDRNLFNBQVN0RSxFQUFFc0UsT0FBTzt3QkFDbEJtVTtvQkFDRjtnQkFDRjtnQkFDQSxLQUFLLE1BQU0sQ0FBQ0EsT0FBTzBaLFVBQVUsSUFBSWwyQixLQUFLSSxRQUFRLENBQUNvQixPQUFPLEdBQUk7b0JBQ3hELElBQ0EsaURBQWlEO29CQUNqRCw0Q0FBNEM7b0JBQzVDMDBCLFVBQVU1eUIsSUFBSSxLQUFLLDJCQUEyQjR5QixVQUFVNXlCLElBQUksS0FBSyx3QkFBd0I7d0JBQ3ZGO29CQUNGO29CQUNBLE1BQU02WixZQUFZOzJCQUFJMWhCO3dCQUFNK2dCO3FCQUFNO29CQUNsQyxNQUFNNmQsc0JBQXNCN3VCLEtBQUtDLFNBQVMsQ0FBQ3lxQixVQUFVaGxCLFFBQVE7b0JBQzdELElBQUlrcEIsMEJBQTBCLENBQUNDLG9CQUFvQixLQUFLaDhCLFdBQVc7d0JBQ2pFaEUsNkNBQVVBLENBQUNpYixXQUFXLENBQUMvQixRQUFROzRCQUM3Qk0sSUFBSXNKO3dCQUNOO3dCQUNBO29CQUNGO29CQUNBLElBQUlnZCxXQUFXNTVCLEdBQUcsQ0FBQzg1QixzQkFBc0I7d0JBQ3ZDaGdDLDZDQUFVQSxDQUFDaWIsV0FBVyxDQUFDL0IsUUFBUTs0QkFDN0JNLElBQUlzSjt3QkFDTjt3QkFDQTtvQkFDRjtvQkFDQWdkLFdBQVdyMUIsR0FBRyxDQUFDdTFCO29CQUNmLE1BQU1DLFdBQVdGLDBCQUEwQixDQUFDQyxvQkFBb0I7b0JBQ2hFLE1BQU1FLGdCQUFnQkQsU0FBUzlkLEtBQUs7b0JBQ3BDLElBQUlBLFVBQVUrZCxlQUFlO3dCQUMzQmxnQyw2Q0FBVUEsQ0FBQytpQixTQUFTLENBQUM3SixRQUFROzRCQUMzQk0sSUFBSXNKOzRCQUNKSixJQUFJO21DQUFJdGhCO2dDQUFNOCtCOzZCQUFjO3dCQUM5Qjt3QkFDQTtvQkFDRjtvQkFDQSxNQUFNQyx3QkFBd0IsQ0FBQyxVQUFVLEVBQUVGLFNBQVNqeUIsT0FBTyxDQUFDOUosSUFBSSxDQUFDLEtBQUssQ0FBQztvQkFDdkUsSUFBSTIzQixVQUFVNXlCLElBQUksS0FBS2szQix1QkFBdUI7d0JBQzVDbmdDLDZDQUFVQSxDQUFDNDdCLFFBQVEsQ0FBQzFpQixRQUFROzRCQUMxQmpRLE1BQU1rM0I7d0JBQ1IsR0FBRzs0QkFDRDNtQixJQUFJc0o7d0JBQ047d0JBQ0E7b0JBQ0Y7b0JBQ0EsTUFBTTNILG1CQUFtQm1pQix5Q0FBeUMyQyxTQUFTanlCLE9BQU87b0JBQ2xGLElBQUlzdUIsaUNBQWlDO3dCQUFDVDt3QkFBVy9ZO3FCQUFVLEVBQUU1SixRQUFRaUMsbUJBQW1CO3dCQUN0RjtvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7UUFDQUMsY0FBYzdUO0lBQ2hCO0lBQ0EsT0FBTzJSO0FBQ1Q7QUFFQSxpR0FBaUc7QUFDakcsU0FBUzhsQixpQkFBaUJwMUIsS0FBSyxFQUFFdkgsTUFBTTtJQUNyQyxJQUFJQSxPQUFPNkIsSUFBSSxLQUFLLFdBQVc3QixPQUFPNkIsSUFBSSxLQUFLLFFBQVE7UUFDckQsT0FBTzBGO0lBQ1Q7SUFDQSxJQUFJdkgsT0FBTzZCLElBQUksS0FBSyxlQUFlO1FBQ2pDLE1BQU04USxtQkFBbUJwTDtRQUN6QixNQUFNdzJCLG9CQUFvQnBCLGlCQUFpQmhxQixpQkFBaUJwTCxLQUFLLEVBQUV2SCxPQUFPb0gsTUFBTSxDQUFDdUwsaUJBQWlCN0IsWUFBWSxDQUFDOUssUUFBUSxHQUFHO1FBQzFILElBQUkrM0Isc0JBQXNCcHJCLGlCQUFpQnBMLEtBQUssRUFBRTtZQUNoRCxPQUFPQTtRQUNUO1FBQ0EsT0FBTztZQUNMdUosY0FBYzZCLGlCQUFpQjdCLFlBQVk7WUFDM0N2SixPQUFPdzJCO1FBQ1Q7SUFDRjtJQUNBLElBQUkvOUIsT0FBTzZCLElBQUksS0FBSyxTQUFTO1FBQzNCLE1BQU1tOEIsV0FBV3oyQjtRQUNqQixNQUFNMDJCLGNBQWNELFNBQVNqNUIsR0FBRyxDQUFDc0MsQ0FBQUEsSUFBS3MxQixpQkFBaUJ0MUIsR0FBR3JILE9BQU9xSSxPQUFPO1FBQ3hFLElBQUlzTyxlQUFlcW5CLFVBQVVDLGNBQWM7WUFDekMsT0FBTzEyQjtRQUNUO1FBQ0EsT0FBTzAyQjtJQUNUO0lBQ0EsSUFBSWorQixPQUFPNkIsSUFBSSxLQUFLLFVBQVU7UUFDNUIsTUFBTXE4QixjQUFjMzJCO1FBQ3BCLElBQUk0MkIsYUFBYTtRQUNqQixNQUFNQyxpQkFBaUIsQ0FBQztRQUN4QixLQUFLLE1BQU0sQ0FBQ3I4QixLQUFLMEcsWUFBWSxJQUFJRixPQUFPekQsT0FBTyxDQUFDOUUsT0FBT3dJLE1BQU0sRUFBRztZQUM5RCxNQUFNNjFCLGFBQWFILFdBQVcsQ0FBQ244QixJQUFJO1lBQ25DLElBQUlzOEIsZUFBZTE4QixXQUFXO2dCQUM1Qnc4QixhQUFhO2dCQUNiQyxjQUFjLENBQUNyOEIsSUFBSSxHQUFHNk8scUJBQXFCbkk7Z0JBQzNDO1lBQ0Y7WUFDQSxNQUFNNjFCLGdCQUFnQjNCLGlCQUFpQjBCLFlBQVk1MUI7WUFDbkQsSUFBSTYxQixrQkFBa0JELFlBQVk7Z0JBQ2hDRixhQUFhO1lBQ2Y7WUFDQUMsY0FBYyxDQUFDcjhCLElBQUksR0FBR3U4QjtRQUN4QjtRQUNBLElBQUlILFlBQVk7WUFDZCxPQUFPQztRQUNUO1FBQ0EsT0FBTzcyQjtJQUNUO0lBQ0FySixrREFBV0EsQ0FBQzhCO0FBQ2Q7QUFFQSxNQUFNdStCLG1CQUFtQixJQUFPO1FBQzlCMzNCLE1BQU07UUFDTmxELFVBQVU7WUFBQztnQkFDVDRQLE1BQU07WUFDUjtTQUFFO0lBQ0o7QUFDQSxTQUFTa3JCLGVBQWUzbkIsTUFBTTtJQUM1QixNQUFNLEVBQ0prQyxhQUFhLEVBQ2QsR0FBR2xDO0lBQ0pBLE9BQU9rQyxhQUFhLEdBQUc3VCxDQUFBQTtRQUNyQixNQUFNLENBQUM1QixNQUFNdkUsS0FBSyxHQUFHbUc7UUFDckIsSUFBSXRILHlDQUFNQSxDQUFDNmdDLFFBQVEsQ0FBQ243QixPQUFPO1lBQ3pCLElBQUl3UixXQUFXeFIsS0FBS0ksUUFBUSxDQUFDSixLQUFLSSxRQUFRLENBQUNiLE1BQU0sR0FBRyxFQUFFO1lBQ3RELElBQUksQ0FBQ2lTLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTbE8sSUFBSSxNQUFNLGFBQWE7Z0JBQ3ZGakosNkNBQVVBLENBQUMyK0IsV0FBVyxDQUFDemxCLFFBQVEwbkIsb0JBQW9CO29CQUNqRHBuQixJQUFJOzJCQUFJcFk7d0JBQU11RSxLQUFLSSxRQUFRLENBQUNiLE1BQU07cUJBQUM7Z0JBQ3JDO2dCQUNBO1lBQ0Y7UUFDRjtRQUNBa1csY0FBYzdUO0lBQ2hCO0lBQ0EsT0FBTzJSO0FBQ1Q7QUFFQSxTQUFTNm5CLFlBQVk3bkIsTUFBTTtJQUN6QixNQUFNLEVBQ0prQyxhQUFhLEVBQ2JtaUIsY0FBYyxFQUNmLEdBQUdya0I7SUFDSkEsT0FBT3FrQixjQUFjLEdBQUdDLENBQUFBO1FBQ3RCLElBQUl0a0IsT0FBT3FpQixTQUFTLElBQUluN0Isd0NBQUtBLENBQUNzN0IsV0FBVyxDQUFDeGlCLE9BQU9xaUIsU0FBUyxLQUMxRCxzQ0FBc0M7UUFDdEMsaUVBQWlFO1FBQ2pFLG9EQUFvRDtRQUNwRCw0Q0FBNEM7UUFDNUNyaUIsT0FBT3FpQixTQUFTLENBQUNyWSxNQUFNLENBQUN4YSxNQUFNLEtBQUssR0FBRztZQUNwQyxNQUFNLENBQUNzNEIsV0FBV0MsVUFBVSxHQUFHaGhDLHlDQUFNQSxDQUFDMmpCLEtBQUssQ0FBQzFLLFFBQVE7Z0JBQ2xEMkssT0FBT2xlLENBQUFBLE9BQVFBLEtBQUtzRCxJQUFJLEtBQUs7WUFDL0IsTUFBTTtnQkFBQ2lRO2dCQUFRLEVBQUU7YUFBQztZQUNsQixJQUFJOG5CLFVBQVUvM0IsSUFBSSxLQUFLLGlCQUFpQjVJLHdDQUFLQSxDQUFDczdCLE1BQU0sQ0FBQzE3Qix5Q0FBTUEsQ0FBQzZJLEtBQUssQ0FBQ29RLFFBQVErbkIsWUFBWS9uQixPQUFPcWlCLFNBQVMsQ0FBQ3JZLE1BQU0sR0FBRztnQkFDOUc7WUFDRjtRQUNGO1FBQ0FxYSxlQUFlQztJQUNqQjtJQUNBdGtCLE9BQU9rQyxhQUFhLEdBQUc3VCxDQUFBQTtRQUNyQixNQUFNLENBQUM1QixNQUFNdkUsS0FBSyxHQUFHbUc7UUFDckIsSUFBSXhILDBDQUFTQSxDQUFDdWIsU0FBUyxDQUFDM1YsU0FBU0EsS0FBS3NELElBQUksS0FBSyxVQUFVO1lBQ3ZELElBQUl0RCxLQUFLMlMsTUFBTSxLQUFLdFUsV0FBVztnQkFDN0JoRSw2Q0FBVUEsQ0FBQ2thLFdBQVcsQ0FBQ2hCLFFBQVE7b0JBQzdCTSxJQUFJcFk7Z0JBQ047Z0JBQ0E7WUFDRjtZQUNBLElBQUl1RSxLQUFLSSxRQUFRLENBQUNiLE1BQU0sR0FBR1MsS0FBSzJTLE1BQU0sQ0FBQ3BULE1BQU0sRUFBRTtnQkFDN0NsRiw2Q0FBVUEsQ0FBQzIrQixXQUFXLENBQUN6bEIsUUFBUXJHLE1BQU1uQyxJQUFJLENBQUM7b0JBQ3hDeEwsUUFBUVMsS0FBSzJTLE1BQU0sQ0FBQ3BULE1BQU0sR0FBR1MsS0FBS0ksUUFBUSxDQUFDYixNQUFNO2dCQUNuRCxHQUFHa0MsR0FBRyxDQUFDLElBQU87d0JBQ1o2QixNQUFNO3dCQUNObEQsVUFBVTs0QkFBQzY2Qjt5QkFBbUI7b0JBQ2hDLEtBQUs7b0JBQ0hwbkIsSUFBSTsyQkFBSXBZO3dCQUFNdUUsS0FBS0ksUUFBUSxDQUFDYixNQUFNO3FCQUFDO2dCQUNyQztnQkFDQTtZQUNGO1lBQ0EsSUFBSVMsS0FBS0ksUUFBUSxDQUFDYixNQUFNLEdBQUdTLEtBQUsyUyxNQUFNLENBQUNwVCxNQUFNLEVBQUU7Z0JBQzdDMk4sTUFBTW5DLElBQUksQ0FBQztvQkFDVHhMLFFBQVFTLEtBQUtJLFFBQVEsQ0FBQ2IsTUFBTSxHQUFHUyxLQUFLMlMsTUFBTSxDQUFDcFQsTUFBTTtnQkFDbkQsR0FBR2tDLEdBQUcsQ0FBQyxDQUFDMlYsR0FBR2xVLElBQU1BLEdBQUd5MUIsT0FBTyxHQUFHalosT0FBTyxDQUFDeGMsQ0FBQUE7b0JBQ3BDLE1BQU1xNEIseUJBQXlCOzJCQUFJOS9CO3dCQUFNeUgsSUFBSWxELEtBQUsyUyxNQUFNLENBQUNwVCxNQUFNO3FCQUFDO29CQUNoRSxNQUFNaVIsUUFBUXhRLEtBQUtJLFFBQVEsQ0FBQzhDLElBQUlsRCxLQUFLMlMsTUFBTSxDQUFDcFQsTUFBTSxDQUFDO29CQUNuRHVkLGFBQWF2SixRQUFRZ29CLHdCQUF3QjsyQkFBSTkvQjt3QkFBTXVFLEtBQUsyUyxNQUFNLENBQUNwVCxNQUFNLEdBQUc7d0JBQUdTLEtBQUtJLFFBQVEsQ0FBQ0osS0FBSzJTLE1BQU0sQ0FBQ3BULE1BQU0sR0FBRyxFQUFFLENBQUNhLFFBQVEsQ0FBQ2IsTUFBTTtxQkFBQyxFQUFFUyxDQUFBQSxPQUFRQSxLQUFLc0QsSUFBSSxLQUFLLGVBQWUvSSx1Q0FBSUEsQ0FBQ290QixNQUFNLENBQUNuWCxXQUFXO29CQUNuTW5XLDZDQUFVQSxDQUFDaWIsV0FBVyxDQUFDL0IsUUFBUTt3QkFDN0JNLElBQUkwbkI7b0JBQ047Z0JBQ0Y7Z0JBQ0E7WUFDRjtRQUNGO1FBQ0E5bEIsY0FBYzdUO0lBQ2hCO0lBQ0EsT0FBTzJSO0FBQ1Q7QUFFQSxNQUFNaW9CLHNCQUFzQjtBQUM1QixTQUFTQyxTQUFTN2Ysc0JBQXNCLEVBQUVqSyxlQUFlLEVBQUU0QixNQUFNO0lBQy9ELE1BQU0sRUFDSmMsVUFBVSxFQUNWcW5CLFFBQVEsRUFDUmptQixhQUFhLEVBQ2QsR0FBR2xDO0lBQ0pBLE9BQU9tb0IsUUFBUSxHQUFHMzJCLENBQUFBO1FBQ2hCLE9BQU9BLFFBQVF6QixJQUFJLEtBQUssU0FBUyxPQUFPbzRCLFNBQVMzMkI7SUFDbkQ7SUFDQSxJQUFJNlcsdUJBQXVCeEgsS0FBSyxFQUFFO1FBQ2hDYixPQUFPYyxVQUFVLEdBQUdyRSxDQUFBQTtZQUNsQnFFLFdBQVdyRTtZQUNYLElBQUlBLFNBQVMsT0FBTyxDQUFDdUQsT0FBT3FpQixTQUFTLEVBQUU7Z0JBQ3JDO1lBQ0Y7WUFDQSxNQUFNK0YsZUFBZXJoQyx5Q0FBTUEsQ0FBQzZJLEtBQUssQ0FBQ29RLFFBQVFqWix5Q0FBTUEsQ0FBQzJqQixLQUFLLENBQUMxSyxRQUFRO2dCQUM3RDJLLE9BQU94QztZQUNULEVBQUUsQ0FBQyxFQUFFO1lBQ0wsTUFBTWtnQixvQ0FBb0N0aEMseUNBQU1BLENBQUNxdEIsTUFBTSxDQUFDcFUsUUFBUTtnQkFDOURnSyxRQUFRaEssT0FBT3FpQixTQUFTLENBQUNyWSxNQUFNO2dCQUMvQkcsT0FBT2llO1lBQ1Q7WUFDQSxNQUFNemQsUUFBUXNkLG9CQUFvQjFiLElBQUksQ0FBQzhiO1lBQ3ZDLElBQUksQ0FBQzFkLE9BQU87Z0JBQ1Y7WUFDRjtZQUNBLE1BQU0yZCw4Q0FBOEM5ZCwrQ0FBK0N4SyxRQUFRcUksd0JBQXdCaks7WUFDbkksSUFBSSxDQUFDa3FCLGdEQUFnRCxRQUFRQSxnREFBZ0QsS0FBSyxJQUFJLEtBQUssSUFBSUEsNENBQTRDcm1CLGdCQUFnQixDQUFDcEIsS0FBSyxNQUFNLE9BQU87Z0JBQzVNO1lBQ0Y7WUFDQSxNQUFNLEdBQUcwbkIsaUJBQWlCQyxVQUFVaHdCLEtBQUssR0FBR21TO1lBQzVDLHFHQUFxRztZQUNyRywwREFBMEQ7WUFDMUQsaUhBQWlIO1lBQ2pIM0ssT0FBT2lpQixPQUFPLENBQUNDLEtBQUssQ0FBQ2x3QixJQUFJLENBQUM7Z0JBQ3hCbXdCLFlBQVksRUFBRTtnQkFDZEMsaUJBQWlCcGlCLE9BQU9xaUIsU0FBUztZQUNuQztZQUNBLE1BQU1vRyxrQkFBa0I5ZCxNQUFNMUIsS0FBSyxLQUFLLElBQUltZixlQUFldGUsNkNBQTZDOUosUUFBUW9vQixjQUFjO2dCQUM1SHJlLFVBQVVZLE1BQU0xQixLQUFLO1lBQ3ZCO1lBQ0EsTUFBTXlmLGtCQUFrQjVlLDZDQUE2QzlKLFFBQVF5b0IsaUJBQWlCO2dCQUM1RjFlLFVBQVV3ZSxvQkFBb0IsS0FBSyxJQUFJO1lBQ3pDO1lBQ0EsTUFBTUksZ0JBQWdCN2UsNkNBQTZDOUosUUFBUTBvQixpQkFBaUI7Z0JBQzFGM2UsVUFBVXllLFNBQVN4OEIsTUFBTTtZQUMzQjtZQUNBbEYsNkNBQVVBLENBQUM2SixNQUFNLENBQUNxUCxRQUFRO2dCQUN4Qk0sSUFBSTtvQkFDRjBKLFFBQVEyZTtvQkFDUnhlLE9BQU9uSyxPQUFPcWlCLFNBQVMsQ0FBQ3JZLE1BQU07Z0JBQ2hDO1lBQ0Y7WUFDQWxqQiw2Q0FBVUEsQ0FBQzZKLE1BQU0sQ0FBQ3FQLFFBQVE7Z0JBQ3hCTSxJQUFJO29CQUNGMEosUUFBUXllO29CQUNSdGUsT0FBT3VlO2dCQUNUO1lBQ0Y7WUFDQTVoQyw2Q0FBVUEsQ0FBQ3k3QixTQUFTLENBQUN2aUIsUUFBUTtnQkFDM0JqUSxNQUFNO2dCQUNOeUk7Z0JBQ0EzTCxVQUFVLEVBQUU7WUFDZCxHQUFHO2dCQUNEeVQsSUFBSTtvQkFDRjBKLFFBQVFoSyxPQUFPcWlCLFNBQVMsQ0FBQ3JZLE1BQU07b0JBQy9CRyxPQUFPc2U7Z0JBQ1Q7Z0JBQ0FqOEIsT0FBTztZQUNUO1lBQ0EsTUFBTW84QixXQUFXN2hDLHlDQUFNQSxDQUFDbXJCLElBQUksQ0FBQ2xTO1lBQzdCLElBQUk0b0IsVUFBVTtnQkFDWjloQyw2Q0FBVUEsQ0FBQ3c3QixNQUFNLENBQUN0aUIsUUFBUTRvQixRQUFRLENBQUMsRUFBRTtZQUN2QztRQUNGO0lBQ0Y7SUFDQTVvQixPQUFPa0MsYUFBYSxHQUFHLENBQUMsQ0FBQ3pWLE1BQU12RSxLQUFLO1FBQ2xDLElBQUl1RSxLQUFLc0QsSUFBSSxLQUFLLFFBQVE7WUFDeEIsSUFBSS9JLHVDQUFJQSxDQUFDb3RCLE1BQU0sQ0FBQzNuQixVQUFVLElBQUk7Z0JBQzVCM0YsNkNBQVVBLENBQUNrYSxXQUFXLENBQUNoQixRQUFRO29CQUM3Qk0sSUFBSXBZO2dCQUNOO2dCQUNBO1lBQ0Y7WUFDQSxLQUFLLE1BQU0sQ0FBQ21ULEtBQUs0QixNQUFNLElBQUl4USxLQUFLSSxRQUFRLENBQUNvQixPQUFPLEdBQUk7Z0JBQ2xELElBQUlnUCxNQUFNbE4sSUFBSSxLQUFLLFFBQVE7b0JBQ3pCLDZCQUE2QjtvQkFDN0JqSiw2Q0FBVUEsQ0FBQ2thLFdBQVcsQ0FBQ2hCLFFBQVE7d0JBQzdCTSxJQUFJOytCQUFJcFk7NEJBQU1tVDt5QkFBSTtvQkFDcEI7b0JBQ0E7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0EsSUFBSTZNLGtCQUFrQnpiLE9BQU87WUFDM0IsSUFBSW84QixtQkFBbUI7WUFDdkIsS0FBSyxNQUFNLENBQUN4dEIsS0FBSzRCLE1BQU0sSUFBSXhRLEtBQUtJLFFBQVEsQ0FBQ29CLE9BQU8sR0FBSTtnQkFDbEQsSUFBSTY2QjtnQkFDSixJQUFJN3JCLE1BQU1sTixJQUFJLEtBQUssVUFBVWtOLE1BQU16RSxJQUFJLEtBQU0sRUFBQ3N3QixvQkFBb0JELGdCQUFlLE1BQU8sUUFBUUMsc0JBQXNCLEtBQUssSUFBSSxLQUFLLElBQUlBLGtCQUFrQnI4QixJQUFJLENBQUMrTCxJQUFJLEdBQUc7b0JBQ3BLLE1BQU11d0IsZ0JBQWdCOzJCQUFJN2dDO3dCQUFNMmdDLGlCQUFpQjVmLEtBQUs7cUJBQUM7b0JBQ3ZELE1BQU0rZixpQkFBaUI7MkJBQUk5Z0M7d0JBQU1tVDtxQkFBSTtvQkFDckMsTUFBTW1PLEtBQUs7MkJBQUl1Zjt3QkFBZUYsaUJBQWlCcDhCLElBQUksQ0FBQ0ksUUFBUSxDQUFDYixNQUFNO3FCQUFDO29CQUNwRSwwRkFBMEY7b0JBQzFGLElBQUssSUFBSTJELElBQUlzTixNQUFNcFEsUUFBUSxDQUFDYixNQUFNLEdBQUcsR0FBRzJELEtBQUssR0FBR0EsSUFBSzt3QkFDbkQsTUFBTWlhLFlBQVk7K0JBQUlvZjs0QkFBZ0JyNUI7eUJBQUU7d0JBQ3hDN0ksNkNBQVVBLENBQUMraUIsU0FBUyxDQUFDN0osUUFBUTs0QkFDM0JNLElBQUlzSjs0QkFDSko7d0JBQ0Y7b0JBQ0Y7b0JBQ0ExaUIsNkNBQVVBLENBQUNpYixXQUFXLENBQUMvQixRQUFRO3dCQUM3Qk0sSUFBSTBvQjtvQkFDTjtvQkFDQTtnQkFDRjtnQkFDQSxJQUFJLENBQUNyaUMsdUNBQUlBLENBQUN3YixNQUFNLENBQUNsRixVQUFVQSxNQUFNUixJQUFJLEtBQUssSUFBSTtvQkFDNUNvc0IsbUJBQW1CO2dCQUNyQjtnQkFDQSxJQUFJNXJCLE1BQU1sTixJQUFJLEtBQUssUUFBUTtvQkFDekI4NEIsbUJBQW1CO3dCQUNqQjVmLE9BQU81Tjt3QkFDUDVPLE1BQU13UTtvQkFDUjtnQkFDRjtZQUNGO1FBQ0Y7UUFDQWlGLGNBQWM7WUFBQ3pWO1lBQU12RTtTQUFLO0lBQzVCO0lBQ0EsT0FBTzhYO0FBQ1Q7QUFFQSxNQUFNaXBCLGFBQWFsNUIsQ0FBQUEsT0FBUUEsU0FBUyxrQkFBa0JBLFNBQVM7QUFDL0QsTUFBTW01QixhQUFhejhCLENBQUFBLE9BQVF3OEIsV0FBV3g4QixLQUFLc0QsSUFBSTtBQUMvQyxTQUFTbzVCLGdCQUFnQm5wQixNQUFNO0lBQzdCLElBQUlBLE9BQU9xaUIsU0FBUyxFQUFFO1FBQ3BCLE1BQU0rRyxXQUFXcmlDLHlDQUFNQSxDQUFDMmpCLEtBQUssQ0FBQzFLLFFBQVE7WUFDcEMySyxPQUFPSixnQkFBZ0I7UUFDekI7UUFDQSxNQUFNNUwsT0FBTzVYLHlDQUFNQSxDQUFDMmpCLEtBQUssQ0FBQzFLLFFBQVE7WUFDaEMySyxPQUFPdWU7UUFDVDtRQUNBLElBQUlFLFlBQVl6cUIsTUFBTTtZQUNwQixPQUFPO2dCQUNMc2tCLFVBQVU7Z0JBQ1ZtRztnQkFDQXpxQjtZQUNGO1FBQ0Y7SUFDRjtJQUNBLE9BQU87UUFDTHNrQixVQUFVO0lBQ1o7QUFDRjtBQUNBLFNBQVNvRyxTQUFTcnBCLE1BQU07SUFDdEIsTUFBTSxFQUNKNGhCLFdBQVcsRUFDWDFmLGFBQWEsRUFDYm1pQixjQUFjLEVBQ2YsR0FBR3JrQjtJQUNKQSxPQUFPcWtCLGNBQWMsR0FBR0MsQ0FBQUE7UUFDdEIsSUFBSXRrQixPQUFPcWlCLFNBQVMsRUFBRTtZQUNwQixNQUFNaUgsZUFBZUgsZ0JBQWdCbnBCO1lBQ3JDLElBQUlzcEIsYUFBYXJHLFFBQVEsSUFBSS83Qix3Q0FBS0EsQ0FBQ3M3QixXQUFXLENBQUN4aUIsT0FBT3FpQixTQUFTLEtBQUt0N0IseUNBQU1BLENBQUN5OUIsT0FBTyxDQUFDeGtCLFFBQVFBLE9BQU9xaUIsU0FBUyxDQUFDclksTUFBTSxFQUFFc2YsYUFBYTNxQixJQUFJLENBQUMsRUFBRSxHQUFHO2dCQUN6STdYLDZDQUFVQSxDQUFDa2EsV0FBVyxDQUFDaEIsUUFBUTtvQkFDN0IySyxPQUFPdWU7b0JBQ1AxOEIsT0FBTztnQkFDVDtnQkFDQTtZQUNGO1FBQ0Y7UUFDQTYzQixlQUFlQztJQUNqQjtJQUNBdGtCLE9BQU80aEIsV0FBVyxHQUFHO1FBQ25CLE1BQU0sQ0FBQ3dILFNBQVMsR0FBR3JpQyx5Q0FBTUEsQ0FBQytXLEtBQUssQ0FBQ2tDLFFBQVE7WUFDdEMySyxPQUFPbGUsQ0FBQUEsT0FBUUEsS0FBS3NELElBQUksS0FBSztZQUM3QnpCLE1BQU07UUFDUjtRQUNBLElBQUk4NkIsWUFBWXBpQyx1Q0FBSUEsQ0FBQ290QixNQUFNLENBQUNnVixRQUFRLENBQUMsRUFBRSxNQUFNLElBQUk7WUFDL0N0aUMsNkNBQVVBLENBQUNrYSxXQUFXLENBQUNoQixRQUFRO2dCQUM3QjJLLE9BQU91ZTtnQkFDUDE4QixPQUFPO1lBQ1Q7WUFDQTtRQUNGO1FBQ0FvMUI7SUFDRjtJQUNBNWhCLE9BQU9rQyxhQUFhLEdBQUc3VCxDQUFBQTtRQUNyQixNQUFNLENBQUM1QixNQUFNdkUsS0FBSyxHQUFHbUc7UUFDckIsSUFBSXhILDBDQUFTQSxDQUFDdWIsU0FBUyxDQUFDM1YsU0FBUzFGLHlDQUFNQSxDQUFDNmdDLFFBQVEsQ0FBQ243QixPQUFPO1lBQ3RELE1BQU04OEIsZ0NBQWdDTCxXQUFXejhCO1lBQ2pELEtBQUssTUFBTSxDQUFDazJCLFdBQVcvWSxVQUFVLElBQUk1aUIsdUNBQUlBLENBQUM2RixRQUFRLENBQUNtVCxRQUFROVgsTUFBTztnQkFDaEUsTUFBTStnQixRQUFRVyxTQUFTLENBQUNBLFVBQVU1ZCxNQUFNLEdBQUcsRUFBRTtnQkFDN0Msc0JBQXNCO2dCQUN0QixJQUFJazlCLFdBQVd2RyxZQUFZO29CQUN6QixJQUFJNkc7b0JBQ0osSUFBSSxDQUFDLENBQUNBLGlCQUFpQi84QixLQUFLSSxRQUFRLENBQUMrYyxTQUFTLENBQUNBLFVBQVU1ZCxNQUFNLEdBQUcsRUFBRSxHQUFHLEVBQUUsTUFBTSxRQUFRdzlCLG1CQUFtQixLQUFLLElBQUksS0FBSyxJQUFJQSxlQUFlejVCLElBQUksTUFBTTR5QixVQUFVNXlCLElBQUksRUFBRTt3QkFDbkssTUFBTTA1QixrQkFBa0J4aUMsdUNBQUlBLENBQUNpckIsSUFBSSxDQUFDdEk7d0JBQ2xDTCxhQUFhdkosUUFBUXlwQixpQkFBaUI7K0JBQUk3Zjs0QkFBVytZLFVBQVU5MUIsUUFBUSxDQUFDYixNQUFNO3lCQUFDO3dCQUMvRWxGLDZDQUFVQSxDQUFDaWIsV0FBVyxDQUFDL0IsUUFBUTs0QkFDN0JNLElBQUltcEI7d0JBQ047d0JBQ0E7b0JBQ0Y7b0JBQ0EsSUFBSUYsK0JBQStCO3dCQUNqQyxNQUFNRyxnQkFBZ0JqOUIsS0FBS0ksUUFBUSxDQUFDb2MsUUFBUSxFQUFFO3dCQUM5QyxJQUFJcGlCLDBDQUFTQSxDQUFDdWIsU0FBUyxDQUFDc25CLGdCQUFnQjs0QkFDdEM1aUMsNkNBQVVBLENBQUMraUIsU0FBUyxDQUFDN0osUUFBUTtnQ0FDM0JNLElBQUlzSjtnQ0FDSkosSUFBSTt1Q0FBSXZpQix1Q0FBSUEsQ0FBQzBpQyxRQUFRLENBQUMvZjtvQ0FBWThmLGNBQWM3OEIsUUFBUSxDQUFDYixNQUFNLEdBQUc7aUNBQUU7NEJBQ3RFO3dCQUNGLE9BQU87NEJBQ0xsRiw2Q0FBVUEsQ0FBQ2thLFdBQVcsQ0FBQ2hCLFFBQVE7Z0NBQzdCTSxJQUFJc0o7NEJBQ047d0JBQ0Y7d0JBQ0E7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0EsSUFBSW5kLEtBQUtzRCxJQUFJLEtBQUssZUFBZTR5QixVQUFVNXlCLElBQUksS0FBSyx1QkFBdUJrWixVQUFVLEtBQUtkLFFBQVF3YSxZQUFZO29CQUM1RyxJQUFJejZCLElBQUksQ0FBQ0EsS0FBSzhELE1BQU0sR0FBRyxFQUFFLEtBQUssR0FBRzt3QkFDL0IsTUFBTTA5QixnQkFBZ0IxaUMsdUNBQUlBLENBQUMwRixHQUFHLENBQUNzVCxRQUFRL1ksdUNBQUlBLENBQUMwaUMsUUFBUSxDQUFDemhDO3dCQUNyRCxJQUFJckIsMENBQVNBLENBQUN1YixTQUFTLENBQUNzbkIsZ0JBQWdCOzRCQUN0QzVpQyw2Q0FBVUEsQ0FBQytpQixTQUFTLENBQUM3SixRQUFRO2dDQUMzQk0sSUFBSXBZO2dDQUNKc2hCLElBQUk7dUNBQUl2aUIsdUNBQUlBLENBQUMwaUMsUUFBUSxDQUFDemhDO29DQUFPd2hDLGNBQWM3OEIsUUFBUSxDQUFDYixNQUFNO2lDQUFDOzRCQUM3RDs0QkFDQTt3QkFDRjtvQkFDRjtvQkFDQWxGLDZDQUFVQSxDQUFDa2EsV0FBVyxDQUFDaEIsUUFBUTt3QkFDN0JNLElBQUlzSjtvQkFDTjtvQkFDQTtnQkFDRjtnQkFDQSxJQUFJbmQsS0FBS3NELElBQUksS0FBSyxlQUFlNHlCLFVBQVU1eUIsSUFBSSxLQUFLLHVCQUF1QmtaLFVBQVUsR0FBRztvQkFDdEZuaUIsNkNBQVVBLENBQUM0K0IsVUFBVSxDQUFDMWxCLFFBQVE7d0JBQzVCTSxJQUFJc0o7b0JBQ047b0JBQ0E7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0ExSCxjQUFjN1Q7SUFDaEI7SUFDQSxPQUFPMlI7QUFDVDtBQUVBLFNBQVM0cEIsTUFBTXA3QixDQUFDLEVBQUVDLENBQUM7SUFDakIsT0FBTztRQUNMbUIsT0FBT2duQixLQUFLelEsR0FBRyxDQUFDM1gsR0FBR0M7UUFDbkJzUyxLQUFLNlYsS0FBS3hRLEdBQUcsQ0FBQzVYLEdBQUdDO0lBQ25CO0FBQ0Y7QUFDQSxTQUFTbzdCLG1CQUFtQkMsT0FBTyxFQUFFQyxRQUFRO0lBQzNDLE9BQU9ELFVBQVVDLGFBQWEsSUFBSTtRQUFDO1FBQUc7S0FBRSxHQUFHO1FBQUM7UUFBR0EsV0FBVztLQUFFLEdBQUc7UUFBQztRQUFHQTtLQUFTO0FBQzlFO0FBQ0EsU0FBU0MscUJBQXFCaHFCLE1BQU07SUFDbEMsSUFBSWlxQixlQUFlQyxtQkFBbUJDLGdCQUFnQkM7SUFDdEQsTUFBTXBnQixTQUFTLENBQUNpZ0IsZ0JBQWdCbGpDLHlDQUFNQSxDQUFDMmpCLEtBQUssQ0FBQzFLLFFBQVE7UUFDbkQySyxPQUFPSixnQkFBZ0I7UUFDdkJqSyxJQUFJLENBQUM0cEIsb0JBQW9CbHFCLE9BQU9xaUIsU0FBUyxNQUFNLFFBQVE2SCxzQkFBc0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsa0JBQWtCbGdCLE1BQU0sQ0FBQzloQixJQUFJO0lBQzlILEVBQUMsTUFBTyxRQUFRK2hDLGtCQUFrQixLQUFLLElBQUksS0FBSyxJQUFJQSxhQUFhLENBQUMsRUFBRTtJQUNwRSxNQUFNOWYsUUFBUSxDQUFDZ2dCLGlCQUFpQnBqQyx5Q0FBTUEsQ0FBQzJqQixLQUFLLENBQUMxSyxRQUFRO1FBQ25EMkssT0FBT0osZ0JBQWdCO1FBQ3ZCakssSUFBSSxDQUFDOHBCLHFCQUFxQnBxQixPQUFPcWlCLFNBQVMsTUFBTSxRQUFRK0gsdUJBQXVCLEtBQUssSUFBSSxLQUFLLElBQUlBLG1CQUFtQmpnQixLQUFLLENBQUNqaUIsSUFBSTtJQUNoSSxFQUFDLE1BQU8sUUFBUWlpQyxtQkFBbUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsY0FBYyxDQUFDLEVBQUU7SUFDdEUsTUFBTW5pQixRQUFRamhCLHlDQUFNQSxDQUFDMmpCLEtBQUssQ0FBQzFLLFFBQVE7UUFDakMySyxPQUFPSixnQkFBZ0I7SUFDekI7SUFDQSxJQUFJdkssT0FBT3FpQixTQUFTLElBQUlyYSxTQUFTbmhCLDBDQUFTQSxDQUFDdWIsU0FBUyxDQUFDNEYsS0FBSyxDQUFDLEVBQUUsQ0FBQ25iLFFBQVEsQ0FBQyxFQUFFLEtBQUttZCxVQUFVRyxTQUFTbGpCLHVDQUFJQSxDQUFDdzdCLE1BQU0sQ0FBQ3pZLE9BQU9wZCxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUl1ZCxNQUFNdmQsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLO1FBQ3JKLE1BQU0sQ0FBQ2dELE9BQU9tUixJQUFJLEdBQUdoYSx5Q0FBTUEsQ0FBQ3NqQyxLQUFLLENBQUNycUIsUUFBUUEsT0FBT3FpQixTQUFTO1FBQzFELE9BQU87WUFDTGlJLFdBQVd0aUIsS0FBSyxDQUFDLEVBQUU7WUFDbkJBLE9BQU9BLEtBQUssQ0FBQyxFQUFFO1lBQ2Z1aUIsWUFBWXRqQyx1Q0FBSUEsQ0FBQ3c3QixNQUFNLENBQUN6WSxRQUFRRyxTQUFTaGpCLHdDQUFLQSxDQUFDczdCLE1BQU0sQ0FBQzE3Qix5Q0FBTUEsQ0FBQzZJLEtBQUssQ0FBQ29RLFFBQVFnSyxTQUFTcGEsVUFBVXpJLHdDQUFLQSxDQUFDczdCLE1BQU0sQ0FBQzE3Qix5Q0FBTUEsQ0FBQ2dhLEdBQUcsQ0FBQ2YsUUFBUWdLLFNBQVNqSixRQUFRLENBQUM1Wix3Q0FBS0EsQ0FBQ3M3QixNQUFNLENBQUM3eUIsT0FBT21SLE9BQU8sYUFBYSxpQkFBaUI7WUFDek15cEIsS0FBS1osTUFBTTVmLE1BQU0sQ0FBQ0EsT0FBT2hlLE1BQU0sR0FBRyxFQUFFLEdBQUdnZSxNQUFNLENBQUNBLE9BQU9oZSxNQUFNLEdBQUcsRUFBRSxFQUFFbWUsS0FBSyxDQUFDQSxNQUFNbmUsTUFBTSxHQUFHLEVBQUUsR0FBR21lLEtBQUssQ0FBQ0gsT0FBT2hlLE1BQU0sR0FBRyxFQUFFO1lBQ3BIeStCLFFBQVFiLE1BQU01ZixNQUFNLENBQUNBLE9BQU9oZSxNQUFNLEdBQUcsRUFBRSxFQUFFbWUsS0FBSyxDQUFDQSxNQUFNbmUsTUFBTSxHQUFHLEVBQUU7UUFDbEU7SUFDRjtBQUNGO0FBQ0EsTUFBTTArQixPQUFPdnJCLENBQUFBLFNBQVc7UUFDdEJwUCxNQUFNO1FBQ04sR0FBSW9QLFNBQVM7WUFDWEEsUUFBUTtRQUNWLElBQUksQ0FBQyxDQUFDO1FBQ050UyxVQUFVO1lBQUM7Z0JBQ1RrRCxNQUFNO2dCQUNObEQsVUFBVTtvQkFBQzt3QkFDVDRQLE1BQU07b0JBQ1I7aUJBQUU7WUFDSjtTQUFFO0lBQ0o7QUFDQSxTQUFTa3VCLGdCQUFnQmwrQixJQUFJO0lBQzNCLElBQUk5Rix1Q0FBSUEsQ0FBQ3diLE1BQU0sQ0FBQzFWLE9BQU8sT0FBTztRQUM1QixHQUFHQSxJQUFJO0lBQ1Q7SUFDQSxPQUFPO1FBQ0wsR0FBR0EsSUFBSTtRQUNQSSxVQUFVSixLQUFLSSxRQUFRLENBQUNxQixHQUFHLENBQUN5OEI7SUFDOUI7QUFDRjtBQUNBLFNBQVNDLFVBQVU1cUIsTUFBTTtJQUN2QixNQUFNLEVBQ0o2cUIsY0FBYyxFQUNkM29CLGFBQWEsRUFDYjRvQixXQUFXLEVBQ1hDLGNBQWMsRUFDZDFHLGNBQWMsRUFDZixHQUFHcmtCO0lBQ0pBLE9BQU8rcUIsY0FBYyxHQUFHQyxDQUFBQTtRQUN0QixNQUFNQyxvQkFBb0JqQixxQkFBcUJocUI7UUFDL0MsSUFBSSxDQUFDaXJCLHFCQUFxQkQsU0FBU2gvQixNQUFNLEtBQUssS0FBS2cvQixRQUFRLENBQUMsRUFBRSxDQUFDajdCLElBQUksS0FBSyxTQUFTO1lBQy9FZzdCLGVBQWVDO1lBQ2Y7UUFDRjtRQUNBLE1BQU1FLFVBQVVGLFFBQVEsQ0FBQyxFQUFFLENBQUNuK0IsUUFBUSxDQUFDZ0MsT0FBTyxDQUFDb08sQ0FBQUEsUUFBU0EsTUFBTWxOLElBQUksS0FBSyxnQkFBZ0JrTixNQUFNbE4sSUFBSSxLQUFLLGVBQWVrTixNQUFNcFEsUUFBUSxHQUFHLEVBQUU7UUFDdEksSUFBSSxDQUFDcStCLFFBQVF0dEIsS0FBSyxDQUFDMk0sZ0JBQWdCLGVBQWU7WUFDaER3Z0IsZUFBZUM7WUFDZjtRQUNGO1FBQ0EsSUFBSSxFQUNGUixHQUFHLEVBQ0hDLE1BQU0sRUFDTkgsU0FBUyxFQUNUdGlCLEtBQUssRUFDTixHQUFHaWpCO1FBQ0osTUFBTUUsZUFBZUYsa0JBQWtCampCLEtBQUssQ0FBQ25iLFFBQVEsQ0FBQ28rQixrQkFBa0JqakIsS0FBSyxDQUFDbmIsUUFBUSxDQUFDYixNQUFNLEtBQUssSUFBSSxJQUFJLEVBQUU7UUFDNUcsSUFBSWsvQixPQUFPLENBQUMsRUFBRSxDQUFDbjdCLElBQUksS0FBSyxlQUFlbzdCLGFBQWFwN0IsSUFBSSxLQUFLLGdCQUFnQm83QixhQUFhdCtCLFFBQVEsQ0FBQyxFQUFFLENBQUNrRCxJQUFJLEtBQUssYUFBYTtZQUMxSGc3QixlQUFlQztZQUNmO1FBQ0Y7UUFDQSxNQUFNbEIsVUFBVTloQixNQUFNbmIsUUFBUSxDQUFDLEVBQUUsQ0FBQ2tELElBQUksS0FBSztRQUMzQyxJQUFJazdCLGtCQUFrQlYsVUFBVSxLQUFLLFFBQVE7WUFDM0NDLE1BQU07Z0JBQ0o1NkIsT0FBTzQ2QixJQUFJNTZCLEtBQUs7Z0JBQ2hCbVIsS0FBSzZWLEtBQUt6USxHQUFHLENBQUNxa0IsSUFBSTU2QixLQUFLLEdBQUdzN0IsUUFBUWwvQixNQUFNLEdBQUcsR0FBR20vQixhQUFhdCtCLFFBQVEsQ0FBQ2IsTUFBTSxHQUFHLElBQUs4OUIsQ0FBQUEsVUFBVSxJQUFJO1lBQ2xHO1lBQ0FXLFNBQVM7Z0JBQ1A3NkIsT0FBTzY2QixPQUFPNzZCLEtBQUs7Z0JBQ25CbVIsS0FBSzZWLEtBQUt6USxHQUFHLENBQUNza0IsT0FBTzc2QixLQUFLLEdBQUdzN0IsT0FBTyxDQUFDLEVBQUUsQ0FBQ3IrQixRQUFRLENBQUNiLE1BQU0sR0FBRyxHQUFHbS9CLGFBQWF0K0IsUUFBUSxDQUFDLEVBQUUsQ0FBQ0EsUUFBUSxDQUFDYixNQUFNLEdBQUc7WUFDMUc7UUFDRjtRQUNBakYseUNBQU1BLENBQUNtK0Isa0JBQWtCLENBQUNsbEIsUUFBUTtZQUNoQyxJQUFLLElBQUkrcEIsV0FBV1MsSUFBSTU2QixLQUFLLEVBQUVtNkIsWUFBWVMsSUFBSXpwQixHQUFHLEVBQUVncEIsV0FBWTtnQkFDOUQsTUFBTXFCLFNBQVNGLE9BQU8sQ0FBQyxDQUFDbkIsV0FBV1MsSUFBSTU2QixLQUFLLElBQUlzN0IsUUFBUWwvQixNQUFNLENBQUM7Z0JBQy9ELElBQUssSUFBSXEvQixZQUFZWixPQUFPNzZCLEtBQUssRUFBRXk3QixhQUFhWixPQUFPMXBCLEdBQUcsRUFBRXNxQixZQUFhO29CQUN2RSxNQUFNQyxtQkFBbUI7MkJBQUl6QixtQkFBbUJDLFNBQVNDO3dCQUFXc0I7cUJBQVU7b0JBQzlFLE1BQU1YLE9BQU8xakMsdUNBQUlBLENBQUMwRixHQUFHLENBQUNzYixPQUFPc2pCO29CQUM3QixNQUFNQyxVQUFVSCxPQUFPditCLFFBQVEsQ0FBQyxDQUFDdytCLFlBQVlaLE9BQU83NkIsS0FBSyxJQUFJdzdCLE9BQU92K0IsUUFBUSxDQUFDYixNQUFNLENBQUM7b0JBQ3BGLElBQUkwK0IsS0FBSzM2QixJQUFJLEtBQUssZ0JBQWdCdzdCLFFBQVF4N0IsSUFBSSxLQUFLLGNBQWM7d0JBQy9EO29CQUNGO29CQUNBLE1BQU15N0IsV0FBVzsyQkFBSWxCOzJCQUFjZ0I7cUJBQWlCO29CQUNwRCxLQUFLLE1BQU1HLFlBQVk7MkJBQUlmLEtBQUs3OUIsUUFBUSxDQUFDcU4sSUFBSTtxQkFBRyxDQUFDa3JCLE9BQU8sR0FBSTt3QkFDMUR0K0IsNkNBQVVBLENBQUNpYixXQUFXLENBQUMvQixRQUFROzRCQUM3Qk0sSUFBSTttQ0FBSWtyQjtnQ0FBVUM7NkJBQVM7d0JBQzdCO29CQUNGO29CQUNBM2tDLDZDQUFVQSxDQUFDMitCLFdBQVcsQ0FBQ3psQixRQUFRdXJCLFFBQVExK0IsUUFBUSxDQUFDcUIsR0FBRyxDQUFDeThCLGtCQUFrQjt3QkFDcEVycUIsSUFBSTsrQkFBSWtyQjs0QkFBVTt5QkFBRTtvQkFDdEI7Z0JBQ0Y7WUFDRjtZQUNBMWtDLDZDQUFVQSxDQUFDNGtDLFlBQVksQ0FBQzFyQixRQUFRO2dCQUM5QmdLLFFBQVFqakIseUNBQU1BLENBQUM2SSxLQUFLLENBQUNvUSxRQUFRO3VCQUFJc3FCO3VCQUFjVCxtQkFBbUJDLFNBQVNVLElBQUk1NkIsS0FBSztvQkFBRzY2QixPQUFPNzZCLEtBQUs7aUJBQUM7Z0JBQ3BHdWEsT0FBT3BqQix5Q0FBTUEsQ0FBQ2dhLEdBQUcsQ0FBQ2YsUUFBUTt1QkFBSXNxQjt1QkFBY1QsbUJBQW1CQyxTQUFTVSxJQUFJenBCLEdBQUc7b0JBQUcwcEIsT0FBTzFwQixHQUFHO2lCQUFDO1lBQy9GO1FBQ0Y7SUFDRjtJQUNBZixPQUFPcWtCLGNBQWMsR0FBR0MsQ0FBQUE7UUFDdEIsSUFBSXRrQixPQUFPcWlCLFNBQVMsSUFBSW43Qix3Q0FBS0EsQ0FBQ3M3QixXQUFXLENBQUN4aUIsT0FBT3FpQixTQUFTLEtBQUtyaUIsT0FBT3FpQixTQUFTLENBQUNyWSxNQUFNLENBQUN4YSxNQUFNLEtBQUssR0FBRztZQUNuRyxNQUFNNHRCLFlBQVlyMkIseUNBQU1BLENBQUMyakIsS0FBSyxDQUFDMUssUUFBUTtnQkFDckMySyxPQUFPSixnQkFBZ0I7WUFDekI7WUFDQSxJQUFJNlMsYUFBYUEsU0FBUyxDQUFDLEVBQUUsQ0FBQ3Z3QixRQUFRLENBQUMsRUFBRSxDQUFDa0QsSUFBSSxLQUFLLGVBQWVxdEIsU0FBUyxDQUFDLEVBQUUsQ0FBQ3Z3QixRQUFRLENBQUMsRUFBRSxDQUFDQSxRQUFRLENBQUMsRUFBRSxDQUFDa0QsSUFBSSxLQUFLakYsYUFBYTdELHVDQUFJQSxDQUFDdzdCLE1BQU0sQ0FBQ3ppQixPQUFPcWlCLFNBQVMsQ0FBQ3JZLE1BQU0sQ0FBQzloQixJQUFJLEVBQUU7bUJBQUlrMUIsU0FBUyxDQUFDLEVBQUU7Z0JBQUU7Z0JBQUc7YUFBRSxHQUFHO2dCQUMvTDtZQUNGO1FBQ0Y7UUFDQWlILGVBQWVDO0lBQ2pCO0lBQ0F0a0IsT0FBTzhxQixXQUFXLEdBQUc7UUFDbkIsTUFBTUcsb0JBQW9CakIscUJBQXFCaHFCO1FBQy9DLElBQUlpckIscUJBQXFCQSxrQkFBa0JWLFVBQVUsS0FBSyxnQkFBZ0I7WUFDeEUsSUFBSW9CO1lBQ0osTUFBTSxFQUNKM2pCLEtBQUssRUFDTixHQUFHaWpCO1lBQ0osTUFBTVcsUUFBUTVqQixNQUFNbmIsUUFBUSxDQUFDLEVBQUUsQ0FBQ2tELElBQUksS0FBSyxnQkFBZ0JpWSxNQUFNbmIsUUFBUSxDQUFDLEVBQUUsQ0FBQ2tELElBQUksS0FBSyxlQUFlaVksTUFBTW5iLFFBQVEsQ0FBQyxFQUFFLEdBQUcvQjtZQUN2SCxJQUFJLENBQUM4Z0MsT0FBTztnQkFDVixPQUFPZDtZQUNUO1lBQ0EsTUFBTWUsU0FBUyxDQUFDLENBQUNGLG1CQUFtQjNqQixNQUFNbmIsUUFBUSxDQUFDLEVBQUUsTUFBTSxRQUFROCtCLHFCQUFxQixLQUFLLElBQUksS0FBSyxJQUFJQSxpQkFBaUI1N0IsSUFBSSxNQUFNLGVBQWVpWSxNQUFNbmIsUUFBUSxDQUFDLEVBQUUsR0FBRy9CO1lBQ3hLLE1BQU1naEMsT0FBT0QsVUFBVUQ7WUFDdkIsTUFBTTlCLFVBQVU4QixNQUFNNzdCLElBQUksS0FBSztZQUMvQixNQUFNZzhCLG9CQUFvQmQsa0JBQWtCVCxHQUFHLENBQUM1NkIsS0FBSyxLQUFLLEtBQUssQ0FBQyxDQUFDaThCO1lBQ2pFLE1BQU1HLGVBQWVmLGtCQUFrQlIsTUFBTSxDQUFDMXBCLEdBQUcsR0FBR2txQixrQkFBa0JSLE1BQU0sQ0FBQzc2QixLQUFLLEdBQUc7WUFDckYsT0FBTztnQkFBQztvQkFDTkcsTUFBTTtvQkFDTmxELFVBQVU7MkJBQUtrL0Isb0JBQW9COzRCQUFDO2dDQUNsQ2g4QixNQUFNO2dDQUNObEQsVUFBVTtvQ0FBQzt3Q0FDVGtELE1BQU07d0NBQ05sRCxVQUFVOE0sTUFBTW5DLElBQUksQ0FBQzs0Q0FDbkJ4TCxRQUFRZ2dDO3dDQUNWLEdBQUc5OUIsR0FBRyxDQUFDLENBQUMyVixHQUFHb29CLGNBQWdCTCxNQUFNLytCLFFBQVEsQ0FBQyxFQUFFLENBQUNBLFFBQVEsQ0FBQ28vQixjQUFjaEIsa0JBQWtCUixNQUFNLENBQUM3NkIsS0FBSyxDQUFDO29DQUNyRztpQ0FBRTs0QkFDSjt5QkFBRSxHQUFHLEVBQUU7d0JBQUc7NEJBQ1JHLE1BQU07NEJBQ05sRCxVQUFVOE0sTUFBTW5DLElBQUksQ0FBQztnQ0FDbkJ4TCxRQUFRaS9CLGtCQUFrQlQsR0FBRyxDQUFDenBCLEdBQUcsR0FBR2txQixrQkFBa0JULEdBQUcsQ0FBQzU2QixLQUFLLEdBQUltOEIsQ0FBQUEsb0JBQW9CLElBQUk7NEJBQzdGLEdBQUc3OUIsR0FBRyxDQUFDLENBQUMyVixHQUFHa21CLFdBQWM7b0NBQ3ZCaDZCLE1BQU07b0NBQ05sRCxVQUFVOE0sTUFBTW5DLElBQUksQ0FBQzt3Q0FDbkJ4TCxRQUFRZ2dDO29DQUNWLEdBQUc5OUIsR0FBRyxDQUFDLENBQUMyVixHQUFHb29CLGNBQWdCSCxLQUFLai9CLFFBQVEsQ0FBQ2s5QixXQUFXa0Isa0JBQWtCVCxHQUFHLENBQUM1NkIsS0FBSyxHQUFJazZCLENBQUFBLFdBQVcsQ0FBQ2lDLG9CQUFvQixJQUFJLEdBQUcsQ0FBQ2wvQixRQUFRLENBQUNvL0IsY0FBY2hCLGtCQUFrQlIsTUFBTSxDQUFDNzZCLEtBQUssQ0FBQztnQ0FDbkw7d0JBQ0Y7cUJBQUU7Z0JBQ0o7YUFBRTtRQUNKO1FBQ0EsT0FBT2s3QjtJQUNUO0lBQ0E5cUIsT0FBTzZxQixjQUFjLEdBQUdxQixDQUFBQTtRQUN0QixJQUFJLENBQUNsc0IsT0FBT3FpQixTQUFTLElBQUluN0Isd0NBQUtBLENBQUNzN0IsV0FBVyxDQUFDeGlCLE9BQU9xaUIsU0FBUyxHQUFHO1lBQzVEd0ksZUFBZXFCO1lBQ2Y7UUFDRjtRQUNBLE1BQU1qQixvQkFBb0JqQixxQkFBcUJocUI7UUFDL0MsSUFBSSxDQUFDaXJCLHFCQUFxQkEsa0JBQWtCVixVQUFVLEtBQUssZ0JBQWdCO1lBQ3pFTSxlQUFlcUI7WUFDZjtRQUNGO1FBQ0EsTUFBTUMsYUFBYWxCLGtCQUFrQmpqQixLQUFLLENBQUNuYixRQUFRLENBQUMsRUFBRTtRQUN0RCxJQUFJLENBQUNoRywwQ0FBU0EsQ0FBQ3ViLFNBQVMsQ0FBQytwQixlQUFlLENBQUN0bEMsMENBQVNBLENBQUN1YixTQUFTLENBQUMrcEIsV0FBV3QvQixRQUFRLENBQUMsRUFBRSxHQUFHO1lBQ3BGZytCLGVBQWVxQjtZQUNmO1FBQ0Y7UUFDQSxNQUFNRSxZQUFZbkIsa0JBQWtCampCLEtBQUssQ0FBQ25iLFFBQVEsQ0FBQ21DLE1BQU0sQ0FBQyxDQUFDQyxLQUFLazlCLGFBQWVsOUIsTUFBT2s5QixDQUFBQSxXQUFXcDhCLElBQUksS0FBSyxnQkFBZ0JvOEIsV0FBV3A4QixJQUFJLEtBQUssZUFBZW84QixXQUFXdC9CLFFBQVEsQ0FBQ2IsTUFBTSxHQUFHLElBQUksS0FBSztRQUNuTSxNQUFNLEVBQ0p3K0IsR0FBRyxFQUNIQyxNQUFNLEVBQ05ILFNBQVMsRUFDVixHQUFHVztRQUNKLHlGQUF5RjtRQUN6RixnSEFBZ0g7UUFDaEgsTUFBTW9CLHlCQUF5QjdCLElBQUk1NkIsS0FBSyxLQUFLLEtBQUs0NkIsSUFBSXpwQixHQUFHLEtBQUtxckI7UUFDOUQsTUFBTUUsc0JBQXNCN0IsT0FBTzc2QixLQUFLLEtBQUssS0FBSzY2QixPQUFPMXBCLEdBQUcsS0FBS29yQixXQUFXdC9CLFFBQVEsQ0FBQyxFQUFFLENBQUNBLFFBQVEsQ0FBQ2IsTUFBTSxHQUFHO1FBQzFHLElBQUlxZ0MsMEJBQTBCQyxxQkFBcUI7WUFDakR4bEMsNkNBQVVBLENBQUNpYixXQUFXLENBQUMvQixRQUFRO2dCQUM3Qk0sSUFBSWdxQjtZQUNOO1lBQ0E7UUFDRjtRQUNBLE1BQU1SLFVBQVVxQyxXQUFXcDhCLElBQUksS0FBSztRQUNwQyxJQUFJdThCLHFCQUFxQjtZQUN2QnZsQyx5Q0FBTUEsQ0FBQ20rQixrQkFBa0IsQ0FBQ2xsQixRQUFRO2dCQUNoQyxJQUFLLElBQUlyUSxJQUFJNjZCLElBQUl6cEIsR0FBRyxFQUFFcFIsS0FBSzY2QixJQUFJNTZCLEtBQUssRUFBRUQsSUFBSztvQkFDekMsSUFBSW02QixTQUFTO3dCQUNYLElBQUluNkIsTUFBTSxHQUFHOzRCQUNYN0ksNkNBQVVBLENBQUNpYixXQUFXLENBQUMvQixRQUFRO2dDQUM3Qk0sSUFBSTt1Q0FBSWdxQjtvQ0FBVztpQ0FBRTs0QkFDdkI7NEJBQ0E7d0JBQ0Y7d0JBQ0F4akMsNkNBQVVBLENBQUNpYixXQUFXLENBQUMvQixRQUFROzRCQUM3Qk0sSUFBSTttQ0FBSWdxQjtnQ0FBVztnQ0FBRzM2QixJQUFJOzZCQUFFO3dCQUM5Qjt3QkFDQTtvQkFDRjtvQkFDQTdJLDZDQUFVQSxDQUFDaWIsV0FBVyxDQUFDL0IsUUFBUTt3QkFDN0JNLElBQUk7K0JBQUlncUI7NEJBQVc7NEJBQUczNkI7eUJBQUU7b0JBQzFCO2dCQUNGO1lBQ0Y7WUFDQTtRQUNGO1FBQ0EsSUFBSTA4Qix3QkFBd0I7WUFDMUJ0bEMseUNBQU1BLENBQUNtK0Isa0JBQWtCLENBQUNsbEIsUUFBUTtnQkFDaEMsSUFBSyxJQUFJclEsSUFBSTg2QixPQUFPMXBCLEdBQUcsRUFBRXBSLEtBQUs4NkIsT0FBTzc2QixLQUFLLEVBQUVELElBQUs7b0JBQy9DLElBQUssSUFBSTQ4QixTQUFTLEdBQUdBLFVBQVVILFdBQVdHLFNBQVU7d0JBQ2xEemxDLDZDQUFVQSxDQUFDaWIsV0FBVyxDQUFDL0IsUUFBUTs0QkFDN0JNLElBQUk7bUNBQUlncUI7bUNBQWNULG1CQUFtQkMsU0FBU3lDO2dDQUFTNThCOzZCQUFFO3dCQUMvRDtvQkFDRjtnQkFDRjtnQkFDQSxNQUFNNjhCLGdCQUFnQjt1QkFBSWxDO29CQUFXO29CQUFHO29CQUFHRyxPQUFPNzZCLEtBQUs7aUJBQUM7Z0JBQ3hELE1BQU1xYSxRQUFRbGpCLHlDQUFNQSxDQUFDNkksS0FBSyxDQUFDb1EsUUFBUXlxQixPQUFPNzZCLEtBQUssS0FBSyxJQUFJNDhCLGdCQUFnQnZsQyx1Q0FBSUEsQ0FBQzBpQyxRQUFRLENBQUM2QztnQkFDdEYxbEMsNkNBQVVBLENBQUN3N0IsTUFBTSxDQUFDdGlCLFFBQVFpSztZQUM1QjtZQUNBO1FBQ0Y7UUFDQSxNQUFNd2lCLGlCQUFpQjFsQyx5Q0FBTUEsQ0FBQzZJLEtBQUssQ0FBQ29RLFFBQVFBLE9BQU9xaUIsU0FBUyxFQUFFbjZCLElBQUk7UUFDbEVuQix5Q0FBTUEsQ0FBQ20rQixrQkFBa0IsQ0FBQ2xsQixRQUFRO1lBQ2hDLElBQUssSUFBSStwQixXQUFXUyxJQUFJNTZCLEtBQUssRUFBRW02QixZQUFZUyxJQUFJenBCLEdBQUcsRUFBRWdwQixXQUFZO2dCQUM5RCxJQUFLLElBQUlzQixZQUFZWixPQUFPNzZCLEtBQUssRUFBRXk3QixhQUFhWixPQUFPMXBCLEdBQUcsRUFBRXNxQixZQUFhO29CQUN2RSxNQUFNQyxtQkFBbUI7MkJBQUl6QixtQkFBbUJDLFNBQVNDO3dCQUFXc0I7cUJBQVU7b0JBQzlFLE1BQU1YLE9BQU8xakMsdUNBQUlBLENBQUMwRixHQUFHLENBQUN1K0Isa0JBQWtCampCLEtBQUssRUFBRXNqQjtvQkFDL0MsSUFBSSxDQUFDemtDLDBDQUFTQSxDQUFDdWIsU0FBUyxDQUFDc29CLE9BQU87d0JBQzlCO29CQUNGO29CQUNBLE1BQU1jLFdBQVc7MkJBQUlsQjsyQkFBY2dCO3FCQUFpQjtvQkFDcER4a0MsNkNBQVVBLENBQUMyK0IsV0FBVyxDQUFDemxCLFFBQVE7d0JBQzdCalEsTUFBTTt3QkFDTmxELFVBQVU7NEJBQUM7Z0NBQ1Q0UCxNQUFNOzRCQUNSO3lCQUFFO29CQUNKLEdBQUc7d0JBQ0Q2RCxJQUFJOytCQUFJa3JCOzRCQUFVO3lCQUFFO29CQUN0QjtvQkFDQSxLQUFLLE1BQU1DLFlBQVk7MkJBQUlmLEtBQUs3OUIsUUFBUSxDQUFDcU4sSUFBSTtxQkFBRyxDQUFDa3JCLE9BQU8sR0FBSTt3QkFDMUR0K0IsNkNBQVVBLENBQUNpYixXQUFXLENBQUMvQixRQUFROzRCQUM3Qk0sSUFBSTttQ0FBSWtyQjtnQ0FBVUMsV0FBVzs2QkFBRTt3QkFDakM7b0JBQ0Y7Z0JBQ0Y7WUFDRjtZQUNBM2tDLDZDQUFVQSxDQUFDdzdCLE1BQU0sQ0FBQ3RpQixRQUFReXNCO1FBQzVCO0lBQ0Y7SUFDQXpzQixPQUFPa0MsYUFBYSxHQUFHN1QsQ0FBQUE7UUFDckIsTUFBTSxDQUFDNUIsTUFBTXZFLEtBQUssR0FBR21HO1FBQ3JCLElBQUk1QixLQUFLc0QsSUFBSSxLQUFLLGdCQUFnQnRELEtBQUtJLFFBQVEsQ0FBQ2IsTUFBTSxHQUFHLEdBQUc7WUFDMUR1ZCxhQUFhdkosUUFBUTlYLE1BQU1qQix1Q0FBSUEsQ0FBQ2lyQixJQUFJLENBQUNocUIsT0FBTyxDQUFDMmIsR0FBR2xVLElBQU1BLE1BQU07WUFDNUQ7UUFDRjtRQUNBLElBQUkrOEIsa0JBQWtCO1FBQ3RCLEtBQUssTUFBTTdzQixVQUFVO1lBQUM7WUFBYztTQUFhLENBQUU7WUFDakQsSUFBSXBULEtBQUtzRCxJQUFJLEtBQUs4UCxRQUFRO2dCQUN4QixLQUFLLE1BQU0sQ0FBQzBzQixRQUFRL0IsSUFBSSxJQUFJLzlCLEtBQUtJLFFBQVEsQ0FBQ29CLE9BQU8sR0FBSTtvQkFDbkQsSUFBSXU4QixJQUFJejZCLElBQUksS0FBSyxhQUFhO3dCQUM1QixLQUFLLE1BQU0sQ0FBQzQ4QixTQUFTakMsS0FBSyxJQUFJRixJQUFJMzlCLFFBQVEsQ0FBQ29CLE9BQU8sR0FBSTs0QkFDcEQsSUFBSXk4QixLQUFLMzZCLElBQUksS0FBSyxjQUFjO2dDQUM5QixNQUFNdVEsS0FBSzt1Q0FBSXBZO29DQUFNcWtDO29DQUFRSTtpQ0FBUTtnQ0FDckMsSUFBSWpDLEtBQUt2ckIsTUFBTSxJQUFJVSxXQUFXLGNBQWM7b0NBQzFDL1ksNkNBQVVBLENBQUN1WixVQUFVLENBQUNMLFFBQVEsVUFBVTt3Q0FDdENNO29DQUNGO29DQUNBb3NCLGtCQUFrQjtnQ0FDcEI7Z0NBQ0EsSUFBSSxDQUFDaEMsS0FBS3ZyQixNQUFNLElBQUlVLFdBQVcsY0FBYztvQ0FDM0MvWSw2Q0FBVUEsQ0FBQzQ3QixRQUFRLENBQUMxaUIsUUFBUTt3Q0FDMUJiLFFBQVE7b0NBQ1YsR0FBRzt3Q0FDRG1CO29DQUNGO29DQUNBb3NCLGtCQUFrQjtnQ0FDcEI7NEJBQ0Y7d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0EsSUFBSUEsaUJBQWlCO1lBQ25CO1FBQ0Y7UUFDQSxJQUFJamdDLEtBQUtzRCxJQUFJLEtBQUssU0FBUztZQUN6QixNQUFNNjhCLGNBQWNuZ0MsS0FBS0ksUUFBUSxDQUFDbUMsTUFBTSxDQUFDLENBQUNvWCxLQUFLM1osT0FBU0EsS0FBS3NELElBQUksS0FBSyxnQkFBZ0J0RCxLQUFLc0QsSUFBSSxLQUFLLGVBQWV0RCxLQUFLSSxRQUFRLENBQUNtQyxNQUFNLENBQUMsQ0FBQ29YLEtBQUszWixPQUFTQSxLQUFLc0QsSUFBSSxLQUFLLGNBQWM2bUIsS0FBS3hRLEdBQUcsQ0FBQ0EsS0FBSzNaLEtBQUtJLFFBQVEsQ0FBQ2IsTUFBTSxJQUFJb2EsS0FBS0EsT0FBT0EsS0FBSztZQUMxTyxJQUFJeW1CLFlBQVk7WUFDaEIsS0FBSyxNQUFNLENBQUN4eEIsS0FBSzRCLE1BQU0sSUFBSXhRLEtBQUtJLFFBQVEsQ0FBQ29CLE9BQU8sR0FBSTtnQkFDbEQsSUFBSWdQLE1BQU1sTixJQUFJLEtBQUssZ0JBQWdCa04sTUFBTWxOLElBQUksS0FBSyxjQUFjO29CQUM5RCxLQUFLLE1BQU0sQ0FBQ3c4QixRQUFRL0IsSUFBSSxJQUFJdnRCLE1BQU1wUSxRQUFRLENBQUNvQixPQUFPLEdBQUk7d0JBQ3BELElBQUl1OEIsSUFBSXo2QixJQUFJLEtBQUssZUFBZXk2QixJQUFJMzlCLFFBQVEsQ0FBQ2IsTUFBTSxLQUFLNGdDLGFBQWE7NEJBQ25FOWxDLDZDQUFVQSxDQUFDMitCLFdBQVcsQ0FBQ3psQixRQUFRckcsTUFBTW5DLElBQUksQ0FBQztnQ0FDeEN4TCxRQUFRNGdDLGNBQWNwQyxJQUFJMzlCLFFBQVEsQ0FBQ2IsTUFBTTs0QkFDM0MsR0FBRyxJQUFNMCtCLEtBQUt6dEIsTUFBTWxOLElBQUksS0FBSyxnQkFBZ0I7Z0NBQzNDdVEsSUFBSTt1Q0FBSXBZO29DQUFNbVQ7b0NBQUtreEI7b0NBQVEvQixJQUFJMzlCLFFBQVEsQ0FBQ2IsTUFBTTtpQ0FBQzs0QkFDakQ7NEJBQ0E2Z0MsWUFBWTt3QkFDZDtvQkFDRjtnQkFDRjtZQUNGO1lBQ0EsSUFBSUEsV0FBVztnQkFDYjtZQUNGO1lBQ0EsSUFBSXBnQyxLQUFLSSxRQUFRLENBQUNiLE1BQU0sS0FBSyxLQUFLUyxLQUFLSSxRQUFRLENBQUMsRUFBRSxDQUFDa0QsSUFBSSxLQUFLLGNBQWM7Z0JBQ3hFakosNkNBQVVBLENBQUMyK0IsV0FBVyxDQUFDemxCLFFBQVE7b0JBQzdCalEsTUFBTTtvQkFDTmxELFVBQVU4TSxNQUFNbkMsSUFBSSxDQUFDO3dCQUNuQnhMLFFBQVFTLEtBQUtJLFFBQVEsQ0FBQyxFQUFFLENBQUNBLFFBQVEsQ0FBQ2IsTUFBTTtvQkFDMUMsR0FBRyxJQUFNMCtCLEtBQUs7Z0JBQ2hCLEdBQUc7b0JBQ0RwcUIsSUFBSTsyQkFBSXBZO3dCQUFNO3FCQUFFO2dCQUNsQjtnQkFDQTtZQUNGO1lBQ0EsSUFBSXVFLEtBQUtJLFFBQVEsQ0FBQ2IsTUFBTSxLQUFLLEtBQUtTLEtBQUtJLFFBQVEsQ0FBQyxFQUFFLENBQUNrRCxJQUFJLEtBQUssY0FBYztnQkFDeEVqSiw2Q0FBVUEsQ0FBQytpQixTQUFTLENBQUM3SixRQUFRO29CQUMzQk0sSUFBSTsyQkFBSXBZO3dCQUFNO3FCQUFFO29CQUNoQnNoQixJQUFJOzJCQUFJdGhCO3dCQUFNO3FCQUFFO2dCQUNsQjtnQkFDQTtZQUNGO1lBQ0EsSUFBSXVFLEtBQUtJLFFBQVEsQ0FBQ2IsTUFBTSxHQUFHLEdBQUc7Z0JBQzVCdWQsYUFBYXZKLFFBQVE5WCxNQUFNakIsdUNBQUlBLENBQUNpckIsSUFBSSxDQUFDaHFCLE9BQU8sQ0FBQzJiLEdBQUdsVSxJQUFNQSxNQUFNLEtBQUtBLE1BQU07Z0JBQ3ZFO1lBQ0Y7UUFDRjtRQUNBdVMsY0FBYzdUO0lBQ2hCO0lBQ0EsT0FBTzJSO0FBQ1Q7QUFFQSxTQUFTOHNCLHFDQUFxQzdxQixnQkFBZ0IsRUFBRTdELGVBQWU7SUFDN0UsT0FBTzJ1QixzQkFBc0IzbEMsbURBQVlBLElBQUk2YSxrQkFBa0I3RDtBQUNqRTtBQUNBLFNBQVMydUIsc0JBQXNCQyxVQUFVLEVBQUUvcUIsZ0JBQWdCLEVBQUU3RCxlQUFlO0lBQzFFLE9BQU82dUIsaUJBQWlCdEYsZUFBZU8sU0FBU2ptQixrQkFBa0I3RCxpQkFBaUJpckIsU0FBU3VCLFVBQVUxRyxvQkFBb0I5bEIsaUJBQWlCNkQsa0JBQWtCaXJCLGlCQUFpQnJGLFlBQVlsRyxjQUFjMWYsa0JBQWtCN0QsaUJBQWlCNEQsa0NBQWtDQyxrQkFBa0IrcUI7QUFDalM7QUFDQSxTQUFTQyxpQkFBaUJqdEIsTUFBTTtJQUM5QixNQUFNLEVBQ0prQyxhQUFhLEVBQ2QsR0FBR2xDO0lBQ0pBLE9BQU9rQyxhQUFhLEdBQUcsQ0FBQyxDQUFDelYsTUFBTXZFLEtBQUs7UUFDbEMsSUFBSSxDQUFDdkIsdUNBQUlBLENBQUN3YixNQUFNLENBQUMxVixTQUFTQSxLQUFLc0QsSUFBSSxLQUFLLFFBQVE7WUFDOUMsTUFBTW85QixXQUFXcG1DLHlDQUFNQSxDQUFDNmdDLFFBQVEsQ0FBQ243QixRQUFRLFdBQVdBLEtBQUtzRCxJQUFJO1lBQzdELElBQUksT0FBT285QixhQUFhLFlBQVl2bEIsWUFBWSxDQUFDdWxCLFNBQVMsS0FBS3JpQyxXQUFXO2dCQUN4RWhFLDZDQUFVQSxDQUFDa2EsV0FBVyxDQUFDaEIsUUFBUTtvQkFDN0JNLElBQUlwWTtnQkFDTjtnQkFDQTtZQUNGO1lBQ0EsTUFBTWtsQyxPQUFPeGxCLFlBQVksQ0FBQ3VsQixTQUFTO1lBQ25DLElBQUlDLEtBQUtwaUMsSUFBSSxLQUFLLFlBQVl5QixLQUFLSSxRQUFRLENBQUNiLE1BQU0sS0FBSyxLQUFLUyxLQUFLSSxRQUFRLENBQUMrUSxLQUFLLENBQUNYLENBQUFBLFFBQVMsQ0FBQ2tMLFFBQVFsTCxTQUFTO2dCQUN6R25XLDZDQUFVQSxDQUFDeTdCLFNBQVMsQ0FBQ3ZpQixRQUFRO29CQUMzQmpRLE1BQU1xOUIsS0FBSzVsQixvQkFBb0I7b0JBQy9CM2EsVUFBVSxFQUFFO2dCQUNkLEdBQUc7b0JBQ0R5VCxJQUFJcFk7b0JBQ0p5aUIsT0FBT2xlLENBQUFBLE9BQVEsQ0FBQzBiLFFBQVExYjtnQkFDMUI7Z0JBQ0E7WUFDRjtZQUNBLElBQUk0Z0MsWUFBWTtZQUNoQixLQUFLLE1BQU0sQ0FBQ3BrQixPQUFPMFosVUFBVSxJQUFJO21CQUFJbDJCLEtBQUtJLFFBQVEsQ0FBQ29CLE9BQU87YUFBRyxDQUFDbTNCLE9BQU8sR0FBSTtnQkFDdkUsTUFBTXhiLFlBQVk7dUJBQUkxaEI7b0JBQU0rZ0I7aUJBQU07Z0JBQ2xDLElBQUlta0IsS0FBS3BpQyxJQUFJLEtBQUssV0FBVztvQkFDM0IsSUFBSSxDQUFDckUsdUNBQUlBLENBQUN3YixNQUFNLENBQUN3Z0IsY0FBY3hhLFFBQVF3YSxZQUFZO3dCQUNqRDJLLDRCQUE0QnR0QixRQUFROzRCQUFDMmlCOzRCQUFXL1k7eUJBQVUsRUFBRTFoQjt3QkFDNURtbEMsWUFBWTt3QkFDWjtvQkFDRjtnQkFDRixPQUFPO29CQUNMLElBQUksQ0FBQ2xsQixRQUFRd2EsWUFBWTt3QkFDdkI3N0IsNkNBQVVBLENBQUN5N0IsU0FBUyxDQUFDdmlCLFFBQVE7NEJBQzNCalEsTUFBTXE5QixLQUFLNWxCLG9CQUFvQjs0QkFDL0IzYSxVQUFVLEVBQUU7d0JBQ2QsR0FBRzs0QkFDRHlULElBQUlzSjt3QkFDTjt3QkFDQXlqQixZQUFZO3dCQUNaO29CQUNGO29CQUNBLElBQUksQ0FBQ0QsS0FBSzdsQixlQUFlLENBQUN2YSxHQUFHLENBQUMyMUIsVUFBVTV5QixJQUFJLEdBQUc7d0JBQzdDdTlCLDRCQUE0QnR0QixRQUFROzRCQUFDMmlCOzRCQUFXL1k7eUJBQVUsRUFBRTFoQjt3QkFDNURtbEMsWUFBWTt3QkFDWjtvQkFDRjtnQkFDRjtZQUNGO1lBQ0EsSUFBSUEsV0FBVztnQkFDYjtZQUNGO1FBQ0Y7UUFDQW5yQixjQUFjO1lBQUN6VjtZQUFNdkU7U0FBSztJQUM1QjtJQUNBLE9BQU84WDtBQUNUO0FBQ0EsU0FBU3N0Qiw0QkFBNEJ0dEIsTUFBTSxFQUFFLENBQUN2VCxNQUFNdkUsS0FBSyxFQUFFcWxDLFlBQVk7SUFDckUsTUFBTUosV0FBVzFnQyxLQUFLc0QsSUFBSTtJQUMxQixNQUFNeTlCLGdCQUFnQjVsQixZQUFZLENBQUN1bEIsU0FBUztJQUM1Qyx3RUFBd0U7SUFDeEUsTUFBTU0sZUFBZXptQyx1Q0FBSUEsQ0FBQzBGLEdBQUcsQ0FBQ3NULFFBQVF1dEI7SUFDdEMsTUFBTUcsaUJBQWlCM21DLHlDQUFNQSxDQUFDNmdDLFFBQVEsQ0FBQzZGLGdCQUFnQixXQUFXQSxhQUFhMTlCLElBQUk7SUFDbkYsTUFBTTQ5QixpQkFBaUIvbEIsWUFBWSxDQUFDOGxCLGVBQWU7SUFDbkQsSUFBSSxDQUFDRixpQkFBaUJBLGNBQWMvbEIseUJBQXlCLEtBQUssVUFBVTtRQUMxRSxJQUFJa21CLGVBQWUzaUMsSUFBSSxLQUFLLFlBQVkyaUMsZUFBZW5tQixvQkFBb0IsRUFBRTtZQUMzRTFnQiw2Q0FBVUEsQ0FBQzQ3QixRQUFRLENBQUMxaUIsUUFBUTtnQkFDMUJqUSxNQUFNNDlCLGVBQWVubUIsb0JBQW9CO2dCQUN6QyxHQUFHOVYsT0FBTzhKLFdBQVcsQ0FBQzlKLE9BQU93SSxJQUFJLENBQUN6TixNQUFNMlQsTUFBTSxDQUFDbFYsQ0FBQUEsTUFBT0EsUUFBUSxVQUFVQSxRQUFRLFlBQVlnRCxHQUFHLENBQUNoRCxDQUFBQSxNQUFPO3dCQUFDQTt3QkFBSztxQkFBSyxHQUFHLG1HQUFtRztZQUMxTixHQUFHO2dCQUNEb1YsSUFBSXBZO1lBQ047WUFDQTtRQUNGO1FBQ0FwQiw2Q0FBVUEsQ0FBQ2thLFdBQVcsQ0FBQ2hCLFFBQVE7WUFDN0JNLElBQUlwWTtRQUNOO1FBQ0E7SUFDRjtJQUNBLE1BQU1rbEMsT0FBT3hsQixZQUFZLENBQUM2bEIsYUFBYTE5QixJQUFJLElBQUksU0FBUztJQUN4RCxJQUFJLENBQUNxOUIsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUtwaUMsSUFBSSxNQUFNLFlBQVlvaUMsS0FBSzdsQixlQUFlLENBQUN2YSxHQUFHLENBQUNtZ0MsV0FBVztRQUM5RyxJQUFJSSxhQUFhdmhDLE1BQU0sS0FBSyxHQUFHO1lBQzdCbEYsNkNBQVVBLENBQUMraUIsU0FBUyxDQUFDN0osUUFBUTtnQkFDM0JNLElBQUlwWTtnQkFDSnNoQixJQUFJO29CQUFDdGhCLElBQUksQ0FBQyxFQUFFLEdBQUc7aUJBQUU7WUFDbkI7UUFDRixPQUFPO1lBQ0xwQiw2Q0FBVUEsQ0FBQytpQixTQUFTLENBQUM3SixRQUFRO2dCQUMzQk0sSUFBSXBZO2dCQUNKc2hCLElBQUl2aUIsdUNBQUlBLENBQUNpckIsSUFBSSxDQUFDcWI7WUFDaEI7UUFDRjtRQUNBO0lBQ0Y7SUFDQSxJQUFJeG1DLHlDQUFNQSxDQUFDNmdDLFFBQVEsQ0FBQzZGLGVBQWU7UUFDakMzbUMsNkNBQVVBLENBQUMraUIsU0FBUyxDQUFDN0osUUFBUTtZQUMzQk0sSUFBSXBZO1lBQ0pzaEIsSUFBSTtnQkFBQ3RoQixJQUFJLENBQUMsRUFBRSxHQUFHO2FBQUU7UUFDbkI7UUFDQXBCLDZDQUFVQSxDQUFDa2EsV0FBVyxDQUFDaEIsUUFBUTtZQUM3Qk0sSUFBSTtnQkFBQ3BZLElBQUksQ0FBQyxFQUFFLEdBQUc7YUFBRTtRQUNuQjtRQUNBO0lBQ0Y7SUFDQW9sQyw0QkFBNEJ0dEIsUUFBUTtRQUFDdlQ7UUFBTXZFO0tBQUssRUFBRXFsQyxhQUFhM2dDLEtBQUssQ0FBQyxHQUFHLENBQUM7QUFDM0U7QUFDQSxTQUFTc2dDLGlCQUFpQmx0QixNQUFNO0lBQzlCLE1BQU0sRUFDSjhGLE1BQU0sRUFDUCxHQUFHOUY7SUFDSkEsT0FBTzhGLE1BQU0sR0FBR3JaLENBQUFBO1FBQ2QsT0FBT0EsS0FBS3NELElBQUksS0FBSyxhQUFhdEQsS0FBS3NELElBQUksS0FBSyxXQUFXK1YsT0FBT3JaO0lBQ3BFO0lBQ0EsT0FBT3VUO0FBQ1Q7QUFFQSxNQUFNNHRCLGNBQWMsSUFBSWppQztBQUN4QixNQUFNa2lDLGNBQWMsSUFBSUM7QUFDeEIsTUFBTUMsa0JBQWtCdHhCLEtBQUs7SUFDM0IzRCxPQUFPO0lBQ1A4TixhQUFhO0FBQ2Y7QUFDQSxNQUFNb25CLGtCQUFrQmgxQixvQ0FBb0M7SUFDMURDO1FBQ0UsT0FBTztJQUNUO0lBQ0FDO1FBQ0UsT0FBTztJQUNUO0lBQ0FDLE9BQU16SSxLQUFLO1FBQ1QsSUFBSUEsVUFBVTVGLFdBQVcsT0FBTztRQUNoQyxJQUFJLE9BQU80RixVQUFVLFVBQVU7WUFDN0IsTUFBTSxJQUFJK0gsZUFBZTtRQUMzQjtRQUNBLE9BQU8vSDtJQUNUO0lBQ0EySSxVQUFTM0ksS0FBSztRQUNaLE9BQU9BO0lBQ1Q7SUFDQTBJLFdBQVUxSSxLQUFLO1FBQ2IsT0FBTztZQUNMQTtRQUNGO0lBQ0Y7QUFDRjtBQUNBLFNBQVN1OUIsMEJBQTBCM2xDLE1BQU07SUFDdkMsSUFBSTRsQyxvQkFBb0JDLHVCQUF1QkMsd0JBQXdCQyx1QkFBdUJDLHVCQUF1QkMsd0JBQXdCQyx3QkFBd0JDLHdCQUF3QkMsd0JBQXdCQyx3QkFBd0JDLHdCQUF3QkMsd0JBQXdCQyx1QkFBdUJDLHdCQUF3QkMsdUJBQXVCQyxzQkFBc0JDLHdCQUF3QkM7SUFDalosTUFBTWp1QixhQUFhNVksT0FBTzRZLFVBQVUsS0FBSyxPQUFPO1FBQzlDLHlEQUF5RDtRQUN6RFMsWUFBWTtRQUNabUgsZUFBZTtRQUNmN0ksYUFBYTtRQUNid0IsV0FBVztRQUNYdkIsWUFBWTtJQUNkLElBQUksQ0FBQ2d1QixxQkFBcUI1bEMsT0FBTzRZLFVBQVUsTUFBTSxRQUFRZ3RCLHVCQUF1QixLQUFLLElBQUlBLHFCQUFxQixDQUFDO0lBQy9HLE1BQU1rQixlQUFlOW1DLE9BQU8rWSxNQUFNLEtBQUssT0FBTyxDQUFDLElBQUkvWSxPQUFPK1ksTUFBTTtJQUNoRSxPQUFPO1FBQ0xILFlBQVk7WUFDVlcsV0FBV1gsV0FBV1csU0FBUyxLQUFLLE9BQU87Z0JBQ3pDQyxRQUFRO2dCQUNSZixLQUFLO1lBQ1AsSUFBSTtnQkFDRmUsUUFBUSxDQUFDLENBQUUsRUFBQ3FzQix3QkFBd0JqdEIsV0FBV1csU0FBUyxNQUFNLFFBQVFzc0IsMEJBQTBCLEtBQUssS0FBS0Esc0JBQXNCcnNCLE1BQU07Z0JBQ3RJZixLQUFLLENBQUMsQ0FBRSxFQUFDcXRCLHlCQUF5Qmx0QixXQUFXVyxTQUFTLE1BQU0sUUFBUXVzQiwyQkFBMkIsS0FBSyxLQUFLQSx1QkFBdUJydEIsR0FBRztZQUNySTtZQUNBWSxZQUFZLENBQUNULGVBQWUsUUFBUUEsZUFBZSxLQUFLLElBQUksS0FBSyxJQUFJQSxXQUFXUyxVQUFVLE1BQU0sT0FBTztnQkFDckdDLFlBQVk7Z0JBQ1pwRSxNQUFNO29CQUNKclUsUUFBUXVMLE9BQU8sQ0FBQztnQkFDbEI7WUFDRixJQUFJO2dCQUNGa04sWUFBWSxDQUFDLENBQUUsRUFBQ3lzQix3QkFBd0JudEIsV0FBV1MsVUFBVSxNQUFNLFFBQVEwc0IsMEJBQTBCLEtBQUssS0FBS0Esc0JBQXNCenNCLFVBQVU7Z0JBQy9JcEUsTUFBTSxDQUFDNnhCLENBQUFBO29CQUNMLElBQUksQ0FBQyxDQUFDQSx5QkFBeUJudUIsV0FBV1MsVUFBVSxNQUFNLFFBQVEwdEIsMkJBQTJCLEtBQUssSUFBSSxLQUFLLElBQUlBLHVCQUF1Qjd4QixJQUFJLE1BQU0xUyxXQUFXO3dCQUN6SixPQUFPO29CQUNUO29CQUNBLElBQUlvVyxXQUFXUyxVQUFVLENBQUNuRSxJQUFJLEtBQUssUUFBUSxDQUFDMEQsV0FBV1MsVUFBVSxDQUFDbkUsSUFBSSxDQUFDclUsTUFBTSxFQUFFO3dCQUM3RSxPQUFPOzRCQUNMQSxRQUFRdUwsT0FBTyxDQUFDO3dCQUNsQjtvQkFDRjtvQkFDQSxLQUFLLE1BQU14SixPQUFPO3dCQUFDO3dCQUFRO3dCQUFZO3FCQUFXLENBQUU7d0JBQ2xELElBQUlBLE9BQU9nVyxXQUFXUyxVQUFVLENBQUNuRSxJQUFJLENBQUNyVSxNQUFNLEVBQUU7NEJBQzVDLE1BQU0sSUFBSVAsTUFBTSxDQUFDLENBQUMsRUFBRXNDLElBQUksK0NBQStDLENBQUM7d0JBQzFFO29CQUNGO29CQUNBLE9BQU87d0JBQ0wvQixRQUFRdUwsT0FBT3dNLFdBQVdTLFVBQVUsQ0FBQ25FLElBQUksQ0FBQ3JVLE1BQU07b0JBQ2xEO2dCQUNGO1lBQ0Y7WUFDQW9ZLFVBQVUsQ0FBQyt0QixDQUFBQTtnQkFDVCxNQUFNQyxNQUFNcnVCLGVBQWUsUUFBUUEsZUFBZSxLQUFLLElBQUksS0FBSyxJQUFJQSxXQUFXNEgsYUFBYTtnQkFDNUYsTUFBTXhULE1BQU0sT0FBT2k2QixRQUFRLFlBQVksWUFBWUEsTUFBTUEsTUFBTTtvQkFDN0QvdEIsUUFBUSt0QjtvQkFDUnBtQyxRQUFRMkI7Z0JBQ1Y7Z0JBQ0EsSUFBSXdLLElBQUluTSxNQUFNLEVBQUU7b0JBQ2QsS0FBSyxNQUFNK0IsT0FBTzt3QkFBQzt3QkFBUTt3QkFBWTt3QkFBUztxQkFBWSxDQUFFO3dCQUM1RCxJQUFJQSxPQUFPb0ssSUFBSW5NLE1BQU0sRUFBRTs0QkFDckIsTUFBTSxJQUFJUCxNQUFNLENBQUMsQ0FBQyxFQUFFc0MsSUFBSSw0Q0FBNEMsQ0FBQzt3QkFDdkU7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0EsT0FBTztvQkFDTHNXLFFBQVE7MkJBQUksSUFBSTFQLElBQUl3RCxJQUFJa00sTUFBTSxLQUFLLE9BQU87NEJBQUM7NEJBQUc7NEJBQUc7NEJBQUc7NEJBQUc7NEJBQUc7eUJBQUUsR0FBR2xNLElBQUlrTSxNQUFNO3FCQUFFO29CQUMzRXJZLFFBQVF1TCxPQUFPLENBQUM0NkIsY0FBY2g2QixJQUFJbk0sTUFBTSxNQUFNLFFBQVFtbUMsZ0JBQWdCLEtBQUssSUFBSUEsY0FBYyxDQUFDO2dCQUNoRztZQUNGO1lBQ0FydkIsYUFBYWlCLFdBQVdqQixXQUFXLEtBQUssT0FBTztnQkFDN0NpRSxNQUFNO2dCQUNOMUcsTUFBTTtnQkFDTjJHLFFBQVE7Z0JBQ1JFLFVBQVU7Z0JBQ1YscUNBQXFDO2dCQUNyQ0MsZUFBZTtnQkFDZkMsV0FBVztnQkFDWCxxQ0FBcUM7Z0JBQ3JDQyxhQUFhO2dCQUNiLHFDQUFxQztnQkFDckNKLFdBQVcsTUFBTSxxQ0FBcUM7WUFDeEQsSUFBSTtnQkFDRkYsTUFBTSxDQUFDLENBQUUsRUFBQ29xQix3QkFBd0JwdEIsV0FBV2pCLFdBQVcsTUFBTSxRQUFRcXVCLDBCQUEwQixLQUFLLEtBQUtBLHNCQUFzQnBxQixJQUFJO2dCQUNwSTFHLE1BQU0sQ0FBQyxDQUFFLEVBQUMrd0IseUJBQXlCcnRCLFdBQVdqQixXQUFXLE1BQU0sUUFBUXN1QiwyQkFBMkIsS0FBSyxLQUFLQSx1QkFBdUIvd0IsSUFBSTtnQkFDdkkyRyxRQUFRLENBQUMsQ0FBRSxFQUFDcXFCLHlCQUF5QnR0QixXQUFXakIsV0FBVyxNQUFNLFFBQVF1dUIsMkJBQTJCLEtBQUssS0FBS0EsdUJBQXVCcnFCLE1BQU07Z0JBQzNJRyxlQUFlLENBQUMsQ0FBRSxFQUFDbXFCLHlCQUF5QnZ0QixXQUFXakIsV0FBVyxNQUFNLFFBQVF3dUIsMkJBQTJCLEtBQUssS0FBS0EsdUJBQXVCbnFCLGFBQWE7Z0JBQ3pKRixXQUFXLENBQUMsQ0FBRSxFQUFDc3FCLHlCQUF5Qnh0QixXQUFXakIsV0FBVyxNQUFNLFFBQVF5dUIsMkJBQTJCLEtBQUssS0FBS0EsdUJBQXVCdHFCLFNBQVM7Z0JBQ2pKQyxVQUFVLENBQUMsQ0FBRSxFQUFDc3FCLHlCQUF5Qnp0QixXQUFXakIsV0FBVyxNQUFNLFFBQVEwdUIsMkJBQTJCLEtBQUssS0FBS0EsdUJBQXVCdHFCLFFBQVE7Z0JBQy9JRSxXQUFXLENBQUMsQ0FBRSxFQUFDcXFCLHlCQUF5QjF0QixXQUFXakIsV0FBVyxNQUFNLFFBQVEydUIsMkJBQTJCLEtBQUssS0FBS0EsdUJBQXVCcnFCLFNBQVM7Z0JBQ2pKQyxhQUFhLENBQUMsQ0FBRSxFQUFDcXFCLHlCQUF5QjN0QixXQUFXakIsV0FBVyxNQUFNLFFBQVE0dUIsMkJBQTJCLEtBQUssS0FBS0EsdUJBQXVCcnFCLFdBQVc7WUFDdko7WUFDQS9DLFdBQVdQLFdBQVdPLFNBQVMsS0FBSyxPQUFPO2dCQUN6Q2hELFNBQVM7Z0JBQ1RpRCxXQUFXO1lBQ2IsSUFBSTtnQkFDRmpELFNBQVMsQ0FBQyxDQUFFLEVBQUNxd0Isd0JBQXdCNXRCLFdBQVdPLFNBQVMsTUFBTSxRQUFRcXRCLDBCQUEwQixLQUFLLEtBQUtBLHNCQUFzQnJ3QixPQUFPO2dCQUN4SWlELFdBQVcsQ0FBQyxDQUFFLEVBQUNxdEIseUJBQXlCN3RCLFdBQVdPLFNBQVMsTUFBTSxRQUFRc3RCLDJCQUEyQixLQUFLLEtBQUtBLHVCQUF1QnJ0QixTQUFTO1lBQ2pKO1lBQ0F4QixZQUFZLENBQUMsQ0FBQ2dCLFdBQVdoQixVQUFVO1FBQ3JDO1FBQ0FXLE9BQU8sQ0FBQyxDQUFDdlksT0FBT3VZLEtBQUs7UUFDckJPLFNBQVM7ZUFBSSxJQUFJdFAsSUFBSSxDQUFDeEosT0FBTzhZLE9BQU8sSUFBSSxFQUFFLEVBQUVsVCxHQUFHLENBQUNzQyxDQUFBQSxJQUFLeUgsS0FBS0MsU0FBUyxDQUFDMUg7U0FBSyxDQUFDdEMsR0FBRyxDQUFDc0MsQ0FBQUEsSUFBS3lILEtBQUtrQixLQUFLLENBQUMzSTtRQUM5RjJRLFVBQVUsQ0FBQyxDQUFDN1ksT0FBTzZZLFFBQVE7UUFDM0JFLFFBQVErdEIsaUJBQWlCdGtDLFlBQVksUUFBUTtZQUMzQyxHQUFHc2tDLFlBQVk7WUFDZmptQyxRQUFRO2dCQUNONlYsS0FBSyxDQUFDZ3dCLHdCQUF3QixDQUFDQyx1QkFBdUJHLGFBQWFqbUMsTUFBTSxNQUFNLFFBQVE4bEMseUJBQXlCLEtBQUssSUFBSSxLQUFLLElBQUlBLHFCQUFxQmp3QixHQUFHLE1BQU0sUUFBUWd3QiwwQkFBMEIsS0FBSyxJQUFJQSx3QkFBd0JqQjtnQkFDbk85dUIsT0FBTyxDQUFDaXdCLHlCQUF5QixDQUFDQyx3QkFBd0JDLGFBQWFqbUMsTUFBTSxNQUFNLFFBQVFnbUMsMEJBQTBCLEtBQUssSUFBSSxLQUFLLElBQUlBLHNCQUFzQmx3QixLQUFLLE1BQU0sUUFBUWl3QiwyQkFBMkIsS0FBSyxJQUFJQSx5QkFBeUJsQjtZQUMvTztRQUNGO1FBQ0Exc0IsUUFBUSxDQUFDLENBQUNoWixPQUFPZ1osTUFBTTtJQUN6QjtBQUNGO0FBQ0EsU0FBU2t1QixXQUFXLEVBQ2xCMTJCLEtBQUssRUFDTHNGLGtCQUFrQixDQUFDLENBQUMsRUFDcEJ3SSxXQUFXLEVBQ1gsR0FBRzZvQix3QkFDSjtJQUNDLE1BQU14dEIsbUJBQW1CZ3NCLDBCQUEwQndCO0lBQ25ELE1BQU10MkIsUUFBUTdLLENBQUFBLE9BQVEsQ0FBQzJZLFFBQVF0YztZQUM3QixNQUFNK2tDLFVBQVU3QixZQUFZOEIsTUFBTSxDQUFDaGxDLEtBQUtZLE9BQU87WUFDL0MsTUFBTXdoQixZQUFXNU8sWUFBWTFYLDZEQUFhLENBQUNpcEMsVUFBVXR4QjtZQUNyRCxNQUFNNEIsU0FBUzhzQixxQ0FBcUM3cUIsa0JBQWtCN0Q7WUFDdEU0QixPQUFPblQsUUFBUSxHQUFHa2dCO1lBQ2xCaG1CLHlDQUFNQSxDQUFDNm9DLFNBQVMsQ0FBQzV2QixRQUFRO2dCQUN2QjZ2QixPQUFPO1lBQ1Q7WUFDQSxPQUFPdHRCLGlCQUFpQnZDLE9BQU9uVCxRQUFRLEVBQUV1UixpQkFBaUJ6VCxLQUFLNlksS0FBSyxFQUFFN1ksS0FBSzhZLFFBQVEsSUFBSSxJQUFJeFcsT0FBT3FCLE1BQU0yVCxrQkFBa0J0WCxLQUFLaEIsSUFBSTtRQUNySTtJQUNBLE9BQU87UUFDTHFCLE1BQU07UUFDTkMsVUFBVTtRQUNWaU87WUFDRSxPQUFPO2dCQUFDO29CQUNObkosTUFBTTtvQkFDTmxELFVBQVU7d0JBQUM7NEJBQ1Q0UCxNQUFNO3dCQUNSO3FCQUFFO2dCQUNKO2FBQUU7UUFDSjtRQUNBeEQsT0FBTXFHLEtBQUs7WUFDVCxPQUFPLFdBQVcsR0FBRXZYLHNEQUFHQSxDQUFDRCxnRkFBa0JBLEVBQUU7Z0JBQzFDc1csaUJBQWlCQTtnQkFDakJ3SSxhQUFhQTtnQkFDYjlOLE9BQU9BO2dCQUNQbUosa0JBQWtCQTtnQkFDbEIsR0FBRzNDLEtBQUs7WUFDVjtRQUNGO1FBQ0FuRyxPQUFPQSxNQUFNO1FBQ2J6TyxrQkFBa0I7UUFDbEIyTyxVQUFTM0ksS0FBSztZQUNaLE9BQU9BO1FBQ1Q7UUFDQVcsYUFBYTtlQUFJUSwrQkFBK0I2QyxPQUFPaEQsT0FBTzhKLFdBQVcsQ0FBQzlKLE9BQU96RCxPQUFPLENBQUNtUSxpQkFBaUJsUSxHQUFHLENBQUMsQ0FBQyxDQUFDQyxNQUFNMnpCLE1BQU0sR0FBSztvQkFBQzN6QjtvQkFBTXVHLE9BQU9vdEIsTUFBTTM0QixNQUFNO2lCQUFFO2VBQVUsT0FBTzhZLGlCQUFpQlosTUFBTSxLQUFLLFlBQVksT0FBT1ksaUJBQWlCWixNQUFNLENBQUM1UCxTQUFTLEtBQUssV0FBVztnQkFBQ3hKLFFBQVFnYSxpQkFBaUJaLE1BQU0sQ0FBQzVQLFNBQVM7YUFBRSxHQUFHLEVBQUU7U0FBRTtRQUNqVTJILFdBQVUxSSxLQUFLLEVBQUVpRSxJQUFJO1lBQ25CLE1BQU0sRUFDSjBPLFVBQVUsRUFDVjVXLElBQUksRUFDTCxHQUFHa1ksa0JBQWtCalUsT0FBTztnQkFDM0IwTjtnQkFDQTZEO2dCQUNBdFksTUFBTWdMLEtBQUtoTCxJQUFJO1lBQ2pCO1lBQ0EsTUFBTTZaLFFBQVEsSUFBSXZXO1lBQ2xCLE1BQU13VyxXQUFXLElBQUl4VztZQUNyQixLQUFLLE1BQU02aUMsUUFBUXpzQixXQUFZO2dCQUM3QixJQUFJeXNCLEtBQUtqd0IsTUFBTSxLQUFLL1UsV0FBVztvQkFDN0IwWSxNQUFNcFgsR0FBRyxDQUFDMGpDLEtBQUs1bkMsSUFBSSxFQUFFNG5DLEtBQUtqa0MsUUFBUTtvQkFDbEM7Z0JBQ0Y7Z0JBQ0EsSUFBSSxDQUFDNFgsU0FBU3pXLEdBQUcsQ0FBQzhpQyxLQUFLandCLE1BQU0sR0FBRztvQkFDOUI0RCxTQUFTclgsR0FBRyxDQUFDMGpDLEtBQUtqd0IsTUFBTSxFQUFFLElBQUk1UztnQkFDaEM7Z0JBQ0F3VyxTQUFTL1csR0FBRyxDQUFDb2pDLEtBQUtqd0IsTUFBTSxFQUFFelQsR0FBRyxDQUFDMGpDLEtBQUs1bkMsSUFBSSxFQUFFNG5DLEtBQUtqa0MsUUFBUTtZQUN4RDtZQUNBLE9BQU87Z0JBQ0xOLFNBQVNxaUMsWUFBWTdoQyxNQUFNLENBQUN0Riw4REFBYyxDQUFDQSw2REFBYSxDQUFDQSw4REFBYyxDQUFDZ0c7Z0JBQ3hFK1c7Z0JBQ0FDO2dCQUNBL1MsT0FBTzVGO1lBQ1Q7UUFDRjtRQUNBd08sUUFBUTtZQUNOSCxPQUFPQSxNQUFNO1FBQ2Y7SUFDRjtBQUNGO0FBRXdpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2tleXN0YXRpYy1zdGFydGVyLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Aa2V5c3RhdGljK2NvcmVAMC4xLjdfbmV4dEAxMy41LjZfcmVhY3QtZG9tQDE4LjIuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL0BrZXlzdGF0aWMvY29yZS9kaXN0L2luZGV4LWIwZWVlOTIzLm5vZGUucmVhY3Qtc2VydmVyLmVzbS5qcz9hOGIzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBNYXJrZG9jLCB7IEFzdCB9IGZyb20gJ0BtYXJrZG9jL21hcmtkb2MnO1xuaW1wb3J0IHsgVGV4dCwgRWxlbWVudCBhcyBFbGVtZW50JDEsIFRyYW5zZm9ybXMsIEVkaXRvciwgTm9kZSwgUGF0aCwgUmFuZ2UsIFBvaW50LCBjcmVhdGVFZGl0b3IgfSBmcm9tICdzbGF0ZSc7XG5pbXBvcnQgeyBhc3NlcnROZXZlciBhcyBhc3NlcnROZXZlciQxLCBhc3NlcnQgYXMgYXNzZXJ0JDEgfSBmcm9tICdlbWVyeS9hc3NlcnRpb25zJztcbmltcG9ydCB7IGFzc2VydCwgYXNzZXJ0TmV2ZXIgfSBmcm9tICdlbWVyeSc7XG5pbXBvcnQgeyBmcm9tVWludDhBcnJheSB9IGZyb20gJ2pzLWJhc2U2NCc7XG5pbXBvcnQgeyBjcmVhdGVIYXNoIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IFQgYXMgVGV4dEZpZWxkSW5wdXQsIEQgYXMgRG9jdW1lbnRGaWVsZElucHV0IH0gZnJvbSAnLi9lbXB0eS1maWVsZC11aS01YjA4ZWUwNy5ub2RlLnJlYWN0LXNlcnZlci5lc20uanMnO1xuaW1wb3J0IHsganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHdlYWtNZW1vaXplIGZyb20gJ0BlbW90aW9uL3dlYWstbWVtb2l6ZSc7XG5cbmZ1bmN0aW9uIGZpeFBhdGgocGF0aCkge1xuICByZXR1cm4gcGF0aC5yZXBsYWNlKC9eXFwuP1xcLysvLCAnJykucmVwbGFjZSgvXFwvKiQvLCAnJyk7XG59XG5jb25zdCBjb2xsZWN0aW9uUGF0aCA9IC9cXC9cXCpcXCo/KD86JHxcXC8pLztcbmZ1bmN0aW9uIGdldENvbmZpZ3VyZWRDb2xsZWN0aW9uUGF0aChjb25maWcsIGNvbGxlY3Rpb24pIHtcbiAgdmFyIF9jb2xsZWN0aW9uQ29uZmlnJHBhdDtcbiAgY29uc3QgY29sbGVjdGlvbkNvbmZpZyA9IGNvbmZpZy5jb2xsZWN0aW9uc1tjb2xsZWN0aW9uXTtcbiAgY29uc3QgcGF0aCA9IChfY29sbGVjdGlvbkNvbmZpZyRwYXQgPSBjb2xsZWN0aW9uQ29uZmlnLnBhdGgpICE9PSBudWxsICYmIF9jb2xsZWN0aW9uQ29uZmlnJHBhdCAhPT0gdm9pZCAwID8gX2NvbGxlY3Rpb25Db25maWckcGF0IDogYCR7Y29sbGVjdGlvbn0vKi9gO1xuICBpZiAoIWNvbGxlY3Rpb25QYXRoLnRlc3QocGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvbGxlY3Rpb24gcGF0aCBtdXN0IGVuZCB3aXRoIC8qIG9yIC8qKiBvciBpbmNsdWRlIC8qLyBvciAvKiovIGJ1dCAke2NvbGxlY3Rpb259IGhhcyAke3BhdGh9YCk7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5mdW5jdGlvbiBnZXRDb2xsZWN0aW9uUGF0aChjb25maWcsIGNvbGxlY3Rpb24pIHtcbiAgY29uc3QgY29uZmlndXJlZFBhdGggPSBnZXRDb25maWd1cmVkQ29sbGVjdGlvblBhdGgoY29uZmlnLCBjb2xsZWN0aW9uKTtcbiAgY29uc3QgcGF0aCA9IGZpeFBhdGgoY29uZmlndXJlZFBhdGgucmVwbGFjZSgvXFwqXFwqPy4qJC8sICcnKSk7XG4gIHJldHVybiBwYXRoO1xufVxuZnVuY3Rpb24gZ2V0Q29sbGVjdGlvbkZvcm1hdChjb25maWcsIGNvbGxlY3Rpb24pIHtcbiAgdmFyIF9jb2xsZWN0aW9uQ29uZmlnJGZvcjtcbiAgY29uc3QgY29sbGVjdGlvbkNvbmZpZyA9IGNvbmZpZy5jb2xsZWN0aW9uc1tjb2xsZWN0aW9uXTtcbiAgcmV0dXJuIGdldEZvcm1hdEluZm8oKF9jb2xsZWN0aW9uQ29uZmlnJGZvciA9IGNvbGxlY3Rpb25Db25maWcuZm9ybWF0KSAhPT0gbnVsbCAmJiBfY29sbGVjdGlvbkNvbmZpZyRmb3IgIT09IHZvaWQgMCA/IF9jb2xsZWN0aW9uQ29uZmlnJGZvciA6ICd5YW1sJywgY29sbGVjdGlvbkNvbmZpZy5zY2hlbWEsIGdldENvbmZpZ3VyZWRDb2xsZWN0aW9uUGF0aChjb25maWcsIGNvbGxlY3Rpb24pKTtcbn1cbmZ1bmN0aW9uIGdldFNpbmdsZXRvbkZvcm1hdChjb25maWcsIHNpbmdsZXRvbikge1xuICB2YXIgX3NpbmdsZXRvbkNvbmZpZyRmb3JtLCBfc2luZ2xldG9uQ29uZmlnJHBhdGg7XG4gIGNvbnN0IHNpbmdsZXRvbkNvbmZpZyA9IGNvbmZpZy5zaW5nbGV0b25zW3NpbmdsZXRvbl07XG4gIHJldHVybiBnZXRGb3JtYXRJbmZvKChfc2luZ2xldG9uQ29uZmlnJGZvcm0gPSBzaW5nbGV0b25Db25maWcuZm9ybWF0KSAhPT0gbnVsbCAmJiBfc2luZ2xldG9uQ29uZmlnJGZvcm0gIT09IHZvaWQgMCA/IF9zaW5nbGV0b25Db25maWckZm9ybSA6ICd5YW1sJywgc2luZ2xldG9uQ29uZmlnLnNjaGVtYSwgKF9zaW5nbGV0b25Db25maWckcGF0aCA9IHNpbmdsZXRvbkNvbmZpZy5wYXRoKSAhPT0gbnVsbCAmJiBfc2luZ2xldG9uQ29uZmlnJHBhdGggIT09IHZvaWQgMCA/IF9zaW5nbGV0b25Db25maWckcGF0aCA6IGAke3NpbmdsZXRvbn0vYCk7XG59XG5mdW5jdGlvbiBnZXRDb2xsZWN0aW9uSXRlbVBhdGgoY29uZmlnLCBjb2xsZWN0aW9uLCBzbHVnKSB7XG4gIGNvbnN0IGJhc2VQYXRoID0gZ2V0Q29sbGVjdGlvblBhdGgoY29uZmlnLCBjb2xsZWN0aW9uKTtcbiAgY29uc3Qgc3VmZml4ID0gZ2V0Q29sbGVjdGlvbkl0ZW1TbHVnU3VmZml4KGNvbmZpZywgY29sbGVjdGlvbik7XG4gIHJldHVybiBgJHtiYXNlUGF0aH0vJHtzbHVnfSR7c3VmZml4fWA7XG59XG5mdW5jdGlvbiBnZXRFbnRyeURhdGFGaWxlcGF0aChkaXIsIGZvcm1hdEluZm8pIHtcbiAgcmV0dXJuIGAke2Rpcn0ke2Zvcm1hdEluZm8uZGF0YUxvY2F0aW9uID09PSAnaW5kZXgnID8gJy9pbmRleCcgOiAnJ30ke2dldERhdGFGaWxlRXh0ZW5zaW9uKGZvcm1hdEluZm8pfWA7XG59XG5mdW5jdGlvbiBnZXRTbHVnR2xvYkZvckNvbGxlY3Rpb24oY29uZmlnLCBjb2xsZWN0aW9uKSB7XG4gIGNvbnN0IGNvbGxlY3Rpb25QYXRoID0gZ2V0Q29uZmlndXJlZENvbGxlY3Rpb25QYXRoKGNvbmZpZywgY29sbGVjdGlvbik7XG4gIHJldHVybiBjb2xsZWN0aW9uUGF0aC5pbmNsdWRlcygnKionKSA/ICcqKicgOiAnKic7XG59XG5mdW5jdGlvbiBnZXRDb2xsZWN0aW9uSXRlbVNsdWdTdWZmaXgoY29uZmlnLCBjb2xsZWN0aW9uKSB7XG4gIGNvbnN0IGNvbmZpZ3VyZWRQYXRoID0gZ2V0Q29uZmlndXJlZENvbGxlY3Rpb25QYXRoKGNvbmZpZywgY29sbGVjdGlvbik7XG4gIGNvbnN0IHBhdGggPSBmaXhQYXRoKGNvbmZpZ3VyZWRQYXRoLnJlcGxhY2UoL15bXipdK1xcKlxcKj8vLCAnJykpO1xuICByZXR1cm4gcGF0aCA/IGAvJHtwYXRofWAgOiAnJztcbn1cbmZ1bmN0aW9uIGdldFNpbmdsZXRvblBhdGgoY29uZmlnLCBzaW5nbGV0b24pIHtcbiAgdmFyIF9zaW5nbGV0b24kcGF0aCwgX3NpbmdsZXRvbiRwYXRoMjtcbiAgaWYgKChfc2luZ2xldG9uJHBhdGggPSBjb25maWcuc2luZ2xldG9uc1tzaW5nbGV0b25dLnBhdGgpICE9PSBudWxsICYmIF9zaW5nbGV0b24kcGF0aCAhPT0gdm9pZCAwICYmIF9zaW5nbGV0b24kcGF0aC5pbmNsdWRlcygnKicpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBTaW5nbGV0b24gcGF0aHMgY2Fubm90IGluY2x1ZGUgKiBidXQgJHtzaW5nbGV0b259IGhhcyAke2NvbmZpZy5zaW5nbGV0b25zW3NpbmdsZXRvbl0ucGF0aH1gKTtcbiAgfVxuICByZXR1cm4gZml4UGF0aCgoX3NpbmdsZXRvbiRwYXRoMiA9IGNvbmZpZy5zaW5nbGV0b25zW3NpbmdsZXRvbl0ucGF0aCkgIT09IG51bGwgJiYgX3NpbmdsZXRvbiRwYXRoMiAhPT0gdm9pZCAwID8gX3NpbmdsZXRvbiRwYXRoMiA6IHNpbmdsZXRvbik7XG59XG5mdW5jdGlvbiBnZXREYXRhRmlsZUV4dGVuc2lvbihmb3JtYXRJbmZvKSB7XG4gIHJldHVybiBmb3JtYXRJbmZvLmNvbnRlbnRGaWVsZCA/IGZvcm1hdEluZm8uY29udGVudEZpZWxkLmNvbmZpZy5jb250ZW50RXh0ZW5zaW9uIDogJy4nICsgZm9ybWF0SW5mby5kYXRhO1xufVxuZnVuY3Rpb24gZ2V0Rm9ybWF0SW5mbyhmb3JtYXQsIHNjaGVtYSwgcGF0aCkge1xuICB2YXIgX2Zvcm1hdCRkYXRhO1xuICBjb25zdCBkYXRhTG9jYXRpb24gPSBwYXRoLmVuZHNXaXRoKCcvJykgPyAnaW5kZXgnIDogJ291dGVyJztcbiAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGFMb2NhdGlvbixcbiAgICAgIGNvbnRlbnRGaWVsZDogdW5kZWZpbmVkLFxuICAgICAgZGF0YTogZm9ybWF0XG4gICAgfTtcbiAgfVxuICBsZXQgY29udGVudEZpZWxkO1xuICBpZiAoZm9ybWF0LmNvbnRlbnRGaWVsZCkge1xuICAgIGNvbnN0IGZpZWxkID0gc2NoZW1hW2Zvcm1hdC5jb250ZW50RmllbGRdO1xuICAgIGFzc2VydCgoZmllbGQgPT09IG51bGwgfHwgZmllbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpZWxkLmtpbmQpID09PSAnZm9ybScsIGAke2Zvcm1hdC5jb250ZW50RmllbGR9IGlzIG5vdCBhIGZvcm0gZmllbGRgKTtcbiAgICBhc3NlcnQoZmllbGQuZm9ybUtpbmQgPT09ICdjb250ZW50JywgYCR7Zm9ybWF0LmNvbnRlbnRGaWVsZH0gaXMgbm90IGEgY29udGVudCBmaWVsZGApO1xuICAgIGNvbnRlbnRGaWVsZCA9IHtcbiAgICAgIGtleTogZm9ybWF0LmNvbnRlbnRGaWVsZCxcbiAgICAgIGNvbmZpZzogZmllbGRcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgZGF0YTogKF9mb3JtYXQkZGF0YSA9IGZvcm1hdC5kYXRhKSAhPT0gbnVsbCAmJiBfZm9ybWF0JGRhdGEgIT09IHZvaWQgMCA/IF9mb3JtYXQkZGF0YSA6ICd5YW1sJyxcbiAgICBjb250ZW50RmllbGQsXG4gICAgZGF0YUxvY2F0aW9uXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYXRoUHJlZml4KHN0b3JhZ2UpIHtcbiAgaWYgKHN0b3JhZ2Uua2luZCA9PT0gJ2xvY2FsJyB8fCAhc3RvcmFnZS5wYXRoUHJlZml4KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gZml4UGF0aChzdG9yYWdlLnBhdGhQcmVmaXgpICsgJy8nO1xufVxuXG5hc3luYyBmdW5jdGlvbiBzaGExKGNvbnRlbnQpIHtcbiAgcmV0dXJuIGNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoY29udGVudCkuZGlnZXN0KCdoZXgnKTtcbn1cblxuY29uc3QgdGV4dEVuY29kZXIkMiA9IG5ldyBUZXh0RW5jb2RlcigpO1xuZnVuY3Rpb24gYmxvYlNoYShjb250ZW50cykge1xuICBjb25zdCBibG9iUHJlZml4ID0gdGV4dEVuY29kZXIkMi5lbmNvZGUoJ2Jsb2IgJyArIGNvbnRlbnRzLmxlbmd0aCArICdcXDAnKTtcbiAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShibG9iUHJlZml4LmJ5dGVMZW5ndGggKyBjb250ZW50cy5ieXRlTGVuZ3RoKTtcbiAgYXJyYXkuc2V0KGJsb2JQcmVmaXgsIDApO1xuICBhcnJheS5zZXQoY29udGVudHMsIGJsb2JQcmVmaXguYnl0ZUxlbmd0aCk7XG4gIHJldHVybiBzaGExKGFycmF5KTtcbn1cbmZ1bmN0aW9uIGdldFRyZWVOb2RlQXRQYXRoKHJvb3QsIHBhdGgpIHtcbiAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XG4gIGxldCBub2RlID0gcm9vdC5nZXQocGFydHNbMF0pO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMuc2xpY2UoMSkpIHtcbiAgICBpZiAoIW5vZGUpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKCFub2RlLmNoaWxkcmVuKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuLmdldChwYXJ0KTtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGdldE5vZGVBdFBhdGgodHJlZSwgcGF0aCkge1xuICBsZXQgbm9kZSA9IHRyZWU7XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXRoLnNwbGl0KCcvJykpIHtcbiAgICBpZiAoIW5vZGUuaGFzKHBhcnQpKSB7XG4gICAgICBub2RlLnNldChwYXJ0LCBuZXcgTWFwKCkpO1xuICAgIH1cbiAgICBjb25zdCBpbm5lck5vZGUgPSBub2RlLmdldChwYXJ0KTtcbiAgICBhc3NlcnQoaW5uZXJOb2RlIGluc3RhbmNlb2YgTWFwLCAnZXhwZWN0ZWQgdHJlZScpO1xuICAgIG5vZGUgPSBpbm5lck5vZGU7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBnZXRGaWxlbmFtZShwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlcGxhY2UoLy4qXFwvLywgJycpO1xufVxuZnVuY3Rpb24gZ2V0RGlybmFtZShwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlcGxhY2UoL1xcL1teL10rJC8sICcnKTtcbn1cbmZ1bmN0aW9uIHRvVHJlZUNoYW5nZXMoY2hhbmdlcykge1xuICBjb25zdCBjaGFuZ2VzUm9vdCA9IG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBkZWxldGlvbiBvZiBjaGFuZ2VzLmRlbGV0aW9ucykge1xuICAgIGNvbnN0IHBhcmVudFRyZWUgPSBnZXROb2RlQXRQYXRoKGNoYW5nZXNSb290LCBnZXREaXJuYW1lKGRlbGV0aW9uKSk7XG4gICAgcGFyZW50VHJlZS5zZXQoZ2V0RmlsZW5hbWUoZGVsZXRpb24pLCAnZGVsZXRlJyk7XG4gIH1cbiAgZm9yIChjb25zdCBhZGRpdGlvbiBvZiBjaGFuZ2VzLmFkZGl0aW9ucykge1xuICAgIGNvbnN0IHBhcmVudFRyZWUgPSBnZXROb2RlQXRQYXRoKGNoYW5nZXNSb290LCBnZXREaXJuYW1lKGFkZGl0aW9uLnBhdGgpKTtcbiAgICBwYXJlbnRUcmVlLnNldChnZXRGaWxlbmFtZShhZGRpdGlvbi5wYXRoKSwgYWRkaXRpb24uY29udGVudHMpO1xuICB9XG4gIHJldHVybiBjaGFuZ2VzUm9vdDtcbn1cbmNvbnN0IFNQQUNFX0NIQVJfQ09ERSA9IDMyO1xuY29uc3Qgc3BhY2UgPSBuZXcgVWludDhBcnJheShbU1BBQ0VfQ0hBUl9DT0RFXSk7XG5jb25zdCBudWxsY2hhciA9IG5ldyBVaW50OEFycmF5KFswXSk7XG5jb25zdCB0cmVlID0gdGV4dEVuY29kZXIkMi5lbmNvZGUoJ3RyZWUgJyk7XG5cbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9pc29tb3JwaGljLWdpdC9pc29tb3JwaGljLWdpdC9ibG9iL2MwOWRmYTIwZmZlMGFiOWU2NjAyZTBmYTE3MmQ3MmJhODk5NGU0NDMvc3JjL21vZGVscy9HaXRUcmVlLmpzI0wxMDgtTDEyMlxuZnVuY3Rpb24gdHJlZVNoYShjaGlsZHJlbikge1xuICBjb25zdCBlbnRyaWVzID0gWy4uLmNoaWxkcmVuXS5tYXAoKFtuYW1lLCBub2RlXSkgPT4gKHtcbiAgICBuYW1lLFxuICAgIHNoYTogbm9kZS5lbnRyeS5zaGEsXG4gICAgbW9kZTogbm9kZS5lbnRyeS5tb2RlXG4gIH0pKTtcbiAgZW50cmllcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgY29uc3QgYU5hbWUgPSBhLm1vZGUgPT09ICcwNDAwMDAnID8gYS5uYW1lICsgJy8nIDogYS5uYW1lO1xuICAgIGNvbnN0IGJOYW1lID0gYi5tb2RlID09PSAnMDQwMDAwJyA/IGIubmFtZSArICcvJyA6IGIubmFtZTtcbiAgICByZXR1cm4gYU5hbWUgPT09IGJOYW1lID8gMCA6IGFOYW1lIDwgYk5hbWUgPyAtMSA6IDE7XG4gIH0pO1xuICBjb25zdCB0cmVlT2JqZWN0ID0gZW50cmllcy5mbGF0TWFwKGVudHJ5ID0+IHtcbiAgICBjb25zdCBtb2RlID0gdGV4dEVuY29kZXIkMi5lbmNvZGUoZW50cnkubW9kZS5yZXBsYWNlKC9eMC8sICcnKSk7XG4gICAgY29uc3QgbmFtZSA9IHRleHRFbmNvZGVyJDIuZW5jb2RlKGVudHJ5Lm5hbWUpO1xuICAgIGNvbnN0IHNoYSA9IGhleFRvQnl0ZXMoZW50cnkuc2hhKTtcbiAgICByZXR1cm4gW21vZGUsIHNwYWNlLCBuYW1lLCBudWxsY2hhciwgc2hhXTtcbiAgfSk7XG4gIHJldHVybiBzaGExKGNvbmNhdEJ5dGVzKFt0cmVlLCB0ZXh0RW5jb2RlciQyLmVuY29kZSh0cmVlT2JqZWN0LnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIHZhbC5ieXRlTGVuZ3RoLCAwKS50b1N0cmluZygpKSwgbnVsbGNoYXIsIC4uLnRyZWVPYmplY3RdKSk7XG59XG5mdW5jdGlvbiBjb25jYXRCeXRlcyhieXRlQXJyYXlzKSB7XG4gIGNvbnN0IHRvdGFsTGVuZ3RoID0gYnl0ZUFycmF5cy5yZWR1Y2UoKHN1bSwgYXJyKSA9PiBzdW0gKyBhcnIuYnl0ZUxlbmd0aCwgMCk7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZvciAoY29uc3QgYXJyIG9mIGJ5dGVBcnJheXMpIHtcbiAgICByZXN1bHQuc2V0KGFyciwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYXJyLmJ5dGVMZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoc3RyKSB7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCAvIDIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmJ5dGVMZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHN0YXJ0ID0gaSAqIDI7XG4gICAgYnl0ZXNbaV0gPSBwYXJzZUludChzdHIuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgMiksIDE2KTtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVUcmVlTm9kZUVudHJ5KHBhdGgsIGNoaWxkcmVuKSB7XG4gIGNvbnN0IHNoYSA9IGF3YWl0IHRyZWVTaGEoY2hpbGRyZW4pO1xuICByZXR1cm4ge1xuICAgIHBhdGgsXG4gICAgbW9kZTogJzA0MDAwMCcsXG4gICAgdHlwZTogJ3RyZWUnLFxuICAgIHNoYVxuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlQmxvYk5vZGVFbnRyeShwYXRoLCBjb250ZW50cykge1xuICBjb25zdCBzaGEgPSAnc2hhJyBpbiBjb250ZW50cyA/IGNvbnRlbnRzLnNoYSA6IGF3YWl0IGJsb2JTaGEoY29udGVudHMpO1xuICByZXR1cm4ge1xuICAgIHBhdGgsXG4gICAgbW9kZTogJzEwMDY0NCcsXG4gICAgdHlwZTogJ2Jsb2InLFxuICAgIHNoYSxcbiAgICBzaXplOiBjb250ZW50cy5ieXRlTGVuZ3RoXG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiB1cGRhdGVUcmVlV2l0aENoYW5nZXModHJlZSwgY2hhbmdlcykge1xuICB2YXIgX2F3YWl0JHVwZGF0ZVRyZWU7XG4gIGNvbnN0IG5ld1RyZWUgPSAoX2F3YWl0JHVwZGF0ZVRyZWUgPSBhd2FpdCB1cGRhdGVUcmVlKHRyZWUsIHRvVHJlZUNoYW5nZXMoY2hhbmdlcyksIFtdKSkgIT09IG51bGwgJiYgX2F3YWl0JHVwZGF0ZVRyZWUgIT09IHZvaWQgMCA/IF9hd2FpdCR1cGRhdGVUcmVlIDogbmV3IE1hcCgpO1xuICByZXR1cm4ge1xuICAgIGVudHJpZXM6IHRyZWVUb0VudHJpZXMobmV3VHJlZSksXG4gICAgc2hhOiBhd2FpdCB0cmVlU2hhKG5ld1RyZWUgIT09IG51bGwgJiYgbmV3VHJlZSAhPT0gdm9pZCAwID8gbmV3VHJlZSA6IG5ldyBNYXAoKSlcbiAgfTtcbn1cbmZ1bmN0aW9uIHRyZWVUb0VudHJpZXModHJlZSkge1xuICByZXR1cm4gWy4uLnRyZWUudmFsdWVzKCldLmZsYXRNYXAoeCA9PiB4LmNoaWxkcmVuID8gW3guZW50cnksIC4uLnRyZWVUb0VudHJpZXMoeC5jaGlsZHJlbildIDogW3guZW50cnldKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVRyZWUodHJlZSwgY2hhbmdlZFRyZWUsIHBhdGgpIHtcbiAgY29uc3QgbmV3VHJlZSA9IG5ldyBNYXAodHJlZSk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGNoYW5nZWRUcmVlKSB7XG4gICAgaWYgKHZhbHVlID09PSAnZGVsZXRlJykge1xuICAgICAgbmV3VHJlZS5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICB2YXIgX25ld1RyZWUkZ2V0JGNoaWxkcmVuLCBfbmV3VHJlZSRnZXQ7XG4gICAgICBjb25zdCBleGlzdGluZ0NoaWxkcmVuID0gKF9uZXdUcmVlJGdldCRjaGlsZHJlbiA9IChfbmV3VHJlZSRnZXQgPSBuZXdUcmVlLmdldChrZXkpKSA9PT0gbnVsbCB8fCBfbmV3VHJlZSRnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9uZXdUcmVlJGdldC5jaGlsZHJlbikgIT09IG51bGwgJiYgX25ld1RyZWUkZ2V0JGNoaWxkcmVuICE9PSB2b2lkIDAgPyBfbmV3VHJlZSRnZXQkY2hpbGRyZW4gOiBuZXcgTWFwKCk7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGF3YWl0IHVwZGF0ZVRyZWUoZXhpc3RpbmdDaGlsZHJlbiwgdmFsdWUsIHBhdGguY29uY2F0KGtleSkpO1xuICAgICAgaWYgKGNoaWxkcmVuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VHJlZS5kZWxldGUoa2V5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBlbnRyeSA9IGF3YWl0IGNyZWF0ZVRyZWVOb2RlRW50cnkocGF0aC5jb25jYXQoa2V5KS5qb2luKCcvJyksIGNoaWxkcmVuKTtcbiAgICAgIG5ld1RyZWUuc2V0KGtleSwge1xuICAgICAgICBlbnRyeSxcbiAgICAgICAgY2hpbGRyZW5cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgJ3NoYScgaW4gdmFsdWUpIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gYXdhaXQgY3JlYXRlQmxvYk5vZGVFbnRyeShwYXRoLmNvbmNhdChrZXkpLmpvaW4oJy8nKSwgdmFsdWUpO1xuICAgICAgbmV3VHJlZS5zZXQoa2V5LCB7XG4gICAgICAgIGVudHJ5XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKG5ld1RyZWUuc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIG5ld1RyZWU7XG59XG5mdW5jdGlvbiB0cmVlRW50cmllc1RvVHJlZU5vZGVzKGVudHJpZXMpIHtcbiAgY29uc3Qgcm9vdCA9IG5ldyBNYXAoKTtcbiAgY29uc3QgZ2V0Q2hpbGRyZW5BdFBhdGggPSBwYXJ0cyA9PiB7XG4gICAgdmFyIF9ub2RlO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiByb290O1xuICAgIH1cbiAgICBsZXQgbm9kZSA9IHJvb3QuZ2V0KHBhcnRzWzBdKTtcbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMuc2xpY2UoMSkpIHtcbiAgICAgIGlmICghbm9kZSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIGlmICghbm9kZS5jaGlsZHJlbikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuLmdldChwYXJ0KTtcbiAgICB9XG4gICAgcmV0dXJuIChfbm9kZSA9IG5vZGUpID09PSBudWxsIHx8IF9ub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZS5jaGlsZHJlbjtcbiAgfTtcbiAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgY29uc3Qgc3BsaXQgPSBlbnRyeS5wYXRoLnNwbGl0KCcvJyk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbkF0UGF0aChzcGxpdC5zbGljZSgwLCAtMSkpO1xuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgY2hpbGRyZW4uc2V0KHNwbGl0W3NwbGl0Lmxlbmd0aCAtIDFdLCB7XG4gICAgICAgIGVudHJ5LFxuICAgICAgICBjaGlsZHJlbjogZW50cnkudHlwZSA9PT0gJ3RyZWUnID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJvb3Q7XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3REaXJlY3Rvcmllc1VzZWRJblNjaGVtYUlubmVyKHNjaGVtYSwgZGlyZWN0b3JpZXMsIHNlZW5TY2hlbWFzKSB7XG4gIGlmIChzZWVuU2NoZW1hcy5oYXMoc2NoZW1hKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBzZWVuU2NoZW1hcy5hZGQoc2NoZW1hKTtcbiAgaWYgKHNjaGVtYS5raW5kID09PSAnYXJyYXknKSB7XG4gICAgcmV0dXJuIGNvbGxlY3REaXJlY3Rvcmllc1VzZWRJblNjaGVtYUlubmVyKHNjaGVtYS5lbGVtZW50LCBkaXJlY3Rvcmllcywgc2VlblNjaGVtYXMpO1xuICB9XG4gIGlmIChzY2hlbWEua2luZCA9PT0gJ2NoaWxkJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc2NoZW1hLmtpbmQgPT09ICdmb3JtJykge1xuICAgIGlmIChzY2hlbWEuZm9ybUtpbmQgPT09ICdhc3NldCcgJiYgc2NoZW1hLmRpcmVjdG9yeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkaXJlY3Rvcmllcy5hZGQoZml4UGF0aChzY2hlbWEuZGlyZWN0b3J5KSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWEuZm9ybUtpbmQgPT09ICdjb250ZW50JyAmJiBzY2hlbWEuZGlyZWN0b3JpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yIChjb25zdCBkaXJlY3Rvcnkgb2Ygc2NoZW1hLmRpcmVjdG9yaWVzKSB7XG4gICAgICAgIGRpcmVjdG9yaWVzLmFkZChmaXhQYXRoKGRpcmVjdG9yeSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNjaGVtYS5raW5kID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgT2JqZWN0LnZhbHVlcyhzY2hlbWEuZmllbGRzKSkge1xuICAgICAgY29sbGVjdERpcmVjdG9yaWVzVXNlZEluU2NoZW1hSW5uZXIoZmllbGQsIGRpcmVjdG9yaWVzLCBzZWVuU2NoZW1hcyk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc2NoZW1hLmtpbmQgPT09ICdjb25kaXRpb25hbCcpIHtcbiAgICBmb3IgKGNvbnN0IGlubmVyU2NoZW1hIG9mIE9iamVjdC52YWx1ZXMoc2NoZW1hLnZhbHVlcykpIHtcbiAgICAgIGNvbGxlY3REaXJlY3Rvcmllc1VzZWRJblNjaGVtYUlubmVyKGlubmVyU2NoZW1hLCBkaXJlY3Rvcmllcywgc2VlblNjaGVtYXMpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgYXNzZXJ0TmV2ZXIoc2NoZW1hKTtcbn1cbmZ1bmN0aW9uIGNvbGxlY3REaXJlY3Rvcmllc1VzZWRJblNjaGVtYShzY2hlbWEpIHtcbiAgY29uc3QgZGlyZWN0b3JpZXMgPSBuZXcgU2V0KCk7XG4gIGNvbGxlY3REaXJlY3Rvcmllc1VzZWRJblNjaGVtYUlubmVyKHNjaGVtYSwgZGlyZWN0b3JpZXMsIG5ldyBTZXQoKSk7XG4gIHJldHVybiBkaXJlY3Rvcmllcztcbn1cbmZ1bmN0aW9uIGdldERpcmVjdG9yaWVzRm9yVHJlZUtleShzY2hlbWEsIGRpcmVjdG9yeSwgc2x1ZywgZm9ybWF0KSB7XG4gIGNvbnN0IGRpcmVjdG9yaWVzID0gW2ZpeFBhdGgoZGlyZWN0b3J5KV07XG4gIGlmIChmb3JtYXQuZGF0YUxvY2F0aW9uID09PSAnb3V0ZXInKSB7XG4gICAgZGlyZWN0b3JpZXMucHVzaChmaXhQYXRoKGRpcmVjdG9yeSkgKyBnZXREYXRhRmlsZUV4dGVuc2lvbihmb3JtYXQpKTtcbiAgfVxuICBjb25zdCB0b0FkZCA9IHNsdWcgPT09IHVuZGVmaW5lZCA/ICcnIDogYC8ke3NsdWd9YDtcbiAgZm9yIChjb25zdCBkaXJlY3Rvcnkgb2YgY29sbGVjdERpcmVjdG9yaWVzVXNlZEluU2NoZW1hKHNjaGVtYSkpIHtcbiAgICBkaXJlY3Rvcmllcy5wdXNoKGRpcmVjdG9yeSArIHRvQWRkKTtcbiAgfVxuICByZXR1cm4gZGlyZWN0b3JpZXM7XG59XG5mdW5jdGlvbiBnZXRUcmVlS2V5KGRpcmVjdG9yaWVzLCB0cmVlKSB7XG4gIHJldHVybiBkaXJlY3Rvcmllcy5tYXAoZCA9PiB7XG4gICAgdmFyIF9nZXRUcmVlTm9kZUF0UGF0aDtcbiAgICByZXR1cm4gKF9nZXRUcmVlTm9kZUF0UGF0aCA9IGdldFRyZWVOb2RlQXRQYXRoKHRyZWUsIGQpKSA9PT0gbnVsbCB8fCBfZ2V0VHJlZU5vZGVBdFBhdGggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXRUcmVlTm9kZUF0UGF0aC5lbnRyeS5zaGE7XG4gIH0pLmpvaW4oJy0nKTtcbn1cblxudmFyIHBrZ0pzb24gPSB7XG5cdG5hbWU6IFwiQGtleXN0YXRpYy9jb3JlXCIsXG5cdHZlcnNpb246IFwiMC4xLjdcIixcblx0bGljZW5zZTogXCJNSVRcIixcblx0cmVwb3NpdG9yeToge1xuXHRcdHR5cGU6IFwiZ2l0XCIsXG5cdFx0dXJsOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9UaGlua21pbGwva2V5c3RhdGljL1wiLFxuXHRcdGRpcmVjdG9yeTogXCJwYWNrYWdlcy9rZXlzdGF0aWNcIlxuXHR9LFxuXHRleHBvcnRzOiB7XG5cdFx0XCIuL3VpXCI6IHtcblx0XHRcdHR5cGVzOiBcIi4vdWkvZGlzdC9rZXlzdGF0aWMtY29yZS11aS5janMuanNcIixcblx0XHRcdG5vZGU6IHtcblx0XHRcdFx0XCJyZWFjdC1zZXJ2ZXJcIjoge1xuXHRcdFx0XHRcdG1vZHVsZTogXCIuL3VpL2Rpc3Qva2V5c3RhdGljLWNvcmUtdWkubm9kZS5yZWFjdC1zZXJ2ZXIuZXNtLmpzXCIsXG5cdFx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiLi91aS9kaXN0L2tleXN0YXRpYy1jb3JlLXVpLm5vZGUucmVhY3Qtc2VydmVyLmNqcy5qc1wiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG1vZHVsZTogXCIuL3VpL2Rpc3Qva2V5c3RhdGljLWNvcmUtdWkubm9kZS5lc20uanNcIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiLi91aS9kaXN0L2tleXN0YXRpYy1jb3JlLXVpLm5vZGUuY2pzLmpzXCJcblx0XHRcdH0sXG5cdFx0XHRcInJlYWN0LXNlcnZlclwiOiB7XG5cdFx0XHRcdG1vZHVsZTogXCIuL3VpL2Rpc3Qva2V5c3RhdGljLWNvcmUtdWkucmVhY3Qtc2VydmVyLmVzbS5qc1wiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogXCIuL3VpL2Rpc3Qva2V5c3RhdGljLWNvcmUtdWkucmVhY3Qtc2VydmVyLmNqcy5qc1wiXG5cdFx0XHR9LFxuXHRcdFx0bW9kdWxlOiBcIi4vdWkvZGlzdC9rZXlzdGF0aWMtY29yZS11aS5lc20uanNcIixcblx0XHRcdFwiZGVmYXVsdFwiOiBcIi4vdWkvZGlzdC9rZXlzdGF0aWMtY29yZS11aS5janMuanNcIlxuXHRcdH0sXG5cdFx0XCIuXCI6IHtcblx0XHRcdHR5cGVzOiBcIi4vZGlzdC9rZXlzdGF0aWMtY29yZS5janMuanNcIixcblx0XHRcdG5vZGU6IHtcblx0XHRcdFx0XCJyZWFjdC1zZXJ2ZXJcIjoge1xuXHRcdFx0XHRcdG1vZHVsZTogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUubm9kZS5yZWFjdC1zZXJ2ZXIuZXNtLmpzXCIsXG5cdFx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiLi9kaXN0L2tleXN0YXRpYy1jb3JlLm5vZGUucmVhY3Qtc2VydmVyLmNqcy5qc1wiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG1vZHVsZTogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUubm9kZS5lc20uanNcIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiLi9kaXN0L2tleXN0YXRpYy1jb3JlLm5vZGUuY2pzLmpzXCJcblx0XHRcdH0sXG5cdFx0XHRcInJlYWN0LXNlcnZlclwiOiB7XG5cdFx0XHRcdG1vZHVsZTogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUucmVhY3Qtc2VydmVyLmVzbS5qc1wiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogXCIuL2Rpc3Qva2V5c3RhdGljLWNvcmUucmVhY3Qtc2VydmVyLmNqcy5qc1wiXG5cdFx0XHR9LFxuXHRcdFx0bW9kdWxlOiBcIi4vZGlzdC9rZXlzdGF0aWMtY29yZS5lc20uanNcIixcblx0XHRcdFwiZGVmYXVsdFwiOiBcIi4vZGlzdC9rZXlzdGF0aWMtY29yZS5janMuanNcIlxuXHRcdH0sXG5cdFx0XCIuL2FwaS91dGlsc1wiOiB7XG5cdFx0XHR0eXBlczogXCIuL2FwaS91dGlscy9kaXN0L2tleXN0YXRpYy1jb3JlLWFwaS11dGlscy5janMuanNcIixcblx0XHRcdG5vZGU6IHtcblx0XHRcdFx0XCJyZWFjdC1zZXJ2ZXJcIjoge1xuXHRcdFx0XHRcdG1vZHVsZTogXCIuL2FwaS91dGlscy9kaXN0L2tleXN0YXRpYy1jb3JlLWFwaS11dGlscy5ub2RlLnJlYWN0LXNlcnZlci5lc20uanNcIixcblx0XHRcdFx0XHRcImRlZmF1bHRcIjogXCIuL2FwaS91dGlscy9kaXN0L2tleXN0YXRpYy1jb3JlLWFwaS11dGlscy5ub2RlLnJlYWN0LXNlcnZlci5janMuanNcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRtb2R1bGU6IFwiLi9hcGkvdXRpbHMvZGlzdC9rZXlzdGF0aWMtY29yZS1hcGktdXRpbHMubm9kZS5lc20uanNcIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiLi9hcGkvdXRpbHMvZGlzdC9rZXlzdGF0aWMtY29yZS1hcGktdXRpbHMubm9kZS5janMuanNcIlxuXHRcdFx0fSxcblx0XHRcdFwicmVhY3Qtc2VydmVyXCI6IHtcblx0XHRcdFx0bW9kdWxlOiBcIi4vYXBpL3V0aWxzL2Rpc3Qva2V5c3RhdGljLWNvcmUtYXBpLXV0aWxzLnJlYWN0LXNlcnZlci5lc20uanNcIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiLi9hcGkvdXRpbHMvZGlzdC9rZXlzdGF0aWMtY29yZS1hcGktdXRpbHMucmVhY3Qtc2VydmVyLmNqcy5qc1wiXG5cdFx0XHR9LFxuXHRcdFx0bW9kdWxlOiBcIi4vYXBpL3V0aWxzL2Rpc3Qva2V5c3RhdGljLWNvcmUtYXBpLXV0aWxzLmVzbS5qc1wiLFxuXHRcdFx0XCJkZWZhdWx0XCI6IFwiLi9hcGkvdXRpbHMvZGlzdC9rZXlzdGF0aWMtY29yZS1hcGktdXRpbHMuY2pzLmpzXCJcblx0XHR9LFxuXHRcdFwiLi9yZW5kZXJlclwiOiB7XG5cdFx0XHR0eXBlczogXCIuL3JlbmRlcmVyL2Rpc3Qva2V5c3RhdGljLWNvcmUtcmVuZGVyZXIuY2pzLmpzXCIsXG5cdFx0XHRub2RlOiB7XG5cdFx0XHRcdFwicmVhY3Qtc2VydmVyXCI6IHtcblx0XHRcdFx0XHRtb2R1bGU6IFwiLi9yZW5kZXJlci9kaXN0L2tleXN0YXRpYy1jb3JlLXJlbmRlcmVyLm5vZGUucmVhY3Qtc2VydmVyLmVzbS5qc1wiLFxuXHRcdFx0XHRcdFwiZGVmYXVsdFwiOiBcIi4vcmVuZGVyZXIvZGlzdC9rZXlzdGF0aWMtY29yZS1yZW5kZXJlci5ub2RlLnJlYWN0LXNlcnZlci5janMuanNcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRtb2R1bGU6IFwiLi9yZW5kZXJlci9kaXN0L2tleXN0YXRpYy1jb3JlLXJlbmRlcmVyLm5vZGUuZXNtLmpzXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiBcIi4vcmVuZGVyZXIvZGlzdC9rZXlzdGF0aWMtY29yZS1yZW5kZXJlci5ub2RlLmNqcy5qc1wiXG5cdFx0XHR9LFxuXHRcdFx0XCJyZWFjdC1zZXJ2ZXJcIjoge1xuXHRcdFx0XHRtb2R1bGU6IFwiLi9yZW5kZXJlci9kaXN0L2tleXN0YXRpYy1jb3JlLXJlbmRlcmVyLnJlYWN0LXNlcnZlci5lc20uanNcIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiLi9yZW5kZXJlci9kaXN0L2tleXN0YXRpYy1jb3JlLXJlbmRlcmVyLnJlYWN0LXNlcnZlci5janMuanNcIlxuXHRcdFx0fSxcblx0XHRcdG1vZHVsZTogXCIuL3JlbmRlcmVyL2Rpc3Qva2V5c3RhdGljLWNvcmUtcmVuZGVyZXIuZXNtLmpzXCIsXG5cdFx0XHRcImRlZmF1bHRcIjogXCIuL3JlbmRlcmVyL2Rpc3Qva2V5c3RhdGljLWNvcmUtcmVuZGVyZXIuY2pzLmpzXCJcblx0XHR9LFxuXHRcdFwiLi9hcGkvZ2VuZXJpY1wiOiB7XG5cdFx0XHR0eXBlczogXCIuL2FwaS9nZW5lcmljL2Rpc3Qva2V5c3RhdGljLWNvcmUtYXBpLWdlbmVyaWMuY2pzLmpzXCIsXG5cdFx0XHRub2RlOiB7XG5cdFx0XHRcdFwicmVhY3Qtc2VydmVyXCI6IHtcblx0XHRcdFx0XHRtb2R1bGU6IFwiLi9hcGkvZ2VuZXJpYy9kaXN0L2tleXN0YXRpYy1jb3JlLWFwaS1nZW5lcmljLm5vZGUucmVhY3Qtc2VydmVyLmVzbS5qc1wiLFxuXHRcdFx0XHRcdFwiZGVmYXVsdFwiOiBcIi4vYXBpL2dlbmVyaWMvZGlzdC9rZXlzdGF0aWMtY29yZS1hcGktZ2VuZXJpYy5ub2RlLnJlYWN0LXNlcnZlci5janMuanNcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRtb2R1bGU6IFwiLi9hcGkvZ2VuZXJpYy9kaXN0L2tleXN0YXRpYy1jb3JlLWFwaS1nZW5lcmljLm5vZGUuZXNtLmpzXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiBcIi4vYXBpL2dlbmVyaWMvZGlzdC9rZXlzdGF0aWMtY29yZS1hcGktZ2VuZXJpYy5ub2RlLmNqcy5qc1wiXG5cdFx0XHR9LFxuXHRcdFx0XCJyZWFjdC1zZXJ2ZXJcIjoge1xuXHRcdFx0XHRtb2R1bGU6IFwiLi9hcGkvZ2VuZXJpYy9kaXN0L2tleXN0YXRpYy1jb3JlLWFwaS1nZW5lcmljLnJlYWN0LXNlcnZlci5lc20uanNcIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiLi9hcGkvZ2VuZXJpYy9kaXN0L2tleXN0YXRpYy1jb3JlLWFwaS1nZW5lcmljLnJlYWN0LXNlcnZlci5janMuanNcIlxuXHRcdFx0fSxcblx0XHRcdG1vZHVsZTogXCIuL2FwaS9nZW5lcmljL2Rpc3Qva2V5c3RhdGljLWNvcmUtYXBpLWdlbmVyaWMuZXNtLmpzXCIsXG5cdFx0XHRcImRlZmF1bHRcIjogXCIuL2FwaS9nZW5lcmljL2Rpc3Qva2V5c3RhdGljLWNvcmUtYXBpLWdlbmVyaWMuY2pzLmpzXCJcblx0XHR9LFxuXHRcdFwiLi9yZWFkZXJcIjoge1xuXHRcdFx0dHlwZXM6IFwiLi9yZWFkZXIvZGlzdC9rZXlzdGF0aWMtY29yZS1yZWFkZXIuY2pzLmpzXCIsXG5cdFx0XHRub2RlOiB7XG5cdFx0XHRcdFwicmVhY3Qtc2VydmVyXCI6IHtcblx0XHRcdFx0XHRtb2R1bGU6IFwiLi9yZWFkZXIvZGlzdC9rZXlzdGF0aWMtY29yZS1yZWFkZXIubm9kZS5yZWFjdC1zZXJ2ZXIuZXNtLmpzXCIsXG5cdFx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiLi9yZWFkZXIvZGlzdC9rZXlzdGF0aWMtY29yZS1yZWFkZXIubm9kZS5yZWFjdC1zZXJ2ZXIuY2pzLmpzXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0bW9kdWxlOiBcIi4vcmVhZGVyL2Rpc3Qva2V5c3RhdGljLWNvcmUtcmVhZGVyLm5vZGUuZXNtLmpzXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiBcIi4vcmVhZGVyL2Rpc3Qva2V5c3RhdGljLWNvcmUtcmVhZGVyLm5vZGUuY2pzLmpzXCJcblx0XHRcdH0sXG5cdFx0XHRcInJlYWN0LXNlcnZlclwiOiB7XG5cdFx0XHRcdG1vZHVsZTogXCIuL3JlYWRlci9kaXN0L2tleXN0YXRpYy1jb3JlLXJlYWRlci5yZWFjdC1zZXJ2ZXIuZXNtLmpzXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiBcIi4vcmVhZGVyL2Rpc3Qva2V5c3RhdGljLWNvcmUtcmVhZGVyLnJlYWN0LXNlcnZlci5janMuanNcIlxuXHRcdFx0fSxcblx0XHRcdG1vZHVsZTogXCIuL3JlYWRlci9kaXN0L2tleXN0YXRpYy1jb3JlLXJlYWRlci5lc20uanNcIixcblx0XHRcdFwiZGVmYXVsdFwiOiBcIi4vcmVhZGVyL2Rpc3Qva2V5c3RhdGljLWNvcmUtcmVhZGVyLmNqcy5qc1wiXG5cdFx0fSxcblx0XHRcIi4vcmVhZGVyL2dpdGh1YlwiOiB7XG5cdFx0XHR0eXBlczogXCIuL3JlYWRlci9naXRodWIvZGlzdC9rZXlzdGF0aWMtY29yZS1yZWFkZXItZ2l0aHViLmNqcy5qc1wiLFxuXHRcdFx0bm9kZToge1xuXHRcdFx0XHRcInJlYWN0LXNlcnZlclwiOiB7XG5cdFx0XHRcdFx0bW9kdWxlOiBcIi4vcmVhZGVyL2dpdGh1Yi9kaXN0L2tleXN0YXRpYy1jb3JlLXJlYWRlci1naXRodWIubm9kZS5yZWFjdC1zZXJ2ZXIuZXNtLmpzXCIsXG5cdFx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiLi9yZWFkZXIvZ2l0aHViL2Rpc3Qva2V5c3RhdGljLWNvcmUtcmVhZGVyLWdpdGh1Yi5ub2RlLnJlYWN0LXNlcnZlci5janMuanNcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRtb2R1bGU6IFwiLi9yZWFkZXIvZ2l0aHViL2Rpc3Qva2V5c3RhdGljLWNvcmUtcmVhZGVyLWdpdGh1Yi5ub2RlLmVzbS5qc1wiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogXCIuL3JlYWRlci9naXRodWIvZGlzdC9rZXlzdGF0aWMtY29yZS1yZWFkZXItZ2l0aHViLm5vZGUuY2pzLmpzXCJcblx0XHRcdH0sXG5cdFx0XHRcInJlYWN0LXNlcnZlclwiOiB7XG5cdFx0XHRcdG1vZHVsZTogXCIuL3JlYWRlci9naXRodWIvZGlzdC9rZXlzdGF0aWMtY29yZS1yZWFkZXItZ2l0aHViLnJlYWN0LXNlcnZlci5lc20uanNcIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiLi9yZWFkZXIvZ2l0aHViL2Rpc3Qva2V5c3RhdGljLWNvcmUtcmVhZGVyLWdpdGh1Yi5yZWFjdC1zZXJ2ZXIuY2pzLmpzXCJcblx0XHRcdH0sXG5cdFx0XHRtb2R1bGU6IFwiLi9yZWFkZXIvZ2l0aHViL2Rpc3Qva2V5c3RhdGljLWNvcmUtcmVhZGVyLWdpdGh1Yi5lc20uanNcIixcblx0XHRcdFwiZGVmYXVsdFwiOiBcIi4vcmVhZGVyL2dpdGh1Yi9kaXN0L2tleXN0YXRpYy1jb3JlLXJlYWRlci1naXRodWIuY2pzLmpzXCJcblx0XHR9LFxuXHRcdFwiLi9jb21wb25lbnQtYmxvY2tzXCI6IHtcblx0XHRcdHR5cGVzOiBcIi4vY29tcG9uZW50LWJsb2Nrcy9kaXN0L2tleXN0YXRpYy1jb3JlLWNvbXBvbmVudC1ibG9ja3MuY2pzLmpzXCIsXG5cdFx0XHRub2RlOiB7XG5cdFx0XHRcdFwicmVhY3Qtc2VydmVyXCI6IHtcblx0XHRcdFx0XHRtb2R1bGU6IFwiLi9jb21wb25lbnQtYmxvY2tzL2Rpc3Qva2V5c3RhdGljLWNvcmUtY29tcG9uZW50LWJsb2Nrcy5ub2RlLnJlYWN0LXNlcnZlci5lc20uanNcIixcblx0XHRcdFx0XHRcImRlZmF1bHRcIjogXCIuL2NvbXBvbmVudC1ibG9ja3MvZGlzdC9rZXlzdGF0aWMtY29yZS1jb21wb25lbnQtYmxvY2tzLm5vZGUucmVhY3Qtc2VydmVyLmNqcy5qc1wiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG1vZHVsZTogXCIuL2NvbXBvbmVudC1ibG9ja3MvZGlzdC9rZXlzdGF0aWMtY29yZS1jb21wb25lbnQtYmxvY2tzLm5vZGUuZXNtLmpzXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiBcIi4vY29tcG9uZW50LWJsb2Nrcy9kaXN0L2tleXN0YXRpYy1jb3JlLWNvbXBvbmVudC1ibG9ja3Mubm9kZS5janMuanNcIlxuXHRcdFx0fSxcblx0XHRcdFwicmVhY3Qtc2VydmVyXCI6IHtcblx0XHRcdFx0bW9kdWxlOiBcIi4vY29tcG9uZW50LWJsb2Nrcy9kaXN0L2tleXN0YXRpYy1jb3JlLWNvbXBvbmVudC1ibG9ja3MucmVhY3Qtc2VydmVyLmVzbS5qc1wiLFxuXHRcdFx0XHRcImRlZmF1bHRcIjogXCIuL2NvbXBvbmVudC1ibG9ja3MvZGlzdC9rZXlzdGF0aWMtY29yZS1jb21wb25lbnQtYmxvY2tzLnJlYWN0LXNlcnZlci5janMuanNcIlxuXHRcdFx0fSxcblx0XHRcdG1vZHVsZTogXCIuL2NvbXBvbmVudC1ibG9ja3MvZGlzdC9rZXlzdGF0aWMtY29yZS1jb21wb25lbnQtYmxvY2tzLmVzbS5qc1wiLFxuXHRcdFx0XCJkZWZhdWx0XCI6IFwiLi9jb21wb25lbnQtYmxvY2tzL2Rpc3Qva2V5c3RhdGljLWNvcmUtY29tcG9uZW50LWJsb2Nrcy5janMuanNcIlxuXHRcdH0sXG5cdFx0XCIuL2Zvcm0vZmllbGRzL21hcmtkb2NcIjoge1xuXHRcdFx0dHlwZXM6IFwiLi9mb3JtL2ZpZWxkcy9tYXJrZG9jL2Rpc3Qva2V5c3RhdGljLWNvcmUtZm9ybS1maWVsZHMtbWFya2RvYy5janMuanNcIixcblx0XHRcdG5vZGU6IHtcblx0XHRcdFx0XCJyZWFjdC1zZXJ2ZXJcIjoge1xuXHRcdFx0XHRcdG1vZHVsZTogXCIuL2Zvcm0vZmllbGRzL21hcmtkb2MvZGlzdC9rZXlzdGF0aWMtY29yZS1mb3JtLWZpZWxkcy1tYXJrZG9jLm5vZGUucmVhY3Qtc2VydmVyLmVzbS5qc1wiLFxuXHRcdFx0XHRcdFwiZGVmYXVsdFwiOiBcIi4vZm9ybS9maWVsZHMvbWFya2RvYy9kaXN0L2tleXN0YXRpYy1jb3JlLWZvcm0tZmllbGRzLW1hcmtkb2Mubm9kZS5yZWFjdC1zZXJ2ZXIuY2pzLmpzXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0bW9kdWxlOiBcIi4vZm9ybS9maWVsZHMvbWFya2RvYy9kaXN0L2tleXN0YXRpYy1jb3JlLWZvcm0tZmllbGRzLW1hcmtkb2Mubm9kZS5lc20uanNcIixcblx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiLi9mb3JtL2ZpZWxkcy9tYXJrZG9jL2Rpc3Qva2V5c3RhdGljLWNvcmUtZm9ybS1maWVsZHMtbWFya2RvYy5ub2RlLmNqcy5qc1wiXG5cdFx0XHR9LFxuXHRcdFx0XCJyZWFjdC1zZXJ2ZXJcIjoge1xuXHRcdFx0XHRtb2R1bGU6IFwiLi9mb3JtL2ZpZWxkcy9tYXJrZG9jL2Rpc3Qva2V5c3RhdGljLWNvcmUtZm9ybS1maWVsZHMtbWFya2RvYy5yZWFjdC1zZXJ2ZXIuZXNtLmpzXCIsXG5cdFx0XHRcdFwiZGVmYXVsdFwiOiBcIi4vZm9ybS9maWVsZHMvbWFya2RvYy9kaXN0L2tleXN0YXRpYy1jb3JlLWZvcm0tZmllbGRzLW1hcmtkb2MucmVhY3Qtc2VydmVyLmNqcy5qc1wiXG5cdFx0XHR9LFxuXHRcdFx0bW9kdWxlOiBcIi4vZm9ybS9maWVsZHMvbWFya2RvYy9kaXN0L2tleXN0YXRpYy1jb3JlLWZvcm0tZmllbGRzLW1hcmtkb2MuZXNtLmpzXCIsXG5cdFx0XHRcImRlZmF1bHRcIjogXCIuL2Zvcm0vZmllbGRzL21hcmtkb2MvZGlzdC9rZXlzdGF0aWMtY29yZS1mb3JtLWZpZWxkcy1tYXJrZG9jLmNqcy5qc1wiXG5cdFx0fSxcblx0XHRcIi4vcGFja2FnZS5qc29uXCI6IFwiLi9wYWNrYWdlLmpzb25cIlxuXHR9LFxuXHRtYWluOiBcImRpc3Qva2V5c3RhdGljLWNvcmUuY2pzLmpzXCIsXG5cdG1vZHVsZTogXCJkaXN0L2tleXN0YXRpYy1jb3JlLmVzbS5qc1wiLFxuXHRmaWxlczogW1xuXHRcdFwiZGlzdFwiLFxuXHRcdFwiYXBpXCIsXG5cdFx0XCJyZWFkZXJcIixcblx0XHRcInJlbmRlcmVyXCIsXG5cdFx0XCJ1aVwiLFxuXHRcdFwiZm9ybVwiLFxuXHRcdFwiY29tcG9uZW50LWJsb2Nrc1wiXG5cdF0sXG5cdHNjcmlwdHM6IHtcblx0XHRzZXR1cDogXCJ0cy1ncWwgYnVpbGQgJiYgdHN4IHNjcmlwdHMvbDEwbi50cyAmJiB0c3ggc2NyaXB0cy9idWlsZC1wcmlzbS50c1wiLFxuXHRcdGJ1aWxkOiBcInBucG0gcnVuIHNldHVwICYmIG5leHQgYnVpbGRcIixcblx0XHRkZXY6IFwibmV4dCBkZXZcIixcblx0XHRzdGFydDogXCJuZXh0IHN0YXJ0XCJcblx0fSxcblx0ZGVwZW5kZW5jaWVzOiB7XG5cdFx0XCJAYmFiZWwvcnVudGltZVwiOiBcIl43LjE4LjNcIixcblx0XHRcIkBicmFpbnRyZWUvc2FuaXRpemUtdXJsXCI6IFwiXjYuMC4yXCIsXG5cdFx0XCJAZW1vdGlvbi9jc3NcIjogXCJeMTEuOS4wXCIsXG5cdFx0XCJAZW1vdGlvbi93ZWFrLW1lbW9pemVcIjogXCJeMC4zLjBcIixcblx0XHRcIkBmbG9hdGluZy11aS9yZWFjdFwiOiBcIl4wLjI0LjBcIixcblx0XHRcIkBpbnRlcm5hdGlvbmFsaXplZC9zdHJpbmdcIjogXCJeMy4xLjFcIixcblx0XHRcIkBrZXlzdGFyL3VpXCI6IFwiXjAuMy4zXCIsXG5cdFx0XCJAbWFya2RvYy9tYXJrZG9jXCI6IFwiXjAuMy4wXCIsXG5cdFx0XCJAcmVhY3QtYXJpYS9mb2N1c1wiOiBcIl4zLjE0LjJcIixcblx0XHRcIkByZWFjdC1hcmlhL2kxOG5cIjogXCJeMy44LjBcIixcblx0XHRcIkByZWFjdC1hcmlhL2ludGVyYWN0aW9uc1wiOiBcIl4zLjE5LjBcIixcblx0XHRcIkByZWFjdC1hcmlhL292ZXJsYXlzXCI6IFwiXjMuMTUuMFwiLFxuXHRcdFwiQHJlYWN0LWFyaWEvc2VsZWN0aW9uXCI6IFwiXjMuMTYuMFwiLFxuXHRcdFwiQHJlYWN0LWFyaWEvdXRpbHNcIjogXCJeMy4yMS4wXCIsXG5cdFx0XCJAcmVhY3QtYXJpYS92aXN1YWxseS1oaWRkZW5cIjogXCJeMy44LjVcIixcblx0XHRcIkByZWFjdC1zdGF0ZWx5L2NvbGxlY3Rpb25zXCI6IFwiXjMuMTAuMlwiLFxuXHRcdFwiQHJlYWN0LXN0YXRlbHkvbGlzdFwiOiBcIl4zLjkuMFwiLFxuXHRcdFwiQHJlYWN0LXN0YXRlbHkvb3ZlcmxheXNcIjogXCJeMy42LjBcIixcblx0XHRcIkByZWFjdC1zdGF0ZWx5L3V0aWxzXCI6IFwiXjMuNy4wXCIsXG5cdFx0XCJAcmVhY3QtdHlwZXMvc2hhcmVkXCI6IFwiXjMuMjEuMFwiLFxuXHRcdFwiQHNpbmRyZXNvcmh1cy9zbHVnaWZ5XCI6IFwiXjEuMS4yXCIsXG5cdFx0XCJAdHMtZ3FsL3RhZ1wiOiBcIl4wLjcuMFwiLFxuXHRcdFwiQHR5cGVzL25vZGVcIjogXCIxNi4xMS4xM1wiLFxuXHRcdFwiQHR5cGVzL3JlYWN0XCI6IFwiXjE4LjIuOFwiLFxuXHRcdFwiQHR5cGVzL3JlYWN0LWRvbVwiOiBcIl4xOC4wLjExXCIsXG5cdFx0XCJAdXJxbC9jb3JlXCI6IFwiXjQuMS4zXCIsXG5cdFx0XCJAdXJxbC9leGNoYW5nZS1hdXRoXCI6IFwiXjIuMS42XCIsXG5cdFx0XCJAdXJxbC9leGNoYW5nZS1ncmFwaGNhY2hlXCI6IFwiXjYuMy4zXCIsXG5cdFx0XCJAdXJxbC9leGNoYW5nZS1wZXJzaXN0ZWRcIjogXCJeNC4xLjBcIixcblx0XHRjb29raWU6IFwiXjAuNS4wXCIsXG5cdFx0ZW1lcnk6IFwiXjEuNC4xXCIsXG5cdFx0XCJlc2NhcGUtc3RyaW5nLXJlZ2V4cFwiOiBcIl40LjAuMFwiLFxuXHRcdFwiZmFzdC1kZWVwLWVxdWFsXCI6IFwiXjMuMS4zXCIsXG5cdFx0Z3JhcGhxbDogXCJeMTYuNi4wXCIsXG5cdFx0XCJpZGIta2V5dmFsXCI6IFwiXjYuMi4xXCIsXG5cdFx0aWdub3JlOiBcIl41LjIuNFwiLFxuXHRcdFwiaXJvbi13ZWJjcnlwdG9cIjogXCJeMC4xMC4xXCIsXG5cdFx0XCJpcy1ob3RrZXlcIjogXCJeMC4yLjBcIixcblx0XHRcImpzLWJhc2U2NFwiOiBcIl4zLjcuNVwiLFxuXHRcdFwianMteWFtbFwiOiBcIl40LjEuMFwiLFxuXHRcdFwibHJ1LWNhY2hlXCI6IFwiXjcuMTQuMVwiLFxuXHRcdFwibWF0Y2gtc29ydGVyXCI6IFwiXjYuMy4xXCIsXG5cdFx0XCJtZGFzdC11dGlsLWZyb20tbWFya2Rvd25cIjogXCJeMC44LjVcIixcblx0XHRcIm1kYXN0LXV0aWwtZ2ZtLWF1dG9saW5rLWxpdGVyYWxcIjogXCJeMC4xLjNcIixcblx0XHRcIm1kYXN0LXV0aWwtZ2ZtLXN0cmlrZXRocm91Z2hcIjogXCJeMC4yLjNcIixcblx0XHRcIm1pY3JvbWFyay1leHRlbnNpb24tZ2ZtLWF1dG9saW5rLWxpdGVyYWxcIjogXCIwLjUuN1wiLFxuXHRcdFwibWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tc3RyaWtldGhyb3VnaFwiOiBcIjAuNi41XCIsXG5cdFx0bWluaW1hdGNoOiBcIl43LjEuMFwiLFxuXHRcdFwicHJvc2VtaXJyb3ItY29tbWFuZHNcIjogXCJeMS41LjFcIixcblx0XHRcInByb3NlbWlycm9yLWhpc3RvcnlcIjogXCJeMS4zLjBcIixcblx0XHRcInByb3NlbWlycm9yLWtleW1hcFwiOiBcIl4xLjIuMVwiLFxuXHRcdFwicHJvc2VtaXJyb3ItbW9kZWxcIjogXCJeMS4xOS4wXCIsXG5cdFx0XCJwcm9zZW1pcnJvci1zdGF0ZVwiOiBcIl4xLjQuMlwiLFxuXHRcdFwicHJvc2VtaXJyb3ItdHJhbnNmb3JtXCI6IFwiXjEuNy4xXCIsXG5cdFx0XCJwcm9zZW1pcnJvci12aWV3XCI6IFwiXjEuMzAuMlwiLFxuXHRcdFwic2Nyb2xsLWludG8tdmlldy1pZi1uZWVkZWRcIjogXCJeMy4wLjNcIixcblx0XHRzbGF0ZTogXCJeMC45MS40XCIsXG5cdFx0XCJzbGF0ZS1oaXN0b3J5XCI6IFwiXjAuODYuMFwiLFxuXHRcdFwic2xhdGUtcmVhY3RcIjogXCJeMC45MS45XCIsXG5cdFx0dXJxbDogXCJeNC4wLjBcIixcblx0XHR6b2Q6IFwiXjMuMjAuMlwiXG5cdH0sXG5cdGRldkRlcGVuZGVuY2llczoge1xuXHRcdFwiQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50XCI6IFwiXjE0LjQuM1wiLFxuXHRcdFwiQHRzLWdxbC9jb21waWxlclwiOiBcIl4wLjE2LjFcIixcblx0XHRcIkB0cy1ncWwvZXNsaW50LXBsdWdpblwiOiBcIl4wLjguNVwiLFxuXHRcdFwiQHRzLWdxbC9uZXh0XCI6IFwiXjE3LjAuMFwiLFxuXHRcdFwiQHR5cGVzL2Nvb2tpZVwiOiBcIl4wLjUuMVwiLFxuXHRcdFwiQHR5cGVzL2lzLWhvdGtleVwiOiBcIl4wLjEuN1wiLFxuXHRcdFwiQHR5cGVzL2pzLXlhbWxcIjogXCJeNC4wLjVcIixcblx0XHRcIkB0eXBlcy9wcmlzbWpzXCI6IFwiXjEuMjYuMFwiLFxuXHRcdFwiQHR5cGVzL3NpZ25hbC1leGl0XCI6IFwiXjMuMC4xXCIsXG5cdFx0ZXNsaW50OiBcIl44LjE4LjBcIixcblx0XHRcImZhc3QtZ2xvYlwiOiBcIl4zLjIuMTJcIixcblx0XHRcImplc3QtZGlmZlwiOiBcIl4yOS4wLjFcIixcblx0XHRvdXRkZW50OiBcIl4wLjguMFwiLFxuXHRcdFwicHJldHR5LWZvcm1hdFwiOiBcIl4yOS4wLjFcIixcblx0XHRwcmlzbWpzOiBcIl4xLjI5LjBcIixcblx0XHRyZWFjdDogXCJeMTguMi4wXCIsXG5cdFx0XCJyZWFjdC1kb21cIjogXCJeMTguMi4wXCIsXG5cdFx0XCJyZWFjdC1lbGVtZW50LXRvLWpzeC1zdHJpbmdcIjogXCJeMTUuMC4wXCIsXG5cdFx0XCJyZXNpemUtb2JzZXJ2ZXItcG9seWZpbGxcIjogXCJeMS41LjFcIixcblx0XHRcInNpZ25hbC1leGl0XCI6IFwiXjMuMC43XCIsXG5cdFx0XCJzbGF0ZS1oeXBlcnNjcmlwdFwiOiBcIl4wLjc3LjBcIixcblx0XHR0c3g6IFwiXjMuOC4wXCIsXG5cdFx0dHlwZXNjcmlwdDogXCJeNS4yLjJcIlxuXHR9LFxuXHRwZWVyRGVwZW5kZW5jaWVzOiB7XG5cdFx0cmVhY3Q6IFwiXjE4LjIuMFwiLFxuXHRcdFwicmVhY3QtZG9tXCI6IFwiXjE4LjIuMFwiXG5cdH0sXG5cdHByZWNvbnN0cnVjdDoge1xuXHRcdGVudHJ5cG9pbnRzOiBbXG5cdFx0XHRcImluZGV4LnRzXCIsXG5cdFx0XHRcImFwaS9nZW5lcmljLnRzXCIsXG5cdFx0XHRcImFwaS91dGlscy50c1wiLFxuXHRcdFx0XCJyZWFkZXIvaW5kZXgudHNcIixcblx0XHRcdFwicmVhZGVyL2dpdGh1Yi50c1wiLFxuXHRcdFx0XCJyZW5kZXJlci50c3hcIixcblx0XHRcdFwidWkudHN4XCIsXG5cdFx0XHRcImZvcm0vZmllbGRzL21hcmtkb2MvaW5kZXgudHN4XCIsXG5cdFx0XHRcImNvbXBvbmVudC1ibG9ja3MvaW5kZXgudHN4XCJcblx0XHRdXG5cdH0sXG5cdFwidHMtZ3FsXCI6IHtcblx0XHRzY2hlbWE6IFwiLi9naXRodWIuZ3JhcGhxbFwiLFxuXHRcdG1vZGU6IFwibm8tdHJhbnNmb3JtXCIsXG5cdFx0YWRkVHlwZW5hbWU6IGZhbHNlLFxuXHRcdHNjYWxhcnM6IHtcblx0XHRcdEdpdE9iamVjdElEOiBcInN0cmluZ1wiXG5cdFx0fVxuXHR9LFxuXHRpbXBvcnRzOiB7XG5cdFx0XCIjcmVhY3QtY2FjaGUtaW4tcmVhY3Qtc2VydmVyXCI6IHtcblx0XHRcdFwicmVhY3Qtc2VydmVyXCI6IFwiLi9zcmMvcmVhZGVyL3JlYWN0LXNlcnZlci1jYWNoZS50c1wiLFxuXHRcdFx0XCJkZWZhdWx0XCI6IFwiLi9zcmMvcmVhZGVyL25vb3AtY2FjaGUudHNcIlxuXHRcdH0sXG5cdFx0XCIjc2hhMVwiOiB7XG5cdFx0XHRub2RlOiBcIi4vc3JjL3NoYTEvbm9kZS50c1wiLFxuXHRcdFx0XCJkZWZhdWx0XCI6IFwiLi9zcmMvc2hhMS93ZWJjcnlwdG8udHNcIlxuXHRcdH0sXG5cdFx0XCIjd2ViY3J5cHRvXCI6IHtcblx0XHRcdG5vZGU6IFwiLi9zcmMvYXBpL3dlYmNyeXB0by9ub2RlLnRzXCIsXG5cdFx0XHRcImRlZmF1bHRcIjogXCIuL3NyYy9hcGkvd2ViY3J5cHRvL2RlZmF1bHQudHNcIlxuXHRcdH0sXG5cdFx0XCIjYXBpLWhhbmRsZXJcIjoge1xuXHRcdFx0bm9kZTogXCIuL3NyYy9hcGkvYXBpLW5vZGUudHNcIixcblx0XHRcdFwiZGVmYXVsdFwiOiBcIi4vc3JjL2FwaS9hcGktbm9vcC50c1wiXG5cdFx0fSxcblx0XHRcIiNmaWVsZC11aS8qXCI6IHtcblx0XHRcdFwicmVhY3Qtc2VydmVyXCI6IFwiLi9zcmMvZm9ybS9maWVsZHMvZW1wdHktZmllbGQtdWkudHN4XCIsXG5cdFx0XHRcImRlZmF1bHRcIjogXCIuL3NyYy9mb3JtL2ZpZWxkcy8qL3VpLnRzeFwiXG5cdFx0fSxcblx0XHRcIiNjb21wb25lbnQtYmxvY2stcHJpbWl0aXZlc1wiOiB7XG5cdFx0XHRcInJlYWN0LXNlcnZlclwiOiBcIi4vc3JjL2Zvcm0vZmllbGRzL2RvY3VtZW50L0RvY3VtZW50RWRpdG9yL3ByaW1pdGl2ZXMvYmxhbmstZm9yLXJlYWN0LXNlcnZlci50c3hcIixcblx0XHRcdFwiZGVmYXVsdFwiOiBcIi4vc3JjL2Zvcm0vZmllbGRzL2RvY3VtZW50L0RvY3VtZW50RWRpdG9yL3ByaW1pdGl2ZXMvaW5kZXgudHN4XCJcblx0XHR9LFxuXHRcdFwiI2Nsb3VkLWltYWdlLXByZXZpZXdcIjoge1xuXHRcdFx0XCJyZWFjdC1zZXJ2ZXJcIjogXCIuL3NyYy9jb21wb25lbnQtYmxvY2tzL2JsYW5rLWZvci1yZWFjdC1zZXJ2ZXIudHN4XCIsXG5cdFx0XHRcImRlZmF1bHRcIjogXCIuL3NyYy9jb21wb25lbnQtYmxvY2tzL2Nsb3VkLWltYWdlLXByZXZpZXcudHN4XCJcblx0XHR9XG5cdH1cbn07XG5cbmZ1bmN0aW9uIG9iamVjdChmaWVsZHMsIG9wdHMpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5vcHRzLFxuICAgIGtpbmQ6ICdvYmplY3QnLFxuICAgIGZpZWxkc1xuICB9O1xufVxuXG5mdW5jdGlvbiBwbHVyYWxpemUoY291bnQsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHNpbmd1bGFyLFxuICAgIHBsdXJhbCA9IHNpbmd1bGFyICsgJ3MnLFxuICAgIGluY2x1c2l2ZSA9IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHZhcmlhbnQgPSBjb3VudCA9PT0gMSA/IHNpbmd1bGFyIDogcGx1cmFsO1xuICByZXR1cm4gaW5jbHVzaXZlID8gYCR7Y291bnR9ICR7dmFyaWFudH1gIDogdmFyaWFudDtcbn1cbmZ1bmN0aW9uIGdldEJyYW5jaFByZWZpeChjb25maWcpIHtcbiAgcmV0dXJuIGNvbmZpZy5zdG9yYWdlLmtpbmQgIT09ICdsb2NhbCcgPyBjb25maWcuc3RvcmFnZS5icmFuY2hQcmVmaXggOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBrZXllZEVudHJpZXMob2JqKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhvYmopLm1hcCgoW2tleSwgdmFsdWVdKSA9PiAoe1xuICAgIGtleSxcbiAgICAuLi52YWx1ZVxuICB9KSk7XG59XG5mdW5jdGlvbiBpc0dpdEh1YkNvbmZpZyhjb25maWcpIHtcbiAgcmV0dXJuIGNvbmZpZy5zdG9yYWdlLmtpbmQgPT09ICdnaXRodWInO1xufVxuZnVuY3Rpb24gaXNMb2NhbENvbmZpZyhjb25maWcpIHtcbiAgcmV0dXJuIGNvbmZpZy5zdG9yYWdlLmtpbmQgPT09ICdsb2NhbCc7XG59XG5mdW5jdGlvbiBpc0Nsb3VkQ29uZmlnKGNvbmZpZykge1xuICB2YXIgX2NvbmZpZyRjbG91ZDtcbiAgaWYgKGNvbmZpZy5zdG9yYWdlLmtpbmQgIT09ICdjbG91ZCcpIHJldHVybiBmYWxzZTtcbiAgaWYgKCEoKF9jb25maWckY2xvdWQgPSBjb25maWcuY2xvdWQpICE9PSBudWxsICYmIF9jb25maWckY2xvdWQgIT09IHZvaWQgMCAmJiBfY29uZmlnJGNsb3VkLnByb2plY3QpIHx8ICFjb25maWcuY2xvdWQucHJvamVjdC5pbmNsdWRlcygnLycpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBLZXlzdGF0aWMgaXMgc2V0IHRvIFxcYHN0b3JhZ2U6IHsga2luZDogJ2Nsb3VkJyB9XFxgIGJ1dCBcXGBjbG91ZC5wcm9qZWN0XFxgIGlzbid0IHNldC5cbmNvbmZpZyh7XG4gIHN0b3JhZ2U6IHsga2luZDogJ2Nsb3VkJyB9LFxuICBjbG91ZDogeyBwcm9qZWN0OiAndGVhbS9wcm9qZWN0JyB9LFxufSlgKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldFNwbGl0Q2xvdWRQcm9qZWN0KGNvbmZpZykge1xuICB2YXIgX2NvbmZpZyRjbG91ZDI7XG4gIGlmICghKChfY29uZmlnJGNsb3VkMiA9IGNvbmZpZy5jbG91ZCkgIT09IG51bGwgJiYgX2NvbmZpZyRjbG91ZDIgIT09IHZvaWQgMCAmJiBfY29uZmlnJGNsb3VkMi5wcm9qZWN0KSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgY29uc3QgW3RlYW0sIHByb2plY3RdID0gY29uZmlnLmNsb3VkLnByb2plY3Quc3BsaXQoJy8nKTtcbiAgcmV0dXJuIHtcbiAgICB0ZWFtLFxuICAgIHByb2plY3RcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFJlcG9QYXRoKGNvbmZpZykge1xuICByZXR1cm4gYCR7Y29uZmlnLm1haW5Pd25lcn0vJHtjb25maWcubWFpblJlcG99YDtcbn1cbmZ1bmN0aW9uIGdldFJlcG9VcmwoY29uZmlnKSB7XG4gIHJldHVybiBgaHR0cHM6Ly9naXRodWIuY29tLyR7Z2V0UmVwb1BhdGgoY29uZmlnKX1gO1xufVxuZnVuY3Rpb24gZ2V0U2x1Z0Zyb21TdGF0ZShjb2xsZWN0aW9uQ29uZmlnLCBzdGF0ZSkge1xuICBjb25zdCB2YWx1ZSA9IHN0YXRlW2NvbGxlY3Rpb25Db25maWcuc2x1Z0ZpZWxkXTtcbiAgY29uc3QgZmllbGQgPSBjb2xsZWN0aW9uQ29uZmlnLnNjaGVtYVtjb2xsZWN0aW9uQ29uZmlnLnNsdWdGaWVsZF07XG4gIGlmIChmaWVsZC5raW5kICE9PSAnZm9ybScgfHwgZmllbGQuZm9ybUtpbmQgIT09ICdzbHVnJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgc2x1Z0ZpZWxkIGlzIG5vdCBhIHNsdWcgZmllbGRgKTtcbiAgfVxuICByZXR1cm4gZmllbGQuc2VyaWFsaXplV2l0aFNsdWcodmFsdWUpLnNsdWc7XG59XG5mdW5jdGlvbiBnZXRFbnRyaWVzSW5Db2xsZWN0aW9uV2l0aFRyZWVLZXkoY29uZmlnLCBjb2xsZWN0aW9uLCByb290VHJlZSkge1xuICB2YXIgX2dldFRyZWVOb2RlQXRQYXRoJGNoLCBfZ2V0VHJlZU5vZGVBdFBhdGg7XG4gIGNvbnN0IGNvbGxlY3Rpb25Db25maWcgPSBjb25maWcuY29sbGVjdGlvbnNbY29sbGVjdGlvbl07XG4gIGNvbnN0IHNjaGVtYSA9IG9iamVjdChjb2xsZWN0aW9uQ29uZmlnLnNjaGVtYSk7XG4gIGNvbnN0IGZvcm1hdEluZm8gPSBnZXRDb2xsZWN0aW9uRm9ybWF0KGNvbmZpZywgY29sbGVjdGlvbik7XG4gIGNvbnN0IGV4dGVuc2lvbiA9IGdldERhdGFGaWxlRXh0ZW5zaW9uKGZvcm1hdEluZm8pO1xuICBjb25zdCBnbG9iID0gZ2V0U2x1Z0dsb2JGb3JDb2xsZWN0aW9uKGNvbmZpZywgY29sbGVjdGlvbik7XG4gIGNvbnN0IGNvbGxlY3Rpb25QYXRoID0gZ2V0Q29sbGVjdGlvblBhdGgoY29uZmlnLCBjb2xsZWN0aW9uKTtcbiAgY29uc3QgZGlyZWN0b3J5ID0gKF9nZXRUcmVlTm9kZUF0UGF0aCRjaCA9IChfZ2V0VHJlZU5vZGVBdFBhdGggPSBnZXRUcmVlTm9kZUF0UGF0aChyb290VHJlZSwgY29sbGVjdGlvblBhdGgpKSA9PT0gbnVsbCB8fCBfZ2V0VHJlZU5vZGVBdFBhdGggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXRUcmVlTm9kZUF0UGF0aC5jaGlsZHJlbikgIT09IG51bGwgJiYgX2dldFRyZWVOb2RlQXRQYXRoJGNoICE9PSB2b2lkIDAgPyBfZ2V0VHJlZU5vZGVBdFBhdGgkY2ggOiBuZXcgTWFwKCk7XG4gIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgY29uc3QgZGlyZWN0b3JpZXNVc2VkSW5TY2hlbWEgPSBbLi4uY29sbGVjdERpcmVjdG9yaWVzVXNlZEluU2NoZW1hKHNjaGVtYSldO1xuICBjb25zdCBzdWZmaXggPSBnZXRDb2xsZWN0aW9uSXRlbVNsdWdTdWZmaXgoY29uZmlnLCBjb2xsZWN0aW9uKTtcbiAgY29uc3QgcG9zc2libGVFbnRyaWVzID0gbmV3IE1hcChkaXJlY3RvcnkpO1xuICBpZiAoZ2xvYiA9PT0gJyoqJykge1xuICAgIGNvbnN0IGhhbmRsZURpcmVjdG9yeSA9IChkaXIsIHByZWZpeCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBba2V5LCBlbnRyeV0gb2YgZGlyKSB7XG4gICAgICAgIGlmIChlbnRyeS5jaGlsZHJlbikge1xuICAgICAgICAgIHBvc3NpYmxlRW50cmllcy5zZXQoYCR7cHJlZml4fSR7a2V5fWAsIGVudHJ5KTtcbiAgICAgICAgICBoYW5kbGVEaXJlY3RvcnkoZW50cnkuY2hpbGRyZW4sIGAke3ByZWZpeH0ke2tleX0vYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9zc2libGVFbnRyaWVzLnNldChgJHtwcmVmaXh9JHtrZXl9YCwgZW50cnkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBoYW5kbGVEaXJlY3RvcnkoZGlyZWN0b3J5LCAnJyk7XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCBlbnRyeV0gb2YgcG9zc2libGVFbnRyaWVzKSB7XG4gICAgaWYgKGZvcm1hdEluZm8uZGF0YUxvY2F0aW9uID09PSAnaW5kZXgnKSB7XG4gICAgICB2YXIgX2FjdHVhbEVudHJ5JGNoaWxkcmVuO1xuICAgICAgY29uc3QgYWN0dWFsRW50cnkgPSBnZXRUcmVlTm9kZUF0UGF0aChyb290VHJlZSwgZ2V0Q29sbGVjdGlvbkl0ZW1QYXRoKGNvbmZpZywgY29sbGVjdGlvbiwga2V5KSk7XG4gICAgICBpZiAoIShhY3R1YWxFbnRyeSAhPT0gbnVsbCAmJiBhY3R1YWxFbnRyeSAhPT0gdm9pZCAwICYmIChfYWN0dWFsRW50cnkkY2hpbGRyZW4gPSBhY3R1YWxFbnRyeS5jaGlsZHJlbikgIT09IG51bGwgJiYgX2FjdHVhbEVudHJ5JGNoaWxkcmVuICE9PSB2b2lkIDAgJiYgX2FjdHVhbEVudHJ5JGNoaWxkcmVuLmhhcygnaW5kZXgnICsgZXh0ZW5zaW9uKSkpIGNvbnRpbnVlO1xuICAgICAgZW50cmllcy5wdXNoKHtcbiAgICAgICAga2V5OiBnZXRUcmVlS2V5KFthY3R1YWxFbnRyeS5lbnRyeS5wYXRoLCAuLi5kaXJlY3Rvcmllc1VzZWRJblNjaGVtYS5tYXAoeCA9PiBgJHt4fS8ke2tleX1gKV0sIHJvb3RUcmVlKSxcbiAgICAgICAgc2x1Zzoga2V5XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN1ZmZpeCkge1xuICAgICAgICBjb25zdCBuZXdFbnRyeSA9IGdldFRyZWVOb2RlQXRQYXRoKHJvb3RUcmVlLCBnZXRDb2xsZWN0aW9uSXRlbVBhdGgoY29uZmlnLCBjb2xsZWN0aW9uLCBrZXkpICsgZXh0ZW5zaW9uKTtcbiAgICAgICAgaWYgKCFuZXdFbnRyeSB8fCBuZXdFbnRyeS5jaGlsZHJlbikgY29udGludWU7XG4gICAgICAgIGVudHJpZXMucHVzaCh7XG4gICAgICAgICAga2V5OiBnZXRUcmVlS2V5KFtlbnRyeS5lbnRyeS5wYXRoLCBnZXRDb2xsZWN0aW9uSXRlbVBhdGgoY29uZmlnLCBjb2xsZWN0aW9uLCBrZXkpLCAuLi5kaXJlY3Rvcmllc1VzZWRJblNjaGVtYS5tYXAoeCA9PiBgJHt4fS8ke2tleX1gKV0sIHJvb3RUcmVlKSxcbiAgICAgICAgICBzbHVnOiBrZXlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoZW50cnkuY2hpbGRyZW4gfHwgIWtleS5lbmRzV2l0aChleHRlbnNpb24pKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHNsdWcgPSBrZXkuc2xpY2UoMCwgLWV4dGVuc2lvbi5sZW5ndGgpO1xuICAgICAgZW50cmllcy5wdXNoKHtcbiAgICAgICAga2V5OiBnZXRUcmVlS2V5KFtlbnRyeS5lbnRyeS5wYXRoLCBnZXRDb2xsZWN0aW9uSXRlbVBhdGgoY29uZmlnLCBjb2xsZWN0aW9uLCBzbHVnKSwgLi4uZGlyZWN0b3JpZXNVc2VkSW5TY2hlbWEubWFwKHggPT4gYCR7eH0vJHtzbHVnfWApXSwgcm9vdFRyZWUpLFxuICAgICAgICBzbHVnXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVudHJpZXM7XG59XG5jb25zdCBLRVlTVEFUSUNfQ0xPVURfQVBJX1VSTCA9ICdodHRwczovL2FwaS5rZXlzdGF0aWMuY2xvdWQnO1xuY29uc3QgS0VZU1RBVElDX0NMT1VEX0hFQURFUlMgPSB7XG4gICd4LWtleXN0YXRpYy12ZXJzaW9uJzogcGtnSnNvbi52ZXJzaW9uXG59O1xuY29uc3QgdGV4dEVuY29kZXIkMSA9IG5ldyBUZXh0RW5jb2RlcigpO1xuYXN5bmMgZnVuY3Rpb24gcmVkaXJlY3RUb0Nsb3VkQXV0aChmcm9tLCBjb25maWcpIHtcbiAgdmFyIF9jb25maWckY2xvdWQzO1xuICBpZiAoISgoX2NvbmZpZyRjbG91ZDMgPSBjb25maWcuY2xvdWQpICE9PSBudWxsICYmIF9jb25maWckY2xvdWQzICE9PSB2b2lkIDAgJiYgX2NvbmZpZyRjbG91ZDMucHJvamVjdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIGNsb3VkIGNvbmZpZycpO1xuICB9XG4gIGNvbnN0IGNvZGVfdmVyaWZpZXIgPSBmcm9tVWludDhBcnJheShjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDMyKSksIHRydWUpO1xuICBjb25zdCBjb2RlX2NoYWxsZW5nZSA9IGZyb21VaW50OEFycmF5KG5ldyBVaW50OEFycmF5KGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgdGV4dEVuY29kZXIkMS5lbmNvZGUoY29kZV92ZXJpZmllcikpKSwgdHJ1ZSk7XG4gIGNvbnN0IHN0YXRlID0gZnJvbVVpbnQ4QXJyYXkoY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgzMikpLCB0cnVlKTtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2tleXN0YXRpYy1jbG91ZC1zdGF0ZScsIEpTT04uc3RyaW5naWZ5KHtcbiAgICBzdGF0ZSxcbiAgICBmcm9tLFxuICAgIGNvZGVfdmVyaWZpZXJcbiAgfSkpO1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke0tFWVNUQVRJQ19DTE9VRF9BUElfVVJMfS9vYXV0aC9hdXRob3JpemVgKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3N0YXRlJywgc3RhdGUpO1xuICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnY2xpZW50X2lkJywgY29uZmlnLmNsb3VkLnByb2plY3QpO1xuICB1cmwuc2VhcmNoUGFyYW1zLnNldCgncmVkaXJlY3RfdXJpJywgYCR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn0va2V5c3RhdGljL2Nsb3VkL29hdXRoL2NhbGxiYWNrYCk7XG4gIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdyZXNwb25zZV90eXBlJywgJ2NvZGUnKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2NvZGVfY2hhbGxlbmdlX21ldGhvZCcsICdTMjU2Jyk7XG4gIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdjb2RlX2NoYWxsZW5nZScsIGNvZGVfY2hhbGxlbmdlKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2tleXN0YXRpY192ZXJzaW9uJywgcGtnSnNvbi52ZXJzaW9uKTtcbiAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcbn1cblxuY2xhc3MgRmllbGREYXRhRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnRmllbGREYXRhRXJyb3InO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFJlcXVpcmVkKHZhbHVlLCB2YWxpZGF0aW9uLCBsYWJlbCkge1xuICBpZiAodmFsdWUgPT09IG51bGwgJiYgdmFsaWRhdGlvbiAhPT0gbnVsbCAmJiB2YWxpZGF0aW9uICE9PSB2b2lkIDAgJiYgdmFsaWRhdGlvbi5pc1JlcXVpcmVkKSB7XG4gICAgdGhyb3cgbmV3IEZpZWxkRGF0YUVycm9yKGAke2xhYmVsfSBpcyByZXF1aXJlZGApO1xuICB9XG59XG5mdW5jdGlvbiBiYXNpY0Zvcm1GaWVsZFdpdGhTaW1wbGVSZWFkZXJQYXJzZShjb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiAnZm9ybScsXG4gICAgSW5wdXQ6IGNvbmZpZy5JbnB1dCxcbiAgICBkZWZhdWx0VmFsdWU6IGNvbmZpZy5kZWZhdWx0VmFsdWUsXG4gICAgcGFyc2U6IGNvbmZpZy5wYXJzZSxcbiAgICBzZXJpYWxpemU6IGNvbmZpZy5zZXJpYWxpemUsXG4gICAgdmFsaWRhdGU6IGNvbmZpZy52YWxpZGF0ZSxcbiAgICByZWFkZXI6IHtcbiAgICAgIHBhcnNlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjb25maWcudmFsaWRhdGUoY29uZmlnLnBhcnNlKHZhbHVlKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBhcnJheVZhbHVlc1RvRWxlbWVudEtleXMgPSBuZXcgV2Vha01hcCgpO1xubGV0IGNvdW50ZXIgPSAwO1xuZnVuY3Rpb24gZ2V0S2V5c0ZvckFycmF5VmFsdWUodmFsdWUpIHtcbiAgaWYgKCFhcnJheVZhbHVlc1RvRWxlbWVudEtleXMuaGFzKHZhbHVlKSkge1xuICAgIGFycmF5VmFsdWVzVG9FbGVtZW50S2V5cy5zZXQodmFsdWUsIEFycmF5LmZyb20oe1xuICAgICAgbGVuZ3RoOiB2YWx1ZS5sZW5ndGhcbiAgICB9LCBnZXROZXdBcnJheUVsZW1lbnRLZXkpKTtcbiAgfVxuICByZXR1cm4gYXJyYXlWYWx1ZXNUb0VsZW1lbnRLZXlzLmdldCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBzZXRLZXlzRm9yQXJyYXlWYWx1ZSh2YWx1ZSwgZWxlbWVudElkcykge1xuICBhcnJheVZhbHVlc1RvRWxlbWVudEtleXMuc2V0KHZhbHVlLCBlbGVtZW50SWRzKTtcbn1cbmZ1bmN0aW9uIGdldE5ld0FycmF5RWxlbWVudEtleSgpIHtcbiAgcmV0dXJuIChjb3VudGVyKyspLnRvU3RyaW5nKCk7XG59XG5jb25zdCBnZXRJbml0aWFsUHJvcHNWYWx1ZSA9IF9nZXRJbml0aWFsUHJvcHNWYWx1ZTtcbmZ1bmN0aW9uIF9nZXRJbml0aWFsUHJvcHNWYWx1ZShzY2hlbWEpIHtcbiAgc3dpdGNoIChzY2hlbWEua2luZCkge1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgcmV0dXJuIHNjaGVtYS5kZWZhdWx0VmFsdWUoKTtcbiAgICBjYXNlICdjaGlsZCc6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlICdjb25kaXRpb25hbCc6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHNjaGVtYS5kaXNjcmltaW5hbnQuZGVmYXVsdFZhbHVlKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGlzY3JpbWluYW50OiBkZWZhdWx0VmFsdWUsXG4gICAgICAgICAgdmFsdWU6IGdldEluaXRpYWxQcm9wc1ZhbHVlKHNjaGVtYS52YWx1ZXNbZGVmYXVsdFZhbHVlLnRvU3RyaW5nKCldKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWEuZmllbGRzKSkge1xuICAgICAgICAgIG9ialtrZXldID0gZ2V0SW5pdGlhbFByb3BzVmFsdWUoc2NoZW1hLmZpZWxkc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfVxuICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICB9XG4gIGFzc2VydE5ldmVyKHNjaGVtYSk7XG59XG5mdW5jdGlvbiBnZXRJbml0aWFsUHJvcHNWYWx1ZUZyb21Jbml0aWFsaXplcihzY2hlbWEsIGluaXRpYWxpemVyKSB7XG4gIHN3aXRjaCAoc2NoZW1hLmtpbmQpIHtcbiAgICBjYXNlICdmb3JtJzpcbiAgICAgIHJldHVybiBpbml0aWFsaXplciA9PT0gdW5kZWZpbmVkID8gc2NoZW1hLmRlZmF1bHRWYWx1ZSgpIDogaW5pdGlhbGl6ZXI7XG4gICAgY2FzZSAnY2hpbGQnOlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSAnY29uZGl0aW9uYWwnOlxuICAgICAge1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBpbml0aWFsaXplciA9PT0gdW5kZWZpbmVkID8gc2NoZW1hLmRpc2NyaW1pbmFudC5kZWZhdWx0VmFsdWUoKSA6IGluaXRpYWxpemVyLmRpc2NyaW1pbmFudDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXNjcmltaW5hbnQ6IGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICB2YWx1ZTogZ2V0SW5pdGlhbFByb3BzVmFsdWVGcm9tSW5pdGlhbGl6ZXIoc2NoZW1hLnZhbHVlc1tkZWZhdWx0VmFsdWUudG9TdHJpbmcoKV0sIGluaXRpYWxpemVyID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBpbml0aWFsaXplci52YWx1ZSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hLmZpZWxkcykpIHtcbiAgICAgICAgICBvYmpba2V5XSA9IGdldEluaXRpYWxQcm9wc1ZhbHVlRnJvbUluaXRpYWxpemVyKHNjaGVtYS5maWVsZHNba2V5XSwgaW5pdGlhbGl6ZXIgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGluaXRpYWxpemVyW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9XG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAge1xuICAgICAgICByZXR1cm4gKGluaXRpYWxpemVyICE9PSBudWxsICYmIGluaXRpYWxpemVyICE9PSB2b2lkIDAgPyBpbml0aWFsaXplciA6IFtdKS5tYXAoeCA9PiBnZXRJbml0aWFsUHJvcHNWYWx1ZUZyb21Jbml0aWFsaXplcihzY2hlbWEuZWxlbWVudCwgeC52YWx1ZSkpO1xuICAgICAgfVxuICB9XG4gIGFzc2VydE5ldmVyKHNjaGVtYSk7XG59XG5mdW5jdGlvbiB1cGRhdGVWYWx1ZShzY2hlbWEsIGN1cnJlbnRWYWx1ZSwgdXBkYXRlcikge1xuICBpZiAodXBkYXRlciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gY3VycmVudFZhbHVlO1xuICBzd2l0Y2ggKHNjaGVtYS5raW5kKSB7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICByZXR1cm4gdXBkYXRlcjtcbiAgICBjYXNlICdjaGlsZCc6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlICdjb25kaXRpb25hbCc6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGlzY3JpbWluYW50OiB1cGRhdGVyLmRpc2NyaW1pbmFudCxcbiAgICAgICAgICB2YWx1ZTogdXBkYXRlci5kaXNjcmltaW5hbnQgPT09IGN1cnJlbnRWYWx1ZS5kaXNjcmltaW5hbnQgPyB1cGRhdGVWYWx1ZShzY2hlbWEudmFsdWVzW3VwZGF0ZXIuZGlzY3JpbWluYW50LnRvU3RyaW5nKCldLCBjdXJyZW50VmFsdWUudmFsdWUsIHVwZGF0ZXIudmFsdWUpIDogZ2V0SW5pdGlhbFByb3BzVmFsdWVGcm9tSW5pdGlhbGl6ZXIoc2NoZW1hLnZhbHVlc1t1cGRhdGVyLmRpc2NyaW1pbmFudC50b1N0cmluZygpXSwgdXBkYXRlci52YWx1ZSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hLmZpZWxkcykpIHtcbiAgICAgICAgICBvYmpba2V5XSA9IHVwZGF0ZVZhbHVlKHNjaGVtYS5maWVsZHNba2V5XSwgY3VycmVudFZhbHVlW2tleV0sIHVwZGF0ZXJba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH1cbiAgICBjYXNlICdhcnJheSc6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRBcnJWYWwgPSBjdXJyZW50VmFsdWU7XG4gICAgICAgIGNvbnN0IG5ld1ZhbCA9IHVwZGF0ZXI7XG4gICAgICAgIGNvbnN0IHVuaXF1ZUtleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgeCBvZiBuZXdWYWwpIHtcbiAgICAgICAgICBpZiAoeC5rZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHVuaXF1ZUtleXMuaGFzKHgua2V5KSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FycmF5IGVsZW1lbnRzIG11c3QgaGF2ZSB1bmlxdWUga2V5cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5pcXVlS2V5cy5hZGQoeC5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlzID0gbmV3VmFsLm1hcCh4ID0+IHtcbiAgICAgICAgICBpZiAoeC5rZXkgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHgua2V5O1xuICAgICAgICAgIGxldCBlbGVtZW50S2V5ID0gZ2V0TmV3QXJyYXlFbGVtZW50S2V5KCk7XG4gICAgICAgICAgLy8ganVzdCBpbiBjYXNlIHNvbWVvbmUgZ2l2ZXMgYSBrZXkgdGhhdCBpcyBhYm92ZSBvdXIgY291bnRlclxuICAgICAgICAgIHdoaWxlICh1bmlxdWVLZXlzLmhhcyhlbGVtZW50S2V5KSkge1xuICAgICAgICAgICAgZWxlbWVudEtleSA9IGdldE5ld0FycmF5RWxlbWVudEtleSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1bmlxdWVLZXlzLmFkZChlbGVtZW50S2V5KTtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudEtleTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHByZXZLZXlzID0gZ2V0S2V5c0ZvckFycmF5VmFsdWUoY3VycmVudEFyclZhbCk7XG4gICAgICAgIGNvbnN0IHByZXZWYWx1ZXNCeUtleSA9IG5ldyBNYXAoY3VycmVudEFyclZhbC5tYXAoKHZhbHVlLCBpKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtwcmV2S2V5c1tpXSwgdmFsdWVdO1xuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IHZhbCA9IG5ld1ZhbC5tYXAoKHgsIGkpID0+IHtcbiAgICAgICAgICBjb25zdCBpZCA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKHByZXZWYWx1ZXNCeUtleS5oYXMoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlVmFsdWUoc2NoZW1hLmVsZW1lbnQsIHByZXZWYWx1ZXNCeUtleS5nZXQoaWQpLCB4LnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGdldEluaXRpYWxQcm9wc1ZhbHVlRnJvbUluaXRpYWxpemVyKHNjaGVtYS5lbGVtZW50LCB4LnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNldEtleXNGb3JBcnJheVZhbHVlKHZhbCwga2V5cyk7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gIH1cbiAgYXNzZXJ0TmV2ZXIoc2NoZW1hKTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVBdFByb3BQYXRoKHZhbHVlLCBpbnB1dFBhdGgpIHtcbiAgY29uc3QgcGF0aCA9IFsuLi5pbnB1dFBhdGhdO1xuICB3aGlsZSAocGF0aC5sZW5ndGgpIHtcbiAgICBjb25zdCBrZXkgPSBwYXRoLnNoaWZ0KCk7XG4gICAgdmFsdWUgPSB2YWx1ZVtrZXldO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHRyYXZlcnNlUHJvcHMoc2NoZW1hLCB2YWx1ZSwgdmlzaXRvciwgcGF0aCA9IFtdKSB7XG4gIGlmIChzY2hlbWEua2luZCA9PT0gJ2Zvcm0nIHx8IHNjaGVtYS5raW5kID09PSAnY2hpbGQnKSB7XG4gICAgdmlzaXRvcihzY2hlbWEsIHZhbHVlLCBwYXRoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNjaGVtYS5raW5kID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAoY29uc3QgW2tleSwgY2hpbGRQcm9wXSBvZiBPYmplY3QuZW50cmllcyhzY2hlbWEuZmllbGRzKSkge1xuICAgICAgdHJhdmVyc2VQcm9wcyhjaGlsZFByb3AsIHZhbHVlW2tleV0sIHZpc2l0b3IsIFsuLi5wYXRoLCBrZXldKTtcbiAgICB9XG4gICAgdmlzaXRvcihzY2hlbWEsIHZhbHVlLCBwYXRoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNjaGVtYS5raW5kID09PSAnYXJyYXknKSB7XG4gICAgZm9yIChjb25zdCBbaWR4LCB2YWxdIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgdHJhdmVyc2VQcm9wcyhzY2hlbWEuZWxlbWVudCwgdmFsLCB2aXNpdG9yLCBwYXRoLmNvbmNhdChpZHgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHZpc2l0b3Ioc2NoZW1hLCB2YWx1ZSwgcGF0aCk7XG4gIH1cbiAgaWYgKHNjaGVtYS5raW5kID09PSAnY29uZGl0aW9uYWwnKSB7XG4gICAgY29uc3QgZGlzY3JpbWluYW50ID0gdmFsdWUuZGlzY3JpbWluYW50O1xuICAgIHZpc2l0b3Ioc2NoZW1hLCBkaXNjcmltaW5hbnQsIHBhdGguY29uY2F0KCdkaXNjcmltaW5hbnQnKSk7XG4gICAgdHJhdmVyc2VQcm9wcyhzY2hlbWEudmFsdWVzW2Rpc2NyaW1pbmFudC50b1N0cmluZygpXSwgdmFsdWUudmFsdWUsIHZpc2l0b3IsIHBhdGguY29uY2F0KCd2YWx1ZScpKTtcbiAgICB2aXNpdG9yKHNjaGVtYSwgdmFsdWUsIHBhdGgpO1xuICAgIHJldHVybjtcbiAgfVxuICBhc3NlcnROZXZlciQxKHNjaGVtYSk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1Qcm9wcyhzY2hlbWEsIHZhbHVlLCB2aXNpdG9ycywgcGF0aCA9IFtdKSB7XG4gIGlmIChzY2hlbWEua2luZCA9PT0gJ2Zvcm0nIHx8IHNjaGVtYS5raW5kID09PSAnY2hpbGQnKSB7XG4gICAgaWYgKHZpc2l0b3JzW3NjaGVtYS5raW5kXSkge1xuICAgICAgcmV0dXJuIHZpc2l0b3JzW3NjaGVtYS5raW5kXShzY2hlbWEsIHZhbHVlLCBwYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChzY2hlbWEua2luZCA9PT0gJ29iamVjdCcpIHtcbiAgICBjb25zdCB2YWwgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoc2NoZW1hLmZpZWxkcykubWFwKChba2V5LCB2YWxdKSA9PiB7XG4gICAgICByZXR1cm4gW2tleSwgdHJhbnNmb3JtUHJvcHModmFsLCB2YWx1ZVtrZXldLCB2aXNpdG9ycywgWy4uLnBhdGgsIGtleV0pXTtcbiAgICB9KSk7XG4gICAgaWYgKHZpc2l0b3JzLm9iamVjdCkge1xuICAgICAgcmV0dXJuIHZpc2l0b3JzW3NjaGVtYS5raW5kXShzY2hlbWEsIHZhbCwgcGF0aCk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKHNjaGVtYS5raW5kID09PSAnYXJyYXknKSB7XG4gICAgY29uc3QgdmFsID0gdmFsdWUubWFwKCh2YWwsIGlkeCkgPT4gdHJhbnNmb3JtUHJvcHMoc2NoZW1hLmVsZW1lbnQsIHZhbCwgdmlzaXRvcnMsIHBhdGguY29uY2F0KGlkeCkpKTtcbiAgICBpZiAodmlzaXRvcnMuYXJyYXkpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yc1tzY2hlbWEua2luZF0oc2NoZW1hLCB2YWwsIHBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGlmIChzY2hlbWEua2luZCA9PT0gJ2NvbmRpdGlvbmFsJykge1xuICAgIGNvbnN0IGRpc2NyaW1pbmFudCA9IHRyYW5zZm9ybVByb3BzKHNjaGVtYS5kaXNjcmltaW5hbnQsIHZhbHVlLmRpc2NyaW1pbmFudCwgdmlzaXRvcnMsIHBhdGguY29uY2F0KCdkaXNjcmltaW5hbnQnKSk7XG4gICAgY29uc3QgY29uZGl0aW9uYWxWYWwgPSB0cmFuc2Zvcm1Qcm9wcyhzY2hlbWEudmFsdWVzW2Rpc2NyaW1pbmFudC50b1N0cmluZygpXSwgdmFsdWUudmFsdWUsIHZpc2l0b3JzLCBwYXRoLmNvbmNhdCgndmFsdWUnKSk7XG4gICAgY29uc3QgdmFsID0ge1xuICAgICAgZGlzY3JpbWluYW50LFxuICAgICAgdmFsdWU6IGNvbmRpdGlvbmFsVmFsXG4gICAgfTtcbiAgICBpZiAodmlzaXRvcnMuY29uZGl0aW9uYWwpIHtcbiAgICAgIHJldHVybiB2aXNpdG9yc1tzY2hlbWEua2luZF0oc2NoZW1hLCB2YWwsIHBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGFzc2VydE5ldmVyJDEoc2NoZW1hKTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VWYWx1ZUF0UHJvcFBhdGgoc2NoZW1hLCB2YWx1ZSwgbmV3VmFsdWUsIHBhdGgpIHtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xuICB9XG4gIGNvbnN0IFtrZXksIC4uLm5ld1BhdGhdID0gcGF0aDtcbiAgaWYgKHNjaGVtYS5raW5kID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi52YWx1ZSxcbiAgICAgIFtrZXldOiByZXBsYWNlVmFsdWVBdFByb3BQYXRoKHNjaGVtYS5maWVsZHNba2V5XSwgdmFsdWVba2V5XSwgbmV3VmFsdWUsIG5ld1BhdGgpXG4gICAgfTtcbiAgfVxuICBpZiAoc2NoZW1hLmtpbmQgPT09ICdjb25kaXRpb25hbCcpIHtcbiAgICBjb25zdCBjb25kaXRpb25hbFZhbHVlID0gdmFsdWU7XG4gICAgLy8gcmVwbGFjZVZhbHVlQXRQcm9wUGF0aCBzaG91bGQgbm90IGJlIHVzZWQgdG8gb25seSB1cGRhdGUgdGhlIGRpc2NyaW1pbmFudCBvZiBhIGNvbmRpdGlvbmFsIGZpZWxkXG4gICAgLy8gaWYgeW91IHdhbnQgdG8gdXBkYXRlIHRoZSBkaXNjcmltaW5hbnQgb2YgYSBjb25kaXRpb25hbCBmaWVsZCwgcmVwbGFjZSB0aGUgdmFsdWUgb2YgdGhlIHdob2xlIGNvbmRpdGlvbmFsIGZpZWxkXG4gICAgYXNzZXJ0JDEoa2V5ID09PSAndmFsdWUnKTtcbiAgICByZXR1cm4ge1xuICAgICAgZGlzY3JpbWluYW50OiBjb25kaXRpb25hbFZhbHVlLmRpc2NyaW1pbmFudCxcbiAgICAgIHZhbHVlOiByZXBsYWNlVmFsdWVBdFByb3BQYXRoKHNjaGVtYS52YWx1ZXNba2V5XSwgY29uZGl0aW9uYWxWYWx1ZS52YWx1ZSwgbmV3VmFsdWUsIG5ld1BhdGgpXG4gICAgfTtcbiAgfVxuICBpZiAoc2NoZW1hLmtpbmQgPT09ICdhcnJheScpIHtcbiAgICBjb25zdCBwcmV2VmFsID0gdmFsdWU7XG4gICAgY29uc3QgbmV3VmFsID0gWy4uLnByZXZWYWxdO1xuICAgIHNldEtleXNGb3JBcnJheVZhbHVlKG5ld1ZhbCwgZ2V0S2V5c0ZvckFycmF5VmFsdWUocHJldlZhbCkpO1xuICAgIG5ld1ZhbFtrZXldID0gcmVwbGFjZVZhbHVlQXRQcm9wUGF0aChzY2hlbWEuZWxlbWVudCwgbmV3VmFsW2tleV0sIG5ld1ZhbHVlLCBuZXdQYXRoKTtcbiAgICByZXR1cm4gbmV3VmFsO1xuICB9XG5cbiAgLy8gd2Ugc2hvdWxkIG5ldmVyIHJlYWNoIGhlcmUgc2luY2UgZm9ybSBvciBjaGlsZCBmaWVsZHMgZG9uJ3QgY29udGFpbiBvdGhlciBmaWVsZHNcbiAgLy8gc28gdGhlIG9ubHkgdGhpbmcgdGhhdCBjYW4gaGFwcGVuIHRvIHRoZW0gaXMgdG8gYmUgcmVwbGFjZWQgd2hpY2ggaGFwcGVucyBhdCB0aGUgc3RhcnQgb2YgdGhpcyBmdW5jdGlvbiB3aGVuIHBhdGgubGVuZ3RoID09PSAwXG4gIGFzc2VydCQxKHNjaGVtYS5raW5kICE9PSAnZm9ybScgJiYgc2NoZW1hLmtpbmQgIT09ICdjaGlsZCcpO1xuICBhc3NlcnROZXZlciQxKHNjaGVtYSk7XG59XG5cbi8vIGEgdiBpbXBvcnRhbnQgbm90ZVxuLy8gbWFya3MgaW4gdGhlIG1hcmtkb3duIGFzdC9odG1sIGFyZSByZXByZXNlbnRlZCBxdWl0ZSBkaWZmZXJlbnRseSB0byBob3cgdGhleSBhcmUgaW4gc2xhdGVcbi8vIGlmIHlvdSBoYWQgdGhlIG1hcmtkb3duICoqc29tZXRoaW5nIGh0dHBzOi8va2V5c3RvbmVqcy5jb20gc29tZXRoaW5nKipcbi8vIHRoZSBib2xkIG5vZGUgaXMgdGhlIHBhcmVudCBvZiB0aGUgbGluayBub2RlXG4vLyBidXQgaW4gc2xhdGUsIG1hcmtzIGFyZSBvbmx5IHJlcHJlc2VudGVkIG9uIHRleHQgbm9kZXNcbmNvbnN0IGN1cnJlbnRseUFjdGl2ZU1hcmtzID0gbmV3IFNldCgpO1xuY29uc3QgY3VycmVudGx5RGlzYWJsZWRNYXJrcyA9IG5ldyBTZXQoKTtcbmxldCBjdXJyZW50TGluayA9IG51bGw7XG5mdW5jdGlvbiBhZGRNYXJrVG9DaGlsZHJlbihtYXJrLCBjYikge1xuICBjb25zdCB3YXNQcmV2aW91c2x5QWN0aXZlID0gY3VycmVudGx5QWN0aXZlTWFya3MuaGFzKG1hcmspO1xuICBjdXJyZW50bHlBY3RpdmVNYXJrcy5hZGQobWFyayk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNiKCk7XG4gIH0gZmluYWxseSB7XG4gICAgaWYgKCF3YXNQcmV2aW91c2x5QWN0aXZlKSB7XG4gICAgICBjdXJyZW50bHlBY3RpdmVNYXJrcy5kZWxldGUobWFyayk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRMaW5rRm9yQ2hpbGRyZW4oaHJlZiwgY2IpIHtcbiAgLy8gd2UnbGwgb25seSB1c2UgdGhlIG91dGVyIGxpbmtcbiAgaWYgKGN1cnJlbnRMaW5rICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNiKCk7XG4gIH1cbiAgY3VycmVudExpbmsgPSBocmVmO1xuICB0cnkge1xuICAgIHJldHVybiBjYigpO1xuICB9IGZpbmFsbHkge1xuICAgIGN1cnJlbnRMaW5rID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgdHlwZSBpcyBtb3JlIHN0cmljdCB0aGFuIGBFbGVtZW50ICYgeyB0eXBlOiAnbGluayc7IH1gIGJlY2F1c2UgYGNoaWxkcmVuYFxuICogaXMgY29uc3RyYWluZWQgdG8gb25seSBjb250YWluIFRleHQgbm9kZXMuIFRoaXMgY2FuJ3QgYmUgYXNzdW1lZCBnZW5lcmFsbHkgYXJvdW5kIHRoZSBlZGl0b3JcbiAqIChiZWNhdXNlIG9mIHBvdGVudGlhbGx5IGZ1dHVyZSBpbmxpbmUgY29tcG9uZW50cyBvciBuZXN0ZWQgbGlua3Mod2hpY2ggYXJlIG5vcm1hbGl6ZWQgYXdheSBidXQgdGhlIGVkaXRvciBuZWVkcyB0byBub3QgYnJlYWsgaWYgaXQgaGFwcGVucykpXG4gKiBidXQgd2hlcmUgdGhpcyB0eXBlIGlzIHVzZWQsIHdlJ3JlIG9ubHkgZ29pbmcgdG8gYWxsb3cgbGlua3MgdG8gY29udGFpbiBUZXh0IGFuZCB0aGF0J3MgaW1wb3J0YW50XG4gKiBzbyB0aGF0IHdlIGtub3cgYSBibG9jayB3aWxsIG5ldmVyIGJlIGluc2lkZSBhbiBpbmxpbmUgYmVjYXVzZSBTbGF0ZSBnZXRzIHVuaGFwcHkgd2hlbiB0aGF0IGhhcHBlbnNcbiAqIChyZWFsbHkgdGhlIGxpbmsgaW5saW5lIHNob3VsZCBwcm9iYWJseSBiZSBhIG1hcmsgcmF0aGVyIHRoYW4gYW4gaW5saW5lLFxuICogbm9uLXZvaWQgaW5saW5lcyBhcmUgcHJvYmFibHkgYWx3YXlzIGJhZCBidXQgdGhhdCB3b3VsZCBpbXBseSBjaGFuZ2luZyB0aGUgZG9jdW1lbnRcbiAqIHN0cnVjdHVyZSB3aGljaCB3b3VsZCBiZSBzdWNoIHVubmVjZXNzYXJ5IGJyZWFrYWdlKVxuICovXG5cbmZ1bmN0aW9uIGdldElubGluZU5vZGVzKHRleHQpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0ZXh0XG4gIH07XG4gIGZvciAoY29uc3QgbWFyayBvZiBjdXJyZW50bHlBY3RpdmVNYXJrcykge1xuICAgIGlmICghY3VycmVudGx5RGlzYWJsZWRNYXJrcy5oYXMobWFyaykpIHtcbiAgICAgIG5vZGVbbWFya10gPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoY3VycmVudExpbmsgIT09IG51bGwpIHtcbiAgICByZXR1cm4gW3tcbiAgICAgIHRleHQ6ICcnXG4gICAgfSwge1xuICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgaHJlZjogY3VycmVudExpbmssXG4gICAgICBjaGlsZHJlbjogW25vZGVdXG4gICAgfSwge1xuICAgICAgdGV4dDogJydcbiAgICB9XTtcbiAgfVxuICByZXR1cm4gW25vZGVdO1xufVxuXG5jbGFzcyBWYXJpYWJsZUNoaWxkRmllbGRzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignVGhlcmUgYXJlIGEgdmFyaWFibGUgbnVtYmVyIG9mIGNoaWxkIGZpZWxkcycpO1xuICB9XG59XG5mdW5jdGlvbiBmaW5kU2luZ2xlQ2hpbGRGaWVsZChzY2hlbWEpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBfZmluZENvbnN0YW50Q2hpbGRGaWVsZHMoc2NoZW1hLCBbXSwgbmV3IFNldCgpKTtcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgVmFyaWFibGVDaGlsZEZpZWxkcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cbmZ1bmN0aW9uIF9maW5kQ29uc3RhbnRDaGlsZEZpZWxkcyhzY2hlbWEsIHBhdGgsIHNlZW5TY2hlbWFzKSB7XG4gIGlmIChzZWVuU2NoZW1hcy5oYXMoc2NoZW1hKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBzZWVuU2NoZW1hcy5hZGQoc2NoZW1hKTtcbiAgc3dpdGNoIChzY2hlbWEua2luZCkge1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNhc2UgJ2NoaWxkJzpcbiAgICAgIHJldHVybiBbe1xuICAgICAgICByZWxhdGl2ZVBhdGg6IHBhdGgsXG4gICAgICAgIG9wdGlvbnM6IHNjaGVtYS5vcHRpb25zLFxuICAgICAgICBraW5kOiAnY2hpbGQnXG4gICAgICB9XTtcbiAgICBjYXNlICdjb25kaXRpb25hbCc6XG4gICAgICB7XG4gICAgICAgIGlmIChjb3VsZENvbnRhaW5DaGlsZEZpZWxkKHNjaGVtYSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVmFyaWFibGVDaGlsZEZpZWxkcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICBjYXNlICdhcnJheSc6XG4gICAgICB7XG4gICAgICAgIGlmIChzY2hlbWEuYXNDaGlsZFRhZykge1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gX2ZpbmRDb25zdGFudENoaWxkRmllbGRzKHNjaGVtYS5lbGVtZW50LCBbXSwgc2VlblNjaGVtYXMpO1xuICAgICAgICAgIGlmIChjaGlsZC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAga2luZDogJ2FycmF5JyxcbiAgICAgICAgICAgIGFzQ2hpbGRUYWc6IHNjaGVtYS5hc0NoaWxkVGFnLFxuICAgICAgICAgICAgZmllbGQ6IHNjaGVtYSxcbiAgICAgICAgICAgIHJlbGF0aXZlUGF0aDogcGF0aCxcbiAgICAgICAgICAgIGNoaWxkOiBjaGlsZFswXVxuICAgICAgICAgIH1dO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VsZENvbnRhaW5DaGlsZEZpZWxkKHNjaGVtYSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVmFyaWFibGVDaGlsZEZpZWxkcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAge1xuICAgICAgICBjb25zdCBwYXRocyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzY2hlbWEuZmllbGRzKSkge1xuICAgICAgICAgIHBhdGhzLnB1c2goLi4uX2ZpbmRDb25zdGFudENoaWxkRmllbGRzKHZhbHVlLCBwYXRoLmNvbmNhdChrZXkpLCBzZWVuU2NoZW1hcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRocztcbiAgICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY291bGRDb250YWluQ2hpbGRGaWVsZChzY2hlbWEsIHNlZW4gPSBuZXcgU2V0KCkpIHtcbiAgaWYgKHNlZW4uaGFzKHNjaGVtYSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc2Vlbi5hZGQoc2NoZW1hKTtcbiAgc3dpdGNoIChzY2hlbWEua2luZCkge1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNhc2UgJ2NoaWxkJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgJ2NvbmRpdGlvbmFsJzpcbiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHNjaGVtYS52YWx1ZXMpLnNvbWUodmFsdWUgPT4gY291bGRDb250YWluQ2hpbGRGaWVsZCh2YWx1ZSwgc2VlbikpO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoc2NoZW1hLmZpZWxkcykuc29tZShrZXkgPT4gY291bGRDb250YWluQ2hpbGRGaWVsZChzY2hlbWEuZmllbGRzW2tleV0sIHNlZW4pKTtcbiAgICBjYXNlICdhcnJheSc6XG4gICAgICByZXR1cm4gY291bGRDb250YWluQ2hpbGRGaWVsZChzY2hlbWEuZWxlbWVudCwgc2Vlbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5saW5lTm9kZUZyb21NYXJrZG9jKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ2lubGluZScpIHtcbiAgICByZXR1cm4gaW5saW5lQ2hpbGRyZW5Gcm9tTWFya2RvYyhub2RlLmNoaWxkcmVuKTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAnbGluaycpIHtcbiAgICByZXR1cm4gc2V0TGlua0ZvckNoaWxkcmVuKG5vZGUuYXR0cmlidXRlcy5ocmVmLCAoKSA9PiBpbmxpbmVDaGlsZHJlbkZyb21NYXJrZG9jKG5vZGUuY2hpbGRyZW4pKTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAndGV4dCcpIHtcbiAgICByZXR1cm4gZ2V0SW5saW5lTm9kZXMobm9kZS5hdHRyaWJ1dGVzLmNvbnRlbnQpO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09ICdzdHJvbmcnKSB7XG4gICAgcmV0dXJuIGFkZE1hcmtUb0NoaWxkcmVuKCdib2xkJywgKCkgPT4gaW5saW5lQ2hpbGRyZW5Gcm9tTWFya2RvYyhub2RlLmNoaWxkcmVuKSk7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ2NvZGUnKSB7XG4gICAgcmV0dXJuIGFkZE1hcmtUb0NoaWxkcmVuKCdjb2RlJywgKCkgPT4gW3tcbiAgICAgIHRleHQ6IG5vZGUuYXR0cmlidXRlcy5jb250ZW50LFxuICAgICAgY29kZTogdHJ1ZVxuICAgIH1dKTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAnZW0nKSB7XG4gICAgcmV0dXJuIGFkZE1hcmtUb0NoaWxkcmVuKCdpdGFsaWMnLCAoKSA9PiBpbmxpbmVDaGlsZHJlbkZyb21NYXJrZG9jKG5vZGUuY2hpbGRyZW4pKTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAncycpIHtcbiAgICByZXR1cm4gYWRkTWFya1RvQ2hpbGRyZW4oJ3N0cmlrZXRocm91Z2gnLCAoKSA9PiBpbmxpbmVDaGlsZHJlbkZyb21NYXJrZG9jKG5vZGUuY2hpbGRyZW4pKTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAndGFnJykge1xuICAgIGlmIChub2RlLnRhZyA9PT0gJ3UnKSB7XG4gICAgICByZXR1cm4gYWRkTWFya1RvQ2hpbGRyZW4oJ3VuZGVybGluZScsICgpID0+IGlubGluZUNoaWxkcmVuRnJvbU1hcmtkb2Mobm9kZS5jaGlsZHJlbikpO1xuICAgIH1cbiAgICBpZiAobm9kZS50YWcgPT09ICdrYmQnKSB7XG4gICAgICByZXR1cm4gYWRkTWFya1RvQ2hpbGRyZW4oJ2tleWJvYXJkJywgKCkgPT4gaW5saW5lQ2hpbGRyZW5Gcm9tTWFya2RvYyhub2RlLmNoaWxkcmVuKSk7XG4gICAgfVxuICAgIGlmIChub2RlLnRhZyA9PT0gJ3N1YicpIHtcbiAgICAgIHJldHVybiBhZGRNYXJrVG9DaGlsZHJlbignc3Vic2NyaXB0JywgKCkgPT4gaW5saW5lQ2hpbGRyZW5Gcm9tTWFya2RvYyhub2RlLmNoaWxkcmVuKSk7XG4gICAgfVxuICAgIGlmIChub2RlLnRhZyA9PT0gJ3N1cCcpIHtcbiAgICAgIHJldHVybiBhZGRNYXJrVG9DaGlsZHJlbignc3VwZXJzY3JpcHQnLCAoKSA9PiBpbmxpbmVDaGlsZHJlbkZyb21NYXJrZG9jKG5vZGUuY2hpbGRyZW4pKTtcbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ3NvZnRicmVhaycpIHtcbiAgICByZXR1cm4gZ2V0SW5saW5lTm9kZXMoJyAnKTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAnaGFyZGJyZWFrJykge1xuICAgIHJldHVybiBnZXRJbmxpbmVOb2RlcygnXFxuJyk7XG4gIH1cbiAgaWYgKG5vZGUudGFnID09PSAnY29tcG9uZW50LWlubGluZS1wcm9wJyAmJiBBcnJheS5pc0FycmF5KG5vZGUuYXR0cmlidXRlcy5wcm9wUGF0aCkgJiYgbm9kZS5hdHRyaWJ1dGVzLnByb3BQYXRoLmV2ZXJ5KHggPT4gdHlwZW9mIHggPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB4ID09PSAnbnVtYmVyJykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2NvbXBvbmVudC1pbmxpbmUtcHJvcCcsXG4gICAgICBjaGlsZHJlbjogaW5saW5lRnJvbU1hcmtkb2Mobm9kZS5jaGlsZHJlbiksXG4gICAgICBwcm9wUGF0aDogbm9kZS5hdHRyaWJ1dGVzLnByb3BQYXRoXG4gICAgfTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gaW5saW5lIG5vZGUgdHlwZTogJHtub2RlLnR5cGV9YCk7XG59XG5mdW5jdGlvbiBpbmxpbmVDaGlsZHJlbkZyb21NYXJrZG9jKG5vZGVzKSB7XG4gIHJldHVybiBub2Rlcy5mbGF0TWFwKGlubGluZU5vZGVGcm9tTWFya2RvYyk7XG59XG5mdW5jdGlvbiBpbmxpbmVGcm9tTWFya2RvYyhub2Rlcykge1xuICBjb25zdCB0cmFuc2Zvcm1lZE5vZGVzID0gbm9kZXMuZmxhdE1hcChpbmxpbmVOb2RlRnJvbU1hcmtkb2MpO1xuICBjb25zdCBuZXh0Tm9kZXMgPSBbXTtcbiAgbGV0IGxhc3ROb2RlO1xuICBmb3IgKGNvbnN0IFtpZHgsIG5vZGVdIG9mIHRyYW5zZm9ybWVkTm9kZXMuZW50cmllcygpKSB7XG4gICAgdmFyIF9sYXN0Tm9kZTtcbiAgICBpZiAobm9kZS50eXBlID09PSB1bmRlZmluZWQgJiYgbm9kZS50ZXh0ID09PSAnJyAmJiAoKF9sYXN0Tm9kZSA9IGxhc3ROb2RlKSA9PT0gbnVsbCB8fCBfbGFzdE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sYXN0Tm9kZS50eXBlKSA9PT0gdW5kZWZpbmVkICYmIGlkeCAhPT0gdHJhbnNmb3JtZWROb2Rlcy5sZW5ndGggLSAxKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbmV4dE5vZGVzLnB1c2gobm9kZSk7XG4gICAgbGFzdE5vZGUgPSBub2RlO1xuICB9XG4gIGlmICghbmV4dE5vZGVzLmxlbmd0aCkge1xuICAgIG5leHROb2Rlcy5wdXNoKHtcbiAgICAgIHRleHQ6ICcnXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5leHROb2Rlcztcbn1cbmZ1bmN0aW9uIGZyb21NYXJrZG9jKG5vZGUsIGNvbXBvbmVudEJsb2Nrcykge1xuICBjb25zdCBub2RlcyA9IG5vZGUuY2hpbGRyZW4uZmxhdE1hcCh4ID0+IGZyb21NYXJrZG9jTm9kZSh4LCBjb21wb25lbnRCbG9ja3MpKTtcbiAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbe1xuICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdGV4dDogJydcbiAgICAgIH1dXG4gICAgfV07XG4gIH1cbiAgaWYgKG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdLnR5cGUgIT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgbm9kZXMucHVzaCh7XG4gICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0ZXh0OiAnJ1xuICAgICAgfV1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbm9kZXM7XG59XG5mdW5jdGlvbiBmcm9tTWFya2RvY05vZGUobm9kZSwgY29tcG9uZW50QmxvY2tzKSB7XG4gIGlmIChub2RlLnR5cGUgPT09ICdibG9ja3F1b3RlJykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnYmxvY2txdW90ZScsXG4gICAgICBjaGlsZHJlbjogbm9kZS5jaGlsZHJlbi5mbGF0TWFwKHggPT4gZnJvbU1hcmtkb2NOb2RlKHgsIGNvbXBvbmVudEJsb2NrcykpXG4gICAgfTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAnZmVuY2UnKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGFuZ3VhZ2UsXG4gICAgICBjb250ZW50LFxuICAgICAgLi4ucmVzdFxuICAgIH0gPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0ZXh0OiBjb250ZW50LnJlcGxhY2UoL1xcbiQvLCAnJylcbiAgICAgIH1dLFxuICAgICAgLi4uKHR5cGVvZiBsYW5ndWFnZSA9PT0gJ3N0cmluZycgPyB7XG4gICAgICAgIGxhbmd1YWdlXG4gICAgICB9IDoge30pLFxuICAgICAgLi4ucmVzdFxuICAgIH07XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ2hlYWRpbmcnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLm5vZGUuYXR0cmlidXRlcyxcbiAgICAgIGxldmVsOiBub2RlLmF0dHJpYnV0ZXMubGV2ZWwsXG4gICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICBjaGlsZHJlbjogaW5saW5lRnJvbU1hcmtkb2Mobm9kZS5jaGlsZHJlbilcbiAgICB9O1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09ICdsaXN0Jykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBub2RlLmF0dHJpYnV0ZXMub3JkZXJlZCA/ICdvcmRlcmVkLWxpc3QnIDogJ3Vub3JkZXJlZC1saXN0JyxcbiAgICAgIGNoaWxkcmVuOiBub2RlLmNoaWxkcmVuLmZsYXRNYXAoeCA9PiBmcm9tTWFya2RvY05vZGUoeCwgY29tcG9uZW50QmxvY2tzKSlcbiAgICB9O1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09ICdpdGVtJykge1xuICAgIHZhciBfbm9kZSRjaGlsZHJlbiQ7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBbe1xuICAgICAgdHlwZTogJ2xpc3QtaXRlbS1jb250ZW50JyxcbiAgICAgIGNoaWxkcmVuOiBub2RlLmNoaWxkcmVuLmxlbmd0aCA/IGlubGluZUZyb21NYXJrZG9jKFtub2RlLmNoaWxkcmVuWzBdXSkgOiBbe1xuICAgICAgICB0ZXh0OiAnJ1xuICAgICAgfV1cbiAgICB9XTtcbiAgICBpZiAoKChfbm9kZSRjaGlsZHJlbiQgPSBub2RlLmNoaWxkcmVuWzFdKSA9PT0gbnVsbCB8fCBfbm9kZSRjaGlsZHJlbiQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJGNoaWxkcmVuJC50eXBlKSA9PT0gJ2xpc3QnKSB7XG4gICAgICBjb25zdCBsaXN0ID0gbm9kZS5jaGlsZHJlblsxXTtcbiAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICB0eXBlOiBsaXN0LmF0dHJpYnV0ZXMub3JkZXJlZCA/ICdvcmRlcmVkLWxpc3QnIDogJ3Vub3JkZXJlZC1saXN0JyxcbiAgICAgICAgY2hpbGRyZW46IGxpc3QuY2hpbGRyZW4uZmxhdE1hcCh4ID0+IGZyb21NYXJrZG9jTm9kZSh4LCBjb21wb25lbnRCbG9ja3MpKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnbGlzdC1pdGVtJyxcbiAgICAgIGNoaWxkcmVuXG4gICAgfTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBub2RlLmNoaWxkcmVuWzBdLnR5cGUgPT09ICdpbmxpbmUnICYmIG5vZGUuY2hpbGRyZW5bMF0uY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIG5vZGUuY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0udHlwZSA9PT0gJ2ltYWdlJykge1xuICAgICAgdmFyIF9pbWFnZSRhdHRyaWJ1dGVzJHRpdDtcbiAgICAgIGNvbnN0IGltYWdlID0gbm9kZS5jaGlsZHJlblswXS5jaGlsZHJlblswXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgIHNyYzogZGVjb2RlVVJJKGltYWdlLmF0dHJpYnV0ZXMuc3JjKSxcbiAgICAgICAgYWx0OiBpbWFnZS5hdHRyaWJ1dGVzLmFsdCxcbiAgICAgICAgdGl0bGU6IChfaW1hZ2UkYXR0cmlidXRlcyR0aXQgPSBpbWFnZS5hdHRyaWJ1dGVzLnRpdGxlKSAhPT0gbnVsbCAmJiBfaW1hZ2UkYXR0cmlidXRlcyR0aXQgIT09IHZvaWQgMCA/IF9pbWFnZSRhdHRyaWJ1dGVzJHRpdCA6ICcnLFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICB9XVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSBpbmxpbmVGcm9tTWFya2RvYyhub2RlLmNoaWxkcmVuKTtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGNoaWxkcmVuWzBdLnR5cGUgPT09ICdjb21wb25lbnQtaW5saW5lLXByb3AnKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5bMF07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgdGV4dEFsaWduOiBub2RlLmF0dHJpYnV0ZXMudGV4dEFsaWduXG4gICAgfTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAnaHInKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdkaXZpZGVyJyxcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0ZXh0OiAnJ1xuICAgICAgfV1cbiAgICB9O1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09ICd0YWJsZScpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3RhYmxlJyxcbiAgICAgIGNoaWxkcmVuOiBub2RlLmNoaWxkcmVuLmZsYXRNYXAoeCA9PiBmcm9tTWFya2RvY05vZGUoeCwgY29tcG9uZW50QmxvY2tzKSlcbiAgICB9O1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09ICd0Ym9keScpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3RhYmxlLWJvZHknLFxuICAgICAgY2hpbGRyZW46IG5vZGUuY2hpbGRyZW4uZmxhdE1hcCh4ID0+IGZyb21NYXJrZG9jTm9kZSh4LCBjb21wb25lbnRCbG9ja3MpKVxuICAgIH07XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ3RoZWFkJykge1xuICAgIGlmICghbm9kZS5jaGlsZHJlbi5sZW5ndGgpIHJldHVybiBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3RhYmxlLWhlYWQnLFxuICAgICAgY2hpbGRyZW46IG5vZGUuY2hpbGRyZW4uZmxhdE1hcCh4ID0+IGZyb21NYXJrZG9jTm9kZSh4LCBjb21wb25lbnRCbG9ja3MpKVxuICAgIH07XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ3RyJykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAndGFibGUtcm93JyxcbiAgICAgIGNoaWxkcmVuOiBub2RlLmNoaWxkcmVuLmZsYXRNYXAoeCA9PiBmcm9tTWFya2RvY05vZGUoeCwgY29tcG9uZW50QmxvY2tzKSlcbiAgICB9O1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09ICd0ZCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3RhYmxlLWNlbGwnLFxuICAgICAgY2hpbGRyZW46IG5vZGUuY2hpbGRyZW4uZmxhdE1hcCh4ID0+IGZyb21NYXJrZG9jTm9kZSh4LCBjb21wb25lbnRCbG9ja3MpKVxuICAgIH07XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ3RoJykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAndGFibGUtY2VsbCcsXG4gICAgICBoZWFkZXI6IHRydWUsXG4gICAgICBjaGlsZHJlbjogbm9kZS5jaGlsZHJlbi5mbGF0TWFwKHggPT4gZnJvbU1hcmtkb2NOb2RlKHgsIGNvbXBvbmVudEJsb2NrcykpXG4gICAgfTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAndGFnJykge1xuICAgIGlmIChub2RlLnRhZyA9PT0gJ3RhYmxlJykge1xuICAgICAgcmV0dXJuIGZyb21NYXJrZG9jTm9kZShub2RlLmNoaWxkcmVuWzBdLCBjb21wb25lbnRCbG9ja3MpO1xuICAgIH1cbiAgICBpZiAobm9kZS50YWcgPT09ICdsYXlvdXQnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnbGF5b3V0JyxcbiAgICAgICAgbGF5b3V0OiBub2RlLmF0dHJpYnV0ZXMubGF5b3V0LFxuICAgICAgICBjaGlsZHJlbjogbm9kZS5jaGlsZHJlbi5mbGF0TWFwKHggPT4gZnJvbU1hcmtkb2NOb2RlKHgsIGNvbXBvbmVudEJsb2NrcykpXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobm9kZS50YWcgPT09ICdsYXlvdXQtYXJlYScpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdsYXlvdXQtYXJlYScsXG4gICAgICAgIGNoaWxkcmVuOiBub2RlLmNoaWxkcmVuLmZsYXRNYXAoeCA9PiBmcm9tTWFya2RvY05vZGUoeCwgY29tcG9uZW50QmxvY2tzKSlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChub2RlLnRhZyA9PT0gJ2NvbXBvbmVudC1ibG9jaycpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdjb21wb25lbnQtYmxvY2snLFxuICAgICAgICBjb21wb25lbnQ6IG5vZGUuYXR0cmlidXRlcy5jb21wb25lbnQsXG4gICAgICAgIHByb3BzOiBub2RlLmF0dHJpYnV0ZXMucHJvcHMsXG4gICAgICAgIGNoaWxkcmVuOiBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCA/IFt7XG4gICAgICAgICAgdHlwZTogJ2NvbXBvbmVudC1pbmxpbmUtcHJvcCcsXG4gICAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgIH1dXG4gICAgICAgIH1dIDogbm9kZS5jaGlsZHJlbi5mbGF0TWFwKHggPT4gZnJvbU1hcmtkb2NOb2RlKHgsIGNvbXBvbmVudEJsb2NrcykpXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobm9kZS50YWcgPT09ICdjb21wb25lbnQtYmxvY2stcHJvcCcgJiYgQXJyYXkuaXNBcnJheShub2RlLmF0dHJpYnV0ZXMucHJvcFBhdGgpICYmIG5vZGUuYXR0cmlidXRlcy5wcm9wUGF0aC5ldmVyeSh4ID0+IHR5cGVvZiB4ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgeCA9PT0gJ251bWJlcicpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnY29tcG9uZW50LWJsb2NrLXByb3AnLFxuICAgICAgICBjaGlsZHJlbjogbm9kZS5jaGlsZHJlbi5mbGF0TWFwKHggPT4gZnJvbU1hcmtkb2NOb2RlKHgsIGNvbXBvbmVudEJsb2NrcykpLFxuICAgICAgICBwcm9wUGF0aDogbm9kZS5hdHRyaWJ1dGVzLnByb3BQYXRoXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobm9kZS50YWcpIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudEJsb2NrID0gY29tcG9uZW50QmxvY2tzW25vZGUudGFnXTtcbiAgICAgIGlmIChjb21wb25lbnRCbG9jaykge1xuICAgICAgICBjb25zdCBzaW5nbGVDaGlsZEZpZWxkID0gZmluZFNpbmdsZUNoaWxkRmllbGQoe1xuICAgICAgICAgIGtpbmQ6ICdvYmplY3QnLFxuICAgICAgICAgIGZpZWxkczogY29tcG9uZW50QmxvY2suc2NoZW1hXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2luZ2xlQ2hpbGRGaWVsZCkge1xuICAgICAgICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG5vZGUuYXR0cmlidXRlcykpO1xuICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gW107XG4gICAgICAgICAgdG9DaGlsZHJlbkFuZFByb3BzJDEobm9kZS5jaGlsZHJlbiwgY2hpbGRyZW4sIG5ld0F0dHJpYnV0ZXMsIHNpbmdsZUNoaWxkRmllbGQsIFtdLCBjb21wb25lbnRCbG9ja3MpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnY29tcG9uZW50LWJsb2NrJyxcbiAgICAgICAgICAgIGNvbXBvbmVudDogbm9kZS50YWcsXG4gICAgICAgICAgICBwcm9wczogbmV3QXR0cmlidXRlcyxcbiAgICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdjb21wb25lbnQtYmxvY2snLFxuICAgICAgICAgIGNvbXBvbmVudDogbm9kZS50YWcsXG4gICAgICAgICAgcHJvcHM6IG5vZGUuYXR0cmlidXRlcyxcbiAgICAgICAgICBjaGlsZHJlbjogbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDAgPyBbe1xuICAgICAgICAgICAgdHlwZTogJ2NvbXBvbmVudC1pbmxpbmUtcHJvcCcsXG4gICAgICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfV0gOiBub2RlLmNoaWxkcmVuLmZsYXRNYXAoeCA9PiBmcm9tTWFya2RvY05vZGUoeCwgY29tcG9uZW50QmxvY2tzKSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHRhZzogJHtub2RlLnRhZ31gKTtcbiAgfVxuICByZXR1cm4gaW5saW5lTm9kZUZyb21NYXJrZG9jKG5vZGUpO1xufVxuZnVuY3Rpb24gdG9DaGlsZHJlbkFuZFByb3BzJDEoZnJvbU1hcmtkb2MsIHJlc3VsdGluZ0NoaWxkcmVuLCB2YWx1ZSwgc2luZ2xlQ2hpbGRGaWVsZCwgcGFyZW50UHJvcFBhdGgsIGNvbXBvbmVudEJsb2Nrcykge1xuICBpZiAoc2luZ2xlQ2hpbGRGaWVsZC5raW5kID09PSAnY2hpbGQnKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBmcm9tTWFya2RvYy5mbGF0TWFwKHggPT4gZnJvbU1hcmtkb2NOb2RlKHgsIGNvbXBvbmVudEJsb2NrcykpO1xuICAgIHJlc3VsdGluZ0NoaWxkcmVuLnB1c2goe1xuICAgICAgdHlwZTogYGNvbXBvbmVudC0ke3NpbmdsZUNoaWxkRmllbGQub3B0aW9ucy5raW5kfS1wcm9wYCxcbiAgICAgIHByb3BQYXRoOiBbLi4ucGFyZW50UHJvcFBhdGgsIC4uLnNpbmdsZUNoaWxkRmllbGQucmVsYXRpdmVQYXRoXSxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSk7XG4gIH1cbiAgaWYgKHNpbmdsZUNoaWxkRmllbGQua2luZCA9PT0gJ2FycmF5Jykge1xuICAgIGNvbnN0IGFyciA9IFtdO1xuICAgIGZvciAobGV0IFtpZHgsIGNoaWxkXSBvZiBmcm9tTWFya2RvYy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChjaGlsZC50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICBjaGlsZCA9IGNoaWxkLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLnR5cGUgIT09ICd0YWcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgdGFnICR7c2luZ2xlQ2hpbGRGaWVsZC5hc0NoaWxkVGFnfSwgZm91bmQgdHlwZTogJHtjaGlsZC50eXBlfWApO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLnRhZyAhPT0gc2luZ2xlQ2hpbGRGaWVsZC5hc0NoaWxkVGFnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgdGFnICR7c2luZ2xlQ2hpbGRGaWVsZC5hc0NoaWxkVGFnfSwgZm91bmQgdGFnOiAke2NoaWxkLnRhZ31gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNoaWxkLmF0dHJpYnV0ZXMpKTtcbiAgICAgIGlmIChzaW5nbGVDaGlsZEZpZWxkLmNoaWxkKSB7XG4gICAgICAgIHRvQ2hpbGRyZW5BbmRQcm9wcyQxKGNoaWxkLmNoaWxkcmVuLCByZXN1bHRpbmdDaGlsZHJlbiwgYXR0cmlidXRlcywgc2luZ2xlQ2hpbGRGaWVsZC5jaGlsZCwgWy4uLnBhcmVudFByb3BQYXRoLCAuLi5zaW5nbGVDaGlsZEZpZWxkLnJlbGF0aXZlUGF0aCwgaWR4XSwgY29tcG9uZW50QmxvY2tzKTtcbiAgICAgIH1cbiAgICAgIGFyci5wdXNoKGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBzaW5nbGVDaGlsZEZpZWxkLnJlbGF0aXZlUGF0aFtzaW5nbGVDaGlsZEZpZWxkLnJlbGF0aXZlUGF0aC5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBwYXJlbnQgPSBnZXRWYWx1ZUF0UHJvcFBhdGgodmFsdWUsIHNpbmdsZUNoaWxkRmllbGQucmVsYXRpdmVQYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgcGFyZW50W2tleV0gPSBhcnI7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXJlQXJyYXlzRXF1YWwoYSwgYikge1xuICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoKHgsIGkpID0+IHggPT09IGJbaV0pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVGV4dEJhc2VkT25JbmxpbmVNYXJrc0FuZFNvZnRCcmVha3MoW25vZGUsIHBhdGhdLCBlZGl0b3IsIGlubGluZU1hcmtzLCBzb2Z0QnJlYWtzKSB7XG4gIGNvbnN0IG1hcmtzVG9SZW1vdmUgPSBPYmplY3Qua2V5cyhub2RlKS5maWx0ZXIoeCA9PiB4ICE9PSAndGV4dCcgJiYgeCAhPT0gJ2luc2VydE1lbnUnICYmIGlubGluZU1hcmtzW3hdICE9PSB0cnVlKTtcbiAgaWYgKG1hcmtzVG9SZW1vdmUubGVuZ3RoKSB7XG4gICAgVHJhbnNmb3Jtcy51bnNldE5vZGVzKGVkaXRvciwgbWFya3NUb1JlbW92ZSwge1xuICAgICAgYXQ6IHBhdGhcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIXNvZnRCcmVha3MpIHtcbiAgICBjb25zdCBoYXNTb2Z0QnJlYWtzID0gbm9kZS50ZXh0LmluY2x1ZGVzKCdcXG4nKTtcbiAgICBpZiAoaGFzU29mdEJyZWFrcykge1xuICAgICAgY29uc3QgW3BhcmVudE5vZGVdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHBhdGgpO1xuICAgICAgaWYgKHBhcmVudE5vZGUudHlwZSAhPT0gJ2NvZGUnKSB7XG4gICAgICAgIGZvciAoY29uc3QgcG9zaXRpb24gb2YgRWRpdG9yLnBvc2l0aW9ucyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aFxuICAgICAgICB9KSkge1xuICAgICAgICAgIGNvbnN0IGNoYXJhY3RlciA9IE5vZGUuZ2V0KGVkaXRvciwgcG9zaXRpb24ucGF0aCkudGV4dFtwb3NpdGlvbi5vZmZzZXRdO1xuICAgICAgICAgIGlmIChjaGFyYWN0ZXIgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IHBvc2l0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBub3JtYWxpemVJbmxpbmVCYXNlZE9uTGlua3MoW25vZGUsIHBhdGhdLCBlZGl0b3IsIGxpbmtzKSB7XG4gIGlmIChub2RlLnR5cGUgPT09ICdsaW5rJyAmJiAhbGlua3MpIHtcbiAgICBUcmFuc2Zvcm1zLmluc2VydFRleHQoZWRpdG9yLCBgICgke25vZGUuaHJlZn0pYCwge1xuICAgICAgYXQ6IEVkaXRvci5lbmQoZWRpdG9yLCBwYXRoKVxuICAgIH0pO1xuICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogcGF0aFxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUVsZW1lbnRCYXNlZE9uRG9jdW1lbnRGZWF0dXJlcyhbbm9kZSwgcGF0aF0sIGVkaXRvciwge1xuICBmb3JtYXR0aW5nLFxuICBkaXZpZGVycyxcbiAgbGF5b3V0cyxcbiAgbGlua3MsXG4gIGltYWdlcyxcbiAgdGFibGVzXG59KSB7XG4gIGlmIChub2RlLnR5cGUgPT09ICdoZWFkaW5nJyAmJiAoIWZvcm1hdHRpbmcuaGVhZGluZ3MubGV2ZWxzLmxlbmd0aCB8fCAhZm9ybWF0dGluZy5oZWFkaW5ncy5sZXZlbHMuaW5jbHVkZXMobm9kZS5sZXZlbCkpIHx8IG5vZGUudHlwZSA9PT0gJ29yZGVyZWQtbGlzdCcgJiYgIWZvcm1hdHRpbmcubGlzdFR5cGVzLm9yZGVyZWQgfHwgbm9kZS50eXBlID09PSAndW5vcmRlcmVkLWxpc3QnICYmICFmb3JtYXR0aW5nLmxpc3RUeXBlcy51bm9yZGVyZWQgfHwgbm9kZS50eXBlID09PSAnY29kZScgJiYgIWZvcm1hdHRpbmcuYmxvY2tUeXBlcy5jb2RlIHx8IG5vZGUudHlwZSA9PT0gJ2Jsb2NrcXVvdGUnICYmICFmb3JtYXR0aW5nLmJsb2NrVHlwZXMuYmxvY2txdW90ZSB8fCBub2RlLnR5cGUgPT09ICdpbWFnZScgJiYgIWltYWdlcyB8fCBub2RlLnR5cGUgPT09ICd0YWJsZScgJiYgIXRhYmxlcyB8fCBub2RlLnR5cGUgPT09ICdsYXlvdXQnICYmIChsYXlvdXRzLmxlbmd0aCA9PT0gMCB8fCAhbGF5b3V0cy5zb21lKGxheW91dCA9PiBhcmVBcnJheXNFcXVhbChsYXlvdXQsIG5vZGUubGF5b3V0KSkpKSB7XG4gICAgVHJhbnNmb3Jtcy51bndyYXBOb2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBwYXRoXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKChub2RlLnR5cGUgPT09ICdwYXJhZ3JhcGgnIHx8IG5vZGUudHlwZSA9PT0gJ2hlYWRpbmcnKSAmJiAoIWZvcm1hdHRpbmcuYWxpZ25tZW50LmNlbnRlciAmJiBub2RlLnRleHRBbGlnbiA9PT0gJ2NlbnRlcicgfHwgIWZvcm1hdHRpbmcuYWxpZ25tZW50LmVuZCAmJiBub2RlLnRleHRBbGlnbiA9PT0gJ2VuZCcgfHwgJ3RleHRBbGlnbicgaW4gbm9kZSAmJiBub2RlLnRleHRBbGlnbiAhPT0gJ2NlbnRlcicgJiYgbm9kZS50ZXh0QWxpZ24gIT09ICdlbmQnKSkge1xuICAgIFRyYW5zZm9ybXMudW5zZXROb2RlcyhlZGl0b3IsICd0ZXh0QWxpZ24nLCB7XG4gICAgICBhdDogcGF0aFxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09ICdkaXZpZGVyJyAmJiAhZGl2aWRlcnMpIHtcbiAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IHBhdGhcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplSW5saW5lQmFzZWRPbkxpbmtzKFtub2RlLCBwYXRoXSwgZWRpdG9yLCBsaW5rcyk7XG59XG5mdW5jdGlvbiB3aXRoRG9jdW1lbnRGZWF0dXJlc05vcm1hbGl6YXRpb24oZG9jdW1lbnRGZWF0dXJlcywgZWRpdG9yKSB7XG4gIGNvbnN0IHtcbiAgICBub3JtYWxpemVOb2RlXG4gIH0gPSBlZGl0b3I7XG4gIGVkaXRvci5ub3JtYWxpemVOb2RlID0gKFtub2RlLCBwYXRoXSkgPT4ge1xuICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgbm9ybWFsaXplVGV4dEJhc2VkT25JbmxpbmVNYXJrc0FuZFNvZnRCcmVha3MoW25vZGUsIHBhdGhdLCBlZGl0b3IsIGRvY3VtZW50RmVhdHVyZXMuZm9ybWF0dGluZy5pbmxpbmVNYXJrcywgZG9jdW1lbnRGZWF0dXJlcy5mb3JtYXR0aW5nLnNvZnRCcmVha3MpO1xuICAgIH0gZWxzZSBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSkge1xuICAgICAgbm9ybWFsaXplRWxlbWVudEJhc2VkT25Eb2N1bWVudEZlYXR1cmVzKFtub2RlLCBwYXRoXSwgZWRpdG9yLCBkb2N1bWVudEZlYXR1cmVzKTtcbiAgICB9XG4gICAgbm9ybWFsaXplTm9kZShbbm9kZSwgcGF0aF0pO1xuICB9O1xuICByZXR1cm4gZWRpdG9yO1xufVxuXG5mdW5jdGlvbiBnZXRTcmNQcmVmaXgocHVibGljUGF0aCwgc2x1Zykge1xuICByZXR1cm4gdHlwZW9mIHB1YmxpY1BhdGggPT09ICdzdHJpbmcnID8gYCR7cHVibGljUGF0aC5yZXBsYWNlKC9cXC8qJC8sICcnKX0vJHtzbHVnID09PSB1bmRlZmluZWQgPyAnJyA6IHNsdWcgKyAnLyd9YCA6ICcnO1xufVxuXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUZpbGVzKG5vZGVzLCBjb21wb25lbnRCbG9ja3MsIGZpbGVzLCBvdGhlckZpbGVzLCBtb2RlLCBkb2N1bWVudEZlYXR1cmVzLCBzbHVnKSB7XG4gIHJldHVybiBub2Rlcy5tYXAobm9kZSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ2NvbXBvbmVudC1ibG9jaycpIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudEJsb2NrID0gY29tcG9uZW50QmxvY2tzW25vZGUuY29tcG9uZW50XTtcbiAgICAgIGlmICghY29tcG9uZW50QmxvY2spIHJldHVybiBub2RlO1xuICAgICAgY29uc3Qgc2NoZW1hID0gb2JqZWN0KGNvbXBvbmVudEJsb2NrLnNjaGVtYSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5ub2RlLFxuICAgICAgICBwcm9wczogZGVzZXJpYWxpemVQcm9wcyhzY2hlbWEsIG5vZGUucHJvcHMsIGZpbGVzLCBvdGhlckZpbGVzLCBtb2RlLCBzbHVnKVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ2ltYWdlJyAmJiB0eXBlb2Ygbm9kZS5zcmMgPT09ICdzdHJpbmcnICYmIG1vZGUgPT09ICdlZGl0Jykge1xuICAgICAgdmFyIF9yZWY7XG4gICAgICBjb25zdCBwcmVmaXggPSBnZXRTcmNQcmVmaXhGb3JJbWFnZUJsb2NrKGRvY3VtZW50RmVhdHVyZXMsIHNsdWcpO1xuICAgICAgY29uc3QgZmlsZW5hbWUgPSBub2RlLnNyYy5zbGljZShwcmVmaXgubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSAoX3JlZiA9IHR5cGVvZiBkb2N1bWVudEZlYXR1cmVzLmltYWdlcyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGRvY3VtZW50RmVhdHVyZXMuaW1hZ2VzLmRpcmVjdG9yeSA9PT0gJ3N0cmluZycgPyBvdGhlckZpbGVzLmdldChmaXhQYXRoKGRvY3VtZW50RmVhdHVyZXMuaW1hZ2VzLmRpcmVjdG9yeSkpIDogZmlsZXMpID09PSBudWxsIHx8IF9yZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZWYuZ2V0KGZpbGVuYW1lKTtcbiAgICAgIGlmICghY29udGVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgICAgdGV4dDogYE1pc3NpbmcgaW1hZ2UgJHtmaWxlbmFtZX1gXG4gICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgIHNyYzoge1xuICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgfSxcbiAgICAgICAgYWx0OiBub2RlLmFsdCxcbiAgICAgICAgdGl0bGU6IG5vZGUudGl0bGUsXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgIH1dXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5vZGUudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gZGVzZXJpYWxpemVGaWxlcyhub2RlLmNoaWxkcmVuLCBjb21wb25lbnRCbG9ja3MsIGZpbGVzLCBvdGhlckZpbGVzLCBtb2RlLCBkb2N1bWVudEZlYXR1cmVzLCBzbHVnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm5vZGUsXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVByb3BzKHNjaGVtYSwgdmFsdWUsIGZpbGVzLCBvdGhlckZpbGVzLCBtb2RlLCBzbHVnKSB7XG4gIHJldHVybiB0cmFuc2Zvcm1Qcm9wcyhzY2hlbWEsIHZhbHVlLCB7XG4gICAgZm9ybTogKHNjaGVtYSwgdmFsdWUpID0+IHtcbiAgICAgIGlmIChzY2hlbWEuZm9ybUtpbmQgPT09ICdhc3NldCcpIHtcbiAgICAgICAgdmFyIF9vdGhlckZpbGVzJGdldDtcbiAgICAgICAgaWYgKG1vZGUgPT09ICdyZWFkJykge1xuICAgICAgICAgIHJldHVybiBzY2hlbWEucmVhZGVyLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHNjaGVtYS5maWxlbmFtZSh2YWx1ZSwge1xuICAgICAgICAgIHNsdWcsXG4gICAgICAgICAgc3VnZ2VzdGVkRmlsZW5hbWVQcmVmaXg6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5wYXJzZSh2YWx1ZSwge1xuICAgICAgICAgIGFzc2V0OiBmaWxlbmFtZSA/IHNjaGVtYS5kaXJlY3RvcnkgPyAoX290aGVyRmlsZXMkZ2V0ID0gb3RoZXJGaWxlcy5nZXQoc2NoZW1hLmRpcmVjdG9yeSkpID09PSBudWxsIHx8IF9vdGhlckZpbGVzJGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX290aGVyRmlsZXMkZ2V0LmdldChmaWxlbmFtZSkgOiBmaWxlcy5nZXQoZmlsZW5hbWUpIDogdW5kZWZpbmVkLFxuICAgICAgICAgIHNsdWdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoc2NoZW1hLmZvcm1LaW5kID09PSAnY29udGVudCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlID09PSAncmVhZCcpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5yZWFkZXIucGFyc2UodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYS5wYXJzZSh2YWx1ZSwgdW5kZWZpbmVkKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0U3JjUHJlZml4Rm9ySW1hZ2VCbG9jayhkb2N1bWVudEZlYXR1cmVzLCBzbHVnKSB7XG4gIHJldHVybiBnZXRTcmNQcmVmaXgodHlwZW9mIGRvY3VtZW50RmVhdHVyZXMuaW1hZ2VzID09PSAnb2JqZWN0JyA/IGRvY3VtZW50RmVhdHVyZXMuaW1hZ2VzLnB1YmxpY1BhdGggOiB1bmRlZmluZWQsIHNsdWcpO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVQcm9wcyhyb290VmFsdWUsIHJvb3RTY2hlbWEsXG4vLyBub3RlIHlvdSBtaWdodCBoYXZlIGEgc2x1ZyB3aXRob3V0IGEgc2x1ZyBmaWVsZCB3aGVuIHNlcmlhbGl6aW5nIHByb3BzIGluc2lkZSBhIGNvbXBvbmVudCBibG9jayBvciBldGMuIGluIHRoZSBlZGl0b3JcbnNsdWdGaWVsZCwgc2x1Zywgc2hvdWxkU3VnZ2VzdEZpbGVuYW1lUHJlZml4KSB7XG4gIGNvbnN0IGV4dHJhRmlsZXMgPSBbXTtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdHJhbnNmb3JtUHJvcHMocm9vdFNjaGVtYSwgcm9vdFZhbHVlLCB7XG4gICAgICBmb3JtKHNjaGVtYSwgdmFsdWUsIHByb3BQYXRoKSB7XG4gICAgICAgIGlmIChwcm9wUGF0aC5sZW5ndGggPT09IDEgJiYgc2x1Z0ZpZWxkID09PSBwcm9wUGF0aFswXSkge1xuICAgICAgICAgIGlmIChzY2hlbWEuZm9ybUtpbmQgIT09ICdzbHVnJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzbHVnRmllbGQgaXMgYSBub3QgYSBzbHVnIGZpZWxkJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzY2hlbWEuc2VyaWFsaXplV2l0aFNsdWcodmFsdWUpLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEuZm9ybUtpbmQgPT09ICdhc3NldCcpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBhc3NldCxcbiAgICAgICAgICAgIHZhbHVlOiBmb3JZYW1sXG4gICAgICAgICAgfSA9IHNjaGVtYS5zZXJpYWxpemUodmFsdWUsIHtcbiAgICAgICAgICAgIHN1Z2dlc3RlZEZpbGVuYW1lUHJlZml4OiBzaG91bGRTdWdnZXN0RmlsZW5hbWVQcmVmaXggPyBnZXRQcm9wUGF0aFBvcnRpb24ocHJvcFBhdGgsIHJvb3RTY2hlbWEsIHJvb3RWYWx1ZSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzbHVnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGFzc2V0KSB7XG4gICAgICAgICAgICBleHRyYUZpbGVzLnB1c2goe1xuICAgICAgICAgICAgICBwYXRoOiBhc3NldC5maWxlbmFtZSxcbiAgICAgICAgICAgICAgY29udGVudHM6IGFzc2V0LmNvbnRlbnQsXG4gICAgICAgICAgICAgIHBhcmVudDogc2NoZW1hLmRpcmVjdG9yeVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmb3JZYW1sO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEuZm9ybUtpbmQgPT09ICdjb250ZW50Jykge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIG90aGVyLFxuICAgICAgICAgICAgZXh0ZXJuYWwsXG4gICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgdmFsdWU6IGZvcllhbWxcbiAgICAgICAgICB9ID0gc2NoZW1hLnNlcmlhbGl6ZSh2YWx1ZSwge1xuICAgICAgICAgICAgc2x1Z1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICBleHRyYUZpbGVzLnB1c2goe1xuICAgICAgICAgICAgICBwYXRoOiBnZXRQcm9wUGF0aFBvcnRpb24ocHJvcFBhdGgsIHJvb3RTY2hlbWEsIHJvb3RWYWx1ZSkgKyBzY2hlbWEuY29udGVudEV4dGVuc2lvbixcbiAgICAgICAgICAgICAgY29udGVudHM6IGNvbnRlbnQsXG4gICAgICAgICAgICAgIHBhcmVudDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCBba2V5LCBjb250ZW50c10gb2Ygb3RoZXIpIHtcbiAgICAgICAgICAgIGV4dHJhRmlsZXMucHVzaCh7XG4gICAgICAgICAgICAgIHBhdGg6IGdldFByb3BQYXRoUG9ydGlvbihwcm9wUGF0aCwgcm9vdFNjaGVtYSwgcm9vdFZhbHVlKSArICcvJyArIGtleSxcbiAgICAgICAgICAgICAgY29udGVudHMsXG4gICAgICAgICAgICAgIHBhcmVudDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYWxsb3dlZERpcmVjdG9yaWVzID0gbmV3IFNldChzY2hlbWEuZGlyZWN0b3JpZXMpO1xuICAgICAgICAgIGZvciAoY29uc3QgW2RpcmVjdG9yeSwgY29udGVudHNdIG9mIGV4dGVybmFsKSB7XG4gICAgICAgICAgICBpZiAoIWFsbG93ZWREaXJlY3Rvcmllcy5oYXMoZGlyZWN0b3J5KSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGlyZWN0b3J5ICR7ZGlyZWN0b3J5fSBpbiBjb250ZW50IGZpZWxkIHNlcmlhbGl6YXRpb25gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ZpbGVuYW1lLCBmaWxlQ29udGVudHNdIG9mIGNvbnRlbnRzKSB7XG4gICAgICAgICAgICAgIGV4dHJhRmlsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgcGF0aDogZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgY29udGVudHM6IGZpbGVDb250ZW50cyxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGRpcmVjdG9yeVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZvcllhbWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjaGVtYS5zZXJpYWxpemUodmFsdWUpLnZhbHVlO1xuICAgICAgfSxcbiAgICAgIG9iamVjdChfc2NoZW1hLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHZhbHVlKS5maWx0ZXIoKFtfLCB2YWxdKSA9PiB2YWwgIT09IHVuZGVmaW5lZCkpO1xuICAgICAgfSxcbiAgICAgIGFycmF5KF9zY2hlbWEsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAodmFsID0+IHZhbCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHZhbCk7XG4gICAgICB9LFxuICAgICAgY2hpbGQoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSksXG4gICAgZXh0cmFGaWxlc1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0UHJvcFBhdGhQb3J0aW9uKHBhdGgsIHNjaGVtYSwgdmFsdWUpIHtcbiAgY29uc3QgZW5kID0gW107XG4gIGZvciAoY29uc3QgcG9ydGlvbiBvZiBwYXRoKSB7XG4gICAgaWYgKHNjaGVtYS5raW5kID09PSAnYXJyYXknKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlW3BvcnRpb25dO1xuICAgICAgaWYgKHNjaGVtYS5zbHVnRmllbGQgJiYgc2NoZW1hLmVsZW1lbnQua2luZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3Qgc2x1ZyA9IGdldFNsdWdGcm9tU3RhdGUoe1xuICAgICAgICAgIHNjaGVtYTogc2NoZW1hLmVsZW1lbnQuZmllbGRzLFxuICAgICAgICAgIHNsdWdGaWVsZDogc2NoZW1hLnNsdWdGaWVsZFxuICAgICAgICB9LCB2YWx1ZSk7XG4gICAgICAgIGVuZC5wdXNoKHNsdWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kLnB1c2gocG9ydGlvbik7XG4gICAgICB9XG4gICAgICBzY2hlbWEgPSBzY2hlbWEuZWxlbWVudDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBlbmQucHVzaChwb3J0aW9uKTtcbiAgICBpZiAoc2NoZW1hLmtpbmQgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlW3BvcnRpb25dO1xuICAgICAgc2NoZW1hID0gc2NoZW1hLmZpZWxkc1twb3J0aW9uXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hLmtpbmQgPT09ICdjb25kaXRpb25hbCcpIHtcbiAgICAgIGlmIChwb3J0aW9uID09PSAnZGlzY3JpbWluYW50Jykge1xuICAgICAgICBzY2hlbWEgPSBzY2hlbWEuZGlzY3JpbWluYW50O1xuICAgICAgfSBlbHNlIGlmIChwb3J0aW9uID09PSAndmFsdWUnKSB7XG4gICAgICAgIHNjaGVtYSA9IHNjaGVtYS52YWx1ZXNbdmFsdWUuZGlzY3JpbWluYW50XTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWVbcG9ydGlvbl07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkICR7c2NoZW1hLmtpbmR9YCk7XG4gIH1cbiAgcmV0dXJuIGVuZC5qb2luKCcvJyk7XG59XG5cbmZ1bmN0aW9uIHRvSW5saW5lKG5vZGVzKSB7XG4gIHJldHVybiBuZXcgQXN0Lk5vZGUoJ2lubGluZScsIHt9LCBub2Rlcy5mbGF0TWFwKHRvTWFya2RvY0lubGluZSkpO1xufVxuY29uc3QgbWFya1RvTWFya2RvYyA9IHtcbiAgYm9sZDoge1xuICAgIHR5cGU6ICdzdHJvbmcnXG4gIH0sXG4gIGNvZGU6IHtcbiAgICB0eXBlOiAnY29kZSdcbiAgfSxcbiAgaXRhbGljOiB7XG4gICAgdHlwZTogJ2VtJ1xuICB9LFxuICB1bmRlcmxpbmU6IHtcbiAgICB0eXBlOiAndGFnJyxcbiAgICB0YWc6ICd1J1xuICB9LFxuICBrZXlib2FyZDoge1xuICAgIHR5cGU6ICd0YWcnLFxuICAgIHRhZzogJ2tiZCdcbiAgfSxcbiAgc3RyaWtldGhyb3VnaDoge1xuICAgIHR5cGU6ICdzJ1xuICB9LFxuICBzdWJzY3JpcHQ6IHtcbiAgICB0eXBlOiAndGFnJyxcbiAgICB0YWc6ICdzdWInXG4gIH0sXG4gIHN1cGVyc2NyaXB0OiB7XG4gICAgdHlwZTogJ3RhZycsXG4gICAgdGFnOiAnc3VwJ1xuICB9XG59O1xuZnVuY3Rpb24gdG9NYXJrZG9jSW5saW5lKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ2xpbmsnKSB7XG4gICAgcmV0dXJuIG5ldyBBc3QuTm9kZSgnbGluaycsIHtcbiAgICAgIGhyZWY6IG5vZGUuaHJlZlxuICAgIH0sIG5vZGUuY2hpbGRyZW4uZmxhdE1hcCh0b01hcmtkb2NJbmxpbmUpKTtcbiAgfVxuICBpZiAobm9kZS50eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgaW5saW5lIG5vZGUgdHlwZTogJHtub2RlLnR5cGV9YCk7XG4gIH1cbiAgaWYgKG5vZGUuY29kZSkge1xuICAgIHJldHVybiBuZXcgQXN0Lk5vZGUoJ2NvZGUnLCB7XG4gICAgICBjb250ZW50OiBub2RlLnRleHRcbiAgICB9LCBbXSk7XG4gIH1cbiAgY29uc3QgbWFya3MgPSBPYmplY3Qua2V5cyhub2RlKS5maWx0ZXIobWFyayA9PiBtYXJrICE9PSAndGV4dCcpLnNvcnQoKTtcbiAgbGV0IG1hcmtkb2NOb2RlID0gbmV3IEFzdC5Ob2RlKCd0ZXh0Jywge1xuICAgIGNvbnRlbnQ6IG5vZGUudGV4dFxuICB9KTtcbiAgZm9yIChjb25zdCBtYXJrIG9mIG1hcmtzKSB7XG4gICAgY29uc3QgY29uZmlnID0gbWFya1RvTWFya2RvY1ttYXJrXTtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICBtYXJrZG9jTm9kZSA9IG5ldyBBc3QuTm9kZShjb25maWcudHlwZSwge30sIFttYXJrZG9jTm9kZV0sIGNvbmZpZy50YWcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWFya2RvY05vZGU7XG59XG5mdW5jdGlvbiB0b01hcmtkb2NEb2N1bWVudChub2RlcywgX2NvbmZpZykge1xuICBjb25zdCBleHRyYUZpbGVzID0gW107XG4gIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAuLi5fY29uZmlnLFxuICAgIGV4dHJhRmlsZXNcbiAgfTtcbiAgY29uc3Qgbm9kZSA9IG5ldyBBc3QuTm9kZSgnZG9jdW1lbnQnLCB7fSwgbm9kZXMuZmxhdE1hcCh4ID0+IHRvTWFya2RvYyh4LCBjb25maWcpKSk7XG4gIHJldHVybiB7XG4gICAgbm9kZSxcbiAgICBleHRyYUZpbGVzXG4gIH07XG59XG5mdW5jdGlvbiB0b0NoaWxkcmVuQW5kUHJvcHMoY2hpbGRyZW5Bc01hcmtkb2MsIHJlc3VsdGluZ0NoaWxkcmVuLCB2YWx1ZSwgc2luZ2xlQ2hpbGRGaWVsZCkge1xuICBpZiAoc2luZ2xlQ2hpbGRGaWVsZC5raW5kID09PSAnY2hpbGQnKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbkFzTWFya2RvYy5maW5kKHggPT4gYXJlQXJyYXlzRXF1YWwoeC5wcm9wUGF0aCwgc2luZ2xlQ2hpbGRGaWVsZC5yZWxhdGl2ZVBhdGgpKTtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIHJlc3VsdGluZ0NoaWxkcmVuLnB1c2goLi4uY2hpbGQuY2hpbGRyZW4pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNpbmdsZUNoaWxkRmllbGQua2luZCA9PT0gJ2FycmF5Jykge1xuICAgIGNvbnN0IGtleSA9IHNpbmdsZUNoaWxkRmllbGQucmVsYXRpdmVQYXRoW3NpbmdsZUNoaWxkRmllbGQucmVsYXRpdmVQYXRoLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHBhcmVudCA9IGdldFZhbHVlQXRQcm9wUGF0aCh2YWx1ZSwgc2luZ2xlQ2hpbGRGaWVsZC5yZWxhdGl2ZVBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICBjb25zdCB2YWx1ZUF0UHJvcFBhdGggPSBwYXJlbnRba2V5XTtcbiAgICBkZWxldGUgcGFyZW50W2tleV07XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuQXNNYXJrZG9jKSB7XG4gICAgICBjb25zdCBpbm5lclByb3BQYXRoID0gY2hpbGQucHJvcFBhdGguc2xpY2Uoc2luZ2xlQ2hpbGRGaWVsZC5yZWxhdGl2ZVBhdGgubGVuZ3RoICsgMSk7XG4gICAgICBjb25zdCBudW0gPSBjaGlsZC5wcm9wUGF0aFtzaW5nbGVDaGlsZEZpZWxkLnJlbGF0aXZlUGF0aC5sZW5ndGhdO1xuICAgICAgaWYgKGNoaWxkTm9kZXMuZ2V0KG51bSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjaGlsZE5vZGVzLnNldChudW0sIFtdKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkTm9kZXMuZ2V0KG51bSkucHVzaCh7XG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZC5jaGlsZHJlbixcbiAgICAgICAgcHJvcFBhdGg6IGlubmVyUHJvcFBhdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXN1bHRpbmdDaGlsZHJlbi5wdXNoKC4uLnZhbHVlQXRQcm9wUGF0aC5tYXAoKHgsIGkpID0+IHtcbiAgICAgIHZhciBfY2hpbGROb2RlcyRnZXQ7XG4gICAgICBjb25zdCBuZXdDaGlsZHJlbkFzTWFya2RvYyA9IChfY2hpbGROb2RlcyRnZXQgPSBjaGlsZE5vZGVzLmdldChpKSkgIT09IG51bGwgJiYgX2NoaWxkTm9kZXMkZ2V0ICE9PSB2b2lkIDAgPyBfY2hpbGROb2RlcyRnZXQgOiBbXTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gW107XG4gICAgICB0b0NoaWxkcmVuQW5kUHJvcHMobmV3Q2hpbGRyZW5Bc01hcmtkb2MsIGNoaWxkcmVuLCB4LCBzaW5nbGVDaGlsZEZpZWxkLmNoaWxkKTtcbiAgICAgIHJldHVybiBuZXcgQXN0Lk5vZGUoJ3RhZycsIHgsIGNoaWxkcmVuLCBzaW5nbGVDaGlsZEZpZWxkLmFzQ2hpbGRUYWcpO1xuICAgIH0pKTtcbiAgfVxufVxuZnVuY3Rpb24gdG9NYXJrZG9jKG5vZGUsIGNvbmZpZykge1xuICBpZiAobm9kZS50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgIGNvbnN0IG1hcmtkb2NOb2RlID0gbmV3IEFzdC5Ob2RlKCdwYXJhZ3JhcGgnLCBub2RlLnRleHRBbGlnbiA/IHtcbiAgICAgIHRleHRBbGlnbjogbm9kZS50ZXh0QWxpZ25cbiAgICB9IDoge30sIFt0b0lubGluZShub2RlLmNoaWxkcmVuKV0pO1xuICAgIGlmIChub2RlLnRleHRBbGlnbikge1xuICAgICAgbWFya2RvY05vZGUuYW5ub3RhdGlvbnMucHVzaCh7XG4gICAgICAgIG5hbWU6ICd0ZXh0QWxpZ24nLFxuICAgICAgICB2YWx1ZTogbm9kZS50ZXh0QWxpZ24sXG4gICAgICAgIHR5cGU6ICdhdHRyaWJ1dGUnXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtkb2NOb2RlO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09ICdpbWFnZScpIHtcbiAgICBjb25maWcuZXh0cmFGaWxlcy5wdXNoKHtcbiAgICAgIGNvbnRlbnRzOiBub2RlLnNyYy5jb250ZW50LFxuICAgICAgcGF0aDogbm9kZS5zcmMuZmlsZW5hbWUsXG4gICAgICBwYXJlbnQ6IHR5cGVvZiBjb25maWcuZG9jdW1lbnRGZWF0dXJlcy5pbWFnZXMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjb25maWcuZG9jdW1lbnRGZWF0dXJlcy5pbWFnZXMuZGlyZWN0b3J5ID09PSAnc3RyaW5nJyA/IGZpeFBhdGgoY29uZmlnLmRvY3VtZW50RmVhdHVyZXMuaW1hZ2VzLmRpcmVjdG9yeSkgOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IEFzdC5Ob2RlKCdwYXJhZ3JhcGgnLCB7fSwgW25ldyBBc3QuTm9kZSgnaW5saW5lJywge30sIFtuZXcgQXN0Lk5vZGUoJ2ltYWdlJywge1xuICAgICAgc3JjOiBlbmNvZGVVUkkoYCR7Z2V0U3JjUHJlZml4Rm9ySW1hZ2VCbG9jayhjb25maWcuZG9jdW1lbnRGZWF0dXJlcywgY29uZmlnLnNsdWcpfSR7bm9kZS5zcmMuZmlsZW5hbWV9YCksXG4gICAgICBhbHQ6IG5vZGUuYWx0LFxuICAgICAgdGl0bGU6IG5vZGUudGl0bGVcbiAgICB9KV0pXSk7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ2NvZGUnKSB7XG4gICAgY29uc3QgZXh0cmFBdHRyaWJ1dGVzID0ge307XG4gICAgY29uc3Qge1xuICAgICAgY2hpbGRyZW4sXG4gICAgICBsYW5ndWFnZSxcbiAgICAgIHR5cGUsXG4gICAgICAuLi5yZXN0XG4gICAgfSA9IG5vZGU7XG4gICAgY29uc3Qgc2NoZW1hID0gdHlwZW9mIGNvbmZpZy5kb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcuYmxvY2tUeXBlcy5jb2RlID09PSAnb2JqZWN0JyA/IGNvbmZpZy5kb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcuYmxvY2tUeXBlcy5jb2RlLnNjaGVtYSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoc2NoZW1hICYmIE9iamVjdC5rZXlzKHNjaGVtYS5maWVsZHMpLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBzZXJpYWxpemVQcm9wcyhnZXRJbml0aWFsUHJvcHNWYWx1ZUZyb21Jbml0aWFsaXplcihzY2hlbWEsIHJlc3QpLCBzY2hlbWEsIHVuZGVmaW5lZCwgY29uZmlnLnNsdWcsIGZhbHNlKTtcbiAgICAgIE9iamVjdC5hc3NpZ24oZXh0cmFBdHRyaWJ1dGVzLCBzZXJpYWxpemVkLnZhbHVlKTtcbiAgICAgIGNvbmZpZy5leHRyYUZpbGVzLnB1c2goLi4uc2VyaWFsaXplZC5leHRyYUZpbGVzKTtcbiAgICB9XG4gICAgbGV0IGNvbnRlbnQgPSBjaGlsZHJlblswXS50ZXh0ICsgJ1xcbic7XG4gICAgY29uc3QgbWFya2RvY05vZGUgPSBuZXcgQXN0Lk5vZGUoJ2ZlbmNlJywge1xuICAgICAgY29udGVudCxcbiAgICAgIGxhbmd1YWdlLFxuICAgICAgLi4uZXh0cmFBdHRyaWJ1dGVzXG4gICAgfSwgW25ldyBBc3QuTm9kZSgndGV4dCcsIHtcbiAgICAgIGNvbnRlbnRcbiAgICB9KV0pO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGV4dHJhQXR0cmlidXRlcykpIHtcbiAgICAgIG1hcmtkb2NOb2RlLmFubm90YXRpb25zLnB1c2goe1xuICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0eXBlOiAnYXR0cmlidXRlJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZG9jTm9kZTtcbiAgfVxuICBjb25zdCBfdG9NYXJrZG9jID0gbm9kZSA9PiB0b01hcmtkb2Mobm9kZSwgY29uZmlnKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ2Jsb2NrcXVvdGUnKSB7XG4gICAgcmV0dXJuIG5ldyBBc3QuTm9kZSgnYmxvY2txdW90ZScsIHt9LCBub2RlLmNoaWxkcmVuLm1hcChfdG9NYXJrZG9jKSk7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ2RpdmlkZXInKSB7XG4gICAgcmV0dXJuIG5ldyBBc3QuTm9kZSgnaHInKTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAndGFibGUnKSB7XG4gICAgY29uc3QgaGVhZCA9IG5vZGUuY2hpbGRyZW4uZmluZCh4ID0+IHgudHlwZSA9PT0gJ3RhYmxlLWhlYWQnKTtcbiAgICByZXR1cm4gbmV3IEFzdC5Ob2RlKCd0YWcnLCB7fSwgW25ldyBBc3QuTm9kZSgndGFibGUnLCB7fSwgW25ldyBBc3QuTm9kZSgndGhlYWQnLCB7fSwgaGVhZCA/IGhlYWQuY2hpbGRyZW4ubWFwKF90b01hcmtkb2MpIDogW10pLCBfdG9NYXJrZG9jKG5vZGUuY2hpbGRyZW4uZmluZCh4ID0+IHgudHlwZSA9PT0gJ3RhYmxlLWJvZHknKSldKV0sICd0YWJsZScpO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09ICd0YWJsZS1ib2R5Jykge1xuICAgIHJldHVybiBuZXcgQXN0Lk5vZGUoJ3Rib2R5Jywge30sIG5vZGUuY2hpbGRyZW4ubWFwKF90b01hcmtkb2MpKTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAndGFibGUtcm93Jykge1xuICAgIHJldHVybiBuZXcgQXN0Lk5vZGUoJ3RyJywge30sIG5vZGUuY2hpbGRyZW4ubWFwKF90b01hcmtkb2MpKTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAndGFibGUtY2VsbCcpIHtcbiAgICByZXR1cm4gbmV3IEFzdC5Ob2RlKG5vZGUuaGVhZGVyID8gJ3RoJyA6ICd0ZCcsIHt9LCBub2RlLmNoaWxkcmVuLm1hcChfdG9NYXJrZG9jKSk7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ2hlYWRpbmcnKSB7XG4gICAgY29uc3QgZXh0cmFBdHRyaWJ1dGVzID0ge307XG4gICAgaWYgKG5vZGUudGV4dEFsaWduKSB7XG4gICAgICBleHRyYUF0dHJpYnV0ZXMudGV4dEFsaWduID0gbm9kZS50ZXh0QWxpZ247XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgbGV2ZWwsXG4gICAgICB0ZXh0QWxpZ24sXG4gICAgICB0eXBlLFxuICAgICAgLi4ucmVzdFxuICAgIH0gPSBub2RlO1xuICAgIGNvbnN0IHNjaGVtYSA9IGNvbmZpZy5kb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcuaGVhZGluZ3Muc2NoZW1hO1xuICAgIGlmIChPYmplY3Qua2V5cyhzY2hlbWEuZmllbGRzKS5sZW5ndGggPiAwKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGV4dHJhQXR0cmlidXRlcywgc2VyaWFsaXplUHJvcHMoZ2V0SW5pdGlhbFByb3BzVmFsdWVGcm9tSW5pdGlhbGl6ZXIoc2NoZW1hLCByZXN0KSwgc2NoZW1hLCB1bmRlZmluZWQsIGNvbmZpZy5zbHVnLCBmYWxzZSkudmFsdWUpO1xuICAgIH1cbiAgICBjb25zdCBtYXJrZG9jTm9kZSA9IG5ldyBBc3QuTm9kZSgnaGVhZGluZycsIHtcbiAgICAgIGxldmVsOiBub2RlLmxldmVsLFxuICAgICAgLi4uZXh0cmFBdHRyaWJ1dGVzXG4gICAgfSwgW3RvSW5saW5lKG5vZGUuY2hpbGRyZW4pXSk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZXh0cmFBdHRyaWJ1dGVzKSkge1xuICAgICAgbWFya2RvY05vZGUuYW5ub3RhdGlvbnMucHVzaCh7XG4gICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHR5cGU6ICdhdHRyaWJ1dGUnXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtkb2NOb2RlO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09ICdvcmRlcmVkLWxpc3QnKSB7XG4gICAgcmV0dXJuIG5ldyBBc3QuTm9kZSgnbGlzdCcsIHtcbiAgICAgIG9yZGVyZWQ6IHRydWVcbiAgICB9LCBub2RlLmNoaWxkcmVuLm1hcChfdG9NYXJrZG9jKSk7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ3Vub3JkZXJlZC1saXN0Jykge1xuICAgIHJldHVybiBuZXcgQXN0Lk5vZGUoJ2xpc3QnLCB7XG4gICAgICBvcmRlcmVkOiBmYWxzZVxuICAgIH0sIG5vZGUuY2hpbGRyZW4ubWFwKF90b01hcmtkb2MpKTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAnbGF5b3V0Jykge1xuICAgIHJldHVybiBuZXcgQXN0Lk5vZGUoJ3RhZycsIHtcbiAgICAgIGxheW91dDogbm9kZS5sYXlvdXRcbiAgICB9LCBub2RlLmNoaWxkcmVuLm1hcChfdG9NYXJrZG9jKSwgJ2xheW91dCcpO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09ICdsYXlvdXQtYXJlYScpIHtcbiAgICByZXR1cm4gbmV3IEFzdC5Ob2RlKCd0YWcnLCB7fSwgbm9kZS5jaGlsZHJlbi5mbGF0TWFwKF90b01hcmtkb2MpLCAnbGF5b3V0LWFyZWEnKTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAnY29tcG9uZW50LWJsb2NrJykge1xuICAgIGNvbnN0IGlzVm9pZCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gJ2NvbXBvbmVudC1pbmxpbmUtcHJvcCcgJiYgbm9kZS5jaGlsZHJlblswXS5wcm9wUGF0aCA9PT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGNvbXBvbmVudEJsb2NrID0gY29uZmlnLmNvbXBvbmVudEJsb2Nrc1tub2RlLmNvbXBvbmVudF07XG4gICAgY29uc3QgY2hpbGRyZW5Bc01hcmtkb2MgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGlmICgoY2hpbGQudHlwZSA9PT0gJ2NvbXBvbmVudC1ibG9jay1wcm9wJyB8fCBjaGlsZC50eXBlID09PSAnY29tcG9uZW50LWlubGluZS1wcm9wJykgJiYgY2hpbGQucHJvcFBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjaGlsZHJlbkFzTWFya2RvYy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBjaGlsZC50eXBlLFxuICAgICAgICAgIHByb3BQYXRoOiBjaGlsZC5wcm9wUGF0aCxcbiAgICAgICAgICBjaGlsZHJlbjogY2hpbGQudHlwZSA9PT0gJ2NvbXBvbmVudC1ibG9jay1wcm9wJyA/IGNoaWxkLmNoaWxkcmVuLmZsYXRNYXAoX3RvTWFya2RvYykgOiBbdG9JbmxpbmUoY2hpbGQuY2hpbGRyZW4pXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGF0dHJpYnV0ZXMgPSBub2RlLnByb3BzO1xuICAgIGlmIChjb21wb25lbnRCbG9jaykge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHNlcmlhbGl6ZVByb3BzKG5vZGUucHJvcHMsIHtcbiAgICAgICAga2luZDogJ29iamVjdCcsXG4gICAgICAgIGZpZWxkczogY29tcG9uZW50QmxvY2suc2NoZW1hXG4gICAgICB9LCB1bmRlZmluZWQsIGNvbmZpZy5zbHVnLCBmYWxzZSk7XG4gICAgICBhdHRyaWJ1dGVzID0gc2VyaWFsaXplZC52YWx1ZTtcbiAgICAgIGNvbmZpZy5leHRyYUZpbGVzLnB1c2goLi4uc2VyaWFsaXplZC5leHRyYUZpbGVzKTtcbiAgICAgIGNvbnN0IHNpbmdsZUNoaWxkRmllbGQgPSBmaW5kU2luZ2xlQ2hpbGRGaWVsZCh7XG4gICAgICAgIGtpbmQ6ICdvYmplY3QnLFxuICAgICAgICBmaWVsZHM6IGNvbXBvbmVudEJsb2NrLnNjaGVtYVxuICAgICAgfSk7XG4gICAgICBpZiAoc2luZ2xlQ2hpbGRGaWVsZCkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB0b0NoaWxkcmVuQW5kUHJvcHMoY2hpbGRyZW5Bc01hcmtkb2MsIGNoaWxkcmVuLCBhdHRyaWJ1dGVzLCBzaW5nbGVDaGlsZEZpZWxkKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBc3QuTm9kZSgndGFnJywgYXR0cmlidXRlcywgY2hpbGRyZW4sIG5vZGUuY29tcG9uZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSBpc1ZvaWQgPyBbXSA6IGNoaWxkcmVuQXNNYXJrZG9jLm1hcCh4ID0+IG5ldyBBc3QuTm9kZSgndGFnJywge1xuICAgICAgcHJvcFBhdGg6IHgucHJvcFBhdGhcbiAgICB9LCB4LmNoaWxkcmVuLCB4LnR5cGUpKTtcbiAgICByZXR1cm4gbmV3IEFzdC5Ob2RlKCd0YWcnLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbiwgbm9kZS5jb21wb25lbnQpO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09ICdjb21wb25lbnQtYmxvY2stcHJvcCcgfHwgbm9kZS50eXBlID09PSAnY29tcG9uZW50LWlubGluZS1wcm9wJykge1xuICAgIHJldHVybiBuZXcgQXN0Lk5vZGUoJ3RhZycsIHtcbiAgICAgIHByb3BQYXRoOiBub2RlLnByb3BQYXRoXG4gICAgfSwgbm9kZS50eXBlID09PSAnY29tcG9uZW50LWlubGluZS1wcm9wJyA/IFt0b0lubGluZShub2RlLmNoaWxkcmVuKV0gOiBub2RlLmNoaWxkcmVuLmZsYXRNYXAoX3RvTWFya2RvYyksIG5vZGUudHlwZSk7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ2xpc3QtaXRlbScpIHtcbiAgICBjb25zdCBsaXN0SXRlbUNvbnRlbnQgPSBub2RlLmNoaWxkcmVuWzBdO1xuICAgIGlmIChsaXN0SXRlbUNvbnRlbnQudHlwZSAhPT0gJ2xpc3QtaXRlbS1jb250ZW50Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsaXN0IGl0ZW0gY29udGVudCBtdXN0IGNvbnRhaW4gYSBsaXN0LWl0ZW0tY29udGVudCcpO1xuICAgIH1cbiAgICBjb25zdCBpbmxpbmUgPSB0b0lubGluZShsaXN0SXRlbUNvbnRlbnQuY2hpbGRyZW4pO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gW2lubGluZV07XG4gICAgY29uc3QgbmVzdGVkTGlzdCA9IG5vZGUuY2hpbGRyZW5bMV07XG4gICAgaWYgKG5lc3RlZExpc3QpIHtcbiAgICAgIGNoaWxkcmVuLnB1c2godG9NYXJrZG9jKG5lc3RlZExpc3QsIGNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFzdC5Ob2RlKCdpdGVtJywge30sIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAnbGlzdC1pdGVtLWNvbnRlbnQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdsaXN0LWl0ZW0tY29udGVudCBpbiB1bmV4cGVjdGVkIHBvc2l0aW9uJyk7XG4gIH1cbiAgZGVidWdnZXI7XG4gIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCBub2RlIHR5cGU6ICR7bm9kZS50eXBlfWApO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVRleHQodmFsLCBtaW4sIG1heCwgZmllbGRMYWJlbCwgc2x1Z0luZm8pIHtcbiAgaWYgKHZhbC5sZW5ndGggPCBtaW4pIHtcbiAgICBpZiAobWluID09PSAxKSB7XG4gICAgICByZXR1cm4gYCR7ZmllbGRMYWJlbH0gbXVzdCBub3QgYmUgZW1wdHlgO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYCR7ZmllbGRMYWJlbH0gbXVzdCBiZSBhdCBsZWFzdCAke21pbn0gY2hhcmFjdGVycyBsb25nYDtcbiAgICB9XG4gIH1cbiAgaWYgKHZhbC5sZW5ndGggPiBtYXgpIHtcbiAgICByZXR1cm4gYCR7ZmllbGRMYWJlbH0gbXVzdCBiZSBubyBsb25nZXIgdGhhbiAke21heH0gY2hhcmFjdGVyc2A7XG4gIH1cbiAgaWYgKHNsdWdJbmZvKSB7XG4gICAgaWYgKHZhbCA9PT0gJycpIHtcbiAgICAgIHJldHVybiBgJHtmaWVsZExhYmVsfSBtdXN0IG5vdCBiZSBlbXB0eWA7XG4gICAgfVxuICAgIGlmICh2YWwgPT09ICcuLicpIHtcbiAgICAgIHJldHVybiBgJHtmaWVsZExhYmVsfSBtdXN0IG5vdCBiZSAuLmA7XG4gICAgfVxuICAgIGlmICh2YWwgPT09ICcuJykge1xuICAgICAgcmV0dXJuIGAke2ZpZWxkTGFiZWx9IG11c3Qgbm90IGJlIC5gO1xuICAgIH1cbiAgICBpZiAoc2x1Z0luZm8uZ2xvYiA9PT0gJyoqJykge1xuICAgICAgY29uc3Qgc3BsaXQgPSB2YWwuc3BsaXQoJy8nKTtcbiAgICAgIGlmIChzcGxpdC5zb21lKHMgPT4gcyA9PT0gJy4uJykpIHtcbiAgICAgICAgcmV0dXJuIGAke2ZpZWxkTGFiZWx9IG11c3Qgbm90IGNvbnRhaW4gLi5gO1xuICAgICAgfVxuICAgICAgaWYgKHNwbGl0LnNvbWUocyA9PiBzID09PSAnLicpKSB7XG4gICAgICAgIHJldHVybiBgJHtmaWVsZExhYmVsfSBtdXN0IG5vdCBiZSAuYDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKChzbHVnSW5mby5nbG9iID09PSAnKicgPyAvW1xcXFwvXS8gOiAvW1xcXFxdLykudGVzdCh2YWwpKSB7XG4gICAgICByZXR1cm4gYCR7ZmllbGRMYWJlbH0gbXVzdCBub3QgY29udGFpbiBzbGFzaGVzYDtcbiAgICB9XG4gICAgaWYgKC9eXFxzfFxccyQvLnRlc3QodmFsKSkge1xuICAgICAgcmV0dXJuIGAke2ZpZWxkTGFiZWx9IG11c3Qgbm90IHN0YXJ0IG9yIGVuZCB3aXRoIHNwYWNlc2A7XG4gICAgfVxuICAgIGlmIChzbHVnSW5mby5zbHVncy5oYXModmFsKSkge1xuICAgICAgcmV0dXJuIGAke2ZpZWxkTGFiZWx9IG11c3QgYmUgdW5pcXVlYDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VBc05vcm1hbEZpZWxkKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEZpZWxkRGF0YUVycm9yKCdNdXN0IGJlIGEgc3RyaW5nJyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgZW1wdHlTZXQgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiB0ZXh0KHtcbiAgbGFiZWwsXG4gIGRlZmF1bHRWYWx1ZSA9ICcnLFxuICB2YWxpZGF0aW9uOiB7XG4gICAgbGVuZ3RoOiB7XG4gICAgICBtYXggPSBJbmZpbml0eSxcbiAgICAgIG1pbiA9IDBcbiAgICB9ID0ge31cbiAgfSA9IHt9LFxuICBkZXNjcmlwdGlvbixcbiAgbXVsdGlsaW5lID0gZmFsc2Vcbn0pIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUsIHNsdWdGaWVsZCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB2YWxpZGF0ZVRleHQodmFsdWUsIG1pbiwgbWF4LCBsYWJlbCwgc2x1Z0ZpZWxkKTtcbiAgICBpZiAobWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGtpbmQ6ICdmb3JtJyxcbiAgICBmb3JtS2luZDogJ3NsdWcnLFxuICAgIElucHV0KHByb3BzKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2pzeChUZXh0RmllbGRJbnB1dCwge1xuICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgICAgbWluOiBtaW4sXG4gICAgICAgIG1heDogbWF4LFxuICAgICAgICBtdWx0aWxpbmU6IG11bHRpbGluZSxcbiAgICAgICAgLi4ucHJvcHNcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09ICdzdHJpbmcnID8gZGVmYXVsdFZhbHVlIDogZGVmYXVsdFZhbHVlKCk7XG4gICAgfSxcbiAgICBwYXJzZSh2YWx1ZSwgYXJncykge1xuICAgICAgaWYgKChhcmdzID09PSBudWxsIHx8IGFyZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFyZ3Muc2x1ZykgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gYXJncy5zbHVnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlQXNOb3JtYWxGaWVsZCh2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXJpYWxpemUodmFsdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSA9PT0gJycgPyB1bmRlZmluZWQgOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9LFxuICAgIHNlcmlhbGl6ZVdpdGhTbHVnKHZhbHVlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzbHVnOiB2YWx1ZSxcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9LFxuICAgIHJlYWRlcjoge1xuICAgICAgcGFyc2UodmFsdWUpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VBc05vcm1hbEZpZWxkKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHBhcnNlZCwgdW5kZWZpbmVkKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZVdpdGhTbHVnKF92YWx1ZSwgYXJncykge1xuICAgICAgICB2YWxpZGF0ZShwYXJzZUFzTm9ybWFsRmllbGQoYXJncy5zbHVnKSwge1xuICAgICAgICAgIGdsb2I6IGFyZ3MuZ2xvYixcbiAgICAgICAgICBzbHVnczogZW1wdHlTZXRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdGUodmFsdWUsIGFyZ3MpIHtcbiAgICAgIHJldHVybiB2YWxpZGF0ZSh2YWx1ZSwgYXJncyA9PT0gbnVsbCB8fCBhcmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcmdzLnNsdWdGaWVsZCk7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCB0YWJsZUNlbGxDaGlsZHJlbiA9IFsncGFyYWdyYXBoJywgJ2NvZGUnLCAnaGVhZGluZycsICdvcmRlcmVkLWxpc3QnLCAndW5vcmRlcmVkLWxpc3QnLCAnZGl2aWRlcicsICdpbWFnZSddO1xuY29uc3QgYmxvY2txdW90ZUNoaWxkcmVuID0gWy4uLnRhYmxlQ2VsbENoaWxkcmVuLCAndGFibGUnXTtcbmNvbnN0IHBhcmFncmFwaExpa2UgPSBbLi4uYmxvY2txdW90ZUNoaWxkcmVuLCAnYmxvY2txdW90ZSddO1xuY29uc3QgaW5zaWRlT2ZMYXlvdXRzID0gWy4uLnBhcmFncmFwaExpa2UsICdjb21wb25lbnQtYmxvY2snXTtcbmZ1bmN0aW9uIGJsb2NrQ29udGFpbmVyKGFyZ3MpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiAnYmxvY2tzJyxcbiAgICBhbGxvd2VkQ2hpbGRyZW46IG5ldyBTZXQoYXJncy5hbGxvd2VkQ2hpbGRyZW4pLFxuICAgIGJsb2NrVG9XcmFwSW5saW5lc0luOiBhcmdzLmFsbG93ZWRDaGlsZHJlblswXSxcbiAgICBpbnZhbGlkUG9zaXRpb25IYW5kbGVNb2RlOiBhcmdzLmludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGlubGluZUNvbnRhaW5lcihhcmdzKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogJ2lubGluZXMnLFxuICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6IGFyZ3MuaW52YWxpZFBvc2l0aW9uSGFuZGxlTW9kZVxuICB9O1xufVxuXG4vLyBhIHVzZXIgbGFuZCB2ZXJzaW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvNDc5MjBcbmZ1bmN0aW9uIHNhdGlzZmllcygpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cbmNvbnN0IGVkaXRvclNjaGVtYSA9IHNhdGlzZmllcygpKHtcbiAgZWRpdG9yOiBibG9ja0NvbnRhaW5lcih7XG4gICAgYWxsb3dlZENoaWxkcmVuOiBbLi4uaW5zaWRlT2ZMYXlvdXRzLCAnbGF5b3V0J10sXG4gICAgaW52YWxpZFBvc2l0aW9uSGFuZGxlTW9kZTogJ21vdmUnXG4gIH0pLFxuICBsYXlvdXQ6IGJsb2NrQ29udGFpbmVyKHtcbiAgICBhbGxvd2VkQ2hpbGRyZW46IFsnbGF5b3V0LWFyZWEnXSxcbiAgICBpbnZhbGlkUG9zaXRpb25IYW5kbGVNb2RlOiAnbW92ZSdcbiAgfSksXG4gICdsYXlvdXQtYXJlYSc6IGJsb2NrQ29udGFpbmVyKHtcbiAgICBhbGxvd2VkQ2hpbGRyZW46IGluc2lkZU9mTGF5b3V0cyxcbiAgICBpbnZhbGlkUG9zaXRpb25IYW5kbGVNb2RlOiAndW53cmFwJ1xuICB9KSxcbiAgYmxvY2txdW90ZTogYmxvY2tDb250YWluZXIoe1xuICAgIGFsbG93ZWRDaGlsZHJlbjogYmxvY2txdW90ZUNoaWxkcmVuLFxuICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6ICdtb3ZlJ1xuICB9KSxcbiAgcGFyYWdyYXBoOiBpbmxpbmVDb250YWluZXIoe1xuICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6ICd1bndyYXAnXG4gIH0pLFxuICBjb2RlOiBpbmxpbmVDb250YWluZXIoe1xuICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6ICdtb3ZlJ1xuICB9KSxcbiAgZGl2aWRlcjogaW5saW5lQ29udGFpbmVyKHtcbiAgICBpbnZhbGlkUG9zaXRpb25IYW5kbGVNb2RlOiAnbW92ZSdcbiAgfSksXG4gIGhlYWRpbmc6IGlubGluZUNvbnRhaW5lcih7XG4gICAgaW52YWxpZFBvc2l0aW9uSGFuZGxlTW9kZTogJ3Vud3JhcCdcbiAgfSksXG4gICdjb21wb25lbnQtYmxvY2snOiBibG9ja0NvbnRhaW5lcih7XG4gICAgYWxsb3dlZENoaWxkcmVuOiBbJ2NvbXBvbmVudC1ibG9jay1wcm9wJywgJ2NvbXBvbmVudC1pbmxpbmUtcHJvcCddLFxuICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6ICdtb3ZlJ1xuICB9KSxcbiAgJ2NvbXBvbmVudC1pbmxpbmUtcHJvcCc6IGlubGluZUNvbnRhaW5lcih7XG4gICAgaW52YWxpZFBvc2l0aW9uSGFuZGxlTW9kZTogJ3Vud3JhcCdcbiAgfSksXG4gICdjb21wb25lbnQtYmxvY2stcHJvcCc6IGJsb2NrQ29udGFpbmVyKHtcbiAgICBhbGxvd2VkQ2hpbGRyZW46IFsuLi5wYXJhZ3JhcGhMaWtlLCAnY29tcG9uZW50LWJsb2NrJ10sXG4gICAgaW52YWxpZFBvc2l0aW9uSGFuZGxlTW9kZTogJ3Vud3JhcCdcbiAgfSksXG4gICdvcmRlcmVkLWxpc3QnOiBibG9ja0NvbnRhaW5lcih7XG4gICAgYWxsb3dlZENoaWxkcmVuOiBbJ2xpc3QtaXRlbSddLFxuICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6ICdtb3ZlJ1xuICB9KSxcbiAgJ3Vub3JkZXJlZC1saXN0JzogYmxvY2tDb250YWluZXIoe1xuICAgIGFsbG93ZWRDaGlsZHJlbjogWydsaXN0LWl0ZW0nXSxcbiAgICBpbnZhbGlkUG9zaXRpb25IYW5kbGVNb2RlOiAnbW92ZSdcbiAgfSksXG4gICdsaXN0LWl0ZW0nOiBibG9ja0NvbnRhaW5lcih7XG4gICAgYWxsb3dlZENoaWxkcmVuOiBbJ2xpc3QtaXRlbS1jb250ZW50JywgJ29yZGVyZWQtbGlzdCcsICd1bm9yZGVyZWQtbGlzdCddLFxuICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6ICd1bndyYXAnXG4gIH0pLFxuICAnbGlzdC1pdGVtLWNvbnRlbnQnOiBpbmxpbmVDb250YWluZXIoe1xuICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6ICd1bndyYXAnXG4gIH0pLFxuICBpbWFnZTogaW5saW5lQ29udGFpbmVyKHtcbiAgICBpbnZhbGlkUG9zaXRpb25IYW5kbGVNb2RlOiAnbW92ZSdcbiAgfSksXG4gIHRhYmxlOiBibG9ja0NvbnRhaW5lcih7XG4gICAgaW52YWxpZFBvc2l0aW9uSGFuZGxlTW9kZTogJ21vdmUnLFxuICAgIGFsbG93ZWRDaGlsZHJlbjogWyd0YWJsZS1oZWFkJywgJ3RhYmxlLWJvZHknXVxuICB9KSxcbiAgJ3RhYmxlLWJvZHknOiBibG9ja0NvbnRhaW5lcih7XG4gICAgaW52YWxpZFBvc2l0aW9uSGFuZGxlTW9kZTogJ21vdmUnLFxuICAgIGFsbG93ZWRDaGlsZHJlbjogWyd0YWJsZS1yb3cnXVxuICB9KSxcbiAgJ3RhYmxlLXJvdyc6IGJsb2NrQ29udGFpbmVyKHtcbiAgICBpbnZhbGlkUG9zaXRpb25IYW5kbGVNb2RlOiAnbW92ZScsXG4gICAgYWxsb3dlZENoaWxkcmVuOiBbJ3RhYmxlLWNlbGwnXVxuICB9KSxcbiAgJ3RhYmxlLWNlbGwnOiBibG9ja0NvbnRhaW5lcih7XG4gICAgaW52YWxpZFBvc2l0aW9uSGFuZGxlTW9kZTogJ21vdmUnLFxuICAgIGFsbG93ZWRDaGlsZHJlbjogdGFibGVDZWxsQ2hpbGRyZW5cbiAgfSksXG4gICd0YWJsZS1oZWFkJzogYmxvY2tDb250YWluZXIoe1xuICAgIGludmFsaWRQb3NpdGlvbkhhbmRsZU1vZGU6ICdtb3ZlJyxcbiAgICBhbGxvd2VkQ2hpbGRyZW46IFsndGFibGUtcm93J11cbiAgfSlcbn0pO1xuY29uc3QgaW5saW5lQ29udGFpbmVyVHlwZXMgPSBuZXcgU2V0KE9iamVjdC5lbnRyaWVzKGVkaXRvclNjaGVtYSkuZmlsdGVyKChbLCB2YWx1ZV0pID0+IHZhbHVlLmtpbmQgPT09ICdpbmxpbmVzJykubWFwKChbdHlwZV0pID0+IHR5cGUpKTtcbmZ1bmN0aW9uIGlzSW5saW5lQ29udGFpbmVyKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudHlwZSAhPT0gdW5kZWZpbmVkICYmIGlubGluZUNvbnRhaW5lclR5cGVzLmhhcyhub2RlLnR5cGUpO1xufVxuY29uc3QgYmxvY2tUeXBlcyA9IG5ldyBTZXQoT2JqZWN0LmtleXMoZWRpdG9yU2NoZW1hKS5maWx0ZXIoeCA9PiB4ICE9PSAnZWRpdG9yJykpO1xuZnVuY3Rpb24gaXNCbG9jayhub2RlKSB7XG4gIHJldHVybiBibG9ja1R5cGVzLmhhcyhub2RlLnR5cGUpO1xufVxuXG4vLyB0byBwcmludCB0aGUgZWRpdG9yIHNjaGVtYSBpbiBHcmFwaHZpeiBpZiB5b3Ugd2FudCB0byB2aXN1YWxpemUgaXRcbi8vIGZ1bmN0aW9uIHByaW50RWRpdG9yU2NoZW1hKGVkaXRvclNjaGVtYTogRWRpdG9yU2NoZW1hKSB7XG4vLyAgIHJldHVybiBgZGlncmFwaCBHIHtcbi8vICAgY29uY2VudHJhdGU9dHJ1ZTtcbi8vICAgJHtPYmplY3Qua2V5cyhlZGl0b3JTY2hlbWEpXG4vLyAgICAgLm1hcChrZXkgPT4ge1xuLy8gICAgICAgbGV0IHZhbCA9IGVkaXRvclNjaGVtYVtrZXldO1xuLy8gICAgICAgaWYgKHZhbC5raW5kID09PSAnaW5saW5lcycpIHtcbi8vICAgICAgICAgcmV0dXJuIGBcIiR7a2V5fVwiIC0+IGlubGluZXNgO1xuLy8gICAgICAgfVxuLy8gICAgICAgaWYgKHZhbC5raW5kID09PSAnYmxvY2tzJykge1xuLy8gICAgICAgICByZXR1cm4gYFwiJHtrZXl9XCIgLT4geyR7Wy4uLnZhbC5hbGxvd2VkQ2hpbGRyZW5dLm1hcCh4ID0+IEpTT04uc3RyaW5naWZ5KHgpKS5qb2luKCcgJyl9fWA7XG4vLyAgICAgICB9XG4vLyAgICAgfSlcbi8vICAgICAuam9pbignXFxuICAnKX1cbi8vIH1gO1xuLy8gfVxuXG5mdW5jdGlvbiBnZXREb2N1bWVudEZlYXR1cmVzRm9yQ2hpbGRGaWVsZChlZGl0b3JEb2N1bWVudEZlYXR1cmVzLCBvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRmb3JtYXR0aW5nLCBfb3B0aW9ucyRmb3JtYXR0aW5nMywgX29wdGlvbnMkZm9ybWF0dGluZzQsIF9vcHRpb25zJGZvcm1hdHRpbmc1LCBfb3B0aW9ucyRmb3JtYXR0aW5nNiwgX29wdGlvbnMkZm9ybWF0dGluZzc7XG4gIC8vIGFuIGltcG9ydGFudCBub3RlIGZvciB0aGlzOiBub3JtYWxpemF0aW9uIGJhc2VkIG9uIGRvY3VtZW50IGZlYXR1cmVzXG4gIC8vIGlzIGRvbmUgYmFzZWQgb24gdGhlIGRvY3VtZW50IGZlYXR1cmVzIHJldHVybmVkIGhlcmVcbiAgLy8gYW5kIHRoZSBlZGl0b3IgZG9jdW1lbnQgZmVhdHVyZXNcbiAgLy8gc28gdGhlIHJlc3VsdCBmb3IgYW55IGdpdmVuIGNoaWxkIHByb3Agd2lsbCBiZSB0aGUgdGhpbmdzIHRoYXQgYXJlXG4gIC8vIGFsbG93ZWQgYnkgYm90aCB0aGVzZSBkb2N1bWVudCBmZWF0dXJlc1xuICAvLyBBTkQgdGhlIGVkaXRvciBkb2N1bWVudCBmZWF0dXJlc1xuICBjb25zdCBpbmxpbmVNYXJrc0Zyb21PcHRpb25zID0gKF9vcHRpb25zJGZvcm1hdHRpbmcgPSBvcHRpb25zLmZvcm1hdHRpbmcpID09PSBudWxsIHx8IF9vcHRpb25zJGZvcm1hdHRpbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zJGZvcm1hdHRpbmcuaW5saW5lTWFya3M7XG4gIGNvbnN0IGlubGluZU1hcmtzID0gaW5saW5lTWFya3NGcm9tT3B0aW9ucyA9PT0gJ2luaGVyaXQnID8gJ2luaGVyaXQnIDogT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5rZXlzKGVkaXRvckRvY3VtZW50RmVhdHVyZXMuZm9ybWF0dGluZy5pbmxpbmVNYXJrcykubWFwKG1hcmsgPT4ge1xuICAgIHJldHVybiBbbWFyaywgISEoaW5saW5lTWFya3NGcm9tT3B0aW9ucyB8fCB7fSlbbWFya11dO1xuICB9KSk7XG4gIGlmIChvcHRpb25zLmtpbmQgPT09ICdpbmxpbmUnKSB7XG4gICAgdmFyIF9vcHRpb25zJGZvcm1hdHRpbmcyO1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiAnaW5saW5lJyxcbiAgICAgIGlubGluZU1hcmtzLFxuICAgICAgZG9jdW1lbnRGZWF0dXJlczoge1xuICAgICAgICBsaW5rczogb3B0aW9ucy5saW5rcyA9PT0gJ2luaGVyaXQnXG4gICAgICB9LFxuICAgICAgc29mdEJyZWFrczogKChfb3B0aW9ucyRmb3JtYXR0aW5nMiA9IG9wdGlvbnMuZm9ybWF0dGluZykgPT09IG51bGwgfHwgX29wdGlvbnMkZm9ybWF0dGluZzIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zJGZvcm1hdHRpbmcyLnNvZnRCcmVha3MpID09PSAnaW5oZXJpdCdcbiAgICB9O1xuICB9XG4gIGNvbnN0IGhlYWRpbmdMZXZlbHMgPSAoX29wdGlvbnMkZm9ybWF0dGluZzMgPSBvcHRpb25zLmZvcm1hdHRpbmcpID09PSBudWxsIHx8IF9vcHRpb25zJGZvcm1hdHRpbmczID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucyRmb3JtYXR0aW5nMy5oZWFkaW5nTGV2ZWxzO1xuICByZXR1cm4ge1xuICAgIGtpbmQ6ICdibG9jaycsXG4gICAgaW5saW5lTWFya3MsXG4gICAgc29mdEJyZWFrczogKChfb3B0aW9ucyRmb3JtYXR0aW5nNCA9IG9wdGlvbnMuZm9ybWF0dGluZykgPT09IG51bGwgfHwgX29wdGlvbnMkZm9ybWF0dGluZzQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zJGZvcm1hdHRpbmc0LnNvZnRCcmVha3MpID09PSAnaW5oZXJpdCcsXG4gICAgZG9jdW1lbnRGZWF0dXJlczoge1xuICAgICAgbGF5b3V0czogW10sXG4gICAgICBkaXZpZGVyczogb3B0aW9ucy5kaXZpZGVycyA9PT0gJ2luaGVyaXQnID8gZWRpdG9yRG9jdW1lbnRGZWF0dXJlcy5kaXZpZGVycyA6IGZhbHNlLFxuICAgICAgZm9ybWF0dGluZzoge1xuICAgICAgICBhbGlnbm1lbnQ6ICgoX29wdGlvbnMkZm9ybWF0dGluZzUgPSBvcHRpb25zLmZvcm1hdHRpbmcpID09PSBudWxsIHx8IF9vcHRpb25zJGZvcm1hdHRpbmc1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucyRmb3JtYXR0aW5nNS5hbGlnbm1lbnQpID09PSAnaW5oZXJpdCcgPyBlZGl0b3JEb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcuYWxpZ25tZW50IDoge1xuICAgICAgICAgIGNlbnRlcjogZmFsc2UsXG4gICAgICAgICAgZW5kOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBibG9ja1R5cGVzOiAoKF9vcHRpb25zJGZvcm1hdHRpbmc2ID0gb3B0aW9ucy5mb3JtYXR0aW5nKSA9PT0gbnVsbCB8fCBfb3B0aW9ucyRmb3JtYXR0aW5nNiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMkZm9ybWF0dGluZzYuYmxvY2tUeXBlcykgPT09ICdpbmhlcml0JyA/IGVkaXRvckRvY3VtZW50RmVhdHVyZXMuZm9ybWF0dGluZy5ibG9ja1R5cGVzIDoge1xuICAgICAgICAgIGJsb2NrcXVvdGU6IGZhbHNlLFxuICAgICAgICAgIGNvZGU6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIGhlYWRpbmdzOiBoZWFkaW5nTGV2ZWxzID09PSAnaW5oZXJpdCcgPyBlZGl0b3JEb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcuaGVhZGluZ3MgOiB7XG4gICAgICAgICAgbGV2ZWxzOiBoZWFkaW5nTGV2ZWxzID8gZWRpdG9yRG9jdW1lbnRGZWF0dXJlcy5mb3JtYXR0aW5nLmhlYWRpbmdzLmxldmVscy5maWx0ZXIobGV2ZWwgPT4gaGVhZGluZ0xldmVscy5pbmNsdWRlcyhsZXZlbCkpIDogW10sXG4gICAgICAgICAgc2NoZW1hOiBlZGl0b3JEb2N1bWVudEZlYXR1cmVzLmZvcm1hdHRpbmcuaGVhZGluZ3Muc2NoZW1hXG4gICAgICAgIH0sXG4gICAgICAgIGxpc3RUeXBlczogKChfb3B0aW9ucyRmb3JtYXR0aW5nNyA9IG9wdGlvbnMuZm9ybWF0dGluZykgPT09IG51bGwgfHwgX29wdGlvbnMkZm9ybWF0dGluZzcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zJGZvcm1hdHRpbmc3Lmxpc3RUeXBlcykgPT09ICdpbmhlcml0JyA/IGVkaXRvckRvY3VtZW50RmVhdHVyZXMuZm9ybWF0dGluZy5saXN0VHlwZXMgOiB7XG4gICAgICAgICAgb3JkZXJlZDogZmFsc2UsXG4gICAgICAgICAgdW5vcmRlcmVkOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGlua3M6IG9wdGlvbnMubGlua3MgPT09ICdpbmhlcml0JyxcbiAgICAgIGltYWdlczogb3B0aW9ucy5pbWFnZXMgPT09ICdpbmhlcml0JyA/IGVkaXRvckRvY3VtZW50RmVhdHVyZXMuaW1hZ2VzIDogZmFsc2UsXG4gICAgICB0YWJsZXM6IG9wdGlvbnMudGFibGVzID09PSAnaW5oZXJpdCdcbiAgICB9LFxuICAgIGNvbXBvbmVudEJsb2Nrczogb3B0aW9ucy5jb21wb25lbnRCbG9ja3MgPT09ICdpbmhlcml0J1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0U2NoZW1hQXRQcm9wUGF0aElubmVyKHBhdGgsIHZhbHVlLCBzY2hlbWEpIHtcbiAgLy8gYmVjYXVzZSB3ZSdyZSBjaGVja2luZyB0aGUgbGVuZ3RoIGhlcmVcbiAgLy8gdGhlIG5vbi1udWxsIGFzc2VydHMgb24gc2hpZnQgYmVsb3cgYXJlIGZpbmVcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHNjaGVtYTtcbiAgfVxuICBpZiAoc2NoZW1hLmtpbmQgPT09ICdjaGlsZCcgfHwgc2NoZW1hLmtpbmQgPT09ICdmb3JtJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc2NoZW1hLmtpbmQgPT09ICdjb25kaXRpb25hbCcpIHtcbiAgICBjb25zdCBrZXkgPSBwYXRoLnNoaWZ0KCk7XG4gICAgaWYgKGtleSA9PT0gJ2Rpc2NyaW1pbmFudCcpIHtcbiAgICAgIHJldHVybiBnZXRTY2hlbWFBdFByb3BQYXRoSW5uZXIocGF0aCwgdmFsdWUuZGlzY3JpbWluYW50LCBzY2hlbWEuZGlzY3JpbWluYW50KTtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgY29uc3QgcHJvcFZhbCA9IHNjaGVtYS52YWx1ZXNbdmFsdWUuZGlzY3JpbWluYW50XTtcbiAgICAgIHJldHVybiBnZXRTY2hlbWFBdFByb3BQYXRoSW5uZXIocGF0aCwgdmFsdWUudmFsdWUsIHByb3BWYWwpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNjaGVtYS5raW5kID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IGtleSA9IHBhdGguc2hpZnQoKTtcbiAgICByZXR1cm4gZ2V0U2NoZW1hQXRQcm9wUGF0aElubmVyKHBhdGgsIHZhbHVlW2tleV0sIHNjaGVtYS5maWVsZHNba2V5XSk7XG4gIH1cbiAgaWYgKHNjaGVtYS5raW5kID09PSAnYXJyYXknKSB7XG4gICAgY29uc3QgaW5kZXggPSBwYXRoLnNoaWZ0KCk7XG4gICAgcmV0dXJuIGdldFNjaGVtYUF0UHJvcFBhdGhJbm5lcihwYXRoLCB2YWx1ZVtpbmRleF0sIHNjaGVtYS5lbGVtZW50KTtcbiAgfVxuICBhc3NlcnROZXZlcihzY2hlbWEpO1xufVxuZnVuY3Rpb24gZ2V0U2NoZW1hQXRQcm9wUGF0aChwYXRoLCB2YWx1ZSwgcHJvcHMpIHtcbiAgcmV0dXJuIGdldFNjaGVtYUF0UHJvcFBhdGhJbm5lcihbLi4ucGF0aF0sIHZhbHVlLCB7XG4gICAga2luZDogJ29iamVjdCcsXG4gICAgZmllbGRzOiBwcm9wc1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEFuY2VzdG9yU2NoZW1hcyhyb290U2NoZW1hLCBwYXRoLCB2YWx1ZSkge1xuICBjb25zdCBhbmNlc3RvcnMgPSBbXTtcbiAgY29uc3QgY3VycmVudFBhdGggPSBbLi4ucGF0aF07XG4gIGxldCBjdXJyZW50UHJvcCA9IHJvb3RTY2hlbWE7XG4gIGxldCBjdXJyZW50VmFsdWUgPSB2YWx1ZTtcbiAgd2hpbGUgKGN1cnJlbnRQYXRoLmxlbmd0aCkge1xuICAgIGFuY2VzdG9ycy5wdXNoKGN1cnJlbnRQcm9wKTtcbiAgICBjb25zdCBrZXkgPSBjdXJyZW50UGF0aC5zaGlmdCgpOyAvLyB0aGlzIGNvZGUgb25seSBydW5zIHdoZW4gcGF0aC5sZW5ndGggaXMgdHJ1dGh5IHNvIHRoaXMgbm9uLW51bGwgYXNzZXJ0aW9uIGlzIGZpbmVcbiAgICBpZiAoY3VycmVudFByb3Aua2luZCA9PT0gJ2FycmF5Jykge1xuICAgICAgY3VycmVudFByb3AgPSBjdXJyZW50UHJvcC5lbGVtZW50O1xuICAgICAgY3VycmVudFZhbHVlID0gY3VycmVudFZhbHVlW2tleV07XG4gICAgfSBlbHNlIGlmIChjdXJyZW50UHJvcC5raW5kID09PSAnY29uZGl0aW9uYWwnKSB7XG4gICAgICBjdXJyZW50UHJvcCA9IGN1cnJlbnRQcm9wLnZhbHVlc1t2YWx1ZS5kaXNjcmltaW5hbnRdO1xuICAgICAgY3VycmVudFZhbHVlID0gY3VycmVudFZhbHVlLnZhbHVlO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudFByb3Aua2luZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9IGN1cnJlbnRWYWx1ZVtrZXldO1xuICAgICAgY3VycmVudFByb3AgPSBjdXJyZW50UHJvcC5maWVsZHNba2V5XTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRQcm9wLmtpbmQgPT09ICdjaGlsZCcgfHwgY3VycmVudFByb3Aua2luZCA9PT0gJ2Zvcm0nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgcHJvcCBcIiR7a2V5fVwiYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydE5ldmVyKGN1cnJlbnRQcm9wKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFuY2VzdG9ycztcbn1cblxuZnVuY3Rpb24gbW92ZUNoaWxkcmVuKGVkaXRvciwgcGFyZW50LCB0bywgc2hvdWxkTW92ZU5vZGUgPSAoKSA9PiB0cnVlKSB7XG4gIGNvbnN0IHBhcmVudFBhdGggPSBQYXRoLmlzUGF0aChwYXJlbnQpID8gcGFyZW50IDogcGFyZW50WzFdO1xuICBjb25zdCBwYXJlbnROb2RlID0gUGF0aC5pc1BhdGgocGFyZW50KSA/IE5vZGUuZ2V0KGVkaXRvciwgcGFyZW50UGF0aCkgOiBwYXJlbnRbMF07XG4gIGlmICghaXNCbG9jayhwYXJlbnROb2RlKSkgcmV0dXJuO1xuICBmb3IgKGxldCBpID0gcGFyZW50Tm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChzaG91bGRNb3ZlTm9kZShwYXJlbnROb2RlLmNoaWxkcmVuW2ldLCBpKSkge1xuICAgICAgY29uc3QgY2hpbGRQYXRoID0gWy4uLnBhcmVudFBhdGgsIGldO1xuICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBjaGlsZFBhdGgsXG4gICAgICAgIHRvXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gRWRpdG9yLmFmdGVyIGV4Y2VwdCB0aGF0IGl0IGlnbm9yZXMgcG9pbnRzIHRoYXQgaGF2ZSBubyBjb250ZW50XG4gKiBsaWtlIHRoZSBwb2ludCBpbiBhIHZvaWQgdGV4dCBub2RlLCBhbiBlbXB0eSB0ZXh0IG5vZGUgYW5kIHRoZSBsYXN0IHBvaW50IGluIGEgdGV4dCBub2RlXG4gKi9cbi8vIFRPRE86IHRoaXMgd291bGQgcHJvYmFibHkgYnJlYWsgaWYgeW91IHdlcmUgdHJ5aW5nIHRvIGdldCB0aGUgbGFzdCBwb2ludCBpbiB0aGUgZWRpdG9yP1xuZnVuY3Rpb24gRWRpdG9yQWZ0ZXJCdXRJZ25vcmluZ2luZ1BvaW50c1dpdGhOb0NvbnRlbnQoZWRpdG9yLCBhdCwge1xuICBkaXN0YW5jZSA9IDFcbn0gPSB7fSkge1xuICBjb25zdCBhbmNob3IgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgIGVkZ2U6ICdlbmQnXG4gIH0pO1xuICBjb25zdCBmb2N1cyA9IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG4gIGNvbnN0IHJhbmdlID0ge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9O1xuICBsZXQgZCA9IDA7XG4gIGxldCB0YXJnZXQ7XG4gIGZvciAoY29uc3QgcCBvZiBFZGl0b3IucG9zaXRpb25zKGVkaXRvciwge1xuICAgIGF0OiByYW5nZVxuICB9KSkge1xuICAgIGlmIChkID4gZGlzdGFuY2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIHRoaXMgaXMgdGhlIGltcG9ydGFudCBjaGFuZ2VcbiAgICBjb25zdCBub2RlID0gTm9kZS5nZXQoZWRpdG9yLCBwLnBhdGgpO1xuICAgIGlmIChub2RlLnRleHQubGVuZ3RoID09PSBwLm9mZnNldCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChkICE9PSAwKSB7XG4gICAgICB0YXJnZXQgPSBwO1xuICAgIH1cbiAgICBkKys7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIG5vZGVUeXBlTWF0Y2hlciguLi5hcmdzKSB7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IHR5cGUgPSBhcmdzWzBdO1xuICAgIHJldHVybiBub2RlID0+IG5vZGUudHlwZSA9PT0gdHlwZTtcbiAgfVxuICBjb25zdCBzZXQgPSBuZXcgU2V0KGFyZ3MpO1xuICByZXR1cm4gbm9kZSA9PiB0eXBlb2Ygbm9kZS50eXBlID09PSAnc3RyaW5nJyAmJiBzZXQuaGFzKG5vZGUudHlwZSk7XG59XG5mdW5jdGlvbiBnZXRBbmNlc3RvckNvbXBvbmVudENoaWxkRmllbGREb2N1bWVudEZlYXR1cmVzKGVkaXRvciwgZWRpdG9yRG9jdW1lbnRGZWF0dXJlcywgY29tcG9uZW50QmxvY2tzKSB7XG4gIGNvbnN0IGFuY2VzdG9yQ29tcG9uZW50UHJvcCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICBtYXRjaDogbm9kZVR5cGVNYXRjaGVyKCdjb21wb25lbnQtYmxvY2stcHJvcCcsICdjb21wb25lbnQtaW5saW5lLXByb3AnKVxuICB9KTtcbiAgaWYgKGFuY2VzdG9yQ29tcG9uZW50UHJvcCkge1xuICAgIGNvbnN0IHByb3BQYXRoID0gYW5jZXN0b3JDb21wb25lbnRQcm9wWzBdLnByb3BQYXRoO1xuICAgIGNvbnN0IGFuY2VzdG9yQ29tcG9uZW50ID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIGFuY2VzdG9yQ29tcG9uZW50UHJvcFsxXSk7XG4gICAgaWYgKGFuY2VzdG9yQ29tcG9uZW50WzBdLnR5cGUgPT09ICdjb21wb25lbnQtYmxvY2snKSB7XG4gICAgICBjb25zdCBjb21wb25lbnQgPSBhbmNlc3RvckNvbXBvbmVudFswXS5jb21wb25lbnQ7XG4gICAgICBjb25zdCBjb21wb25lbnRCbG9jayA9IGNvbXBvbmVudEJsb2Nrc1tjb21wb25lbnRdO1xuICAgICAgaWYgKGNvbXBvbmVudEJsb2NrICYmIHByb3BQYXRoKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkRmllbGQgPSBnZXRTY2hlbWFBdFByb3BQYXRoKHByb3BQYXRoLCBhbmNlc3RvckNvbXBvbmVudFswXS5wcm9wcywgY29tcG9uZW50QmxvY2suc2NoZW1hKTtcbiAgICAgICAgaWYgKChjaGlsZEZpZWxkID09PSBudWxsIHx8IGNoaWxkRmllbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoaWxkRmllbGQua2luZCkgPT09ICdjaGlsZCcpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0RG9jdW1lbnRGZWF0dXJlc0ZvckNoaWxkRmllbGQoZWRpdG9yRG9jdW1lbnRGZWF0dXJlcywgY2hpbGRGaWVsZC5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuZ2xvYmFsVGhpcy5QcmlzbSA9IHtcbiAgbWFudWFsOiB0cnVlXG59O1xuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLWNvcmUuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLy8vIDxyZWZlcmVuY2UgbGliPVwiV2ViV29ya2VyXCIvPlxuXG52YXIgX3NlbGYgPSBnbG9iYWxUaGlzO1xuXG4vKipcbiAqIFByaXNtOiBMaWdodHdlaWdodCwgcm9idXN0LCBlbGVnYW50IHN5bnRheCBoaWdobGlnaHRpbmdcbiAqXG4gKiBAbGljZW5zZSBNSVQgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPlxuICogQGF1dGhvciBMZWEgVmVyb3UgPGh0dHBzOi8vbGVhLnZlcm91Lm1lPlxuICogQG5hbWVzcGFjZVxuICogQHB1YmxpY1xuICovXG52YXIgUHJpc20gPSBmdW5jdGlvbiAoX3NlbGYpIHtcbiAgLy8gUHJpdmF0ZSBoZWxwZXIgdmFyc1xuICB2YXIgbGFuZyA9IC8oPzpefFxccylsYW5nKD86dWFnZSk/LShbXFx3LV0rKSg/PVxcc3wkKS9pO1xuICB2YXIgdW5pcXVlSWQgPSAwO1xuXG4gIC8vIFRoZSBncmFtbWFyIG9iamVjdCBmb3IgcGxhaW50ZXh0XG4gIHZhciBwbGFpblRleHRHcmFtbWFyID0ge307XG4gIHZhciBfID0ge1xuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIFByaXNtIHdpbGwgYXR0ZW1wdCB0byBoaWdobGlnaHQgYWxsIGNvZGUgZWxlbWVudHMgKGJ5IGNhbGxpbmcge0BsaW5rIFByaXNtLmhpZ2hsaWdodEFsbH0pIG9uIHRoZVxuICAgICAqIGN1cnJlbnQgcGFnZSBhZnRlciB0aGUgcGFnZSBmaW5pc2hlZCBsb2FkaW5nLiBUaGlzIG1pZ2h0IGJlIGEgcHJvYmxlbSBpZiBlLmcuIHlvdSB3YW50ZWQgdG8gYXN5bmNocm9ub3VzbHkgbG9hZFxuICAgICAqIGFkZGl0aW9uYWwgbGFuZ3VhZ2VzIG9yIHBsdWdpbnMgeW91cnNlbGYuXG4gICAgICpcbiAgICAgKiBCeSBzZXR0aW5nIHRoaXMgdmFsdWUgdG8gYHRydWVgLCBQcmlzbSB3aWxsIG5vdCBhdXRvbWF0aWNhbGx5IGhpZ2hsaWdodCBhbGwgY29kZSBlbGVtZW50cyBvbiB0aGUgcGFnZS5cbiAgICAgKlxuICAgICAqIFlvdSBvYnZpb3VzbHkgaGF2ZSB0byBjaGFuZ2UgdGhpcyB2YWx1ZSBiZWZvcmUgdGhlIGF1dG9tYXRpYyBoaWdobGlnaHRpbmcgc3RhcnRlZC4gVG8gZG8gdGhpcywgeW91IGNhbiBhZGQgYW5cbiAgICAgKiBlbXB0eSBQcmlzbSBvYmplY3QgaW50byB0aGUgZ2xvYmFsIHNjb3BlIGJlZm9yZSBsb2FkaW5nIHRoZSBQcmlzbSBzY3JpcHQgbGlrZSB0aGlzOlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiB3aW5kb3cuUHJpc20gPSB3aW5kb3cuUHJpc20gfHwge307XG4gICAgICogUHJpc20ubWFudWFsID0gdHJ1ZTtcbiAgICAgKiAvLyBhZGQgYSBuZXcgPHNjcmlwdD4gdG8gbG9hZCBQcmlzbSdzIHNjcmlwdFxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyb2YgUHJpc21cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgbWFudWFsOiBfc2VsZi5QcmlzbSAmJiBfc2VsZi5QcmlzbS5tYW51YWwsXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgaWYgUHJpc20gaXMgaW4gYSB3ZWIgd29ya2VyLCBpdCBhc3N1bWVzIHRoYXQgaXQgaXMgaW4gYSB3b3JrZXIgaXQgY3JlYXRlZCBpdHNlbGYsIHNvIGl0IHVzZXNcbiAgICAgKiBgYWRkRXZlbnRMaXN0ZW5lcmAgdG8gY29tbXVuaWNhdGUgd2l0aCBpdHMgcGFyZW50IGluc3RhbmNlLiBIb3dldmVyLCBpZiB5b3UncmUgdXNpbmcgUHJpc20gbWFudWFsbHkgaW4geW91clxuICAgICAqIG93biB3b3JrZXIsIHlvdSBkb24ndCB3YW50IGl0IHRvIGRvIHRoaXMuXG4gICAgICpcbiAgICAgKiBCeSBzZXR0aW5nIHRoaXMgdmFsdWUgdG8gYHRydWVgLCBQcmlzbSB3aWxsIG5vdCBhZGQgaXRzIG93biBsaXN0ZW5lcnMgdG8gdGhlIHdvcmtlci5cbiAgICAgKlxuICAgICAqIFlvdSBvYnZpb3VzbHkgaGF2ZSB0byBjaGFuZ2UgdGhpcyB2YWx1ZSBiZWZvcmUgUHJpc20gZXhlY3V0ZXMuIFRvIGRvIHRoaXMsIHlvdSBjYW4gYWRkIGFuXG4gICAgICogZW1wdHkgUHJpc20gb2JqZWN0IGludG8gdGhlIGdsb2JhbCBzY29wZSBiZWZvcmUgbG9hZGluZyB0aGUgUHJpc20gc2NyaXB0IGxpa2UgdGhpczpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogd2luZG93LlByaXNtID0gd2luZG93LlByaXNtIHx8IHt9O1xuICAgICAqIFByaXNtLmRpc2FibGVXb3JrZXJNZXNzYWdlSGFuZGxlciA9IHRydWU7XG4gICAgICogLy8gTG9hZCBQcmlzbSdzIHNjcmlwdFxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyb2YgUHJpc21cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZGlzYWJsZVdvcmtlck1lc3NhZ2VIYW5kbGVyOiBfc2VsZi5QcmlzbSAmJiBfc2VsZi5QcmlzbS5kaXNhYmxlV29ya2VyTWVzc2FnZUhhbmRsZXIsXG4gICAgLyoqXG4gICAgICogQSBuYW1lc3BhY2UgZm9yIHV0aWxpdHkgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIEFsbCBmdW5jdGlvbiBpbiB0aGlzIG5hbWVzcGFjZSB0aGF0IGFyZSBub3QgZXhwbGljaXRseSBtYXJrZWQgYXMgX3B1YmxpY18gYXJlIGZvciBfX2ludGVybmFsIHVzZSBvbmx5X18gYW5kIG1heVxuICAgICAqIGNoYW5nZSBvciBkaXNhcHBlYXIgYXQgYW55IHRpbWUuXG4gICAgICpcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFByaXNtXG4gICAgICovXG4gICAgdXRpbDoge1xuICAgICAgZW5jb2RlOiBmdW5jdGlvbiBlbmNvZGUodG9rZW5zKSB7XG4gICAgICAgIGlmICh0b2tlbnMgaW5zdGFuY2VvZiBUb2tlbikge1xuICAgICAgICAgIHJldHVybiBuZXcgVG9rZW4odG9rZW5zLnR5cGUsIGVuY29kZSh0b2tlbnMuY29udGVudCksIHRva2Vucy5hbGlhcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0b2tlbnMpKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2Vucy5tYXAoZW5jb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW5zLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoL1xcdTAwYTAvZywgJyAnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgdHlwZSBvZiB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHthbnl9IG9cbiAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogdHlwZShudWxsKSAgICAgID09PSAnTnVsbCdcbiAgICAgICAqIHR5cGUodW5kZWZpbmVkKSA9PT0gJ1VuZGVmaW5lZCdcbiAgICAgICAqIHR5cGUoMTIzKSAgICAgICA9PT0gJ051bWJlcidcbiAgICAgICAqIHR5cGUoJ2ZvbycpICAgICA9PT0gJ1N0cmluZydcbiAgICAgICAqIHR5cGUodHJ1ZSkgICAgICA9PT0gJ0Jvb2xlYW4nXG4gICAgICAgKiB0eXBlKFsxLCAyXSkgICAgPT09ICdBcnJheSdcbiAgICAgICAqIHR5cGUoe30pICAgICAgICA9PT0gJ09iamVjdCdcbiAgICAgICAqIHR5cGUoU3RyaW5nKSAgICA9PT0gJ0Z1bmN0aW9uJ1xuICAgICAgICogdHlwZSgvYWJjKy8pICAgID09PSAnUmVnRXhwJ1xuICAgICAgICovXG4gICAgICB0eXBlOiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSB1bmlxdWUgbnVtYmVyIGZvciB0aGUgZ2l2ZW4gb2JqZWN0LiBMYXRlciBjYWxscyB3aWxsIHN0aWxsIHJldHVybiB0aGUgc2FtZSBudW1iZXIuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgb2JqSWQ6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgaWYgKCFvYmpbJ19faWQnXSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosICdfX2lkJywge1xuICAgICAgICAgICAgdmFsdWU6ICsrdW5pcXVlSWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqWydfX2lkJ107XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgZGVlcCBjbG9uZSBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICAgICAgICpcbiAgICAgICAqIFRoZSBtYWluIGludGVuZGVkIHVzZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIHRvIGNsb25lIGxhbmd1YWdlIGRlZmluaXRpb25zLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7VH0gb1xuICAgICAgICogQHBhcmFtIHtSZWNvcmQ8bnVtYmVyLCBhbnk+fSBbdmlzaXRlZF1cbiAgICAgICAqIEByZXR1cm5zIHtUfVxuICAgICAgICogQHRlbXBsYXRlIFRcbiAgICAgICAqL1xuICAgICAgY2xvbmU6IGZ1bmN0aW9uIGRlZXBDbG9uZShvLCB2aXNpdGVkKSB7XG4gICAgICAgIHZpc2l0ZWQgPSB2aXNpdGVkIHx8IHt9O1xuICAgICAgICB2YXIgY2xvbmU7XG4gICAgICAgIHZhciBpZDtcbiAgICAgICAgc3dpdGNoIChfLnV0aWwudHlwZShvKSkge1xuICAgICAgICAgIGNhc2UgJ09iamVjdCc6XG4gICAgICAgICAgICBpZCA9IF8udXRpbC5vYmpJZChvKTtcbiAgICAgICAgICAgIGlmICh2aXNpdGVkW2lkXSkge1xuICAgICAgICAgICAgICByZXR1cm4gdmlzaXRlZFtpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbG9uZSA9IC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gKi97fTtcbiAgICAgICAgICAgIHZpc2l0ZWRbaWRdID0gY2xvbmU7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbykge1xuICAgICAgICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgY2xvbmVba2V5XSA9IGRlZXBDbG9uZShvW2tleV0sIHZpc2l0ZWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKC8qKiBAdHlwZSB7YW55fSAqL2Nsb25lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgICAgICAgIGlkID0gXy51dGlsLm9iaklkKG8pO1xuICAgICAgICAgICAgaWYgKHZpc2l0ZWRbaWRdKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2aXNpdGVkW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsb25lID0gW107XG4gICAgICAgICAgICB2aXNpdGVkW2lkXSA9IGNsb25lO1xuICAgICAgICAgICAgLyoqIEB0eXBlIHtBcnJheX0gKi8gLyoqIEB0eXBlIHthbnl9ICovby5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgICAgICAgIGNsb25lW2ldID0gZGVlcENsb25lKHYsIHZpc2l0ZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKC8qKiBAdHlwZSB7YW55fSAqL2Nsb25lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0aGUgUHJpc20gbGFuZ3VhZ2Ugb2YgdGhlIGdpdmVuIGVsZW1lbnQgc2V0IGJ5IGEgYGxhbmd1YWdlLXh4eHhgIG9yIGBsYW5nLXh4eHhgIGNsYXNzLlxuICAgICAgICpcbiAgICAgICAqIElmIG5vIGxhbmd1YWdlIGlzIHNldCBmb3IgdGhlIGVsZW1lbnQgb3IgdGhlIGVsZW1lbnQgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLCBgbm9uZWAgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIGdldExhbmd1YWdlOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB3aGlsZSAoZWxlbWVudCkge1xuICAgICAgICAgIHZhciBtID0gbGFuZy5leGVjKGVsZW1lbnQuY2xhc3NOYW1lKTtcbiAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgcmV0dXJuIG1bMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ25vbmUnO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogU2V0cyB0aGUgUHJpc20gYGxhbmd1YWdlLXh4eHhgIGNsYXNzIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlXG4gICAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgICAqL1xuICAgICAgc2V0TGFuZ3VhZ2U6IGZ1bmN0aW9uIChlbGVtZW50LCBsYW5ndWFnZSkge1xuICAgICAgICAvLyByZW1vdmUgYWxsIGBsYW5ndWFnZS14eHh4YCBjbGFzc2VzXG4gICAgICAgIC8vICh0aGlzIG1pZ2h0IGxlYXZlIGJlaGluZCBhIGxlYWRpbmcgc3BhY2UpXG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZShSZWdFeHAobGFuZywgJ2dpJyksICcnKTtcblxuICAgICAgICAvLyBhZGQgdGhlIG5ldyBgbGFuZ3VhZ2UteHh4eGAgY2xhc3NcbiAgICAgICAgLy8gKHVzaW5nIGBjbGFzc0xpc3RgIHdpbGwgYXV0b21hdGljYWxseSBjbGVhbiB1cCBzcGFjZXMgZm9yIHVzKVxuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2xhbmd1YWdlLScgKyBsYW5ndWFnZSk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSBzY3JpcHQgZWxlbWVudCB0aGF0IGlzIGN1cnJlbnRseSBleGVjdXRpbmcuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBkb2VzIF9fbm90X18gd29yayBmb3IgbGluZSBzY3JpcHQgZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7SFRNTFNjcmlwdEVsZW1lbnQgfCBudWxsfVxuICAgICAgICovXG4gICAgICBjdXJyZW50U2NyaXB0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdjdXJyZW50U2NyaXB0JyBpbiBkb2N1bWVudCAmJiAxIDwgMiAvKiBoYWNrIHRvIHRyaXAgVFMnIGZsb3cgYW5hbHlzaXMgKi8pIHtcbiAgICAgICAgICByZXR1cm4gKC8qKiBAdHlwZSB7YW55fSAqL2RvY3VtZW50LmN1cnJlbnRTY3JpcHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSUUxMSB3b3JrYXJvdW5kXG4gICAgICAgIC8vIHdlJ2xsIGdldCB0aGUgc3JjIG9mIHRoZSBjdXJyZW50IHNjcmlwdCBieSBwYXJzaW5nIElFMTEncyBlcnJvciBzdGFjayB0cmFjZVxuICAgICAgICAvLyB0aGlzIHdpbGwgbm90IHdvcmsgZm9yIGlubGluZSBzY3JpcHRzXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gR2V0IGZpbGUgc3JjIHVybCBmcm9tIHN0YWNrLiBTcGVjaWZpY2FsbHkgd29ya3Mgd2l0aCB0aGUgZm9ybWF0IG9mIHN0YWNrIHRyYWNlcyBpbiBJRS5cbiAgICAgICAgICAvLyBBIHN0YWNrIHdpbGwgbG9vayBsaWtlIHRoaXM6XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBFcnJvclxuICAgICAgICAgIC8vICAgIGF0IF8udXRpbC5jdXJyZW50U2NyaXB0IChodHRwOi8vbG9jYWxob3N0L2NvbXBvbmVudHMvcHJpc20tY29yZS5qczoxMTk6NSlcbiAgICAgICAgICAvLyAgICBhdCBHbG9iYWwgY29kZSAoaHR0cDovL2xvY2FsaG9zdC9jb21wb25lbnRzL3ByaXNtLWNvcmUuanM6NjA2OjEpXG5cbiAgICAgICAgICB2YXIgc3JjID0gKC9hdCBbXihcXHJcXG5dKlxcKCguKik6W146XSs6W146XStcXCkkL2kuZXhlYyhlcnIuc3RhY2spIHx8IFtdKVsxXTtcbiAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICB2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gc2NyaXB0cykge1xuICAgICAgICAgICAgICBpZiAoc2NyaXB0c1tpXS5zcmMgPT0gc3JjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjcmlwdHNbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgd2hldGhlciBhIGdpdmVuIGNsYXNzIGlzIGFjdGl2ZSBmb3IgYGVsZW1lbnRgLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBjbGFzcyBjYW4gYmUgYWN0aXZhdGVkIGlmIGBlbGVtZW50YCBvciBvbmUgb2YgaXRzIGFuY2VzdG9ycyBoYXMgdGhlIGdpdmVuIGNsYXNzIGFuZCBpdCBjYW4gYmUgZGVhY3RpdmF0ZWRcbiAgICAgICAqIGlmIGBlbGVtZW50YCBvciBvbmUgb2YgaXRzIGFuY2VzdG9ycyBoYXMgdGhlIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gY2xhc3MuIFRoZSBfbmVnYXRlZCB2ZXJzaW9uXyBvZiB0aGVcbiAgICAgICAqIGdpdmVuIGNsYXNzIGlzIGp1c3QgdGhlIGdpdmVuIGNsYXNzIHdpdGggYSBgbm8tYCBwcmVmaXguXG4gICAgICAgKlxuICAgICAgICogV2hldGhlciB0aGUgY2xhc3MgaXMgYWN0aXZlIGlzIGRldGVybWluZWQgYnkgdGhlIGNsb3Nlc3QgYW5jZXN0b3Igb2YgYGVsZW1lbnRgICh3aGVyZSBgZWxlbWVudGAgaXRzZWxmIGlzXG4gICAgICAgKiBjbG9zZXN0IGFuY2VzdG9yKSB0aGF0IGhhcyB0aGUgZ2l2ZW4gY2xhc3Mgb3IgdGhlIG5lZ2F0ZWQgdmVyc2lvbiBvZiBpdC4gSWYgbmVpdGhlciBgZWxlbWVudGAgbm9yIGFueSBvZiBpdHNcbiAgICAgICAqIGFuY2VzdG9ycyBoYXZlIHRoZSBnaXZlbiBjbGFzcyBvciB0aGUgbmVnYXRlZCB2ZXJzaW9uIG9mIGl0LCB0aGVuIHRoZSBkZWZhdWx0IGFjdGl2YXRpb24gd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgICAqXG4gICAgICAgKiBJbiB0aGUgcGFyYWRveGljYWwgc2l0dWF0aW9uIHdoZXJlIHRoZSBjbG9zZXN0IGFuY2VzdG9yIGNvbnRhaW5zIF9fYm90aF9fIHRoZSBnaXZlbiBjbGFzcyBhbmQgdGhlIG5lZ2F0ZWRcbiAgICAgICAqIHZlcnNpb24gb2YgaXQsIHRoZSBjbGFzcyBpcyBjb25zaWRlcmVkIGFjdGl2ZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlZmF1bHRBY3RpdmF0aW9uPWZhbHNlXVxuICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIGlzQWN0aXZlOiBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lLCBkZWZhdWx0QWN0aXZhdGlvbikge1xuICAgICAgICB2YXIgbm8gPSAnbm8tJyArIGNsYXNzTmFtZTtcbiAgICAgICAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICAgICAgICB2YXIgY2xhc3NMaXN0ID0gZWxlbWVudC5jbGFzc0xpc3Q7XG4gICAgICAgICAgaWYgKGNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNsYXNzTGlzdC5jb250YWlucyhubykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISFkZWZhdWx0QWN0aXZhdGlvbjtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoaXMgbmFtZXNwYWNlIGNvbnRhaW5zIGFsbCBjdXJyZW50bHkgbG9hZGVkIGxhbmd1YWdlcyBhbmQgdGhlIHNvbWUgaGVscGVyIGZ1bmN0aW9ucyB0byBjcmVhdGUgYW5kIG1vZGlmeSBsYW5ndWFnZXMuXG4gICAgICpcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFByaXNtXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGxhbmd1YWdlczoge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgZ3JhbW1hciBmb3IgcGxhaW4sIHVuZm9ybWF0dGVkIHRleHQuXG4gICAgICAgKi9cbiAgICAgIHBsYWluOiBwbGFpblRleHRHcmFtbWFyLFxuICAgICAgcGxhaW50ZXh0OiBwbGFpblRleHRHcmFtbWFyLFxuICAgICAgdGV4dDogcGxhaW5UZXh0R3JhbW1hcixcbiAgICAgIHR4dDogcGxhaW5UZXh0R3JhbW1hcixcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIGRlZXAgY29weSBvZiB0aGUgbGFuZ3VhZ2Ugd2l0aCB0aGUgZ2l2ZW4gaWQgYW5kIGFwcGVuZHMgdGhlIGdpdmVuIHRva2Vucy5cbiAgICAgICAqXG4gICAgICAgKiBJZiBhIHRva2VuIGluIGByZWRlZmAgYWxzbyBhcHBlYXJzIGluIHRoZSBjb3BpZWQgbGFuZ3VhZ2UsIHRoZW4gdGhlIGV4aXN0aW5nIHRva2VuIGluIHRoZSBjb3BpZWQgbGFuZ3VhZ2VcbiAgICAgICAqIHdpbGwgYmUgb3ZlcndyaXR0ZW4gYXQgaXRzIG9yaWdpbmFsIHBvc2l0aW9uLlxuICAgICAgICpcbiAgICAgICAqICMjIEJlc3QgcHJhY3RpY2VzXG4gICAgICAgKlxuICAgICAgICogU2luY2UgdGhlIHBvc2l0aW9uIG9mIG92ZXJ3cml0aW5nIHRva2VucyAodG9rZW4gaW4gYHJlZGVmYCB0aGF0IG92ZXJ3cml0ZSB0b2tlbnMgaW4gdGhlIGNvcGllZCBsYW5ndWFnZSlcbiAgICAgICAqIGRvZXNuJ3QgbWF0dGVyLCB0aGV5IGNhbiB0ZWNobmljYWxseSBiZSBpbiBhbnkgb3JkZXIuIEhvd2V2ZXIsIHRoaXMgY2FuIGJlIGNvbmZ1c2luZyB0byBvdGhlcnMgdGhhdCB0cnlpbmcgdG9cbiAgICAgICAqIHVuZGVyc3RhbmQgdGhlIGxhbmd1YWdlIGRlZmluaXRpb24gYmVjYXVzZSwgbm9ybWFsbHksIHRoZSBvcmRlciBvZiB0b2tlbnMgbWF0dGVycyBpbiBQcmlzbSBncmFtbWFycy5cbiAgICAgICAqXG4gICAgICAgKiBUaGVyZWZvcmUsIGl0IGlzIGVuY291cmFnZWQgdG8gb3JkZXIgb3ZlcndyaXRpbmcgdG9rZW5zIGFjY29yZGluZyB0byB0aGUgcG9zaXRpb25zIG9mIHRoZSBvdmVyd3JpdHRlbiB0b2tlbnMuXG4gICAgICAgKiBGdXJ0aGVybW9yZSwgYWxsIG5vbi1vdmVyd3JpdGluZyB0b2tlbnMgc2hvdWxkIGJlIHBsYWNlZCBhZnRlciB0aGUgb3ZlcndyaXRpbmcgb25lcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGlkIG9mIHRoZSBsYW5ndWFnZSB0byBleHRlbmQuIFRoaXMgaGFzIHRvIGJlIGEga2V5IGluIGBQcmlzbS5sYW5ndWFnZXNgLlxuICAgICAgICogQHBhcmFtIHtHcmFtbWFyfSByZWRlZiBUaGUgbmV3IHRva2VucyB0byBhcHBlbmQuXG4gICAgICAgKiBAcmV0dXJucyB7R3JhbW1hcn0gVGhlIG5ldyBsYW5ndWFnZSBjcmVhdGVkLlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIFByaXNtLmxhbmd1YWdlc1snY3NzLXdpdGgtY29sb3JzJ10gPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjc3MnLCB7XG4gICAgICAgKiAgICAgLy8gUHJpc20ubGFuZ3VhZ2VzLmNzcyBhbHJlYWR5IGhhcyBhICdjb21tZW50JyB0b2tlbiwgc28gdGhpcyB0b2tlbiB3aWxsIG92ZXJ3cml0ZSBDU1MnICdjb21tZW50JyB0b2tlblxuICAgICAgICogICAgIC8vIGF0IGl0cyBvcmlnaW5hbCBwb3NpdGlvblxuICAgICAgICogICAgICdjb21tZW50JzogeyAuLi4gfSxcbiAgICAgICAqICAgICAvLyBDU1MgZG9lc24ndCBoYXZlIGEgJ2NvbG9yJyB0b2tlbiwgc28gdGhpcyB0b2tlbiB3aWxsIGJlIGFwcGVuZGVkXG4gICAgICAgKiAgICAgJ2NvbG9yJzogL1xcYig/OnJlZHxncmVlbnxibHVlKVxcYi9cbiAgICAgICAqIH0pO1xuICAgICAgICovXG4gICAgICBleHRlbmQ6IGZ1bmN0aW9uIChpZCwgcmVkZWYpIHtcbiAgICAgICAgdmFyIGxhbmcgPSBfLnV0aWwuY2xvbmUoXy5sYW5ndWFnZXNbaWRdKTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHJlZGVmKSB7XG4gICAgICAgICAgbGFuZ1trZXldID0gcmVkZWZba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFuZztcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEluc2VydHMgdG9rZW5zIF9iZWZvcmVfIGFub3RoZXIgdG9rZW4gaW4gYSBsYW5ndWFnZSBkZWZpbml0aW9uIG9yIGFueSBvdGhlciBncmFtbWFyLlxuICAgICAgICpcbiAgICAgICAqICMjIFVzYWdlXG4gICAgICAgKlxuICAgICAgICogVGhpcyBoZWxwZXIgbWV0aG9kIG1ha2VzIGl0IGVhc3kgdG8gbW9kaWZ5IGV4aXN0aW5nIGxhbmd1YWdlcy4gRm9yIGV4YW1wbGUsIHRoZSBDU1MgbGFuZ3VhZ2UgZGVmaW5pdGlvblxuICAgICAgICogbm90IG9ubHkgZGVmaW5lcyBDU1MgaGlnaGxpZ2h0aW5nIGZvciBDU1MgZG9jdW1lbnRzLCBidXQgYWxzbyBuZWVkcyB0byBkZWZpbmUgaGlnaGxpZ2h0aW5nIGZvciBDU1MgZW1iZWRkZWRcbiAgICAgICAqIGluIEhUTUwgdGhyb3VnaCBgPHN0eWxlPmAgZWxlbWVudHMuIFRvIGRvIHRoaXMsIGl0IG5lZWRzIHRvIG1vZGlmeSBgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cGAgYW5kIGFkZCB0aGVcbiAgICAgICAqIGFwcHJvcHJpYXRlIHRva2Vucy4gSG93ZXZlciwgYFByaXNtLmxhbmd1YWdlcy5tYXJrdXBgIGlzIGEgcmVndWxhciBKYXZhU2NyaXB0IG9iamVjdCBsaXRlcmFsLCBzbyBpZiB5b3UgZG9cbiAgICAgICAqIHRoaXM6XG4gICAgICAgKlxuICAgICAgICogYGBganNcbiAgICAgICAqIFByaXNtLmxhbmd1YWdlcy5tYXJrdXAuc3R5bGUgPSB7XG4gICAgICAgKiAgICAgLy8gdG9rZW5cbiAgICAgICAqIH07XG4gICAgICAgKiBgYGBcbiAgICAgICAqXG4gICAgICAgKiB0aGVuIHRoZSBgc3R5bGVgIHRva2VuIHdpbGwgYmUgYWRkZWQgKGFuZCBwcm9jZXNzZWQpIGF0IHRoZSBlbmQuIGBpbnNlcnRCZWZvcmVgIGFsbG93cyB5b3UgdG8gaW5zZXJ0IHRva2Vuc1xuICAgICAgICogYmVmb3JlIGV4aXN0aW5nIHRva2Vucy4gRm9yIHRoZSBDU1MgZXhhbXBsZSBhYm92ZSwgeW91IHdvdWxkIHVzZSBpdCBsaWtlIHRoaXM6XG4gICAgICAgKlxuICAgICAgICogYGBganNcbiAgICAgICAqIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICdjZGF0YScsIHtcbiAgICAgICAqICAgICAnc3R5bGUnOiB7XG4gICAgICAgKiAgICAgICAgIC8vIHRva2VuXG4gICAgICAgKiAgICAgfVxuICAgICAgICogfSk7XG4gICAgICAgKiBgYGBcbiAgICAgICAqXG4gICAgICAgKiAjIyBTcGVjaWFsIGNhc2VzXG4gICAgICAgKlxuICAgICAgICogSWYgdGhlIGdyYW1tYXJzIG9mIGBpbnNpZGVgIGFuZCBgaW5zZXJ0YCBoYXZlIHRva2VucyB3aXRoIHRoZSBzYW1lIG5hbWUsIHRoZSB0b2tlbnMgaW4gYGluc2lkZWAncyBncmFtbWFyXG4gICAgICAgKiB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBiZWhhdmlvciBjYW4gYmUgdXNlZCB0byBpbnNlcnQgdG9rZW5zIGFmdGVyIGBiZWZvcmVgOlxuICAgICAgICpcbiAgICAgICAqIGBgYGpzXG4gICAgICAgKiBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdtYXJrdXAnLCAnY29tbWVudCcsIHtcbiAgICAgICAqICAgICAnY29tbWVudCc6IFByaXNtLmxhbmd1YWdlcy5tYXJrdXAuY29tbWVudCxcbiAgICAgICAqICAgICAvLyB0b2tlbnMgYWZ0ZXIgJ2NvbW1lbnQnXG4gICAgICAgKiB9KTtcbiAgICAgICAqIGBgYFxuICAgICAgICpcbiAgICAgICAqICMjIExpbWl0YXRpb25zXG4gICAgICAgKlxuICAgICAgICogVGhlIG1haW4gcHJvYmxlbSBgaW5zZXJ0QmVmb3JlYCBoYXMgdG8gc29sdmUgaXMgaXRlcmF0aW9uIG9yZGVyLiBTaW5jZSBFUzIwMTUsIHRoZSBpdGVyYXRpb24gb3JkZXIgZm9yIG9iamVjdFxuICAgICAgICogcHJvcGVydGllcyBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSBpbnNlcnRpb24gb3JkZXIgKGV4Y2VwdCBmb3IgaW50ZWdlciBrZXlzKSBidXQgc29tZSBicm93c2VycyBiZWhhdmVcbiAgICAgICAqIGRpZmZlcmVudGx5IHdoZW4ga2V5cyBhcmUgZGVsZXRlZCBhbmQgcmUtaW5zZXJ0ZWQuIFNvIGBpbnNlcnRCZWZvcmVgIGNhbid0IGJlIGltcGxlbWVudGVkIGJ5IHRlbXBvcmFyaWx5XG4gICAgICAgKiBkZWxldGluZyBwcm9wZXJ0aWVzIHdoaWNoIGlzIG5lY2Vzc2FyeSB0byBpbnNlcnQgYXQgYXJiaXRyYXJ5IHBvc2l0aW9ucy5cbiAgICAgICAqXG4gICAgICAgKiBUbyBzb2x2ZSB0aGlzIHByb2JsZW0sIGBpbnNlcnRCZWZvcmVgIGRvZXNuJ3QgYWN0dWFsbHkgaW5zZXJ0IHRoZSBnaXZlbiB0b2tlbnMgaW50byB0aGUgdGFyZ2V0IG9iamVjdC5cbiAgICAgICAqIEluc3RlYWQsIGl0IHdpbGwgY3JlYXRlIGEgbmV3IG9iamVjdCBhbmQgcmVwbGFjZSBhbGwgcmVmZXJlbmNlcyB0byB0aGUgdGFyZ2V0IG9iamVjdCB3aXRoIHRoZSBuZXcgb25lLiBUaGlzXG4gICAgICAgKiBjYW4gYmUgZG9uZSB3aXRob3V0IHRlbXBvcmFyaWx5IGRlbGV0aW5nIHByb3BlcnRpZXMsIHNvIHRoZSBpdGVyYXRpb24gb3JkZXIgaXMgd2VsbC1kZWZpbmVkLlxuICAgICAgICpcbiAgICAgICAqIEhvd2V2ZXIsIG9ubHkgcmVmZXJlbmNlcyB0aGF0IGNhbiBiZSByZWFjaGVkIGZyb20gYFByaXNtLmxhbmd1YWdlc2Agb3IgYGluc2VydGAgd2lsbCBiZSByZXBsYWNlZC4gSS5lLiBpZlxuICAgICAgICogeW91IGhvbGQgdGhlIHRhcmdldCBvYmplY3QgaW4gYSB2YXJpYWJsZSwgdGhlbiB0aGUgdmFsdWUgb2YgdGhlIHZhcmlhYmxlIHdpbGwgbm90IGNoYW5nZS5cbiAgICAgICAqXG4gICAgICAgKiBgYGBqc1xuICAgICAgICogdmFyIG9sZE1hcmt1cCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG4gICAgICAgKiB2YXIgbmV3TWFya3VwID0gUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya3VwJywgJ2NvbW1lbnQnLCB7IC4uLiB9KTtcbiAgICAgICAqXG4gICAgICAgKiBhc3NlcnQob2xkTWFya3VwICE9PSBQcmlzbS5sYW5ndWFnZXMubWFya3VwKTtcbiAgICAgICAqIGFzc2VydChuZXdNYXJrdXAgPT09IFByaXNtLmxhbmd1YWdlcy5tYXJrdXApO1xuICAgICAgICogYGBgXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGluc2lkZSBUaGUgcHJvcGVydHkgb2YgYHJvb3RgIChlLmcuIGEgbGFuZ3VhZ2UgaWQgaW4gYFByaXNtLmxhbmd1YWdlc2ApIHRoYXQgY29udGFpbnMgdGhlXG4gICAgICAgKiBvYmplY3QgdG8gYmUgbW9kaWZpZWQuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmVmb3JlIFRoZSBrZXkgdG8gaW5zZXJ0IGJlZm9yZS5cbiAgICAgICAqIEBwYXJhbSB7R3JhbW1hcn0gaW5zZXJ0IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBrZXktdmFsdWUgcGFpcnMgdG8gYmUgaW5zZXJ0ZWQuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IFtyb290XSBUaGUgb2JqZWN0IGNvbnRhaW5pbmcgYGluc2lkZWAsIGkuZS4gdGhlIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZVxuICAgICAgICogb2JqZWN0IHRvIGJlIG1vZGlmaWVkLlxuICAgICAgICpcbiAgICAgICAqIERlZmF1bHRzIHRvIGBQcmlzbS5sYW5ndWFnZXNgLlxuICAgICAgICogQHJldHVybnMge0dyYW1tYXJ9IFRoZSBuZXcgZ3JhbW1hciBvYmplY3QuXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIGluc2VydEJlZm9yZTogZnVuY3Rpb24gKGluc2lkZSwgYmVmb3JlLCBpbnNlcnQsIHJvb3QpIHtcbiAgICAgICAgcm9vdCA9IHJvb3QgfHwgLyoqIEB0eXBlIHthbnl9ICovXy5sYW5ndWFnZXM7XG4gICAgICAgIHZhciBncmFtbWFyID0gcm9vdFtpbnNpZGVdO1xuICAgICAgICAvKiogQHR5cGUge0dyYW1tYXJ9ICovXG4gICAgICAgIHZhciByZXQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgdG9rZW4gaW4gZ3JhbW1hcikge1xuICAgICAgICAgIGlmIChncmFtbWFyLmhhc093blByb3BlcnR5KHRva2VuKSkge1xuICAgICAgICAgICAgaWYgKHRva2VuID09IGJlZm9yZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBuZXdUb2tlbiBpbiBpbnNlcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0Lmhhc093blByb3BlcnR5KG5ld1Rva2VuKSkge1xuICAgICAgICAgICAgICAgICAgcmV0W25ld1Rva2VuXSA9IGluc2VydFtuZXdUb2tlbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERvIG5vdCBpbnNlcnQgdG9rZW4gd2hpY2ggYWxzbyBvY2N1ciBpbiBpbnNlcnQuIFNlZSAjMTUyNVxuICAgICAgICAgICAgaWYgKCFpbnNlcnQuaGFzT3duUHJvcGVydHkodG9rZW4pKSB7XG4gICAgICAgICAgICAgIHJldFt0b2tlbl0gPSBncmFtbWFyW3Rva2VuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9sZCA9IHJvb3RbaW5zaWRlXTtcbiAgICAgICAgcm9vdFtpbnNpZGVdID0gcmV0O1xuXG4gICAgICAgIC8vIFVwZGF0ZSByZWZlcmVuY2VzIGluIG90aGVyIGxhbmd1YWdlIGRlZmluaXRpb25zXG4gICAgICAgIF8ubGFuZ3VhZ2VzLkRGUyhfLmxhbmd1YWdlcywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPT09IG9sZCAmJiBrZXkgIT0gaW5zaWRlKSB7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSByZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sXG4gICAgICAvLyBUcmF2ZXJzZSBhIGxhbmd1YWdlIGRlZmluaXRpb24gd2l0aCBEZXB0aCBGaXJzdCBTZWFyY2hcbiAgICAgIERGUzogZnVuY3Rpb24gREZTKG8sIGNhbGxiYWNrLCB0eXBlLCB2aXNpdGVkKSB7XG4gICAgICAgIHZpc2l0ZWQgPSB2aXNpdGVkIHx8IHt9O1xuICAgICAgICB2YXIgb2JqSWQgPSBfLnV0aWwub2JqSWQ7XG4gICAgICAgIGZvciAodmFyIGkgaW4gbykge1xuICAgICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKG8sIGksIG9baV0sIHR5cGUgfHwgaSk7XG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBvW2ldO1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5VHlwZSA9IF8udXRpbC50eXBlKHByb3BlcnR5KTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eVR5cGUgPT09ICdPYmplY3QnICYmICF2aXNpdGVkW29iaklkKHByb3BlcnR5KV0pIHtcbiAgICAgICAgICAgICAgdmlzaXRlZFtvYmpJZChwcm9wZXJ0eSldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgREZTKHByb3BlcnR5LCBjYWxsYmFjaywgbnVsbCwgdmlzaXRlZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5VHlwZSA9PT0gJ0FycmF5JyAmJiAhdmlzaXRlZFtvYmpJZChwcm9wZXJ0eSldKSB7XG4gICAgICAgICAgICAgIHZpc2l0ZWRbb2JqSWQocHJvcGVydHkpXSA9IHRydWU7XG4gICAgICAgICAgICAgIERGUyhwcm9wZXJ0eSwgY2FsbGJhY2ssIGksIHZpc2l0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcGx1Z2luczoge30sXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgbW9zdCBoaWdoLWxldmVsIGZ1bmN0aW9uIGluIFByaXNt4oCZcyBBUEkuXG4gICAgICogSXQgZmV0Y2hlcyBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIGAubGFuZ3VhZ2UteHh4eGAgY2xhc3MgYW5kIHRoZW4gY2FsbHMge0BsaW5rIFByaXNtLmhpZ2hsaWdodEVsZW1lbnR9IG9uXG4gICAgICogZWFjaCBvbmUgb2YgdGhlbS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byBgUHJpc20uaGlnaGxpZ2h0QWxsVW5kZXIoZG9jdW1lbnQsIGFzeW5jLCBjYWxsYmFjaylgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYXN5bmM9ZmFsc2VdIFNhbWUgYXMgaW4ge0BsaW5rIFByaXNtLmhpZ2hsaWdodEFsbFVuZGVyfS5cbiAgICAgKiBAcGFyYW0ge0hpZ2hsaWdodENhbGxiYWNrfSBbY2FsbGJhY2tdIFNhbWUgYXMgaW4ge0BsaW5rIFByaXNtLmhpZ2hsaWdodEFsbFVuZGVyfS5cbiAgICAgKiBAbWVtYmVyb2YgUHJpc21cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgaGlnaGxpZ2h0QWxsOiBmdW5jdGlvbiAoYXN5bmMsIGNhbGxiYWNrKSB7XG4gICAgICBfLmhpZ2hsaWdodEFsbFVuZGVyKGRvY3VtZW50LCBhc3luYywgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhbGwgdGhlIGRlc2NlbmRhbnRzIG9mIGBjb250YWluZXJgIHRoYXQgaGF2ZSBhIGAubGFuZ3VhZ2UteHh4eGAgY2xhc3MgYW5kIHRoZW4gY2FsbHNcbiAgICAgKiB7QGxpbmsgUHJpc20uaGlnaGxpZ2h0RWxlbWVudH0gb24gZWFjaCBvbmUgb2YgdGhlbS5cbiAgICAgKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgaG9va3Mgd2lsbCBiZSBydW46XG4gICAgICogMS4gYGJlZm9yZS1oaWdobGlnaHRhbGxgXG4gICAgICogMi4gYGJlZm9yZS1hbGwtZWxlbWVudHMtaGlnaGxpZ2h0YFxuICAgICAqIDMuIEFsbCBob29rcyBvZiB7QGxpbmsgUHJpc20uaGlnaGxpZ2h0RWxlbWVudH0gZm9yIGVhY2ggZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFyZW50Tm9kZX0gY29udGFpbmVyIFRoZSByb290IGVsZW1lbnQsIHdob3NlIGRlc2NlbmRhbnRzIHRoYXQgaGF2ZSBhIGAubGFuZ3VhZ2UteHh4eGAgY2xhc3Mgd2lsbCBiZSBoaWdobGlnaHRlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthc3luYz1mYWxzZV0gV2hldGhlciBlYWNoIGVsZW1lbnQgaXMgdG8gYmUgaGlnaGxpZ2h0ZWQgYXN5bmNocm9ub3VzbHkgdXNpbmcgV2ViIFdvcmtlcnMuXG4gICAgICogQHBhcmFtIHtIaWdobGlnaHRDYWxsYmFja30gW2NhbGxiYWNrXSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGVhY2ggZWxlbWVudCBhZnRlciBpdHMgaGlnaGxpZ2h0aW5nIGlzIGRvbmUuXG4gICAgICogQG1lbWJlcm9mIFByaXNtXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGhpZ2hsaWdodEFsbFVuZGVyOiBmdW5jdGlvbiAoY29udGFpbmVyLCBhc3luYywgY2FsbGJhY2spIHtcbiAgICAgIHZhciBlbnYgPSB7XG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgIHNlbGVjdG9yOiAnY29kZVtjbGFzcyo9XCJsYW5ndWFnZS1cIl0sIFtjbGFzcyo9XCJsYW5ndWFnZS1cIl0gY29kZSwgY29kZVtjbGFzcyo9XCJsYW5nLVwiXSwgW2NsYXNzKj1cImxhbmctXCJdIGNvZGUnXG4gICAgICB9O1xuICAgICAgXy5ob29rcy5ydW4oJ2JlZm9yZS1oaWdobGlnaHRhbGwnLCBlbnYpO1xuICAgICAgZW52LmVsZW1lbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGVudi5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChlbnYuc2VsZWN0b3IpKTtcbiAgICAgIF8uaG9va3MucnVuKCdiZWZvcmUtYWxsLWVsZW1lbnRzLWhpZ2hsaWdodCcsIGVudik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgZWxlbWVudDsgZWxlbWVudCA9IGVudi5lbGVtZW50c1tpKytdOykge1xuICAgICAgICBfLmhpZ2hsaWdodEVsZW1lbnQoZWxlbWVudCwgYXN5bmMgPT09IHRydWUsIGVudi5jYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBIaWdobGlnaHRzIHRoZSBjb2RlIGluc2lkZSBhIHNpbmdsZSBlbGVtZW50LlxuICAgICAqXG4gICAgICogVGhlIGZvbGxvd2luZyBob29rcyB3aWxsIGJlIHJ1bjpcbiAgICAgKiAxLiBgYmVmb3JlLXNhbml0eS1jaGVja2BcbiAgICAgKiAyLiBgYmVmb3JlLWhpZ2hsaWdodGBcbiAgICAgKiAzLiBBbGwgaG9va3Mgb2Yge0BsaW5rIFByaXNtLmhpZ2hsaWdodH0uIFRoZXNlIGhvb2tzIHdpbGwgYmUgcnVuIGJ5IGFuIGFzeW5jaHJvbm91cyB3b3JrZXIgaWYgYGFzeW5jYCBpcyBgdHJ1ZWAuXG4gICAgICogNC4gYGJlZm9yZS1pbnNlcnRgXG4gICAgICogNS4gYGFmdGVyLWhpZ2hsaWdodGBcbiAgICAgKiA2LiBgY29tcGxldGVgXG4gICAgICpcbiAgICAgKiBTb21lIHRoZSBhYm92ZSBob29rcyB3aWxsIGJlIHNraXBwZWQgaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBjb250YWluIGFueSB0ZXh0IG9yIHRoZXJlIGlzIG5vIGdyYW1tYXIgbG9hZGVkIGZvclxuICAgICAqIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgY29udGFpbmluZyB0aGUgY29kZS5cbiAgICAgKiBJdCBtdXN0IGhhdmUgYSBjbGFzcyBvZiBgbGFuZ3VhZ2UteHh4eGAgdG8gYmUgcHJvY2Vzc2VkLCB3aGVyZSBgeHh4eGAgaXMgYSB2YWxpZCBsYW5ndWFnZSBpZGVudGlmaWVyLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FzeW5jPWZhbHNlXSBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIHRvIGJlIGhpZ2hsaWdodGVkIGFzeW5jaHJvbm91c2x5IHVzaW5nIFdlYiBXb3JrZXJzXG4gICAgICogdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSBhbmQgYXZvaWQgYmxvY2tpbmcgdGhlIFVJIHdoZW4gaGlnaGxpZ2h0aW5nIHZlcnkgbGFyZ2UgY2h1bmtzIG9mIGNvZGUuIFRoaXMgb3B0aW9uIGlzXG4gICAgICogW2Rpc2FibGVkIGJ5IGRlZmF1bHRdKGh0dHBzOi8vcHJpc21qcy5jb20vZmFxLmh0bWwjd2h5LWlzLWFzeW5jaHJvbm91cy1oaWdobGlnaHRpbmctZGlzYWJsZWQtYnktZGVmYXVsdCkuXG4gICAgICpcbiAgICAgKiBOb3RlOiBBbGwgbGFuZ3VhZ2UgZGVmaW5pdGlvbnMgcmVxdWlyZWQgdG8gaGlnaGxpZ2h0IHRoZSBjb2RlIG11c3QgYmUgaW5jbHVkZWQgaW4gdGhlIG1haW4gYHByaXNtLmpzYCBmaWxlIGZvclxuICAgICAqIGFzeW5jaHJvbm91cyBoaWdobGlnaHRpbmcgdG8gd29yay4gWW91IGNhbiBidWlsZCB5b3VyIG93biBidW5kbGUgb24gdGhlXG4gICAgICogW0Rvd25sb2FkIHBhZ2VdKGh0dHBzOi8vcHJpc21qcy5jb20vZG93bmxvYWQuaHRtbCkuXG4gICAgICogQHBhcmFtIHtIaWdobGlnaHRDYWxsYmFja30gW2NhbGxiYWNrXSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBoaWdobGlnaHRpbmcgaXMgZG9uZS5cbiAgICAgKiBNb3N0bHkgdXNlZnVsIHdoZW4gYGFzeW5jYCBpcyBgdHJ1ZWAsIHNpbmNlIGluIHRoYXQgY2FzZSwgdGhlIGhpZ2hsaWdodGluZyBpcyBkb25lIGFzeW5jaHJvbm91c2x5LlxuICAgICAqIEBtZW1iZXJvZiBQcmlzbVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBoaWdobGlnaHRFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCwgYXN5bmMsIGNhbGxiYWNrKSB7XG4gICAgICAvLyBGaW5kIGxhbmd1YWdlXG4gICAgICB2YXIgbGFuZ3VhZ2UgPSBfLnV0aWwuZ2V0TGFuZ3VhZ2UoZWxlbWVudCk7XG4gICAgICB2YXIgZ3JhbW1hciA9IF8ubGFuZ3VhZ2VzW2xhbmd1YWdlXTtcblxuICAgICAgLy8gU2V0IGxhbmd1YWdlIG9uIHRoZSBlbGVtZW50LCBpZiBub3QgcHJlc2VudFxuICAgICAgXy51dGlsLnNldExhbmd1YWdlKGVsZW1lbnQsIGxhbmd1YWdlKTtcblxuICAgICAgLy8gU2V0IGxhbmd1YWdlIG9uIHRoZSBwYXJlbnQsIGZvciBzdHlsaW5nXG4gICAgICB2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3ByZScpIHtcbiAgICAgICAgXy51dGlsLnNldExhbmd1YWdlKHBhcmVudCwgbGFuZ3VhZ2UpO1xuICAgICAgfVxuICAgICAgdmFyIGNvZGUgPSBlbGVtZW50LnRleHRDb250ZW50O1xuICAgICAgdmFyIGVudiA9IHtcbiAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgbGFuZ3VhZ2U6IGxhbmd1YWdlLFxuICAgICAgICBncmFtbWFyOiBncmFtbWFyLFxuICAgICAgICBjb2RlOiBjb2RlXG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gaW5zZXJ0SGlnaGxpZ2h0ZWRDb2RlKGhpZ2hsaWdodGVkQ29kZSkge1xuICAgICAgICBlbnYuaGlnaGxpZ2h0ZWRDb2RlID0gaGlnaGxpZ2h0ZWRDb2RlO1xuICAgICAgICBfLmhvb2tzLnJ1bignYmVmb3JlLWluc2VydCcsIGVudik7XG4gICAgICAgIGVudi5lbGVtZW50LmlubmVySFRNTCA9IGVudi5oaWdobGlnaHRlZENvZGU7XG4gICAgICAgIF8uaG9va3MucnVuKCdhZnRlci1oaWdobGlnaHQnLCBlbnYpO1xuICAgICAgICBfLmhvb2tzLnJ1bignY29tcGxldGUnLCBlbnYpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGVudi5lbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIF8uaG9va3MucnVuKCdiZWZvcmUtc2FuaXR5LWNoZWNrJywgZW52KTtcblxuICAgICAgLy8gcGx1Z2lucyBtYXkgY2hhbmdlL2FkZCB0aGUgcGFyZW50L2VsZW1lbnRcbiAgICAgIHBhcmVudCA9IGVudi5lbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICBpZiAocGFyZW50ICYmIHBhcmVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAncHJlJyAmJiAhcGFyZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICBwYXJlbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICcwJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWVudi5jb2RlKSB7XG4gICAgICAgIF8uaG9va3MucnVuKCdjb21wbGV0ZScsIGVudik7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoZW52LmVsZW1lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfLmhvb2tzLnJ1bignYmVmb3JlLWhpZ2hsaWdodCcsIGVudik7XG4gICAgICBpZiAoIWVudi5ncmFtbWFyKSB7XG4gICAgICAgIGluc2VydEhpZ2hsaWdodGVkQ29kZShfLnV0aWwuZW5jb2RlKGVudi5jb2RlKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChhc3luYyAmJiBfc2VsZi5Xb3JrZXIpIHtcbiAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIoXy5maWxlbmFtZSk7XG4gICAgICAgIHdvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgaW5zZXJ0SGlnaGxpZ2h0ZWRDb2RlKGV2dC5kYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBsYW5ndWFnZTogZW52Lmxhbmd1YWdlLFxuICAgICAgICAgIGNvZGU6IGVudi5jb2RlLFxuICAgICAgICAgIGltbWVkaWF0ZUNsb3NlOiB0cnVlXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc2VydEhpZ2hsaWdodGVkQ29kZShfLmhpZ2hsaWdodChlbnYuY29kZSwgZW52LmdyYW1tYXIsIGVudi5sYW5ndWFnZSkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogTG93LWxldmVsIGZ1bmN0aW9uLCBvbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdeKAmXJlIGRvaW5nLiBJdCBhY2NlcHRzIGEgc3RyaW5nIG9mIHRleHQgYXMgaW5wdXRcbiAgICAgKiBhbmQgdGhlIGxhbmd1YWdlIGRlZmluaXRpb25zIHRvIHVzZSwgYW5kIHJldHVybnMgYSBzdHJpbmcgd2l0aCB0aGUgSFRNTCBwcm9kdWNlZC5cbiAgICAgKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgaG9va3Mgd2lsbCBiZSBydW46XG4gICAgICogMS4gYGJlZm9yZS10b2tlbml6ZWBcbiAgICAgKiAyLiBgYWZ0ZXItdG9rZW5pemVgXG4gICAgICogMy4gYHdyYXBgOiBPbiBlYWNoIHtAbGluayBUb2tlbn0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBBIHN0cmluZyB3aXRoIHRoZSBjb2RlIHRvIGJlIGhpZ2hsaWdodGVkLlxuICAgICAqIEBwYXJhbSB7R3JhbW1hcn0gZ3JhbW1hciBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgdG9rZW5zIHRvIHVzZS5cbiAgICAgKlxuICAgICAqIFVzdWFsbHkgYSBsYW5ndWFnZSBkZWZpbml0aW9uIGxpa2UgYFByaXNtLmxhbmd1YWdlcy5tYXJrdXBgLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZSBUaGUgbmFtZSBvZiB0aGUgbGFuZ3VhZ2UgZGVmaW5pdGlvbiBwYXNzZWQgdG8gYGdyYW1tYXJgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBoaWdobGlnaHRlZCBIVE1MLlxuICAgICAqIEBtZW1iZXJvZiBQcmlzbVxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFByaXNtLmhpZ2hsaWdodCgndmFyIGZvbyA9IHRydWU7JywgUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQsICdqYXZhc2NyaXB0Jyk7XG4gICAgICovXG4gICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAodGV4dCwgZ3JhbW1hciwgbGFuZ3VhZ2UpIHtcbiAgICAgIHZhciBlbnYgPSB7XG4gICAgICAgIGNvZGU6IHRleHQsXG4gICAgICAgIGdyYW1tYXI6IGdyYW1tYXIsXG4gICAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZVxuICAgICAgfTtcbiAgICAgIF8uaG9va3MucnVuKCdiZWZvcmUtdG9rZW5pemUnLCBlbnYpO1xuICAgICAgaWYgKCFlbnYuZ3JhbW1hcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBsYW5ndWFnZSBcIicgKyBlbnYubGFuZ3VhZ2UgKyAnXCIgaGFzIG5vIGdyYW1tYXIuJyk7XG4gICAgICB9XG4gICAgICBlbnYudG9rZW5zID0gXy50b2tlbml6ZShlbnYuY29kZSwgZW52LmdyYW1tYXIpO1xuICAgICAgXy5ob29rcy5ydW4oJ2FmdGVyLXRva2VuaXplJywgZW52KTtcbiAgICAgIHJldHVybiBUb2tlbi5zdHJpbmdpZnkoXy51dGlsLmVuY29kZShlbnYudG9rZW5zKSwgZW52Lmxhbmd1YWdlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGhlYXJ0IG9mIFByaXNtLCBhbmQgdGhlIG1vc3QgbG93LWxldmVsIGZ1bmN0aW9uIHlvdSBjYW4gdXNlLiBJdCBhY2NlcHRzIGEgc3RyaW5nIG9mIHRleHQgYXMgaW5wdXRcbiAgICAgKiBhbmQgdGhlIGxhbmd1YWdlIGRlZmluaXRpb25zIHRvIHVzZSwgYW5kIHJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgdG9rZW5pemVkIGNvZGUuXG4gICAgICpcbiAgICAgKiBXaGVuIHRoZSBsYW5ndWFnZSBkZWZpbml0aW9uIGluY2x1ZGVzIG5lc3RlZCB0b2tlbnMsIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgcmVjdXJzaXZlbHkgb24gZWFjaCBvZiB0aGVzZSB0b2tlbnMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBjb3VsZCBiZSB1c2VmdWwgaW4gb3RoZXIgY29udGV4dHMgYXMgd2VsbCwgYXMgYSB2ZXJ5IGNydWRlIHBhcnNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IEEgc3RyaW5nIHdpdGggdGhlIGNvZGUgdG8gYmUgaGlnaGxpZ2h0ZWQuXG4gICAgICogQHBhcmFtIHtHcmFtbWFyfSBncmFtbWFyIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSB0b2tlbnMgdG8gdXNlLlxuICAgICAqXG4gICAgICogVXN1YWxseSBhIGxhbmd1YWdlIGRlZmluaXRpb24gbGlrZSBgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cGAuXG4gICAgICogQHJldHVybnMge1Rva2VuU3RyZWFtfSBBbiBhcnJheSBvZiBzdHJpbmdzIGFuZCB0b2tlbnMsIGEgdG9rZW4gc3RyZWFtLlxuICAgICAqIEBtZW1iZXJvZiBQcmlzbVxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGxldCBjb2RlID0gYHZhciBmb28gPSAwO2A7XG4gICAgICogbGV0IHRva2VucyA9IFByaXNtLnRva2VuaXplKGNvZGUsIFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0KTtcbiAgICAgKiB0b2tlbnMuZm9yRWFjaCh0b2tlbiA9PiB7XG4gICAgICogICAgIGlmICh0b2tlbiBpbnN0YW5jZW9mIFByaXNtLlRva2VuICYmIHRva2VuLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgbnVtZXJpYyBsaXRlcmFsOiAke3Rva2VuLmNvbnRlbnR9YCk7XG4gICAgICogICAgIH1cbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICB0b2tlbml6ZTogZnVuY3Rpb24gKHRleHQsIGdyYW1tYXIpIHtcbiAgICAgIHZhciByZXN0ID0gZ3JhbW1hci5yZXN0O1xuICAgICAgaWYgKHJlc3QpIHtcbiAgICAgICAgZm9yICh2YXIgdG9rZW4gaW4gcmVzdCkge1xuICAgICAgICAgIGdyYW1tYXJbdG9rZW5dID0gcmVzdFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGdyYW1tYXIucmVzdDtcbiAgICAgIH1cbiAgICAgIHZhciB0b2tlbkxpc3QgPSBuZXcgTGlua2VkTGlzdCgpO1xuICAgICAgYWRkQWZ0ZXIodG9rZW5MaXN0LCB0b2tlbkxpc3QuaGVhZCwgdGV4dCk7XG4gICAgICBtYXRjaEdyYW1tYXIodGV4dCwgdG9rZW5MaXN0LCBncmFtbWFyLCB0b2tlbkxpc3QuaGVhZCwgMCk7XG4gICAgICByZXR1cm4gdG9BcnJheSh0b2tlbkxpc3QpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQcmlzbVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBob29rczoge1xuICAgICAgYWxsOiB7fSxcbiAgICAgIC8qKlxuICAgICAgICogQWRkcyB0aGUgZ2l2ZW4gY2FsbGJhY2sgdG8gdGhlIGxpc3Qgb2YgY2FsbGJhY2tzIGZvciB0aGUgZ2l2ZW4gaG9vay5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIHdoZW4gdGhlIGhvb2sgaXQgaXMgcmVnaXN0ZXJlZCBmb3IgaXMgcnVuLlxuICAgICAgICogSG9va3MgYXJlIHVzdWFsbHkgZGlyZWN0bHkgcnVuIGJ5IGEgaGlnaGxpZ2h0IGZ1bmN0aW9uIGJ1dCB5b3UgY2FuIGFsc28gcnVuIGhvb2tzIHlvdXJzZWxmLlxuICAgICAgICpcbiAgICAgICAqIE9uZSBjYWxsYmFjayBmdW5jdGlvbiBjYW4gYmUgcmVnaXN0ZXJlZCB0byBtdWx0aXBsZSBob29rcyBhbmQgdGhlIHNhbWUgaG9vayBtdWx0aXBsZSB0aW1lcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaG9vay5cbiAgICAgICAqIEBwYXJhbSB7SG9va0NhbGxiYWNrfSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggaXMgZ2l2ZW4gZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBhZGQ6IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaG9va3MgPSBfLmhvb2tzLmFsbDtcbiAgICAgICAgaG9va3NbbmFtZV0gPSBob29rc1tuYW1lXSB8fCBbXTtcbiAgICAgICAgaG9va3NbbmFtZV0ucHVzaChjYWxsYmFjayk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBSdW5zIGEgaG9vayBpbnZva2luZyBhbGwgcmVnaXN0ZXJlZCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICAgICAgICpcbiAgICAgICAqIENhbGxiYWNrcyB3aWxsIGJlIGludm9rZWQgc3luY2hyb25vdXNseSBhbmQgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgd2VyZSByZWdpc3RlcmVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBob29rLlxuICAgICAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBlbnYgVGhlIGVudmlyb25tZW50IHZhcmlhYmxlcyBvZiB0aGUgaG9vayBwYXNzZWQgdG8gYWxsIGNhbGxiYWNrcyByZWdpc3RlcmVkLlxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBydW46IGZ1bmN0aW9uIChuYW1lLCBlbnYpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IF8uaG9va3MuYWxsW25hbWVdO1xuICAgICAgICBpZiAoIWNhbGxiYWNrcyB8fCAhY2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgY2FsbGJhY2s7IGNhbGxiYWNrID0gY2FsbGJhY2tzW2krK107KSB7XG4gICAgICAgICAgY2FsbGJhY2soZW52KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgVG9rZW46IFRva2VuXG4gIH07XG4gIF9zZWxmLlByaXNtID0gXztcblxuICAvLyBUeXBlc2NyaXB0IG5vdGU6XG4gIC8vIFRoZSBmb2xsb3dpbmcgY2FuIGJlIHVzZWQgdG8gaW1wb3J0IHRoZSBUb2tlbiB0eXBlIGluIEpTRG9jOlxuICAvL1xuICAvLyAgIEB0eXBlZGVmIHtJbnN0YW5jZVR5cGU8aW1wb3J0KFwiLi9wcmlzbS1jb3JlXCIpW1wiVG9rZW5cIl0+fSBUb2tlblxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHRva2VuLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBTZWUge0BsaW5rIFRva2VuI3R5cGUgdHlwZX1cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBUb2tlblN0cmVhbX0gY29udGVudCBTZWUge0BsaW5rIFRva2VuI2NvbnRlbnQgY29udGVudH1cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFthbGlhc10gVGhlIGFsaWFzKGVzKSBvZiB0aGUgdG9rZW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbWF0Y2hlZFN0cj1cIlwiXSBBIGNvcHkgb2YgdGhlIGZ1bGwgc3RyaW5nIHRoaXMgdG9rZW4gd2FzIGNyZWF0ZWQgZnJvbS5cbiAgICogQGNsYXNzXG4gICAqIEBnbG9iYWxcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZnVuY3Rpb24gVG9rZW4odHlwZSwgY29udGVudCwgYWxpYXMsIG1hdGNoZWRTdHIpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgdG9rZW4uXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHVzdWFsbHkgdGhlIGtleSBvZiBhIHBhdHRlcm4gaW4gYSB7QGxpbmsgR3JhbW1hcn0uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBzZWUgR3JhbW1hclRva2VuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgLyoqXG4gICAgICogVGhlIHN0cmluZ3Mgb3IgdG9rZW5zIGNvbnRhaW5lZCBieSB0aGlzIHRva2VuLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGJlIGEgdG9rZW4gc3RyZWFtIGlmIHRoZSBwYXR0ZXJuIG1hdGNoZWQgYWxzbyBkZWZpbmVkIGFuIGBpbnNpZGVgIGdyYW1tYXIuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nIHwgVG9rZW5TdHJlYW19XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgLyoqXG4gICAgICogVGhlIGFsaWFzKGVzKSBvZiB0aGUgdG9rZW4uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfHN0cmluZ1tdfVxuICAgICAqIEBzZWUgR3JhbW1hclRva2VuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHRoaXMuYWxpYXMgPSBhbGlhcztcbiAgICAvLyBDb3B5IG9mIHRoZSBmdWxsIHN0cmluZyB0aGlzIHRva2VuIHdhcyBjcmVhdGVkIGZyb21cbiAgICB0aGlzLmxlbmd0aCA9IChtYXRjaGVkU3RyIHx8ICcnKS5sZW5ndGggfCAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdG9rZW4gc3RyZWFtIGlzIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIHtAbGluayBUb2tlbiBUb2tlbn0gb2JqZWN0cy5cbiAgICpcbiAgICogVG9rZW4gc3RyZWFtcyBoYXZlIHRvIGZ1bGZpbGwgYSBmZXcgcHJvcGVydGllcyB0aGF0IGFyZSBhc3N1bWVkIGJ5IG1vc3QgZnVuY3Rpb25zIChtb3N0bHkgaW50ZXJuYWwgb25lcykgdGhhdCBwcm9jZXNzXG4gICAqIHRoZW0uXG4gICAqXG4gICAqIDEuIE5vIGFkamFjZW50IHN0cmluZ3MuXG4gICAqIDIuIE5vIGVtcHR5IHN0cmluZ3MuXG4gICAqXG4gICAqICAgIFRoZSBvbmx5IGV4Y2VwdGlvbiBoZXJlIGlzIHRoZSB0b2tlbiBzdHJlYW0gdGhhdCBvbmx5IGNvbnRhaW5zIHRoZSBlbXB0eSBzdHJpbmcgYW5kIG5vdGhpbmcgZWxzZS5cbiAgICpcbiAgICogQHR5cGVkZWYge0FycmF5PHN0cmluZyB8IFRva2VuPn0gVG9rZW5TdHJlYW1cbiAgICogQGdsb2JhbFxuICAgKiBAcHVibGljXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdG9rZW4gb3IgdG9rZW4gc3RyZWFtIHRvIGFuIEhUTUwgcmVwcmVzZW50YXRpb24uXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgaG9va3Mgd2lsbCBiZSBydW46XG4gICAqIDEuIGB3cmFwYDogT24gZWFjaCB7QGxpbmsgVG9rZW59LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFRva2VuIHwgVG9rZW5TdHJlYW19IG8gVGhlIHRva2VuIG9yIHRva2VuIHN0cmVhbSB0byBiZSBjb252ZXJ0ZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZSBUaGUgbmFtZSBvZiBjdXJyZW50IGxhbmd1YWdlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgSFRNTCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdG9rZW4gb3IgdG9rZW4gc3RyZWFtLlxuICAgKiBAbWVtYmVyb2YgVG9rZW5cbiAgICogQHN0YXRpY1xuICAgKi9cbiAgVG9rZW4uc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5KG8sIGxhbmd1YWdlKSB7XG4gICAgaWYgKHR5cGVvZiBvID09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbztcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykpIHtcbiAgICAgIHZhciBzID0gJyc7XG4gICAgICBvLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcyArPSBzdHJpbmdpZnkoZSwgbGFuZ3VhZ2UpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgdmFyIGVudiA9IHtcbiAgICAgIHR5cGU6IG8udHlwZSxcbiAgICAgIGNvbnRlbnQ6IHN0cmluZ2lmeShvLmNvbnRlbnQsIGxhbmd1YWdlKSxcbiAgICAgIHRhZzogJ3NwYW4nLFxuICAgICAgY2xhc3NlczogWyd0b2tlbicsIG8udHlwZV0sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZVxuICAgIH07XG4gICAgdmFyIGFsaWFzZXMgPSBvLmFsaWFzO1xuICAgIGlmIChhbGlhc2VzKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhbGlhc2VzKSkge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlbnYuY2xhc3NlcywgYWxpYXNlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnYuY2xhc3Nlcy5wdXNoKGFsaWFzZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBfLmhvb2tzLnJ1bignd3JhcCcsIGVudik7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSAnJztcbiAgICBmb3IgKHZhciBuYW1lIGluIGVudi5hdHRyaWJ1dGVzKSB7XG4gICAgICBhdHRyaWJ1dGVzICs9ICcgJyArIG5hbWUgKyAnPVwiJyArIChlbnYuYXR0cmlidXRlc1tuYW1lXSB8fCAnJykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpICsgJ1wiJztcbiAgICB9XG4gICAgcmV0dXJuICc8JyArIGVudi50YWcgKyAnIGNsYXNzPVwiJyArIGVudi5jbGFzc2VzLmpvaW4oJyAnKSArICdcIicgKyBhdHRyaWJ1dGVzICsgJz4nICsgZW52LmNvbnRlbnQgKyAnPC8nICsgZW52LnRhZyArICc+JztcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtSZWdFeHB9IHBhdHRlcm5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb2tiZWhpbmRcbiAgICogQHJldHVybnMge1JlZ0V4cEV4ZWNBcnJheSB8IG51bGx9XG4gICAqL1xuICBmdW5jdGlvbiBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcG9zLCB0ZXh0LCBsb29rYmVoaW5kKSB7XG4gICAgcGF0dGVybi5sYXN0SW5kZXggPSBwb3M7XG4gICAgdmFyIG1hdGNoID0gcGF0dGVybi5leGVjKHRleHQpO1xuICAgIGlmIChtYXRjaCAmJiBsb29rYmVoaW5kICYmIG1hdGNoWzFdKSB7XG4gICAgICAvLyBjaGFuZ2UgdGhlIG1hdGNoIHRvIHJlbW92ZSB0aGUgdGV4dCBtYXRjaGVkIGJ5IHRoZSBQcmlzbSBsb29rYmVoaW5kIGdyb3VwXG4gICAgICB2YXIgbG9va2JlaGluZExlbmd0aCA9IG1hdGNoWzFdLmxlbmd0aDtcbiAgICAgIG1hdGNoLmluZGV4ICs9IGxvb2tiZWhpbmRMZW5ndGg7XG4gICAgICBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKGxvb2tiZWhpbmRMZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICogQHBhcmFtIHtMaW5rZWRMaXN0PHN0cmluZyB8IFRva2VuPn0gdG9rZW5MaXN0XG4gICAqIEBwYXJhbSB7YW55fSBncmFtbWFyXG4gICAqIEBwYXJhbSB7TGlua2VkTGlzdE5vZGU8c3RyaW5nIHwgVG9rZW4+fSBzdGFydE5vZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0UG9zXG4gICAqIEBwYXJhbSB7UmVtYXRjaE9wdGlvbnN9IFtyZW1hdGNoXVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHR5cGVkZWYgUmVtYXRjaE9wdGlvbnNcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGNhdXNlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZWFjaFxuICAgKi9cbiAgZnVuY3Rpb24gbWF0Y2hHcmFtbWFyKHRleHQsIHRva2VuTGlzdCwgZ3JhbW1hciwgc3RhcnROb2RlLCBzdGFydFBvcywgcmVtYXRjaCkge1xuICAgIGZvciAodmFyIHRva2VuIGluIGdyYW1tYXIpIHtcbiAgICAgIGlmICghZ3JhbW1hci5oYXNPd25Qcm9wZXJ0eSh0b2tlbikgfHwgIWdyYW1tYXJbdG9rZW5dKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHBhdHRlcm5zID0gZ3JhbW1hclt0b2tlbl07XG4gICAgICBwYXR0ZXJucyA9IEFycmF5LmlzQXJyYXkocGF0dGVybnMpID8gcGF0dGVybnMgOiBbcGF0dGVybnNdO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXR0ZXJucy5sZW5ndGg7ICsraikge1xuICAgICAgICBpZiAocmVtYXRjaCAmJiByZW1hdGNoLmNhdXNlID09IHRva2VuICsgJywnICsgaikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGF0dGVybk9iaiA9IHBhdHRlcm5zW2pdO1xuICAgICAgICB2YXIgaW5zaWRlID0gcGF0dGVybk9iai5pbnNpZGU7XG4gICAgICAgIHZhciBsb29rYmVoaW5kID0gISFwYXR0ZXJuT2JqLmxvb2tiZWhpbmQ7XG4gICAgICAgIHZhciBncmVlZHkgPSAhIXBhdHRlcm5PYmouZ3JlZWR5O1xuICAgICAgICB2YXIgYWxpYXMgPSBwYXR0ZXJuT2JqLmFsaWFzO1xuICAgICAgICBpZiAoZ3JlZWR5ICYmICFwYXR0ZXJuT2JqLnBhdHRlcm4uZ2xvYmFsKSB7XG4gICAgICAgICAgLy8gV2l0aG91dCB0aGUgZ2xvYmFsIGZsYWcsIGxhc3RJbmRleCB3b24ndCB3b3JrXG4gICAgICAgICAgdmFyIGZsYWdzID0gcGF0dGVybk9iai5wYXR0ZXJuLnRvU3RyaW5nKCkubWF0Y2goL1tpbXN1eV0qJC8pWzBdO1xuICAgICAgICAgIHBhdHRlcm5PYmoucGF0dGVybiA9IFJlZ0V4cChwYXR0ZXJuT2JqLnBhdHRlcm4uc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHR5cGUge1JlZ0V4cH0gKi9cbiAgICAgICAgdmFyIHBhdHRlcm4gPSBwYXR0ZXJuT2JqLnBhdHRlcm4gfHwgcGF0dGVybk9iajtcbiAgICAgICAgZm9yIChcbiAgICAgICAgLy8gaXRlcmF0ZSB0aGUgdG9rZW4gbGlzdCBhbmQga2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCB0b2tlbi9zdHJpbmcgcG9zaXRpb25cbiAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gc3RhcnROb2RlLm5leHQsIHBvcyA9IHN0YXJ0UG9zOyBjdXJyZW50Tm9kZSAhPT0gdG9rZW5MaXN0LnRhaWw7IHBvcyArPSBjdXJyZW50Tm9kZS52YWx1ZS5sZW5ndGgsIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUubmV4dCkge1xuICAgICAgICAgIGlmIChyZW1hdGNoICYmIHBvcyA+PSByZW1hdGNoLnJlYWNoKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHN0ciA9IGN1cnJlbnROb2RlLnZhbHVlO1xuICAgICAgICAgIGlmICh0b2tlbkxpc3QubGVuZ3RoID4gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHRlcnJpYmx5IHdyb25nLCBBQk9SVCwgQUJPUlQhXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdHIgaW5zdGFuY2VvZiBUb2tlbikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZW1vdmVDb3VudCA9IDE7IC8vIHRoaXMgaXMgdGhlIHRvIHBhcmFtZXRlciBvZiByZW1vdmVCZXR3ZWVuXG4gICAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICAgIGlmIChncmVlZHkpIHtcbiAgICAgICAgICAgIG1hdGNoID0gbWF0Y2hQYXR0ZXJuKHBhdHRlcm4sIHBvcywgdGV4dCwgbG9va2JlaGluZCk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoIHx8IG1hdGNoLmluZGV4ID49IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZyb20gPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICAgIHZhciB0byA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHAgPSBwb3M7XG5cbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIG5vZGUgdGhhdCBjb250YWlucyB0aGUgbWF0Y2hcbiAgICAgICAgICAgIHAgKz0gY3VycmVudE5vZGUudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGZyb20gPj0gcCkge1xuICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLm5leHQ7XG4gICAgICAgICAgICAgIHAgKz0gY3VycmVudE5vZGUudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRqdXN0IHBvcyAoYW5kIHApXG4gICAgICAgICAgICBwIC09IGN1cnJlbnROb2RlLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIHBvcyA9IHA7XG5cbiAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IG5vZGUgaXMgYSBUb2tlbiwgdGhlbiB0aGUgbWF0Y2ggc3RhcnRzIGluc2lkZSBhbm90aGVyIFRva2VuLCB3aGljaCBpcyBpbnZhbGlkXG4gICAgICAgICAgICBpZiAoY3VycmVudE5vZGUudmFsdWUgaW5zdGFuY2VvZiBUb2tlbikge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZmluZCB0aGUgbGFzdCBub2RlIHdoaWNoIGlzIGFmZmVjdGVkIGJ5IHRoaXMgbWF0Y2hcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSBjdXJyZW50Tm9kZTsgayAhPT0gdG9rZW5MaXN0LnRhaWwgJiYgKHAgPCB0byB8fCB0eXBlb2Ygay52YWx1ZSA9PT0gJ3N0cmluZycpOyBrID0gay5uZXh0KSB7XG4gICAgICAgICAgICAgIHJlbW92ZUNvdW50Kys7XG4gICAgICAgICAgICAgIHAgKz0gay52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdmVDb3VudC0tO1xuXG4gICAgICAgICAgICAvLyByZXBsYWNlIHdpdGggdGhlIG5ldyBtYXRjaFxuICAgICAgICAgICAgc3RyID0gdGV4dC5zbGljZShwb3MsIHApO1xuICAgICAgICAgICAgbWF0Y2guaW5kZXggLT0gcG9zO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaCA9IG1hdGNoUGF0dGVybihwYXR0ZXJuLCAwLCBzdHIsIGxvb2tiZWhpbmQpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG4gICAgICAgICAgdmFyIGZyb20gPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICB2YXIgbWF0Y2hTdHIgPSBtYXRjaFswXTtcbiAgICAgICAgICB2YXIgYmVmb3JlID0gc3RyLnNsaWNlKDAsIGZyb20pO1xuICAgICAgICAgIHZhciBhZnRlciA9IHN0ci5zbGljZShmcm9tICsgbWF0Y2hTdHIubGVuZ3RoKTtcbiAgICAgICAgICB2YXIgcmVhY2ggPSBwb3MgKyBzdHIubGVuZ3RoO1xuICAgICAgICAgIGlmIChyZW1hdGNoICYmIHJlYWNoID4gcmVtYXRjaC5yZWFjaCkge1xuICAgICAgICAgICAgcmVtYXRjaC5yZWFjaCA9IHJlYWNoO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVtb3ZlRnJvbSA9IGN1cnJlbnROb2RlLnByZXY7XG4gICAgICAgICAgaWYgKGJlZm9yZSkge1xuICAgICAgICAgICAgcmVtb3ZlRnJvbSA9IGFkZEFmdGVyKHRva2VuTGlzdCwgcmVtb3ZlRnJvbSwgYmVmb3JlKTtcbiAgICAgICAgICAgIHBvcyArPSBiZWZvcmUubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZW1vdmVSYW5nZSh0b2tlbkxpc3QsIHJlbW92ZUZyb20sIHJlbW92ZUNvdW50KTtcbiAgICAgICAgICB2YXIgd3JhcHBlZCA9IG5ldyBUb2tlbih0b2tlbiwgaW5zaWRlID8gXy50b2tlbml6ZShtYXRjaFN0ciwgaW5zaWRlKSA6IG1hdGNoU3RyLCBhbGlhcywgbWF0Y2hTdHIpO1xuICAgICAgICAgIGN1cnJlbnROb2RlID0gYWRkQWZ0ZXIodG9rZW5MaXN0LCByZW1vdmVGcm9tLCB3cmFwcGVkKTtcbiAgICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICAgIGFkZEFmdGVyKHRva2VuTGlzdCwgY3VycmVudE5vZGUsIGFmdGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlbW92ZUNvdW50ID4gMSkge1xuICAgICAgICAgICAgLy8gYXQgbGVhc3Qgb25lIFRva2VuIG9iamVjdCB3YXMgcmVtb3ZlZCwgc28gd2UgaGF2ZSB0byBkbyBzb21lIHJlbWF0Y2hpbmdcbiAgICAgICAgICAgIC8vIHRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBjdXJyZW50IHBhdHRlcm4gaXMgZ3JlZWR5XG5cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7UmVtYXRjaE9wdGlvbnN9ICovXG4gICAgICAgICAgICB2YXIgbmVzdGVkUmVtYXRjaCA9IHtcbiAgICAgICAgICAgICAgY2F1c2U6IHRva2VuICsgJywnICsgaixcbiAgICAgICAgICAgICAgcmVhY2g6IHJlYWNoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbWF0Y2hHcmFtbWFyKHRleHQsIHRva2VuTGlzdCwgZ3JhbW1hciwgY3VycmVudE5vZGUucHJldiwgcG9zLCBuZXN0ZWRSZW1hdGNoKTtcblxuICAgICAgICAgICAgLy8gdGhlIHJlYWNoIG1pZ2h0IGhhdmUgYmVlbiBleHRlbmRlZCBiZWNhdXNlIG9mIHRoZSByZW1hdGNoaW5nXG4gICAgICAgICAgICBpZiAocmVtYXRjaCAmJiBuZXN0ZWRSZW1hdGNoLnJlYWNoID4gcmVtYXRjaC5yZWFjaCkge1xuICAgICAgICAgICAgICByZW1hdGNoLnJlYWNoID0gbmVzdGVkUmVtYXRjaC5yZWFjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGVkZWYgTGlua2VkTGlzdE5vZGVcbiAgICogQHByb3BlcnR5IHtUfSB2YWx1ZVxuICAgKiBAcHJvcGVydHkge0xpbmtlZExpc3ROb2RlPFQ+IHwgbnVsbH0gcHJldiBUaGUgcHJldmlvdXMgbm9kZS5cbiAgICogQHByb3BlcnR5IHtMaW5rZWRMaXN0Tm9kZTxUPiB8IG51bGx9IG5leHQgVGhlIG5leHQgbm9kZS5cbiAgICogQHRlbXBsYXRlIFRcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBMaW5rZWRMaXN0KCkge1xuICAgIC8qKiBAdHlwZSB7TGlua2VkTGlzdE5vZGU8VD59ICovXG4gICAgdmFyIGhlYWQgPSB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIHByZXY6IG51bGwsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICAvKiogQHR5cGUge0xpbmtlZExpc3ROb2RlPFQ+fSAqL1xuICAgIHZhciB0YWlsID0ge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBwcmV2OiBoZWFkLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgaGVhZC5uZXh0ID0gdGFpbDtcblxuICAgIC8qKiBAdHlwZSB7TGlua2VkTGlzdE5vZGU8VD59ICovXG4gICAgdGhpcy5oZWFkID0gaGVhZDtcbiAgICAvKiogQHR5cGUge0xpbmtlZExpc3ROb2RlPFQ+fSAqL1xuICAgIHRoaXMudGFpbCA9IHRhaWw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgbm9kZSB3aXRoIHRoZSBnaXZlbiB2YWx1ZSB0byB0aGUgbGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHtMaW5rZWRMaXN0PFQ+fSBsaXN0XG4gICAqIEBwYXJhbSB7TGlua2VkTGlzdE5vZGU8VD59IG5vZGVcbiAgICogQHBhcmFtIHtUfSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7TGlua2VkTGlzdE5vZGU8VD59IFRoZSBhZGRlZCBub2RlLlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cbiAgZnVuY3Rpb24gYWRkQWZ0ZXIobGlzdCwgbm9kZSwgdmFsdWUpIHtcbiAgICAvLyBhc3N1bWVzIHRoYXQgbm9kZSAhPSBsaXN0LnRhaWwgJiYgdmFsdWVzLmxlbmd0aCA+PSAwXG4gICAgdmFyIG5leHQgPSBub2RlLm5leHQ7XG4gICAgdmFyIG5ld05vZGUgPSB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBwcmV2OiBub2RlLFxuICAgICAgbmV4dDogbmV4dFxuICAgIH07XG4gICAgbm9kZS5uZXh0ID0gbmV3Tm9kZTtcbiAgICBuZXh0LnByZXYgPSBuZXdOb2RlO1xuICAgIGxpc3QubGVuZ3RoKys7XG4gICAgcmV0dXJuIG5ld05vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYGNvdW50YCBub2RlcyBhZnRlciB0aGUgZ2l2ZW4gbm9kZS4gVGhlIGdpdmVuIG5vZGUgd2lsbCBub3QgYmUgcmVtb3ZlZC5cbiAgICpcbiAgICogQHBhcmFtIHtMaW5rZWRMaXN0PFQ+fSBsaXN0XG4gICAqIEBwYXJhbSB7TGlua2VkTGlzdE5vZGU8VD59IG5vZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqL1xuICBmdW5jdGlvbiByZW1vdmVSYW5nZShsaXN0LCBub2RlLCBjb3VudCkge1xuICAgIHZhciBuZXh0ID0gbm9kZS5uZXh0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQgJiYgbmV4dCAhPT0gbGlzdC50YWlsOyBpKyspIHtcbiAgICAgIG5leHQgPSBuZXh0Lm5leHQ7XG4gICAgfVxuICAgIG5vZGUubmV4dCA9IG5leHQ7XG4gICAgbmV4dC5wcmV2ID0gbm9kZTtcbiAgICBsaXN0Lmxlbmd0aCAtPSBpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0xpbmtlZExpc3Q8VD59IGxpc3RcbiAgICogQHJldHVybnMge1RbXX1cbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG4gIGZ1bmN0aW9uIHRvQXJyYXkobGlzdCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIHZhciBub2RlID0gbGlzdC5oZWFkLm5leHQ7XG4gICAgd2hpbGUgKG5vZGUgIT09IGxpc3QudGFpbCkge1xuICAgICAgYXJyYXkucHVzaChub2RlLnZhbHVlKTtcbiAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuICBpZiAoIV9zZWxmLmRvY3VtZW50KSB7XG4gICAgaWYgKCFfc2VsZi5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAvLyBpbiBOb2RlLmpzXG4gICAgICByZXR1cm4gXztcbiAgICB9XG4gICAgaWYgKCFfLmRpc2FibGVXb3JrZXJNZXNzYWdlSGFuZGxlcikge1xuICAgICAgLy8gSW4gd29ya2VyXG4gICAgICBfc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IEpTT04ucGFyc2UoZXZ0LmRhdGEpO1xuICAgICAgICB2YXIgbGFuZyA9IG1lc3NhZ2UubGFuZ3VhZ2U7XG4gICAgICAgIHZhciBjb2RlID0gbWVzc2FnZS5jb2RlO1xuICAgICAgICB2YXIgaW1tZWRpYXRlQ2xvc2UgPSBtZXNzYWdlLmltbWVkaWF0ZUNsb3NlO1xuICAgICAgICBfc2VsZi5wb3N0TWVzc2FnZShfLmhpZ2hsaWdodChjb2RlLCBfLmxhbmd1YWdlc1tsYW5nXSwgbGFuZykpO1xuICAgICAgICBpZiAoaW1tZWRpYXRlQ2xvc2UpIHtcbiAgICAgICAgICBfc2VsZi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9LCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiBfO1xuICB9XG5cbiAgLy8gR2V0IGN1cnJlbnQgc2NyaXB0IGFuZCBoaWdobGlnaHRcbiAgdmFyIHNjcmlwdCA9IF8udXRpbC5jdXJyZW50U2NyaXB0KCk7XG4gIGlmIChzY3JpcHQpIHtcbiAgICBfLmZpbGVuYW1lID0gc2NyaXB0LnNyYztcbiAgICBpZiAoc2NyaXB0Lmhhc0F0dHJpYnV0ZSgnZGF0YS1tYW51YWwnKSkge1xuICAgICAgXy5tYW51YWwgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBoaWdobGlnaHRBdXRvbWF0aWNhbGx5Q2FsbGJhY2soKSB7XG4gICAgaWYgKCFfLm1hbnVhbCkge1xuICAgICAgXy5oaWdobGlnaHRBbGwoKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFfLm1hbnVhbCkge1xuICAgIC8vIElmIHRoZSBkb2N1bWVudCBzdGF0ZSBpcyBcImxvYWRpbmdcIiwgdGhlbiB3ZSdsbCB1c2UgRE9NQ29udGVudExvYWRlZC5cbiAgICAvLyBJZiB0aGUgZG9jdW1lbnQgc3RhdGUgaXMgXCJpbnRlcmFjdGl2ZVwiIGFuZCB0aGUgcHJpc20uanMgc2NyaXB0IGlzIGRlZmVycmVkLCB0aGVuIHdlJ2xsIGFsc28gdXNlIHRoZVxuICAgIC8vIERPTUNvbnRlbnRMb2FkZWQgZXZlbnQgYmVjYXVzZSB0aGVyZSBtaWdodCBiZSBzb21lIHBsdWdpbnMgb3IgbGFuZ3VhZ2VzIHdoaWNoIGhhdmUgYWxzbyBiZWVuIGRlZmVycmVkIGFuZCB0aGV5XG4gICAgLy8gbWlnaHQgdGFrZSBsb25nZXIgb25lIGFuaW1hdGlvbiBmcmFtZSB0byBleGVjdXRlIHdoaWNoIGNhbiBjcmVhdGUgYSByYWNlIGNvbmRpdGlvbiB3aGVyZSBvbmx5IHNvbWUgcGx1Z2lucyBoYXZlXG4gICAgLy8gYmVlbiBsb2FkZWQgd2hlbiBQcmlzbS5oaWdobGlnaHRBbGwoKSBpcyBleGVjdXRlZCwgZGVwZW5kaW5nIG9uIGhvdyBmYXN0IHJlc291cmNlcyBhcmUgbG9hZGVkLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vUHJpc21KUy9wcmlzbS9pc3N1ZXMvMjEwMlxuICAgIHZhciByZWFkeVN0YXRlID0gZG9jdW1lbnQucmVhZHlTdGF0ZTtcbiAgICBpZiAocmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnIHx8IHJlYWR5U3RhdGUgPT09ICdpbnRlcmFjdGl2ZScgJiYgc2NyaXB0ICYmIHNjcmlwdC5kZWZlcikge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGhpZ2hsaWdodEF1dG9tYXRpY2FsbHlDYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaGlnaGxpZ2h0QXV0b21hdGljYWxseUNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGhpZ2hsaWdodEF1dG9tYXRpY2FsbHlDYWxsYmFjaywgMTYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gXztcbn0oX3NlbGYpO1xuXG4vLyBzb21lIGFkZGl0aW9uYWwgZG9jdW1lbnRhdGlvbi90eXBlc1xuXG4vKipcbiAqIFRoZSBleHBhbnNpb24gb2YgYSBzaW1wbGUgYFJlZ0V4cGAgbGl0ZXJhbCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgcHJvcGVydGllcy5cbiAqXG4gKiBAdHlwZWRlZiBHcmFtbWFyVG9rZW5cbiAqIEBwcm9wZXJ0eSB7UmVnRXhwfSBwYXR0ZXJuIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gb2YgdGhlIHRva2VuLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbbG9va2JlaGluZD1mYWxzZV0gSWYgYHRydWVgLCB0aGVuIHRoZSBmaXJzdCBjYXB0dXJpbmcgZ3JvdXAgb2YgYHBhdHRlcm5gIHdpbGwgKGVmZmVjdGl2ZWx5KVxuICogYmVoYXZlIGFzIGEgbG9va2JlaGluZCBncm91cCBtZWFuaW5nIHRoYXQgdGhlIGNhcHR1cmVkIHRleHQgd2lsbCBub3QgYmUgcGFydCBvZiB0aGUgbWF0Y2hlZCB0ZXh0IG9mIHRoZSBuZXcgdG9rZW4uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtncmVlZHk9ZmFsc2VdIFdoZXRoZXIgdGhlIHRva2VuIGlzIGdyZWVkeS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfHN0cmluZ1tdfSBbYWxpYXNdIEFuIG9wdGlvbmFsIGFsaWFzIG9yIGxpc3Qgb2YgYWxpYXNlcy5cbiAqIEBwcm9wZXJ0eSB7R3JhbW1hcn0gW2luc2lkZV0gVGhlIG5lc3RlZCBncmFtbWFyIG9mIHRoaXMgdG9rZW4uXG4gKlxuICogVGhlIGBpbnNpZGVgIGdyYW1tYXIgd2lsbCBiZSB1c2VkIHRvIHRva2VuaXplIHRoZSB0ZXh0IHZhbHVlIG9mIGVhY2ggdG9rZW4gb2YgdGhpcyBraW5kLlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbWFrZSBuZXN0ZWQgYW5kIGV2ZW4gcmVjdXJzaXZlIGxhbmd1YWdlIGRlZmluaXRpb25zLlxuICpcbiAqIE5vdGU6IFRoaXMgY2FuIGNhdXNlIGluZmluaXRlIHJlY3Vyc2lvbi4gQmUgY2FyZWZ1bCB3aGVuIHlvdSBlbWJlZCBkaWZmZXJlbnQgbGFuZ3VhZ2VzIG9yIGV2ZW4gdGhlIHNhbWUgbGFuZ3VhZ2UgaW50b1xuICogZWFjaCBhbm90aGVyLlxuICogQGdsb2JhbFxuICogQHB1YmxpY1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYgR3JhbW1hclxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIFJlZ0V4cCB8IEdyYW1tYXJUb2tlbiB8IEFycmF5PFJlZ0V4cCB8IEdyYW1tYXJUb2tlbj4+fVxuICogQHByb3BlcnR5IHtHcmFtbWFyfSBbcmVzdF0gQW4gb3B0aW9uYWwgZ3JhbW1hciBvYmplY3QgdGhhdCB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoaXMgZ3JhbW1hci5cbiAqIEBnbG9iYWxcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gd2hpY2ggd2lsbCBpbnZva2VkIGFmdGVyIGFuIGVsZW1lbnQgd2FzIHN1Y2Nlc3NmdWxseSBoaWdobGlnaHRlZC5cbiAqXG4gKiBAY2FsbGJhY2sgSGlnaGxpZ2h0Q2FsbGJhY2tcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCBzdWNjZXNzZnVsbHkgaGlnaGxpZ2h0ZWQuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBnbG9iYWxcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBIb29rQ2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gZW52IFRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgb2YgdGhlIGhvb2suXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBnbG9iYWxcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLW1hcmt1cC5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMubWFya3VwID0ge1xuICAnY29tbWVudCc6IHtcbiAgICBwYXR0ZXJuOiAvPCEtLSg/Oig/ITwhLS0pW1xcc1xcU10pKj8tLT4vLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAncHJvbG9nJzoge1xuICAgIHBhdHRlcm46IC88XFw/W1xcc1xcU10rP1xcPz4vLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnZG9jdHlwZSc6IHtcbiAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIveG1sLyNOVC1kb2N0eXBlZGVjbFxuICAgIHBhdHRlcm46IC88IURPQ1RZUEUoPzpbXj5cIidbXFxdXXxcIlteXCJdKlwifCdbXiddKicpKyg/OlxcWyg/OltePFwiJ1xcXV18XCJbXlwiXSpcInwnW14nXSonfDwoPyEhLS0pfDwhLS0oPzpbXi1dfC0oPyEtPikpKi0tPikqXFxdXFxzKik/Pi9pLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdpbnRlcm5hbC1zdWJzZXQnOiB7XG4gICAgICAgIHBhdHRlcm46IC8oXlteXFxbXSpcXFspW1xcc1xcU10rKD89XFxdPiQpLyxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgICBpbnNpZGU6IG51bGwgLy8gc2VlIGJlbG93XG4gICAgICB9LFxuXG4gICAgICAnc3RyaW5nJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXCJbXlwiXSpcInwnW14nXSonLyxcbiAgICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgICB9LFxuICAgICAgJ3B1bmN0dWF0aW9uJzogL148IXw+JHxbW1xcXV0vLFxuICAgICAgJ2RvY3R5cGUtdGFnJzogL15ET0NUWVBFL2ksXG4gICAgICAnbmFtZSc6IC9bXlxcczw+J1wiXSsvXG4gICAgfVxuICB9LFxuICAnY2RhdGEnOiB7XG4gICAgcGF0dGVybjogLzwhXFxbQ0RBVEFcXFtbXFxzXFxTXSo/XFxdXFxdPi9pLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAndGFnJzoge1xuICAgIHBhdHRlcm46IC88XFwvPyg/IVxcZClbXlxccz5cXC89JDwlXSsoPzpcXHMoPzpcXHMqW15cXHM+XFwvPV0rKD86XFxzKj1cXHMqKD86XCJbXlwiXSpcInwnW14nXSonfFteXFxzJ1wiPj1dKyg/PVtcXHM+XSkpfCg/PVtcXHMvPl0pKSkrKT9cXHMqXFwvPz4vLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICd0YWcnOiB7XG4gICAgICAgIHBhdHRlcm46IC9ePFxcLz9bXlxccz5cXC9dKy8sXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9ePFxcLz8vLFxuICAgICAgICAgICduYW1lc3BhY2UnOiAvXlteXFxzPlxcLzpdKzovXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnc3BlY2lhbC1hdHRyJzogW10sXG4gICAgICAnYXR0ci12YWx1ZSc6IHtcbiAgICAgICAgcGF0dGVybjogLz1cXHMqKD86XCJbXlwiXSpcInwnW14nXSonfFteXFxzJ1wiPj1dKykvLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAncHVuY3R1YXRpb24nOiBbe1xuICAgICAgICAgICAgcGF0dGVybjogL149LyxcbiAgICAgICAgICAgIGFsaWFzOiAnYXR0ci1lcXVhbHMnXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgcGF0dGVybjogL14oXFxzKilbXCInXXxbXCInXSQvLFxuICAgICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICAgIH1dXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAncHVuY3R1YXRpb24nOiAvXFwvPz4vLFxuICAgICAgJ2F0dHItbmFtZSc6IHtcbiAgICAgICAgcGF0dGVybjogL1teXFxzPlxcL10rLyxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgJ25hbWVzcGFjZSc6IC9eW15cXHM+XFwvOl0rOi9cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgJ2VudGl0eSc6IFt7XG4gICAgcGF0dGVybjogLyZbXFxkYS16XXsxLDh9Oy9pLFxuICAgIGFsaWFzOiAnbmFtZWQtZW50aXR5J1xuICB9LCAvJiN4P1tcXGRhLWZdezEsOH07L2ldXG59O1xuUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cFsndGFnJ10uaW5zaWRlWydhdHRyLXZhbHVlJ10uaW5zaWRlWydlbnRpdHknXSA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXBbJ2VudGl0eSddO1xuUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cFsnZG9jdHlwZSddLmluc2lkZVsnaW50ZXJuYWwtc3Vic2V0J10uaW5zaWRlID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblxuLy8gUGx1Z2luIHRvIG1ha2UgZW50aXR5IHRpdGxlIHNob3cgdGhlIHJlYWwgZW50aXR5LCBpZGVhIGJ5IFJvbWFuIEtvbWFyb3ZcblByaXNtLmhvb2tzLmFkZCgnd3JhcCcsIGZ1bmN0aW9uIChlbnYpIHtcbiAgaWYgKGVudi50eXBlID09PSAnZW50aXR5Jykge1xuICAgIGVudi5hdHRyaWJ1dGVzWyd0aXRsZSddID0gZW52LmNvbnRlbnQucmVwbGFjZSgvJmFtcDsvLCAnJicpO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZywgJ2FkZElubGluZWQnLCB7XG4gIC8qKlxuICAgKiBBZGRzIGFuIGlubGluZWQgbGFuZ3VhZ2UgdG8gbWFya3VwLlxuICAgKlxuICAgKiBBbiBleGFtcGxlIG9mIGFuIGlubGluZWQgbGFuZ3VhZ2UgaXMgQ1NTIHdpdGggYDxzdHlsZT5gIHRhZ3MuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lIFRoZSBuYW1lIG9mIHRoZSB0YWcgdGhhdCBjb250YWlucyB0aGUgaW5saW5lZCBsYW5ndWFnZS4gVGhpcyBuYW1lIHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgKiBjYXNlIGluc2Vuc2l0aXZlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZyBUaGUgbGFuZ3VhZ2Uga2V5LlxuICAgKiBAZXhhbXBsZVxuICAgKiBhZGRJbmxpbmVkKCdzdHlsZScsICdjc3MnKTtcbiAgICovXG4gIHZhbHVlOiBmdW5jdGlvbiBhZGRJbmxpbmVkKHRhZ05hbWUsIGxhbmcpIHtcbiAgICB2YXIgaW5jbHVkZWRDZGF0YUluc2lkZSA9IHt9O1xuICAgIGluY2x1ZGVkQ2RhdGFJbnNpZGVbJ2xhbmd1YWdlLScgKyBsYW5nXSA9IHtcbiAgICAgIHBhdHRlcm46IC8oXjwhXFxbQ0RBVEFcXFspW1xcc1xcU10rPyg/PVxcXVxcXT4kKS9pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzW2xhbmddXG4gICAgfTtcbiAgICBpbmNsdWRlZENkYXRhSW5zaWRlWydjZGF0YSddID0gL148IVxcW0NEQVRBXFxbfFxcXVxcXT4kL2k7XG4gICAgdmFyIGluc2lkZSA9IHtcbiAgICAgICdpbmNsdWRlZC1jZGF0YSc6IHtcbiAgICAgICAgcGF0dGVybjogLzwhXFxbQ0RBVEFcXFtbXFxzXFxTXSo/XFxdXFxdPi9pLFxuICAgICAgICBpbnNpZGU6IGluY2x1ZGVkQ2RhdGFJbnNpZGVcbiAgICAgIH1cbiAgICB9O1xuICAgIGluc2lkZVsnbGFuZ3VhZ2UtJyArIGxhbmddID0ge1xuICAgICAgcGF0dGVybjogL1tcXHNcXFNdKy8sXG4gICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlc1tsYW5nXVxuICAgIH07XG4gICAgdmFyIGRlZiA9IHt9O1xuICAgIGRlZlt0YWdOYW1lXSA9IHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgvKDxfX1tePl0qPikoPzo8IVxcW0NEQVRBXFxbKD86W15cXF1dfFxcXSg/IVxcXT4pKSpcXF1cXF0+fCg/ITwhXFxbQ0RBVEFcXFspW1xcc1xcU10pKj8oPz08XFwvX18+KS8uc291cmNlLnJlcGxhY2UoL19fL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRhZ05hbWU7XG4gICAgICB9KSwgJ2knKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IGluc2lkZVxuICAgIH07XG4gICAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya3VwJywgJ2NkYXRhJywgZGVmKTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcsICdhZGRBdHRyaWJ1dGUnLCB7XG4gIC8qKlxuICAgKiBBZGRzIGFuIHBhdHRlcm4gdG8gaGlnaGxpZ2h0IGxhbmd1YWdlcyBlbWJlZGRlZCBpbiBIVE1MIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEFuIGV4YW1wbGUgb2YgYW4gaW5saW5lZCBsYW5ndWFnZSBpcyBDU1Mgd2l0aCBgc3R5bGVgIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyTmFtZSBUaGUgbmFtZSBvZiB0aGUgdGFnIHRoYXQgY29udGFpbnMgdGhlIGlubGluZWQgbGFuZ3VhZ2UuIFRoaXMgbmFtZSB3aWxsIGJlIHRyZWF0ZWQgYXNcbiAgICogY2FzZSBpbnNlbnNpdGl2ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmcgVGhlIGxhbmd1YWdlIGtleS5cbiAgICogQGV4YW1wbGVcbiAgICogYWRkQXR0cmlidXRlKCdzdHlsZScsICdjc3MnKTtcbiAgICovXG4gIHZhbHVlOiBmdW5jdGlvbiAoYXR0ck5hbWUsIGxhbmcpIHtcbiAgICBQcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZy5pbnNpZGVbJ3NwZWNpYWwtYXR0ciddLnB1c2goe1xuICAgICAgcGF0dGVybjogUmVnRXhwKC8oXnxbXCInXFxzXSkvLnNvdXJjZSArICcoPzonICsgYXR0ck5hbWUgKyAnKScgKyAvXFxzKj1cXHMqKD86XCJbXlwiXSpcInwnW14nXSonfFteXFxzJ1wiPj1dKyg/PVtcXHM+XSkpLy5zb3VyY2UsICdpJyksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdhdHRyLW5hbWUnOiAvXlteXFxzPV0rLyxcbiAgICAgICAgJ2F0dHItdmFsdWUnOiB7XG4gICAgICAgICAgcGF0dGVybjogLz1bXFxzXFxTXSsvLFxuICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgJ3ZhbHVlJzoge1xuICAgICAgICAgICAgICBwYXR0ZXJuOiAvKF49XFxzKihbXCInXXwoPyFbXCInXSkpKVxcU1tcXHNcXFNdKig/PVxcMiQpLyxcbiAgICAgICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICAgICAgYWxpYXM6IFtsYW5nLCAnbGFuZ3VhZ2UtJyArIGxhbmddLFxuICAgICAgICAgICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlc1tsYW5nXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdwdW5jdHVhdGlvbic6IFt7XG4gICAgICAgICAgICAgIHBhdHRlcm46IC9ePS8sXG4gICAgICAgICAgICAgIGFsaWFzOiAnYXR0ci1lcXVhbHMnXG4gICAgICAgICAgICB9LCAvXCJ8Jy9dXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0pO1xuUHJpc20ubGFuZ3VhZ2VzLmh0bWwgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuUHJpc20ubGFuZ3VhZ2VzLm1hdGhtbCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5QcmlzbS5sYW5ndWFnZXMuc3ZnID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblByaXNtLmxhbmd1YWdlcy54bWwgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdtYXJrdXAnLCB7fSk7XG5QcmlzbS5sYW5ndWFnZXMuc3NtbCA9IFByaXNtLmxhbmd1YWdlcy54bWw7XG5QcmlzbS5sYW5ndWFnZXMuYXRvbSA9IFByaXNtLmxhbmd1YWdlcy54bWw7XG5QcmlzbS5sYW5ndWFnZXMucnNzID0gUHJpc20ubGFuZ3VhZ2VzLnhtbDtcblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1jc3MuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuKGZ1bmN0aW9uIChQcmlzbSkge1xuICB2YXIgc3RyaW5nID0gLyg/OlwiKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8W15cIlxcXFxcXHJcXG5dKSpcInwnKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8W14nXFxcXFxcclxcbl0pKicpLztcbiAgUHJpc20ubGFuZ3VhZ2VzLmNzcyA9IHtcbiAgICAnY29tbWVudCc6IC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvLyxcbiAgICAnYXRydWxlJzoge1xuICAgICAgcGF0dGVybjogUmVnRXhwKCdAW1xcXFx3LV0oPzonICsgL1teO3tcXHNcIiddfFxccysoPyFcXHMpLy5zb3VyY2UgKyAnfCcgKyBzdHJpbmcuc291cmNlICsgJykqPycgKyAvKD86O3woPz1cXHMqXFx7KSkvLnNvdXJjZSksXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3J1bGUnOiAvXkBbXFx3LV0rLyxcbiAgICAgICAgJ3NlbGVjdG9yLWZ1bmN0aW9uLWFyZ3VtZW50Jzoge1xuICAgICAgICAgIHBhdHRlcm46IC8oXFxic2VsZWN0b3JcXHMqXFwoXFxzKig/IVtcXHMpXSkpKD86W14oKVxcc118XFxzKyg/IVtcXHMpXSl8XFwoKD86W14oKV18XFwoW14oKV0qXFwpKSpcXCkpKyg/PVxccypcXCkpLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGFsaWFzOiAnc2VsZWN0b3InXG4gICAgICAgIH0sXG4gICAgICAgICdrZXl3b3JkJzoge1xuICAgICAgICAgIHBhdHRlcm46IC8oXnxbXlxcdy1dKSg/OmFuZHxub3R8b25seXxvcikoPyFbXFx3LV0pLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VlIHJlc3QgYmVsb3dcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgJ3VybCc6IHtcbiAgICAgIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTMvI3VybHNcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgnXFxcXGJ1cmxcXFxcKCg/OicgKyBzdHJpbmcuc291cmNlICsgJ3wnICsgLyg/OlteXFxcXFxcclxcbigpXCInXXxcXFxcW1xcc1xcU10pKi8uc291cmNlICsgJylcXFxcKScsICdpJyksXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2Z1bmN0aW9uJzogL151cmwvaSxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL15cXCh8XFwpJC8sXG4gICAgICAgICdzdHJpbmcnOiB7XG4gICAgICAgICAgcGF0dGVybjogUmVnRXhwKCdeJyArIHN0cmluZy5zb3VyY2UgKyAnJCcpLFxuICAgICAgICAgIGFsaWFzOiAndXJsJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAnc2VsZWN0b3InOiB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoJyhefFt7fVxcXFxzXSlbXnt9XFxcXHNdKD86W157fTtcIlxcJ1xcXFxzXXxcXFxccysoPyFbXFxcXHN7XSl8JyArIHN0cmluZy5zb3VyY2UgKyAnKSooPz1cXFxccypcXFxceyknKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICdzdHJpbmcnOiB7XG4gICAgICBwYXR0ZXJuOiBzdHJpbmcsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LFxuICAgICdwcm9wZXJ0eSc6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXi1cXHdcXHhBMC1cXHVGRkZGXSkoPyFcXHMpWy1fYS16XFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWy1cXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKjopL2ksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAnaW1wb3J0YW50JzogLyFpbXBvcnRhbnRcXGIvaSxcbiAgICAnZnVuY3Rpb24nOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W14tYS16MC05XSlbLWEtejAtOV0rKD89XFwoKS9pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgJ3B1bmN0dWF0aW9uJzogL1soKXt9OzosXS9cbiAgfTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmNzc1snYXRydWxlJ10uaW5zaWRlLnJlc3QgPSBQcmlzbS5sYW5ndWFnZXMuY3NzO1xuICB2YXIgbWFya3VwID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcbiAgaWYgKG1hcmt1cCkge1xuICAgIG1hcmt1cC50YWcuYWRkSW5saW5lZCgnc3R5bGUnLCAnY3NzJyk7XG4gICAgbWFya3VwLnRhZy5hZGRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2NzcycpO1xuICB9XG59KShQcmlzbSk7XG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tY2xpa2UuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuUHJpc20ubGFuZ3VhZ2VzLmNsaWtlID0ge1xuICAnY29tbWVudCc6IFt7XG4gICAgcGF0dGVybjogLyhefFteXFxcXF0pXFwvXFwqW1xcc1xcU10qPyg/OlxcKlxcL3wkKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBncmVlZHk6IHRydWVcbiAgfSwge1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFw6XSlcXC9cXC8uKi8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBncmVlZHk6IHRydWVcbiAgfV0sXG4gICdzdHJpbmcnOiB7XG4gICAgcGF0dGVybjogLyhbXCInXSkoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXwoPyFcXDEpW15cXFxcXFxyXFxuXSkqXFwxLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ2NsYXNzLW5hbWUnOiB7XG4gICAgcGF0dGVybjogLyhcXGIoPzpjbGFzc3xleHRlbmRzfGltcGxlbWVudHN8aW5zdGFuY2VvZnxpbnRlcmZhY2V8bmV3fHRyYWl0KVxccyt8XFxiY2F0Y2hcXHMrXFwoKVtcXHcuXFxcXF0rL2ksXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdwdW5jdHVhdGlvbic6IC9bLlxcXFxdL1xuICAgIH1cbiAgfSxcbiAgJ2tleXdvcmQnOiAvXFxiKD86YnJlYWt8Y2F0Y2h8Y29udGludWV8ZG98ZWxzZXxmaW5hbGx5fGZvcnxmdW5jdGlvbnxpZnxpbnxpbnN0YW5jZW9mfG5ld3xudWxsfHJldHVybnx0aHJvd3x0cnl8d2hpbGUpXFxiLyxcbiAgJ2Jvb2xlYW4nOiAvXFxiKD86ZmFsc2V8dHJ1ZSlcXGIvLFxuICAnZnVuY3Rpb24nOiAvXFxiXFx3Kyg/PVxcKCkvLFxuICAnbnVtYmVyJzogL1xcYjB4W1xcZGEtZl0rXFxifCg/OlxcYlxcZCsoPzpcXC5cXGQqKT98XFxCXFwuXFxkKykoPzplWystXT9cXGQrKT8vaSxcbiAgJ29wZXJhdG9yJzogL1s8Pl09P3xbIT1dPT89P3wtLT98XFwrXFwrP3wmJj98XFx8XFx8P3xbPyovfl4lXS8sXG4gICdwdW5jdHVhdGlvbic6IC9be31bXFxdOygpLC46XS9cbn07XG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tamF2YXNjcmlwdC5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NsaWtlJywge1xuICAnY2xhc3MtbmFtZSc6IFtQcmlzbS5sYW5ndWFnZXMuY2xpa2VbJ2NsYXNzLW5hbWUnXSwge1xuICAgIHBhdHRlcm46IC8oXnxbXiRcXHdcXHhBMC1cXHVGRkZGXSkoPyFcXHMpW18kQS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD89XFwuKD86Y29uc3RydWN0b3J8cHJvdG90eXBlKSkvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfV0sXG4gICdrZXl3b3JkJzogW3tcbiAgICBwYXR0ZXJuOiAvKCg/Ol58XFx9KVxccyopY2F0Y2hcXGIvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSwge1xuICAgIHBhdHRlcm46IC8oXnxbXi5dfFxcLlxcLlxcLlxccyopXFxiKD86YXN8YXNzZXJ0KD89XFxzKlxceyl8YXN5bmMoPz1cXHMqKD86ZnVuY3Rpb25cXGJ8XFwofFskXFx3XFx4QTAtXFx1RkZGRl18JCkpfGF3YWl0fGJyZWFrfGNhc2V8Y2xhc3N8Y29uc3R8Y29udGludWV8ZGVidWdnZXJ8ZGVmYXVsdHxkZWxldGV8ZG98ZWxzZXxlbnVtfGV4cG9ydHxleHRlbmRzfGZpbmFsbHkoPz1cXHMqKD86XFx7fCQpKXxmb3J8ZnJvbSg/PVxccyooPzpbJ1wiXXwkKSl8ZnVuY3Rpb258KD86Z2V0fHNldCkoPz1cXHMqKD86WyNcXFskXFx3XFx4QTAtXFx1RkZGRl18JCkpfGlmfGltcGxlbWVudHN8aW1wb3J0fGlufGluc3RhbmNlb2Z8aW50ZXJmYWNlfGxldHxuZXd8bnVsbHxvZnxwYWNrYWdlfHByaXZhdGV8cHJvdGVjdGVkfHB1YmxpY3xyZXR1cm58c3RhdGljfHN1cGVyfHN3aXRjaHx0aGlzfHRocm93fHRyeXx0eXBlb2Z8dW5kZWZpbmVkfHZhcnx2b2lkfHdoaWxlfHdpdGh8eWllbGQpXFxiLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH1dLFxuICAvLyBBbGxvdyBmb3IgYWxsIG5vbi1BU0NJSSBjaGFyYWN0ZXJzIChTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjAwODQ0NClcbiAgJ2Z1bmN0aW9uJzogLyM/KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccyooPzpcXC5cXHMqKD86YXBwbHl8YmluZHxjYWxsKVxccyopP1xcKCkvLFxuICAnbnVtYmVyJzoge1xuICAgIHBhdHRlcm46IFJlZ0V4cCgvKF58W15cXHckXSkvLnNvdXJjZSArICcoPzonICsgKFxuICAgIC8vIGNvbnN0YW50XG4gICAgL05hTnxJbmZpbml0eS8uc291cmNlICsgJ3wnICtcbiAgICAvLyBiaW5hcnkgaW50ZWdlclxuICAgIC8wW2JCXVswMV0rKD86X1swMV0rKSpuPy8uc291cmNlICsgJ3wnICtcbiAgICAvLyBvY3RhbCBpbnRlZ2VyXG4gICAgLzBbb09dWzAtN10rKD86X1swLTddKykqbj8vLnNvdXJjZSArICd8JyArXG4gICAgLy8gaGV4YWRlY2ltYWwgaW50ZWdlclxuICAgIC8wW3hYXVtcXGRBLUZhLWZdKyg/Ol9bXFxkQS1GYS1mXSspKm4/Ly5zb3VyY2UgKyAnfCcgK1xuICAgIC8vIGRlY2ltYWwgYmlnaW50XG4gICAgL1xcZCsoPzpfXFxkKykqbi8uc291cmNlICsgJ3wnICtcbiAgICAvLyBkZWNpbWFsIG51bWJlciAoaW50ZWdlciBvciBmbG9hdCkgYnV0IG5vIGJpZ2ludFxuICAgIC8oPzpcXGQrKD86X1xcZCspKig/OlxcLig/OlxcZCsoPzpfXFxkKykqKT8pP3xcXC5cXGQrKD86X1xcZCspKikoPzpbRWVdWystXT9cXGQrKD86X1xcZCspKik/Ly5zb3VyY2UpICsgJyknICsgLyg/IVtcXHckXSkvLnNvdXJjZSksXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9LFxuICAnb3BlcmF0b3InOiAvLS18XFwrXFwrfFxcKlxcKj0/fD0+fCYmPT98XFx8XFx8PT98WyE9XT09fDw8PT98Pj4+Pz0/fFstKyovJSZ8XiE9PD5dPT98XFwuezN9fFxcP1xcPz0/fFxcP1xcLj98W346XS9cbn0pO1xuUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRbJ2NsYXNzLW5hbWUnXVswXS5wYXR0ZXJuID0gLyhcXGIoPzpjbGFzc3xleHRlbmRzfGltcGxlbWVudHN8aW5zdGFuY2VvZnxpbnRlcmZhY2V8bmV3KVxccyspW1xcdy5cXFxcXSsvO1xuUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdrZXl3b3JkJywge1xuICAncmVnZXgnOiB7XG4gICAgcGF0dGVybjogUmVnRXhwKFxuICAgIC8vIGxvb2tiZWhpbmRcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVnZXhwL25vLWR1cGUtY2hhcmFjdGVycy1jaGFyYWN0ZXItY2xhc3NcbiAgICAvKCg/Ol58W14kXFx3XFx4QTAtXFx1RkZGRi5cIidcXF0pXFxzXXxcXGIoPzpyZXR1cm58eWllbGQpKVxccyopLy5zb3VyY2UgK1xuICAgIC8vIFJlZ2V4IHBhdHRlcm46XG4gICAgLy8gVGhlcmUgYXJlIDIgcmVnZXggcGF0dGVybnMgaGVyZS4gVGhlIFJlZ0V4cCBzZXQgbm90YXRpb24gcHJvcG9zYWwgYWRkZWQgc3VwcG9ydCBmb3IgbmVzdGVkIGNoYXJhY3RlclxuICAgIC8vIGNsYXNzZXMgaWYgdGhlIGB2YCBmbGFnIGlzIHByZXNlbnQuIFVuZm9ydHVuYXRlbHksIG5lc3RlZCBDQ3MgYXJlIGJvdGggY29udGV4dC1mcmVlIGFuZCBpbmNvbXBhdGlibGVcbiAgICAvLyB3aXRoIHRoZSBvbmx5IHN5bnRheCwgc28gd2UgaGF2ZSB0byBkZWZpbmUgMiBkaWZmZXJlbnQgcmVnZXggcGF0dGVybnMuXG4gICAgL1xcLy8uc291cmNlICsgJyg/OicgKyAvKD86XFxbKD86W15cXF1cXFxcXFxyXFxuXXxcXFxcLikqXFxdfFxcXFwufFteL1xcXFxcXFtcXHJcXG5dKStcXC9bZGdpbXl1c117MCw3fS8uc291cmNlICsgJ3wnICtcbiAgICAvLyBgdmAgZmxhZyBzeW50YXguIFRoaXMgc3VwcG9ydHMgMyBsZXZlbHMgb2YgbmVzdGVkIGNoYXJhY3RlciBjbGFzc2VzLlxuICAgIC8oPzpcXFsoPzpbXltcXF1cXFxcXFxyXFxuXXxcXFxcLnxcXFsoPzpbXltcXF1cXFxcXFxyXFxuXXxcXFxcLnxcXFsoPzpbXltcXF1cXFxcXFxyXFxuXXxcXFxcLikqXFxdKSpcXF0pKlxcXXxcXFxcLnxbXi9cXFxcXFxbXFxyXFxuXSkrXFwvW2RnaW15dXNdezAsN312W2RnaW15dXNdezAsN30vLnNvdXJjZSArICcpJyArXG4gICAgLy8gbG9va2FoZWFkXG4gICAgLyg/PSg/Olxcc3xcXC9cXCooPzpbXipdfFxcKig/IVxcLykpKlxcKlxcLykqKD86JHxbXFxyXFxuLC47On0pXFxdXXxcXC9cXC8pKS8uc291cmNlKSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdyZWdleC1zb3VyY2UnOiB7XG4gICAgICAgIHBhdHRlcm46IC9eKFxcLylbXFxzXFxTXSsoPz1cXC9bYS16XSokKS8sXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgIGFsaWFzOiAnbGFuZ3VhZ2UtcmVnZXgnLFxuICAgICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5yZWdleFxuICAgICAgfSxcbiAgICAgICdyZWdleC1kZWxpbWl0ZXInOiAvXlxcL3xcXC8kLyxcbiAgICAgICdyZWdleC1mbGFncyc6IC9eW2Etel0rJC9cbiAgICB9XG4gIH0sXG4gIC8vIFRoaXMgbXVzdCBiZSBkZWNsYXJlZCBiZWZvcmUga2V5d29yZCBiZWNhdXNlIHdlIHVzZSBcImZ1bmN0aW9uXCIgaW5zaWRlIHRoZSBsb29rLWZvcndhcmRcbiAgJ2Z1bmN0aW9uLXZhcmlhYmxlJzoge1xuICAgIHBhdHRlcm46IC8jPyg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqWz06XVxccyooPzphc3luY1xccyopPyg/OlxcYmZ1bmN0aW9uXFxifCg/OlxcKCg/OlteKCldfFxcKFteKCldKlxcKSkqXFwpfCg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSopXFxzKj0+KSkvLFxuICAgIGFsaWFzOiAnZnVuY3Rpb24nXG4gIH0sXG4gICdwYXJhbWV0ZXInOiBbe1xuICAgIHBhdHRlcm46IC8oZnVuY3Rpb24oPzpcXHMrKD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKik/XFxzKlxcKFxccyopKD8hXFxzKSg/OlteKClcXHNdfFxccysoPyFbXFxzKV0pfFxcKFteKCldKlxcKSkrKD89XFxzKlxcKSkvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuICB9LCB7XG4gICAgcGF0dGVybjogLyhefFteJFxcd1xceEEwLVxcdUZGRkZdKSg/IVxccylbXyRhLXpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqPT4pL2ksXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvKFxcKFxccyopKD8hXFxzKSg/OlteKClcXHNdfFxccysoPyFbXFxzKV0pfFxcKFteKCldKlxcKSkrKD89XFxzKlxcKVxccyo9PikvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuICB9LCB7XG4gICAgcGF0dGVybjogLygoPzpcXGJ8XFxzfF4pKD8hKD86YXN8YXN5bmN8YXdhaXR8YnJlYWt8Y2FzZXxjYXRjaHxjbGFzc3xjb25zdHxjb250aW51ZXxkZWJ1Z2dlcnxkZWZhdWx0fGRlbGV0ZXxkb3xlbHNlfGVudW18ZXhwb3J0fGV4dGVuZHN8ZmluYWxseXxmb3J8ZnJvbXxmdW5jdGlvbnxnZXR8aWZ8aW1wbGVtZW50c3xpbXBvcnR8aW58aW5zdGFuY2VvZnxpbnRlcmZhY2V8bGV0fG5ld3xudWxsfG9mfHBhY2thZ2V8cHJpdmF0ZXxwcm90ZWN0ZWR8cHVibGljfHJldHVybnxzZXR8c3RhdGljfHN1cGVyfHN3aXRjaHx0aGlzfHRocm93fHRyeXx0eXBlb2Z8dW5kZWZpbmVkfHZhcnx2b2lkfHdoaWxlfHdpdGh8eWllbGQpKD8hWyRcXHdcXHhBMC1cXHVGRkZGXSkpKD86KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKlxccyopXFwoXFxzKnxcXF1cXHMqXFwoXFxzKikoPyFcXHMpKD86W14oKVxcc118XFxzKyg/IVtcXHMpXSl8XFwoW14oKV0qXFwpKSsoPz1cXHMqXFwpXFxzKlxceykvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuICB9XSxcbiAgJ2NvbnN0YW50JzogL1xcYltBLVpdKD86W0EtWl9dfFxcZHg/KSpcXGIvXG59KTtcblByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAnc3RyaW5nJywge1xuICAnaGFzaGJhbmcnOiB7XG4gICAgcGF0dGVybjogL14jIS4qLyxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgYWxpYXM6ICdjb21tZW50J1xuICB9LFxuICAndGVtcGxhdGUtc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC9gKD86XFxcXFtcXHNcXFNdfFxcJFxceyg/Oltee31dfFxceyg/Oltee31dfFxce1tefV0qXFx9KSpcXH0pK1xcfXwoPyFcXCRcXHspW15cXFxcYF0pKmAvLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICd0ZW1wbGF0ZS1wdW5jdHVhdGlvbic6IHtcbiAgICAgICAgcGF0dGVybjogL15gfGAkLyxcbiAgICAgICAgYWxpYXM6ICdzdHJpbmcnXG4gICAgICB9LFxuICAgICAgJ2ludGVycG9sYXRpb24nOiB7XG4gICAgICAgIHBhdHRlcm46IC8oKD86XnxbXlxcXFxdKSg/OlxcXFx7Mn0pKilcXCRcXHsoPzpbXnt9XXxcXHsoPzpbXnt9XXxcXHtbXn1dKlxcfSkqXFx9KStcXH0vLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAnaW50ZXJwb2xhdGlvbi1wdW5jdHVhdGlvbic6IHtcbiAgICAgICAgICAgIHBhdHRlcm46IC9eXFwkXFx7fFxcfSQvLFxuICAgICAgICAgICAgYWxpYXM6ICdwdW5jdHVhdGlvbidcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc3Q6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnc3RyaW5nJzogL1tcXHNcXFNdKy9cbiAgICB9XG4gIH0sXG4gICdzdHJpbmctcHJvcGVydHknOiB7XG4gICAgcGF0dGVybjogLygoPzpefFsse10pWyBcXHRdKikoW1wiJ10pKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8KD8hXFwyKVteXFxcXFxcclxcbl0pKlxcMig/PVxccyo6KS9tLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGFsaWFzOiAncHJvcGVydHknXG4gIH1cbn0pO1xuUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdvcGVyYXRvcicsIHtcbiAgJ2xpdGVyYWwtcHJvcGVydHknOiB7XG4gICAgcGF0dGVybjogLygoPzpefFsse10pWyBcXHRdKikoPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKjopL20sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBhbGlhczogJ3Byb3BlcnR5J1xuICB9XG59KTtcbmlmIChQcmlzbS5sYW5ndWFnZXMubWFya3VwKSB7XG4gIFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLmFkZElubGluZWQoJ3NjcmlwdCcsICdqYXZhc2NyaXB0Jyk7XG5cbiAgLy8gYWRkIGF0dHJpYnV0ZSBzdXBwb3J0IGZvciBhbGwgRE9NIGV2ZW50cy5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzI1N0YW5kYXJkX2V2ZW50c1xuICBQcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZy5hZGRBdHRyaWJ1dGUoL29uKD86YWJvcnR8Ymx1cnxjaGFuZ2V8Y2xpY2t8Y29tcG9zaXRpb24oPzplbmR8c3RhcnR8dXBkYXRlKXxkYmxjbGlja3xlcnJvcnxmb2N1cyg/OmlufG91dCk/fGtleSg/OmRvd258dXApfGxvYWR8bW91c2UoPzpkb3dufGVudGVyfGxlYXZlfG1vdmV8b3V0fG92ZXJ8dXApfHJlc2V0fHJlc2l6ZXxzY3JvbGx8c2VsZWN0fHNsb3RjaGFuZ2V8c3VibWl0fHVubG9hZHx3aGVlbCkvLnNvdXJjZSwgJ2phdmFzY3JpcHQnKTtcbn1cblByaXNtLmxhbmd1YWdlcy5qcyA9IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0O1xuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLWZpbGUtaGlnaGxpZ2h0LmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbihmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgUHJpc20gPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9tYXRjaGVzI1BvbHlmaWxsXG4gIGlmICghRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcykge1xuICAgIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgPSBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG4gIH1cbiAgdmFyIExPQURJTkdfTUVTU0FHRSA9ICdMb2FkaW5n4oCmJztcbiAgdmFyIEZBSUxVUkVfTUVTU0FHRSA9IGZ1bmN0aW9uIChzdGF0dXMsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gJ+KcliBFcnJvciAnICsgc3RhdHVzICsgJyB3aGlsZSBmZXRjaGluZyBmaWxlOiAnICsgbWVzc2FnZTtcbiAgfTtcbiAgdmFyIEZBSUxVUkVfRU1QVFlfTUVTU0FHRSA9ICfinJYgRXJyb3I6IEZpbGUgZG9lcyBub3QgZXhpc3Qgb3IgaXMgZW1wdHknO1xuICB2YXIgRVhURU5TSU9OUyA9IHtcbiAgICAnanMnOiAnamF2YXNjcmlwdCcsXG4gICAgJ3B5JzogJ3B5dGhvbicsXG4gICAgJ3JiJzogJ3J1YnknLFxuICAgICdwczEnOiAncG93ZXJzaGVsbCcsXG4gICAgJ3BzbTEnOiAncG93ZXJzaGVsbCcsXG4gICAgJ3NoJzogJ2Jhc2gnLFxuICAgICdiYXQnOiAnYmF0Y2gnLFxuICAgICdoJzogJ2MnLFxuICAgICd0ZXgnOiAnbGF0ZXgnXG4gIH07XG4gIHZhciBTVEFUVVNfQVRUUiA9ICdkYXRhLXNyYy1zdGF0dXMnO1xuICB2YXIgU1RBVFVTX0xPQURJTkcgPSAnbG9hZGluZyc7XG4gIHZhciBTVEFUVVNfTE9BREVEID0gJ2xvYWRlZCc7XG4gIHZhciBTVEFUVVNfRkFJTEVEID0gJ2ZhaWxlZCc7XG4gIHZhciBTRUxFQ1RPUiA9ICdwcmVbZGF0YS1zcmNdOm5vdChbJyArIFNUQVRVU19BVFRSICsgJz1cIicgKyBTVEFUVVNfTE9BREVEICsgJ1wiXSknICsgJzpub3QoWycgKyBTVEFUVVNfQVRUUiArICc9XCInICsgU1RBVFVTX0xPQURJTkcgKyAnXCJdKSc7XG5cbiAgLyoqXG4gICAqIExvYWRzIHRoZSBnaXZlbiBmaWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIFRoZSBVUkwgb3IgcGF0aCBvZiB0aGUgc291cmNlIGZpbGUgdG8gbG9hZC5cbiAgICogQHBhcmFtIHsocmVzdWx0OiBzdHJpbmcpID0+IHZvaWR9IHN1Y2Nlc3NcbiAgICogQHBhcmFtIHsocmVhc29uOiBzdHJpbmcpID0+IHZvaWR9IGVycm9yXG4gICAqL1xuICBmdW5jdGlvbiBsb2FkRmlsZShzcmMsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vcGVuKCdHRVQnLCBzcmMsIHRydWUpO1xuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICBpZiAoeGhyLnN0YXR1cyA8IDQwMCAmJiB4aHIucmVzcG9uc2VUZXh0KSB7XG4gICAgICAgICAgc3VjY2Vzcyh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSA0MDApIHtcbiAgICAgICAgICAgIGVycm9yKEZBSUxVUkVfTUVTU0FHRSh4aHIuc3RhdHVzLCB4aHIuc3RhdHVzVGV4dCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcihGQUlMVVJFX0VNUFRZX01FU1NBR0UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgeGhyLnNlbmQobnVsbCk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIHRoZSBnaXZlbiByYW5nZS5cbiAgICpcbiAgICogVGhpcyByZXR1cm5zIGEgcmFuZ2Ugd2l0aCBpbmNsdXNpdmUgZW5kcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSByYW5nZVxuICAgKiBAcmV0dXJucyB7W251bWJlciwgbnVtYmVyIHwgdW5kZWZpbmVkXSB8IHVuZGVmaW5lZH1cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlUmFuZ2UocmFuZ2UpIHtcbiAgICB2YXIgbSA9IC9eXFxzKihcXGQrKVxccyooPzooLClcXHMqKD86KFxcZCspXFxzKik/KT8kLy5leGVjKHJhbmdlIHx8ICcnKTtcbiAgICBpZiAobSkge1xuICAgICAgdmFyIHN0YXJ0ID0gTnVtYmVyKG1bMV0pO1xuICAgICAgdmFyIGNvbW1hID0gbVsyXTtcbiAgICAgIHZhciBlbmQgPSBtWzNdO1xuICAgICAgaWYgKCFjb21tYSkge1xuICAgICAgICByZXR1cm4gW3N0YXJ0LCBzdGFydF07XG4gICAgICB9XG4gICAgICBpZiAoIWVuZCkge1xuICAgICAgICByZXR1cm4gW3N0YXJ0LCB1bmRlZmluZWRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtzdGFydCwgTnVtYmVyKGVuZCldO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIFByaXNtLmhvb2tzLmFkZCgnYmVmb3JlLWhpZ2hsaWdodGFsbCcsIGZ1bmN0aW9uIChlbnYpIHtcbiAgICBlbnYuc2VsZWN0b3IgKz0gJywgJyArIFNFTEVDVE9SO1xuICB9KTtcbiAgUHJpc20uaG9va3MuYWRkKCdiZWZvcmUtc2FuaXR5LWNoZWNrJywgZnVuY3Rpb24gKGVudikge1xuICAgIHZhciBwcmUgPSAvKiogQHR5cGUge0hUTUxQcmVFbGVtZW50fSAqL2Vudi5lbGVtZW50O1xuICAgIGlmIChwcmUubWF0Y2hlcyhTRUxFQ1RPUikpIHtcbiAgICAgIGVudi5jb2RlID0gJyc7IC8vIGZhc3QtcGF0aCB0aGUgd2hvbGUgdGhpbmcgYW5kIGdvIHRvIGNvbXBsZXRlXG5cbiAgICAgIHByZS5zZXRBdHRyaWJ1dGUoU1RBVFVTX0FUVFIsIFNUQVRVU19MT0FESU5HKTsgLy8gbWFyayBhcyBsb2FkaW5nXG5cbiAgICAgIC8vIGFkZCBjb2RlIGVsZW1lbnQgd2l0aCBsb2FkaW5nIG1lc3NhZ2VcbiAgICAgIHZhciBjb2RlID0gcHJlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0NPREUnKSk7XG4gICAgICBjb2RlLnRleHRDb250ZW50ID0gTE9BRElOR19NRVNTQUdFO1xuICAgICAgdmFyIHNyYyA9IHByZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3JjJyk7XG4gICAgICB2YXIgbGFuZ3VhZ2UgPSBlbnYubGFuZ3VhZ2U7XG4gICAgICBpZiAobGFuZ3VhZ2UgPT09ICdub25lJykge1xuICAgICAgICAvLyB0aGUgbGFuZ3VhZ2UgbWlnaHQgYmUgJ25vbmUnIGJlY2F1c2UgdGhlcmUgaXMgbm8gbGFuZ3VhZ2Ugc2V0O1xuICAgICAgICAvLyBpbiB0aGlzIGNhc2UsIHdlIHdhbnQgdG8gdXNlIHRoZSBleHRlbnNpb24gYXMgdGhlIGxhbmd1YWdlXG4gICAgICAgIHZhciBleHRlbnNpb24gPSAoL1xcLihcXHcrKSQvLmV4ZWMoc3JjKSB8fCBbLCAnbm9uZSddKVsxXTtcbiAgICAgICAgbGFuZ3VhZ2UgPSBFWFRFTlNJT05TW2V4dGVuc2lvbl0gfHwgZXh0ZW5zaW9uO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgbGFuZ3VhZ2UgY2xhc3Nlc1xuICAgICAgUHJpc20udXRpbC5zZXRMYW5ndWFnZShjb2RlLCBsYW5ndWFnZSk7XG4gICAgICBQcmlzbS51dGlsLnNldExhbmd1YWdlKHByZSwgbGFuZ3VhZ2UpO1xuXG4gICAgICAvLyBwcmVsb2FkIHRoZSBsYW5ndWFnZVxuICAgICAgdmFyIGF1dG9sb2FkZXIgPSBQcmlzbS5wbHVnaW5zLmF1dG9sb2FkZXI7XG4gICAgICBpZiAoYXV0b2xvYWRlcikge1xuICAgICAgICBhdXRvbG9hZGVyLmxvYWRMYW5ndWFnZXMobGFuZ3VhZ2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBsb2FkIGZpbGVcbiAgICAgIGxvYWRGaWxlKHNyYywgZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgLy8gbWFyayBhcyBsb2FkZWRcbiAgICAgICAgcHJlLnNldEF0dHJpYnV0ZShTVEFUVVNfQVRUUiwgU1RBVFVTX0xPQURFRCk7XG5cbiAgICAgICAgLy8gaGFuZGxlIGRhdGEtcmFuZ2VcbiAgICAgICAgdmFyIHJhbmdlID0gcGFyc2VSYW5nZShwcmUuZ2V0QXR0cmlidXRlKCdkYXRhLXJhbmdlJykpO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KC9cXHJcXG4/fFxcbi9nKTtcblxuICAgICAgICAgIC8vIHRoZSByYW5nZSBpcyBvbmUtYmFzZWQgYW5kIGluY2x1c2l2ZSBvbiBib3RoIGVuZHNcbiAgICAgICAgICB2YXIgc3RhcnQgPSByYW5nZVswXTtcbiAgICAgICAgICB2YXIgZW5kID0gcmFuZ2VbMV0gPT0gbnVsbCA/IGxpbmVzLmxlbmd0aCA6IHJhbmdlWzFdO1xuICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzdGFydCAtIDEsIGxpbmVzLmxlbmd0aCkpO1xuICAgICAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgICAgICBlbmQgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbmQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihlbmQsIGxpbmVzLmxlbmd0aCkpO1xuICAgICAgICAgIHRleHQgPSBsaW5lcy5zbGljZShzdGFydCwgZW5kKS5qb2luKCdcXG4nKTtcblxuICAgICAgICAgIC8vIGFkZCBkYXRhLXN0YXJ0IGZvciBsaW5lIG51bWJlcnNcbiAgICAgICAgICBpZiAoIXByZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtc3RhcnQnKSkge1xuICAgICAgICAgICAgcHJlLnNldEF0dHJpYnV0ZSgnZGF0YS1zdGFydCcsIFN0cmluZyhzdGFydCArIDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoaWdobGlnaHQgY29kZVxuICAgICAgICBjb2RlLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgUHJpc20uaGlnaGxpZ2h0RWxlbWVudChjb2RlKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAvLyBtYXJrIGFzIGZhaWxlZFxuICAgICAgICBwcmUuc2V0QXR0cmlidXRlKFNUQVRVU19BVFRSLCBTVEFUVVNfRkFJTEVEKTtcbiAgICAgICAgY29kZS50ZXh0Q29udGVudCA9IGVycm9yO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgUHJpc20ucGx1Z2lucy5maWxlSGlnaGxpZ2h0ID0ge1xuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBGaWxlIEhpZ2hsaWdodCBwbHVnaW4gZm9yIGFsbCBtYXRjaGluZyBgcHJlYCBlbGVtZW50cyB1bmRlciB0aGUgZ2l2ZW4gY29udGFpbmVyLlxuICAgICAqXG4gICAgICogTm90ZTogRWxlbWVudHMgd2hpY2ggYXJlIGFscmVhZHkgbG9hZGVkIG9yIGN1cnJlbnRseSBsb2FkaW5nIHdpbGwgbm90IGJlIHRvdWNoZWQgYnkgdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhcmVudE5vZGV9IFtjb250YWluZXI9ZG9jdW1lbnRdXG4gICAgICovXG4gICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiBoaWdobGlnaHQoY29udGFpbmVyKSB7XG4gICAgICB2YXIgZWxlbWVudHMgPSAoY29udGFpbmVyIHx8IGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBlbGVtZW50OyBlbGVtZW50ID0gZWxlbWVudHNbaSsrXTspIHtcbiAgICAgICAgUHJpc20uaGlnaGxpZ2h0RWxlbWVudChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBsb2dnZWQgPSBmYWxzZTtcbiAgLyoqIEBkZXByZWNhdGVkIFVzZSBgUHJpc20ucGx1Z2lucy5maWxlSGlnaGxpZ2h0LmhpZ2hsaWdodGAgaW5zdGVhZC4gKi9cbiAgUHJpc20uZmlsZUhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWxvZ2dlZCkge1xuICAgICAgY29uc29sZS53YXJuKCdQcmlzbS5maWxlSGlnaGxpZ2h0IGlzIGRlcHJlY2F0ZWQuIFVzZSBgUHJpc20ucGx1Z2lucy5maWxlSGlnaGxpZ2h0LmhpZ2hsaWdodGAgaW5zdGVhZC4nKTtcbiAgICAgIGxvZ2dlZCA9IHRydWU7XG4gICAgfVxuICAgIFByaXNtLnBsdWdpbnMuZmlsZUhpZ2hsaWdodC5oaWdobGlnaHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn0pKCk7XG5QcmlzbS5sYW5ndWFnZXMuY2xpa2UgPSB7XG4gICdjb21tZW50JzogW3tcbiAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSlcXC9cXCpbXFxzXFxTXSo/KD86XFwqXFwvfCQpLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LCB7XG4gICAgcGF0dGVybjogLyhefFteXFxcXDpdKVxcL1xcLy4qLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9XSxcbiAgJ3N0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvKFtcIiddKSg/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfCg/IVxcMSlbXlxcXFxcXHJcXG5dKSpcXDEvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnY2xhc3MtbmFtZSc6IHtcbiAgICBwYXR0ZXJuOiAvKFxcYig/OmNsYXNzfGV4dGVuZHN8aW1wbGVtZW50c3xpbnN0YW5jZW9mfGludGVyZmFjZXxuZXd8dHJhaXQpXFxzK3xcXGJjYXRjaFxccytcXCgpW1xcdy5cXFxcXSsvaSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ3B1bmN0dWF0aW9uJzogL1suXFxcXF0vXG4gICAgfVxuICB9LFxuICAna2V5d29yZCc6IC9cXGIoPzpicmVha3xjYXRjaHxjb250aW51ZXxkb3xlbHNlfGZpbmFsbHl8Zm9yfGZ1bmN0aW9ufGlmfGlufGluc3RhbmNlb2Z8bmV3fG51bGx8cmV0dXJufHRocm93fHRyeXx3aGlsZSlcXGIvLFxuICAnYm9vbGVhbic6IC9cXGIoPzpmYWxzZXx0cnVlKVxcYi8sXG4gICdmdW5jdGlvbic6IC9cXGJcXHcrKD89XFwoKS8sXG4gICdudW1iZXInOiAvXFxiMHhbXFxkYS1mXStcXGJ8KD86XFxiXFxkKyg/OlxcLlxcZCopP3xcXEJcXC5cXGQrKSg/OmVbKy1dP1xcZCspPy9pLFxuICAnb3BlcmF0b3InOiAvWzw+XT0/fFshPV09Pz0/fC0tP3xcXCtcXCs/fCYmP3xcXHxcXHw/fFs/Ki9+XiVdLyxcbiAgJ3B1bmN0dWF0aW9uJzogL1t7fVtcXF07KCksLjpdL1xufTtcblByaXNtLmxhbmd1YWdlcy5jID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY2xpa2UnLCB7XG4gICdjb21tZW50Jzoge1xuICAgIHBhdHRlcm46IC9cXC9cXC8oPzpbXlxcclxcblxcXFxdfFxcXFwoPzpcXHJcXG4/fFxcbnwoPyFbXFxyXFxuXSkpKSp8XFwvXFwqW1xcc1xcU10qPyg/OlxcKlxcL3wkKS8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdzdHJpbmcnOiB7XG4gICAgLy8gaHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvYy9sYW5ndWFnZS9zdHJpbmdfbGl0ZXJhbFxuICAgIHBhdHRlcm46IC9cIig/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfFteXCJcXFxcXFxyXFxuXSkqXCIvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnY2xhc3MtbmFtZSc6IHtcbiAgICBwYXR0ZXJuOiAvKFxcYig/OmVudW18c3RydWN0KVxccysoPzpfX2F0dHJpYnV0ZV9fXFxzKlxcKFxcKFtcXHNcXFNdKj9cXClcXClcXHMqKT8pXFx3K3xcXGJbYS16XVxcdypfdFxcYi8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9LFxuICAna2V5d29yZCc6IC9cXGIoPzpfQWxpZ25hc3xfQWxpZ25vZnxfQXRvbWljfF9Cb29sfF9Db21wbGV4fF9HZW5lcmljfF9JbWFnaW5hcnl8X05vcmV0dXJufF9TdGF0aWNfYXNzZXJ0fF9UaHJlYWRfbG9jYWx8X19hdHRyaWJ1dGVfX3xhc218YXV0b3xicmVha3xjYXNlfGNoYXJ8Y29uc3R8Y29udGludWV8ZGVmYXVsdHxkb3xkb3VibGV8ZWxzZXxlbnVtfGV4dGVybnxmbG9hdHxmb3J8Z290b3xpZnxpbmxpbmV8aW50fGxvbmd8cmVnaXN0ZXJ8cmV0dXJufHNob3J0fHNpZ25lZHxzaXplb2Z8c3RhdGljfHN0cnVjdHxzd2l0Y2h8dHlwZWRlZnx0eXBlb2Z8dW5pb258dW5zaWduZWR8dm9pZHx2b2xhdGlsZXx3aGlsZSlcXGIvLFxuICAnZnVuY3Rpb24nOiAvXFxiW2Etel9dXFx3Kig/PVxccypcXCgpL2ksXG4gICdudW1iZXInOiAvKD86XFxiMHgoPzpbXFxkYS1mXSsoPzpcXC5bXFxkYS1mXSopP3xcXC5bXFxkYS1mXSspKD86cFsrLV0/XFxkKyk/fCg/OlxcYlxcZCsoPzpcXC5cXGQqKT98XFxCXFwuXFxkKykoPzplWystXT9cXGQrKT8pW2Z1bF17MCw0fS9pLFxuICAnb3BlcmF0b3InOiAvPj49P3w8PD0/fC0+fChbLSsmfDpdKVxcMXxbPzp+XXxbLSsqLyUmfF4hPTw+XT0/L1xufSk7XG5QcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjJywgJ3N0cmluZycsIHtcbiAgJ2NoYXInOiB7XG4gICAgLy8gaHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvYy9sYW5ndWFnZS9jaGFyYWN0ZXJfY29uc3RhbnRcbiAgICBwYXR0ZXJuOiAvJyg/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfFteJ1xcXFxcXHJcXG5dKXswLDMyfScvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9XG59KTtcblByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2MnLCAnc3RyaW5nJywge1xuICAnbWFjcm8nOiB7XG4gICAgLy8gYWxsb3cgZm9yIG11bHRpbGluZSBtYWNybyBkZWZpbml0aW9uc1xuICAgIC8vIHNwYWNlcyBhZnRlciB0aGUgIyBjaGFyYWN0ZXIgY29tcGlsZSBmaW5lIHdpdGggZ2NjXG4gICAgcGF0dGVybjogLyheW1xcdCBdKikjXFxzKlthLXpdKD86W15cXHJcXG5cXFxcL118XFwvKD8hXFwqKXxcXC9cXCooPzpbXipdfFxcKig/IVxcLykpKlxcKlxcL3xcXFxcKD86XFxyXFxufFtcXHNcXFNdKSkqL2ltLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGFsaWFzOiAncHJvcGVydHknLFxuICAgIGluc2lkZToge1xuICAgICAgJ3N0cmluZyc6IFt7XG4gICAgICAgIC8vIGhpZ2hsaWdodCB0aGUgcGF0aCBvZiB0aGUgaW5jbHVkZSBzdGF0ZW1lbnQgYXMgYSBzdHJpbmdcbiAgICAgICAgcGF0dGVybjogL14oI1xccyppbmNsdWRlXFxzKik8W14+XSs+LyxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgfSwgUHJpc20ubGFuZ3VhZ2VzLmNbJ3N0cmluZyddXSxcbiAgICAgICdjaGFyJzogUHJpc20ubGFuZ3VhZ2VzLmNbJ2NoYXInXSxcbiAgICAgICdjb21tZW50JzogUHJpc20ubGFuZ3VhZ2VzLmNbJ2NvbW1lbnQnXSxcbiAgICAgICdtYWNyby1uYW1lJzogW3tcbiAgICAgICAgcGF0dGVybjogLyheI1xccypkZWZpbmVcXHMrKVxcdytcXGIoPyFcXCgpL2ksXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcGF0dGVybjogLyheI1xccypkZWZpbmVcXHMrKVxcdytcXGIoPz1cXCgpL2ksXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgIGFsaWFzOiAnZnVuY3Rpb24nXG4gICAgICB9XSxcbiAgICAgIC8vIGhpZ2hsaWdodCBtYWNybyBkaXJlY3RpdmVzIGFzIGtleXdvcmRzXG4gICAgICAnZGlyZWN0aXZlJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXigjXFxzKilbYS16XSsvLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICBhbGlhczogJ2tleXdvcmQnXG4gICAgICB9LFxuICAgICAgJ2RpcmVjdGl2ZS1oYXNoJzogL14jLyxcbiAgICAgICdwdW5jdHVhdGlvbic6IC8jI3xcXFxcKD89W1xcclxcbl0pLyxcbiAgICAgICdleHByZXNzaW9uJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXFxTW1xcc1xcU10qLyxcbiAgICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuY1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5QcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjJywgJ2Z1bmN0aW9uJywge1xuICAvLyBoaWdobGlnaHQgcHJlZGVmaW5lZCBtYWNyb3MgYXMgY29uc3RhbnRzXG4gICdjb25zdGFudCc6IC9cXGIoPzpFT0Z8TlVMTHxTRUVLX0NVUnxTRUVLX0VORHxTRUVLX1NFVHxfX0RBVEVfX3xfX0ZJTEVfX3xfX0xJTkVfX3xfX1RJTUVTVEFNUF9ffF9fVElNRV9ffF9fZnVuY19ffHN0ZGVycnxzdGRpbnxzdGRvdXQpXFxiL1xufSk7XG5kZWxldGUgUHJpc20ubGFuZ3VhZ2VzLmNbJ2Jvb2xlYW4nXTtcbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgdmFyIGtleXdvcmQgPSAvXFxiKD86YWxpZ25hc3xhbGlnbm9mfGFzbXxhdXRvfGJvb2x8YnJlYWt8Y2FzZXxjYXRjaHxjaGFyfGNoYXIxNl90fGNoYXIzMl90fGNoYXI4X3R8Y2xhc3N8Y29fYXdhaXR8Y29fcmV0dXJufGNvX3lpZWxkfGNvbXBsfGNvbmNlcHR8Y29uc3R8Y29uc3RfY2FzdHxjb25zdGV2YWx8Y29uc3RleHByfGNvbnN0aW5pdHxjb250aW51ZXxkZWNsdHlwZXxkZWZhdWx0fGRlbGV0ZXxkb3xkb3VibGV8ZHluYW1pY19jYXN0fGVsc2V8ZW51bXxleHBsaWNpdHxleHBvcnR8ZXh0ZXJufGZpbmFsfGZsb2F0fGZvcnxmcmllbmR8Z290b3xpZnxpbXBvcnR8aW5saW5lfGludHxpbnQxNl90fGludDMyX3R8aW50NjRfdHxpbnQ4X3R8bG9uZ3xtb2R1bGV8bXV0YWJsZXxuYW1lc3BhY2V8bmV3fG5vZXhjZXB0fG51bGxwdHJ8b3BlcmF0b3J8b3ZlcnJpZGV8cHJpdmF0ZXxwcm90ZWN0ZWR8cHVibGljfHJlZ2lzdGVyfHJlaW50ZXJwcmV0X2Nhc3R8cmVxdWlyZXN8cmV0dXJufHNob3J0fHNpZ25lZHxzaXplb2Z8c3RhdGljfHN0YXRpY19hc3NlcnR8c3RhdGljX2Nhc3R8c3RydWN0fHN3aXRjaHx0ZW1wbGF0ZXx0aGlzfHRocmVhZF9sb2NhbHx0aHJvd3x0cnl8dHlwZWRlZnx0eXBlaWR8dHlwZW5hbWV8dWludDE2X3R8dWludDMyX3R8dWludDY0X3R8dWludDhfdHx1bmlvbnx1bnNpZ25lZHx1c2luZ3x2aXJ0dWFsfHZvaWR8dm9sYXRpbGV8d2NoYXJfdHx3aGlsZSlcXGIvO1xuICB2YXIgbW9kTmFtZSA9IC9cXGIoPyE8a2V5d29yZD4pXFx3Kyg/OlxccypcXC5cXHMqXFx3KykqXFxiLy5zb3VyY2UucmVwbGFjZSgvPGtleXdvcmQ+L2csIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ga2V5d29yZC5zb3VyY2U7XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuY3BwID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnYycsIHtcbiAgICAnY2xhc3MtbmFtZSc6IFt7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoLyhcXGIoPzpjbGFzc3xjb25jZXB0fGVudW18c3RydWN0fHR5cGVuYW1lKVxccyspKD8hPGtleXdvcmQ+KVxcdysvLnNvdXJjZS5yZXBsYWNlKC88a2V5d29yZD4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ga2V5d29yZC5zb3VyY2U7XG4gICAgICB9KSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAvLyBUaGlzIGlzIGludGVuZGVkIHRvIGNhcHR1cmUgdGhlIGNsYXNzIG5hbWUgb2YgbWV0aG9kIGltcGxlbWVudGF0aW9ucyBsaWtlOlxuICAgIC8vICAgdm9pZCBmb286OmJhcigpIGNvbnN0IHt9XG4gICAgLy8gSG93ZXZlciEgVGhlIGBmb29gIGluIHRoZSBhYm92ZSBleGFtcGxlIGNvdWxkIGFsc28gYmUgYSBuYW1lc3BhY2UsIHNvIHdlIG9ubHkgY2FwdHVyZSB0aGUgY2xhc3MgbmFtZSBpZlxuICAgIC8vIGl0IHN0YXJ0cyB3aXRoIGFuIHVwcGVyY2FzZSBsZXR0ZXIuIFRoaXMgYXBwcm94aW1hdGlvbiBzaG91bGQgZ2l2ZSBkZWNlbnQgcmVzdWx0cy5cbiAgICAvXFxiW0EtWl1cXHcqKD89XFxzKjo6XFxzKlxcdytcXHMqXFwoKS8sXG4gICAgLy8gVGhpcyB3aWxsIGNhcHR1cmUgdGhlIGNsYXNzIG5hbWUgYmVmb3JlIGRlc3RydWN0b3JzIGxpa2U6XG4gICAgLy8gICBGb286On5Gb28oKSB7fVxuICAgIC9cXGJbQS1aX11cXHcqKD89XFxzKjo6XFxzKn5cXHcrXFxzKlxcKCkvaSxcbiAgICAvLyBUaGlzIGFsc28gaW50ZW5kcyB0byBjYXB0dXJlIHRoZSBjbGFzcyBuYW1lIG9mIG1ldGhvZCBpbXBsZW1lbnRhdGlvbnMgYnV0IGhlcmUgdGhlIGNsYXNzIGhhcyB0ZW1wbGF0ZVxuICAgIC8vIHBhcmFtZXRlcnMsIHNvIGl0IGNhbid0IGJlIGEgbmFtZXNwYWNlICh1bnRpbCBDKysgYWRkcyBnZW5lcmljIG5hbWVzcGFjZXMpLlxuICAgIC9cXGJcXHcrKD89XFxzKjwoPzpbXjw+XXw8KD86W148Pl18PFtePD5dKj4pKj4pKj5cXHMqOjpcXHMqXFx3K1xccypcXCgpL10sXG4gICAgJ2tleXdvcmQnOiBrZXl3b3JkLFxuICAgICdudW1iZXInOiB7XG4gICAgICBwYXR0ZXJuOiAvKD86XFxiMGJbMDEnXSt8XFxiMHgoPzpbXFxkYS1mJ10rKD86XFwuW1xcZGEtZiddKik/fFxcLltcXGRhLWYnXSspKD86cFsrLV0/W1xcZCddKyk/fCg/OlxcYltcXGQnXSsoPzpcXC5bXFxkJ10qKT98XFxCXFwuW1xcZCddKykoPzplWystXT9bXFxkJ10rKT8pW2Z1bF17MCw0fS9pLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSxcbiAgICAnb3BlcmF0b3InOiAvPj49P3w8PD0/fC0+fC0tfFxcK1xcK3wmJnxcXHxcXHx8Wz86fl18PD0+fFstKyovJSZ8XiE9PD5dPT98XFxiKD86YW5kfGFuZF9lcXxiaXRhbmR8Yml0b3J8bm90fG5vdF9lcXxvcnxvcl9lcXx4b3J8eG9yX2VxKVxcYi8sXG4gICAgJ2Jvb2xlYW4nOiAvXFxiKD86ZmFsc2V8dHJ1ZSlcXGIvXG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjcHAnLCAnc3RyaW5nJywge1xuICAgICdtb2R1bGUnOiB7XG4gICAgICAvLyBodHRwczovL2VuLmNwcHJlZmVyZW5jZS5jb20vdy9jcHAvbGFuZ3VhZ2UvbW9kdWxlc1xuICAgICAgcGF0dGVybjogUmVnRXhwKC8oXFxiKD86aW1wb3J0fG1vZHVsZSlcXHMrKS8uc291cmNlICsgJyg/OicgK1xuICAgICAgLy8gaGVhZGVyLW5hbWVcbiAgICAgIC9cIig/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfFteXCJcXFxcXFxyXFxuXSkqXCJ8PFtePD5cXHJcXG5dKj4vLnNvdXJjZSArICd8JyArXG4gICAgICAvLyBtb2R1bGUgbmFtZSBvciBwYXJ0aXRpb24gb3IgYm90aFxuICAgICAgLzxtb2QtbmFtZT4oPzpcXHMqOlxccyo8bW9kLW5hbWU+KT98Olxccyo8bW9kLW5hbWU+Ly5zb3VyY2UucmVwbGFjZSgvPG1vZC1uYW1lPi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtb2ROYW1lO1xuICAgICAgfSkgKyAnKScpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnc3RyaW5nJzogL15bPFwiXVtcXHNcXFNdKy8sXG4gICAgICAgICdvcGVyYXRvcic6IC86LyxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcLi9cbiAgICAgIH1cbiAgICB9LFxuICAgICdyYXctc3RyaW5nJzoge1xuICAgICAgcGF0dGVybjogL1JcIihbXigpXFxcXCBdezAsMTZ9KVxcKFtcXHNcXFNdKj9cXClcXDFcIi8sXG4gICAgICBhbGlhczogJ3N0cmluZycsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjcHAnLCAna2V5d29yZCcsIHtcbiAgICAnZ2VuZXJpYy1mdW5jdGlvbic6IHtcbiAgICAgIHBhdHRlcm46IC9cXGIoPyFvcGVyYXRvclxcYilbYS16X11cXHcqXFxzKjwoPzpbXjw+XXw8W148Pl0qPikqPig/PVxccypcXCgpL2ksXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2Z1bmN0aW9uJzogL15cXHcrLyxcbiAgICAgICAgJ2dlbmVyaWMnOiB7XG4gICAgICAgICAgcGF0dGVybjogLzxbXFxzXFxTXSsvLFxuICAgICAgICAgIGFsaWFzOiAnY2xhc3MtbmFtZScsXG4gICAgICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuY3BwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjcHAnLCAnb3BlcmF0b3InLCB7XG4gICAgJ2RvdWJsZS1jb2xvbic6IHtcbiAgICAgIHBhdHRlcm46IC86Oi8sXG4gICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgIH1cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2NwcCcsICdjbGFzcy1uYW1lJywge1xuICAgIC8vIHRoZSBiYXNlIGNsYXVzZSBpcyBhbiBvcHRpb25hbCBsaXN0IG9mIHBhcmVudCBjbGFzc2VzXG4gICAgLy8gaHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2xhbmd1YWdlL2NsYXNzXG4gICAgJ2Jhc2UtY2xhdXNlJzoge1xuICAgICAgcGF0dGVybjogLyhcXGIoPzpjbGFzc3xzdHJ1Y3QpXFxzK1xcdytcXHMqOlxccyopW147e31cIidcXHNdKyg/OlxccytbXjt7fVwiJ1xcc10rKSooPz1cXHMqWzt7XSkvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY3BwJywge30pXG4gICAgfVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnaW5zaWRlJywgJ2RvdWJsZS1jb2xvbicsIHtcbiAgICAvLyBBbGwgdW50b2tlbml6ZWQgd29yZHMgdGhhdCBhcmUgbm90IG5hbWVzcGFjZXMgc2hvdWxkIGJlIGNsYXNzIG5hbWVzXG4gICAgJ2NsYXNzLW5hbWUnOiAvXFxiW2Etel9dXFx3KlxcYig/IVxccyo6OikvaVxuICB9LCBQcmlzbS5sYW5ndWFnZXMuY3BwWydiYXNlLWNsYXVzZSddKTtcbn0pKFByaXNtKTtcblByaXNtLmxhbmd1YWdlcy5hcmR1aW5vID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY3BwJywge1xuICAna2V5d29yZCc6IC9cXGIoPzpTdHJpbmd8YXJyYXl8Ym9vbHxib29sZWFufGJyZWFrfGJ5dGV8Y2FzZXxjYXRjaHxjb250aW51ZXxkZWZhdWx0fGRvfGRvdWJsZXxlbHNlfGZpbmFsbHl8Zm9yfGZ1bmN0aW9ufGdvdG98aWZ8aW58aW5zdGFuY2VvZnxpbnR8aW50ZWdlcnxsb25nfGxvb3B8bmV3fG51bGx8cmV0dXJufHNldHVwfHN0cmluZ3xzd2l0Y2h8dGhyb3d8dHJ5fHZvaWR8d2hpbGV8d29yZClcXGIvLFxuICAnY29uc3RhbnQnOiAvXFxiKD86QU5BTE9HX01FU1NBR0V8REVGQVVMVHxESUdJVEFMX01FU1NBR0V8RVhURVJOQUx8RklSTUFUQV9TVFJJTkd8SElHSHxJTlBVVHxJTlBVVF9QVUxMVVB8SU5URVJOQUx8SU5URVJOQUwxVjF8SU5URVJOQUwyVjU2fExFRF9CVUlMVElOfExPV3xPVVRQVVR8UkVQT1JUX0FOQUxPR3xSRVBPUlRfRElHSVRBTHxTRVRfUElOX01PREV8U1lTRVhfU1RBUlR8U1lTVEVNX1JFU0VUKVxcYi8sXG4gICdidWlsdGluJzogL1xcYig/OkF1ZGlvfEJTU0lEfEJyaWRnZXxDbGllbnR8Q29uc29sZXxFRVBST018RXNwbG9yYXxFc3Bsb3JhVEZUfEV0aGVybmV0fEV0aGVybmV0Q2xpZW50fEV0aGVybmV0U2VydmVyfEV0aGVybmV0VURQfEZpbGV8RmlsZUlPfEZpbGVTeXN0ZW18RmlybWF0YXxHUFJTfEdTTXxHU01CYW5kfEdTTUNsaWVudHxHU01Nb2RlbXxHU01QSU58R1NNU2Nhbm5lcnxHU01TZXJ2ZXJ8R1NNVm9pY2VDYWxsfEdTTV9TTVN8SHR0cENsaWVudHxJUEFkZHJlc3N8SVJyZWFkfEtleWJvYXJkfEtleWJvYXJkQ29udHJvbGxlcnxMaXF1aWRDcnlzdGFsfExpcXVpZENyeXN0YWxfSTJDfE1haWxib3h8TW91c2V8TW91c2VDb250cm9sbGVyfFBJbWFnZXxQcm9jZXNzfFJTU0l8Um9ib3RDb250cm9sfFJvYm90TW90b3J8U0R8U1BJfFNTSUR8U2NoZWR1bGVyfFNlcmlhbHxTZXJ2ZXJ8U2Vydm98U29mdHdhcmVTZXJpYWx8U3RlcHBlcnxTdHJlYW18VEZUfFRhc2t8VVNCSG9zdHxXaUZpfFdpRmlDbGllbnR8V2lGaVNlcnZlcnxXaUZpVURQfFdpcmV8WXVuQ2xpZW50fFl1blNlcnZlcnxhYnN8YWRkUGFyYW1ldGVyfGFuYWxvZ1JlYWR8YW5hbG9nUmVhZFJlc29sdXRpb258YW5hbG9nUmVmZXJlbmNlfGFuYWxvZ1dyaXRlfGFuYWxvZ1dyaXRlUmVzb2x1dGlvbnxhbnN3ZXJDYWxsfGF0dGFjaHxhdHRhY2hHUFJTfGF0dGFjaEludGVycnVwdHxhdHRhY2hlZHxhdXRvc2Nyb2xsfGF2YWlsYWJsZXxiYWNrZ3JvdW5kfGJlZXB8YmVnaW58YmVnaW5QYWNrZXR8YmVnaW5TRHxiZWdpblNNU3xiZWdpblNwZWFrZXJ8YmVnaW5URlR8YmVnaW5UcmFuc21pc3Npb258YmVnaW5Xcml0ZXxiaXR8Yml0Q2xlYXJ8Yml0UmVhZHxiaXRTZXR8Yml0V3JpdGV8Ymxpbmt8YmxpbmtWZXJzaW9ufGJ1ZmZlcnxjaGFuZ2VQSU58Y2hlY2tQSU58Y2hlY2tQVUt8Y2hlY2tSZWd8Y2lyY2xlfGNpdHlOYW1lUmVhZHxjaXR5TmFtZVdyaXRlfGNsZWFyfGNsZWFyU2NyZWVufGNsaWNrfGNsb3NlfGNvbXBhc3NSZWFkfGNvbmZpZ3xjb25uZWN0fGNvbm5lY3RlZHxjb25zdHJhaW58Y29zfGNvdW50cnlOYW1lUmVhZHxjb3VudHJ5TmFtZVdyaXRlfGNyZWF0ZUNoYXJ8Y3Vyc29yfGRlYnVnUHJpbnR8ZGVsYXl8ZGVsYXlNaWNyb3NlY29uZHN8ZGV0YWNofGRldGFjaEludGVycnVwdHxkaWdpdGFsUmVhZHxkaWdpdGFsV3JpdGV8ZGlzY29ubmVjdHxkaXNwbGF5fGRpc3BsYXlMb2dvc3xkcmF3Qk1QfGRyYXdDb21wYXNzfGVuY3J5cHRpb25UeXBlfGVuZHxlbmRQYWNrZXR8ZW5kU01TfGVuZFRyYW5zbWlzc2lvbnxlbmRXcml0ZXxleGlzdHN8ZXhpdFZhbHVlfGZpbGx8ZmluZHxmaW5kVW50aWx8Zmx1c2h8Z2F0ZXdheUlQfGdldHxnZXRBc3luY2hyb25vdXNseXxnZXRCYW5kfGdldEJ1dHRvbnxnZXRDdXJyZW50Q2FycmllcnxnZXRJTUVJfGdldEtleXxnZXRNb2RpZmllcnN8Z2V0T2VtS2V5fGdldFBJTlVzZWR8Z2V0UmVzdWx0fGdldFNpZ25hbFN0cmVuZ3RofGdldFNvY2tldHxnZXRWb2ljZUNhbGxTdGF0dXN8Z2V0WENoYW5nZXxnZXRZQ2hhbmdlfGhhbmdDYWxsfGhlaWdodHxoaWdoQnl0ZXxob21lfGltYWdlfGludGVycnVwdHN8aXNBY3Rpb25Eb25lfGlzRGlyZWN0b3J5fGlzTGlzdGVuaW5nfGlzUElOfGlzUHJlc3NlZHxpc1ZhbGlkfGtleVByZXNzZWR8a2V5UmVsZWFzZWR8a2V5Ym9hcmRSZWFkfGtub2JSZWFkfGxlZnRUb1JpZ2h0fGxpbmV8bGluZUZvbGxvd0NvbmZpZ3xsaXN0ZW58bGlzdGVuT25Mb2NhbGhvc3R8bG9hZEltYWdlfGxvY2FsSVB8bG93Qnl0ZXxtYWNBZGRyZXNzfG1haW50YWlufG1hcHxtYXh8bWVzc2FnZUF2YWlsYWJsZXxtaWNyb3N8bWlsbGlzfG1pbnxta2Rpcnxtb3RvcnNTdG9wfG1vdG9yc1dyaXRlfG1vdXNlRHJhZ2dlZHxtb3VzZU1vdmVkfG1vdXNlUHJlc3NlZHxtb3VzZVJlbGVhc2VkfG1vdmV8bm9BdXRvc2Nyb2xsfG5vQmxpbmt8bm9CdWZmZXJ8bm9DdXJzb3J8bm9EaXNwbGF5fG5vRmlsbHxub0ludGVycnVwdHN8bm9MaXN0ZW5PbkxvY2FsaG9zdHxub1N0cm9rZXxub1RvbmV8b25SZWNlaXZlfG9uUmVxdWVzdHxvcGVufG9wZW5OZXh0RmlsZXxvdmVyZmxvd3xwYXJzZUNvbW1hbmR8cGFyc2VGbG9hdHxwYXJzZUludHxwYXJzZVBhY2tldHxwYXVzZU1vZGV8cGVla3xwaW5Nb2RlfHBsYXlGaWxlfHBsYXlNZWxvZHl8cG9pbnR8cG9pbnRUb3xwb3NpdGlvbnxwb3d8cHJlcGFyZXxwcmVzc3xwcmludHxwcmludEZpcm13YXJlVmVyc2lvbnxwcmludFZlcnNpb258cHJpbnRsbnxwcm9jZXNzfHByb2Nlc3NJbnB1dHxwdWxzZUlufHB1dHxyYW5kb218cmFuZG9tU2VlZHxyZWFkfHJlYWRBY2NlbGVyb21ldGVyfHJlYWRCbHVlfHJlYWRCdXR0b258cmVhZEJ5dGVzfHJlYWRCeXRlc1VudGlsfHJlYWRHcmVlbnxyZWFkSm95c3RpY2tCdXR0b258cmVhZEpveXN0aWNrU3dpdGNofHJlYWRKb3lzdGlja1h8cmVhZEpveXN0aWNrWXxyZWFkTGlnaHRTZW5zb3J8cmVhZE1lc3NhZ2V8cmVhZE1pY3JvcGhvbmV8cmVhZE5ldHdvcmtzfHJlYWRSZWR8cmVhZFNsaWRlcnxyZWFkU3RyaW5nfHJlYWRTdHJpbmdVbnRpbHxyZWFkVGVtcGVyYXR1cmV8cmVhZHl8cmVjdHxyZWxlYXNlfHJlbGVhc2VBbGx8cmVtb3RlSVB8cmVtb3RlTnVtYmVyfHJlbW90ZVBvcnR8cmVtb3ZlfHJlcXVlc3RGcm9tfHJldHJpZXZlQ2FsbGluZ051bWJlcnxyZXdpbmREaXJlY3Rvcnl8cmlnaHRUb0xlZnR8cm1kaXJ8cm9ib3ROYW1lUmVhZHxyb2JvdE5hbWVXcml0ZXxydW58cnVuQXN5bmNocm9ub3VzbHl8cnVuU2hlbGxDb21tYW5kfHJ1blNoZWxsQ29tbWFuZEFzeW5jaHJvbm91c2x5fHJ1bm5pbmd8c2Nhbk5ldHdvcmtzfHNjcm9sbERpc3BsYXlMZWZ0fHNjcm9sbERpc3BsYXlSaWdodHxzZWVrfHNlbmRBbmFsb2d8c2VuZERpZ2l0YWxQb3J0UGFpcnxzZW5kRGlnaXRhbFBvcnRzfHNlbmRTdHJpbmd8c2VuZFN5c2V4fHNlcmlhbEV2ZW50fHNldEJhbmR8c2V0Qml0T3JkZXJ8c2V0Q2xvY2tEaXZpZGVyfHNldEN1cnNvcnxzZXRETlN8c2V0RGF0YU1vZGV8c2V0RmlybXdhcmVWZXJzaW9ufHNldE1vZGV8c2V0UElOVXNlZHxzZXRTcGVlZHxzZXRUZXh0U2l6ZXxzZXRUaW1lb3V0fHNoaWZ0SW58c2hpZnRPdXR8c2h1dGRvd258c2lufHNpemV8c3FydHxzdGFydExvb3B8c3RlcHxzdG9wfHN0cm9rZXxzdWJuZXRNYXNrfHN3aXRjaFBJTnx0YW58dGVtcG9Xcml0ZXx0ZXh0fHRvbmV8dHJhbnNmZXJ8dHVuZVdyaXRlfHR1cm58dXBkYXRlSVJ8dXNlck5hbWVSZWFkfHVzZXJOYW1lV3JpdGV8dm9pY2VDYWxsfHdhaXRDb250aW51ZXx3aWR0aHx3cml0ZXx3cml0ZUJsdWV8d3JpdGVHcmVlbnx3cml0ZUpTT058d3JpdGVNZXNzYWdlfHdyaXRlTWljcm9zZWNvbmRzfHdyaXRlUkdCfHdyaXRlUmVkfHlpZWxkKVxcYi9cbn0pO1xuUHJpc20ubGFuZ3VhZ2VzLmlubyA9IFByaXNtLmxhbmd1YWdlcy5hcmR1aW5vO1xuKGZ1bmN0aW9uIChQcmlzbSkge1xuICAvLyAkIHNldCB8IGdyZXAgJ15bQS1aXVteWzpzcGFjZTpdXSo9JyB8IGN1dCAtZD0gLWYxIHwgdHIgJ1xcbicgJ3wnXG4gIC8vICsgTENfQUxMLCBSQU5ET00sIFJFUExZLCBTRUNPTkRTLlxuICAvLyArIG1ha2Ugc3VyZSBQUzEuLjQgYXJlIGhlcmUgYXMgdGhleSBhcmUgbm90IGFsd2F5cyBzZXQsXG4gIC8vIC0gc29tZSB1c2VsZXNzIHRoaW5ncy5cbiAgdmFyIGVudlZhcnMgPSAnXFxcXGIoPzpCQVNIfEJBU0hPUFRTfEJBU0hfQUxJQVNFU3xCQVNIX0FSR0N8QkFTSF9BUkdWfEJBU0hfQ01EU3xCQVNIX0NPTVBMRVRJT05fQ09NUEFUX0RJUnxCQVNIX0xJTkVOT3xCQVNIX1JFTUFUQ0h8QkFTSF9TT1VSQ0V8QkFTSF9WRVJTSU5GT3xCQVNIX1ZFUlNJT058Q09MT1JURVJNfENPTFVNTlN8Q09NUF9XT1JEQlJFQUtTfERCVVNfU0VTU0lPTl9CVVNfQUREUkVTU3xERUZBVUxUU19QQVRIfERFU0tUT1BfU0VTU0lPTnxESVJTVEFDS3xESVNQTEFZfEVVSUR8R0RNU0VTU0lPTnxHRE1fTEFOR3xHTk9NRV9LRVlSSU5HX0NPTlRST0x8R05PTUVfS0VZUklOR19QSUR8R1BHX0FHRU5UX0lORk98R1JPVVBTfEhJU1RDT05UUk9MfEhJU1RGSUxFfEhJU1RGSUxFU0laRXxISVNUU0laRXxIT01FfEhPU1ROQU1FfEhPU1RUWVBFfElGU3xJTlNUQU5DRXxKT0J8TEFOR3xMQU5HVUFHRXxMQ19BRERSRVNTfExDX0FMTHxMQ19JREVOVElGSUNBVElPTnxMQ19NRUFTVVJFTUVOVHxMQ19NT05FVEFSWXxMQ19OQU1FfExDX05VTUVSSUN8TENfUEFQRVJ8TENfVEVMRVBIT05FfExDX1RJTUV8TEVTU0NMT1NFfExFU1NPUEVOfExJTkVTfExPR05BTUV8TFNfQ09MT1JTfE1BQ0hUWVBFfE1BSUxDSEVDS3xNQU5EQVRPUllfUEFUSHxOT19BVF9CUklER0V8T0xEUFdEfE9QVEVSUnxPUFRJTkR8T1JCSVRfU09DS0VURElSfE9TVFlQRXxQQVBFUlNJWkV8UEFUSHxQSVBFU1RBVFVTfFBQSUR8UFMxfFBTMnxQUzN8UFM0fFBXRHxSQU5ET018UkVQTFl8U0VDT05EU3xTRUxJTlVYX0lOSVR8U0VTU0lPTnxTRVNTSU9OVFlQRXxTRVNTSU9OX01BTkFHRVJ8U0hFTEx8U0hFTExPUFRTfFNITFZMfFNTSF9BVVRIX1NPQ0t8VEVSTXxVSUR8VVBTVEFSVF9FVkVOVFN8VVBTVEFSVF9JTlNUQU5DRXxVUFNUQVJUX0pPQnxVUFNUQVJUX1NFU1NJT058VVNFUnxXSU5ET1dJRHxYQVVUSE9SSVRZfFhER19DT05GSUdfRElSU3xYREdfQ1VSUkVOVF9ERVNLVE9QfFhER19EQVRBX0RJUlN8WERHX0dSRUVURVJfREFUQV9ESVJ8WERHX01FTlVfUFJFRklYfFhER19SVU5USU1FX0RJUnxYREdfU0VBVHxYREdfU0VBVF9QQVRIfFhER19TRVNTSU9OX0RFU0tUT1B8WERHX1NFU1NJT05fSUR8WERHX1NFU1NJT05fUEFUSHxYREdfU0VTU0lPTl9UWVBFfFhER19WVE5SfFhNT0RJRklFUlMpXFxcXGInO1xuICB2YXIgY29tbWFuZEFmdGVySGVyZWRvYyA9IHtcbiAgICBwYXR0ZXJuOiAvKF4oW1wiJ10/KVxcdytcXDIpWyBcXHRdK1xcUy4qLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGFsaWFzOiAncHVuY3R1YXRpb24nLFxuICAgIC8vIHRoaXMgbG9va3MgcmVhc29uYWJseSB3ZWxsIGluIGFsbCB0aGVtZXNcbiAgICBpbnNpZGU6IG51bGwgLy8gc2VlIGJlbG93XG4gIH07XG5cbiAgdmFyIGluc2lkZVN0cmluZyA9IHtcbiAgICAnYmFzaCc6IGNvbW1hbmRBZnRlckhlcmVkb2MsXG4gICAgJ2Vudmlyb25tZW50Jzoge1xuICAgICAgcGF0dGVybjogUmVnRXhwKCdcXFxcJCcgKyBlbnZWYXJzKSxcbiAgICAgIGFsaWFzOiAnY29uc3RhbnQnXG4gICAgfSxcbiAgICAndmFyaWFibGUnOiBbXG4gICAgLy8gWzBdOiBBcml0aG1ldGljIEVudmlyb25tZW50XG4gICAge1xuICAgICAgcGF0dGVybjogL1xcJD9cXChcXChbXFxzXFxTXSs/XFwpXFwpLyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhICQgc2lnbiBhdCB0aGUgYmVnaW5uaW5nIGhpZ2hsaWdodCAkKCggYW5kICkpIGFzIHZhcmlhYmxlXG4gICAgICAgICd2YXJpYWJsZSc6IFt7XG4gICAgICAgICAgcGF0dGVybjogLyheXFwkXFwoXFwoW1xcc1xcU10rKVxcKVxcKS8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICB9LCAvXlxcJFxcKFxcKC9dLFxuICAgICAgICAnbnVtYmVyJzogL1xcYjB4W1xcZEEtRmEtZl0rXFxifCg/OlxcYlxcZCsoPzpcXC5cXGQqKT98XFxCXFwuXFxkKykoPzpbRWVdLT9cXGQrKT8vLFxuICAgICAgICAvLyBPcGVyYXRvcnMgYWNjb3JkaW5nIHRvIGh0dHBzOi8vd3d3LmdudS5vcmcvc29mdHdhcmUvYmFzaC9tYW51YWwvYmFzaHJlZi5odG1sI1NoZWxsLUFyaXRobWV0aWNcbiAgICAgICAgJ29wZXJhdG9yJzogLy0tfFxcK1xcK3xcXCpcXCo9P3w8PD0/fD4+PT98JiZ8XFx8XFx8fFs9IStcXC0qLyU8Pl4mfF09P3xbP346XS8sXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vICQgc2lnbiBhdCB0aGUgYmVnaW5uaW5nIGhpZ2hsaWdodCAoKCBhbmQgKSkgYXMgcHVuY3R1YXRpb25cbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcKFxcKD98XFwpXFwpP3wsfDsvXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBbMV06IENvbW1hbmQgU3Vic3RpdHV0aW9uXG4gICAge1xuICAgICAgcGF0dGVybjogL1xcJFxcKCg/OlxcKFteKV0rXFwpfFteKCldKStcXCl8YFteYF0rYC8sXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3ZhcmlhYmxlJzogL15cXCRcXCh8XmB8XFwpJHxgJC9cbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIFsyXTogQnJhY2UgZXhwYW5zaW9uXG4gICAge1xuICAgICAgcGF0dGVybjogL1xcJFxce1tefV0rXFx9LyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnb3BlcmF0b3InOiAvOlstPT8rXT98WyFcXC9dfCMjP3wlJT98XFxeXFxeP3wsLD8vLFxuICAgICAgICAncHVuY3R1YXRpb24nOiAvW1xcW1xcXV0vLFxuICAgICAgICAnZW52aXJvbm1lbnQnOiB7XG4gICAgICAgICAgcGF0dGVybjogUmVnRXhwKCcoXFxcXHspJyArIGVudlZhcnMpLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgYWxpYXM6ICdjb25zdGFudCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIC9cXCQoPzpcXHcrfFsjPyohQCRdKS9dLFxuICAgIC8vIEVzY2FwZSBzZXF1ZW5jZXMgZnJvbSBlY2hvIGFuZCBwcmludGYncyBtYW51YWxzLCBhbmQgZXNjYXBlZCBxdW90ZXMuXG4gICAgJ2VudGl0eSc6IC9cXFxcKD86W2FiY2VFZm5ydHZcXFxcXCJdfE8/WzAtN117MSwzfXxVWzAtOWEtZkEtRl17OH18dVswLTlhLWZBLUZdezR9fHhbMC05YS1mQS1GXXsxLDJ9KS9cbiAgfTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmJhc2ggPSB7XG4gICAgJ3NoZWJhbmcnOiB7XG4gICAgICBwYXR0ZXJuOiAvXiMhXFxzKlxcLy4qLyxcbiAgICAgIGFsaWFzOiAnaW1wb3J0YW50J1xuICAgIH0sXG4gICAgJ2NvbW1lbnQnOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W15cIntcXFxcJF0pIy4qLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICdmdW5jdGlvbi1uYW1lJzogW1xuICAgIC8vIGEpIGZ1bmN0aW9uIGZvbyB7XG4gICAgLy8gYikgZm9vKCkge1xuICAgIC8vIGMpIGZ1bmN0aW9uIGZvbygpIHtcbiAgICAvLyBidXQgbm90IOKAnGZvbyB74oCdXG4gICAge1xuICAgICAgLy8gYSkgYW5kIGMpXG4gICAgICBwYXR0ZXJuOiAvKFxcYmZ1bmN0aW9uXFxzKylbXFx3LV0rKD89KD86XFxzKlxcKD86XFxzKlxcKSk/XFxzKlxceykvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnZnVuY3Rpb24nXG4gICAgfSwge1xuICAgICAgLy8gYilcbiAgICAgIHBhdHRlcm46IC9cXGJbXFx3LV0rKD89XFxzKlxcKFxccypcXClcXHMqXFx7KS8sXG4gICAgICBhbGlhczogJ2Z1bmN0aW9uJ1xuICAgIH1dLFxuICAgIC8vIEhpZ2hsaWdodCB2YXJpYWJsZSBuYW1lcyBhcyB2YXJpYWJsZXMgaW4gZm9yIGFuZCBzZWxlY3QgYmVnaW5uaW5ncy5cbiAgICAnZm9yLW9yLXNlbGVjdCc6IHtcbiAgICAgIHBhdHRlcm46IC8oXFxiKD86Zm9yfHNlbGVjdClcXHMrKVxcdysoPz1cXHMraW5cXHMpLyxcbiAgICAgIGFsaWFzOiAndmFyaWFibGUnLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgLy8gSGlnaGxpZ2h0IHZhcmlhYmxlIG5hbWVzIGFzIHZhcmlhYmxlcyBpbiB0aGUgbGVmdC1oYW5kIHBhcnRcbiAgICAvLyBvZiBhc3NpZ25tZW50cyAo4oCcPeKAnSBhbmQg4oCcKz3igJ0pLlxuICAgICdhc3NpZ24tbGVmdCc6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXFxzO3wmXXxbPD5dXFwoKVxcdysoPzpcXC5cXHcrKSooPz1cXCs/PSkvLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdlbnZpcm9ubWVudCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiBSZWdFeHAoJyhefFtcXFxcczt8Jl18Wzw+XVxcXFwoKScgKyBlbnZWYXJzKSxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGFsaWFzOiAnY29uc3RhbnQnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhbGlhczogJ3ZhcmlhYmxlJyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgIC8vIEhpZ2hsaWdodCBwYXJhbWV0ZXIgbmFtZXMgYXMgdmFyaWFibGVzXG4gICAgJ3BhcmFtZXRlcic6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxcXHMpLXsxLDJ9KD86XFx3KzpbKy1dPyk/XFx3Kyg/OlxcLlxcdyspKig/PVs9XFxzXXwkKS8sXG4gICAgICBhbGlhczogJ3ZhcmlhYmxlJyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICdzdHJpbmcnOiBbXG4gICAgLy8gU3VwcG9ydCBmb3IgSGVyZS1kb2N1bWVudHMgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGVyZV9kb2N1bWVudFxuICAgIHtcbiAgICAgIHBhdHRlcm46IC8oKD86XnxbXjxdKTw8LT9cXHMqKShcXHcrKVxcc1tcXHNcXFNdKj8oPzpcXHI/XFxufFxccilcXDIvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZTogaW5zaWRlU3RyaW5nXG4gICAgfSxcbiAgICAvLyBIZXJlLWRvY3VtZW50IHdpdGggcXVvdGVzIGFyb3VuZCB0aGUgdGFnXG4gICAgLy8g4oaSIE5vIGV4cGFuc2lvbiAoc28gbm8g4oCcaW5zaWRl4oCdKS5cbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvKCg/Ol58W148XSk8PC0/XFxzKikoW1wiJ10pKFxcdyspXFwyXFxzW1xcc1xcU10qPyg/Olxccj9cXG58XFxyKVxcMy8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdiYXNoJzogY29tbWFuZEFmdGVySGVyZWRvY1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8g4oCcTm9ybWFs4oCdIHN0cmluZ1xuICAgIHtcbiAgICAgIC8vIGh0dHBzOi8vd3d3LmdudS5vcmcvc29mdHdhcmUvYmFzaC9tYW51YWwvaHRtbF9ub2RlL0RvdWJsZS1RdW90ZXMuaHRtbFxuICAgICAgcGF0dGVybjogLyhefFteXFxcXF0oPzpcXFxcXFxcXCkqKVwiKD86XFxcXFtcXHNcXFNdfFxcJFxcKFteKV0rXFwpfFxcJCg/IVxcKCl8YFteYF0rYHxbXlwiXFxcXGAkXSkqXCIvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZTogaW5zaWRlU3RyaW5nXG4gICAgfSwge1xuICAgICAgLy8gaHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9iYXNoL21hbnVhbC9odG1sX25vZGUvU2luZ2xlLVF1b3Rlcy5odG1sXG4gICAgICBwYXR0ZXJuOiAvKF58W14kXFxcXF0pJ1teJ10qJy8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSwge1xuICAgICAgLy8gaHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9iYXNoL21hbnVhbC9odG1sX25vZGUvQU5TSV8wMDJkQy1RdW90aW5nLmh0bWxcbiAgICAgIHBhdHRlcm46IC9cXCQnKD86W14nXFxcXF18XFxcXFtcXHNcXFNdKSonLyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnZW50aXR5JzogaW5zaWRlU3RyaW5nLmVudGl0eVxuICAgICAgfVxuICAgIH1dLFxuICAgICdlbnZpcm9ubWVudCc6IHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgnXFxcXCQ/JyArIGVudlZhcnMpLFxuICAgICAgYWxpYXM6ICdjb25zdGFudCdcbiAgICB9LFxuICAgICd2YXJpYWJsZSc6IGluc2lkZVN0cmluZy52YXJpYWJsZSxcbiAgICAnZnVuY3Rpb24nOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W1xcczt8Jl18Wzw+XVxcKCkoPzphZGR8YXByb3Bvc3xhcHR8YXB0LWNhY2hlfGFwdC1nZXR8YXB0aXR1ZGV8YXNwZWxsfGF1dG9teXNxbGJhY2t1cHxhd2t8YmFzZW5hbWV8YmFzaHxiY3xiY29uc29sZXxiZ3xiemlwMnxjYWx8Y2FyZ298Y2F0fGNmZGlza3xjaGdycHxjaGtjb25maWd8Y2htb2R8Y2hvd258Y2hyb290fGNrc3VtfGNsZWFyfGNtcHxjb2x1bW58Y29tbXxjb21wb3NlcnxjcHxjcm9ufGNyb250YWJ8Y3NwbGl0fGN1cmx8Y3V0fGRhdGV8ZGN8ZGR8ZGRyZXNjdWV8ZGVib290c3RyYXB8ZGZ8ZGlmZnxkaWZmM3xkaWd8ZGlyfGRpcmNvbG9yc3xkaXJuYW1lfGRpcnN8ZG1lc2d8ZG9ja2VyfGRvY2tlci1jb21wb3NlfGR1fGVncmVwfGVqZWN0fGVudnxldGh0b29sfGV4cGFuZHxleHBlY3R8ZXhwcnxmZGZvcm1hdHxmZGlza3xmZ3xmZ3JlcHxmaWxlfGZpbmR8Zm10fGZvbGR8Zm9ybWF0fGZyZWV8ZnNja3xmdHB8ZnVzZXJ8Z2F3a3xnaXR8Z3BhcnRlZHxncmVwfGdyb3VwYWRkfGdyb3VwZGVsfGdyb3VwbW9kfGdyb3Vwc3xncnViLW1rY29uZmlnfGd6aXB8aGFsdHxoZWFkfGhnfGhpc3Rvcnl8aG9zdHxob3N0bmFtZXxodG9wfGljb252fGlkfGlmY29uZmlnfGlmZG93bnxpZnVwfGltcG9ydHxpbnN0YWxsfGlwfGphdmF8am9ic3xqb2lufGtpbGx8a2lsbGFsbHxsZXNzfGxpbmt8bG58bG9jYXRlfGxvZ25hbWV8bG9ncm90YXRlfGxvb2t8bHBjfGxwcnxscHJpbnR8bHByaW50ZHxscHJpbnRxfGxwcm18bHN8bHNvZnxseW54fG1ha2V8bWFufG1jfG1kYWRtfG1rY29uZmlnfG1rZGlyfG1rZTJmc3xta2ZpZm98bWtmc3xta2lzb2ZzfG1rbm9kfG1rc3dhcHxtbXZ8bW9yZXxtb3N0fG1vdW50fG10b29sc3xtdHJ8bXV0dHxtdnxuYW5vfG5jfG5ldHN0YXR8bmljZXxubHxub2RlfG5vaHVwfG5vdGlmeS1zZW5kfG5wbXxuc2xvb2t1cHxvcHxvcGVufHBhcnRlZHxwYXNzd2R8cGFzdGV8cGF0aGNoa3xwaW5nfHBraWxsfHBucG18cG9kbWFufHBvZG1hbi1jb21wb3NlfHBvcGR8cHJ8cHJpbnRjYXB8cHJpbnRlbnZ8cHN8cHVzaGR8cHZ8cXVvdGF8cXVvdGFjaGVja3xxdW90YWN0bHxyYW18cmFyfHJjcHxyZWJvb3R8cmVtc3luY3xyZW5hbWV8cmVuaWNlfHJldnxybXxybWRpcnxycG18cnN5bmN8c2NwfHNjcmVlbnxzZGlmZnxzZWR8c2VuZG1haWx8c2VxfHNlcnZpY2V8c2Z0cHxzaHxzaGVsbGNoZWNrfHNodWZ8c2h1dGRvd258c2xlZXB8c2xvY2F0ZXxzb3J0fHNwbGl0fHNzaHxzdGF0fHN0cmFjZXxzdXxzdWRvfHN1bXxzdXNwZW5kfHN3YXBvbnxzeW5jfHN5c2N0bHx0YWN8dGFpbHx0YXJ8dGVlfHRpbWV8dGltZW91dHx0b3B8dG91Y2h8dHJ8dHJhY2Vyb3V0ZXx0c29ydHx0dHl8dW1vdW50fHVuYW1lfHVuZXhwYW5kfHVuaXF8dW5pdHN8dW5yYXJ8dW5zaGFyfHVuemlwfHVwZGF0ZS1ncnVifHVwdGltZXx1c2VyYWRkfHVzZXJkZWx8dXNlcm1vZHx1c2Vyc3x1dWRlY29kZXx1dWVuY29kZXx2fHZjcGtnfHZkaXJ8dml8dmltfHZpcnNofHZtc3RhdHx3YWl0fHdhdGNofHdjfHdnZXR8d2hlcmVpc3x3aGljaHx3aG98d2hvYW1pfHdyaXRlfHhhcmdzfHhkZy1vcGVufHlhcm58eWVzfHplbml0eXx6aXB8enNofHp5cHBlcikoPz0kfFspXFxzO3wmXSkvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgJ2tleXdvcmQnOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W1xcczt8Jl18Wzw+XVxcKCkoPzpjYXNlfGRvfGRvbmV8ZWxpZnxlbHNlfGVzYWN8Zml8Zm9yfGZ1bmN0aW9ufGlmfGlufHNlbGVjdHx0aGVufHVudGlsfHdoaWxlKSg/PSR8WylcXHM7fCZdKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAvLyBodHRwczovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2Jhc2gvbWFudWFsL2h0bWxfbm9kZS9TaGVsbC1CdWlsdGluLUNvbW1hbmRzLmh0bWxcbiAgICAnYnVpbHRpbic6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXFxzO3wmXXxbPD5dXFwoKSg/OlxcLnw6fGFsaWFzfGJpbmR8YnJlYWt8YnVpbHRpbnxjYWxsZXJ8Y2R8Y29tbWFuZHxjb250aW51ZXxkZWNsYXJlfGVjaG98ZW5hYmxlfGV2YWx8ZXhlY3xleGl0fGV4cG9ydHxnZXRvcHRzfGhhc2h8aGVscHxsZXR8bG9jYWx8bG9nb3V0fG1hcGZpbGV8cHJpbnRmfHB3ZHxyZWFkfHJlYWRhcnJheXxyZWFkb25seXxyZXR1cm58c2V0fHNoaWZ0fHNob3B0fHNvdXJjZXx0ZXN0fHRpbWVzfHRyYXB8dHlwZXx0eXBlc2V0fHVsaW1pdHx1bWFza3x1bmFsaWFzfHVuc2V0KSg/PSR8WylcXHM7fCZdKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgLy8gQWxpYXMgYWRkZWQgdG8gbWFrZSB0aG9zZSBlYXNpZXIgdG8gZGlzdGluZ3Vpc2ggZnJvbSBzdHJpbmdzLlxuICAgICAgYWxpYXM6ICdjbGFzcy1uYW1lJ1xuICAgIH0sXG4gICAgJ2Jvb2xlYW4nOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W1xcczt8Jl18Wzw+XVxcKCkoPzpmYWxzZXx0cnVlKSg/PSR8WylcXHM7fCZdKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAnZmlsZS1kZXNjcmlwdG9yJzoge1xuICAgICAgcGF0dGVybjogL1xcQiZcXGRcXGIvLFxuICAgICAgYWxpYXM6ICdpbXBvcnRhbnQnXG4gICAgfSxcbiAgICAnb3BlcmF0b3InOiB7XG4gICAgICAvLyBMb3RzIG9mIHJlZGlyZWN0aW9ucyBoZXJlLCBidXQgbm90IGp1c3QgdGhhdC5cbiAgICAgIHBhdHRlcm46IC9cXGQ/PD58PlxcfHxcXCs9fD1bPX5dP3whPT98PDxbPC1dP3xbJlxcZF0/Pj58XFxkWzw+XSY/fFs8Pl1bJj1dP3wmWz4mXT98XFx8WyZ8XT8vLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdmaWxlLWRlc2NyaXB0b3InOiB7XG4gICAgICAgICAgcGF0dGVybjogL15cXGQvLFxuICAgICAgICAgIGFsaWFzOiAnaW1wb3J0YW50J1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAncHVuY3R1YXRpb24nOiAvXFwkP1xcKFxcKD98XFwpXFwpP3xcXC5cXC58W3t9W1xcXTtcXFxcXS8sXG4gICAgJ251bWJlcic6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxcXHMpKD86WzEtOV1cXGQqfDApKD86Wy4sXVxcZCspP1xcYi8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfVxuICB9O1xuICBjb21tYW5kQWZ0ZXJIZXJlZG9jLmluc2lkZSA9IFByaXNtLmxhbmd1YWdlcy5iYXNoO1xuXG4gIC8qIFBhdHRlcm5zIGluIGNvbW1hbmQgc3Vic3RpdHV0aW9uLiAqL1xuICB2YXIgdG9CZUNvcGllZCA9IFsnY29tbWVudCcsICdmdW5jdGlvbi1uYW1lJywgJ2Zvci1vci1zZWxlY3QnLCAnYXNzaWduLWxlZnQnLCAncGFyYW1ldGVyJywgJ3N0cmluZycsICdlbnZpcm9ubWVudCcsICdmdW5jdGlvbicsICdrZXl3b3JkJywgJ2J1aWx0aW4nLCAnYm9vbGVhbicsICdmaWxlLWRlc2NyaXB0b3InLCAnb3BlcmF0b3InLCAncHVuY3R1YXRpb24nLCAnbnVtYmVyJ107XG4gIHZhciBpbnNpZGUgPSBpbnNpZGVTdHJpbmcudmFyaWFibGVbMV0uaW5zaWRlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRvQmVDb3BpZWQubGVuZ3RoOyBpKyspIHtcbiAgICBpbnNpZGVbdG9CZUNvcGllZFtpXV0gPSBQcmlzbS5sYW5ndWFnZXMuYmFzaFt0b0JlQ29waWVkW2ldXTtcbiAgfVxuICBQcmlzbS5sYW5ndWFnZXMuc2ggPSBQcmlzbS5sYW5ndWFnZXMuYmFzaDtcbiAgUHJpc20ubGFuZ3VhZ2VzLnNoZWxsID0gUHJpc20ubGFuZ3VhZ2VzLmJhc2g7XG59KShQcmlzbSk7XG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgcGxhY2Vob2xkZXJzIFwiPDxuPj5cIiBvZiBnaXZlbiBwYXR0ZXJuIHdpdGggdGhlIG4tdGggcmVwbGFjZW1lbnQgKHplcm8gYmFzZWQpLlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGlzIGEgc2ltcGxlIHRleHQgYmFzZWQgcmVwbGFjZW1lbnQuIEJlIGNhcmVmdWwgd2hlbiB1c2luZyBiYWNrcmVmZXJlbmNlcyFcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm4gdGhlIGdpdmVuIHBhdHRlcm4uXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IHJlcGxhY2VtZW50cyBhIGxpc3Qgb2YgcmVwbGFjZW1lbnQgd2hpY2ggY2FuIGJlIGluc2VydGVkIGludG8gdGhlIGdpdmVuIHBhdHRlcm4uXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBwYXR0ZXJuIHdpdGggYWxsIHBsYWNlaG9sZGVycyByZXBsYWNlZCB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmcgcmVwbGFjZW1lbnRzLlxuICAgKiBAZXhhbXBsZSByZXBsYWNlKC9hPDwwPj5hLy5zb3VyY2UsIFsvYisvLnNvdXJjZV0pID09PSAvYSg/OmIrKWEvLnNvdXJjZVxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZShwYXR0ZXJuLCByZXBsYWNlbWVudHMpIHtcbiAgICByZXR1cm4gcGF0dGVybi5yZXBsYWNlKC88PChcXGQrKT4+L2csIGZ1bmN0aW9uIChtLCBpbmRleCkge1xuICAgICAgcmV0dXJuICcoPzonICsgcmVwbGFjZW1lbnRzWytpbmRleF0gKyAnKSc7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IHJlcGxhY2VtZW50c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZsYWdzXVxuICAgKiBAcmV0dXJucyB7UmVnRXhwfVxuICAgKi9cbiAgZnVuY3Rpb24gcmUocGF0dGVybiwgcmVwbGFjZW1lbnRzLCBmbGFncykge1xuICAgIHJldHVybiBSZWdFeHAocmVwbGFjZShwYXR0ZXJuLCByZXBsYWNlbWVudHMpLCBmbGFncyB8fCAnJyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5lc3RlZCBwYXR0ZXJuIHdoZXJlIGFsbCBvY2N1cnJlbmNlcyBvZiB0aGUgc3RyaW5nIGA8PHNlbGY+PmAgYXJlIHJlcGxhY2VkIHdpdGggdGhlIHBhdHRlcm4gaXRzZWxmLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVyblxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVwdGhMb2cyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiBuZXN0ZWQocGF0dGVybiwgZGVwdGhMb2cyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXB0aExvZzI7IGkrKykge1xuICAgICAgcGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZSgvPDxzZWxmPj4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJyg/OicgKyBwYXR0ZXJuICsgJyknO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuLnJlcGxhY2UoLzw8c2VsZj4+L2csICdbXlxcXFxzXFxcXFNdJyk7XG4gIH1cblxuICAvLyBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy9kb3RuZXQvY3NoYXJwL2xhbmd1YWdlLXJlZmVyZW5jZS9rZXl3b3Jkcy9cbiAgdmFyIGtleXdvcmRLaW5kcyA9IHtcbiAgICAvLyBrZXl3b3JkcyB3aGljaCByZXByZXNlbnQgYSByZXR1cm4gb3IgdmFyaWFibGUgdHlwZVxuICAgIHR5cGU6ICdib29sIGJ5dGUgY2hhciBkZWNpbWFsIGRvdWJsZSBkeW5hbWljIGZsb2F0IGludCBsb25nIG9iamVjdCBzYnl0ZSBzaG9ydCBzdHJpbmcgdWludCB1bG9uZyB1c2hvcnQgdmFyIHZvaWQnLFxuICAgIC8vIGtleXdvcmRzIHdoaWNoIGFyZSB1c2VkIHRvIGRlY2xhcmUgYSB0eXBlXG4gICAgdHlwZURlY2xhcmF0aW9uOiAnY2xhc3MgZW51bSBpbnRlcmZhY2UgcmVjb3JkIHN0cnVjdCcsXG4gICAgLy8gY29udGV4dHVhbCBrZXl3b3Jkc1xuICAgIC8vIChcInZhclwiIGFuZCBcImR5bmFtaWNcIiBhcmUgbWlzc2luZyBiZWNhdXNlIHRoZXkgYXJlIHVzZWQgbGlrZSB0eXBlcylcbiAgICBjb250ZXh0dWFsOiAnYWRkIGFsaWFzIGFuZCBhc2NlbmRpbmcgYXN5bmMgYXdhaXQgYnkgZGVzY2VuZGluZyBmcm9tKD89XFxcXHMqKD86XFxcXHd8JCkpIGdldCBnbG9iYWwgZ3JvdXAgaW50byBpbml0KD89XFxcXHMqOykgam9pbiBsZXQgbmFtZW9mIG5vdCBub3RudWxsIG9uIG9yIG9yZGVyYnkgcGFydGlhbCByZW1vdmUgc2VsZWN0IHNldCB1bm1hbmFnZWQgdmFsdWUgd2hlbiB3aGVyZSB3aXRoKD89XFxcXHMqeyknLFxuICAgIC8vIGFsbCBvdGhlciBrZXl3b3Jkc1xuICAgIG90aGVyOiAnYWJzdHJhY3QgYXMgYmFzZSBicmVhayBjYXNlIGNhdGNoIGNoZWNrZWQgY29uc3QgY29udGludWUgZGVmYXVsdCBkZWxlZ2F0ZSBkbyBlbHNlIGV2ZW50IGV4cGxpY2l0IGV4dGVybiBmaW5hbGx5IGZpeGVkIGZvciBmb3JlYWNoIGdvdG8gaWYgaW1wbGljaXQgaW4gaW50ZXJuYWwgaXMgbG9jayBuYW1lc3BhY2UgbmV3IG51bGwgb3BlcmF0b3Igb3V0IG92ZXJyaWRlIHBhcmFtcyBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgcmVhZG9ubHkgcmVmIHJldHVybiBzZWFsZWQgc2l6ZW9mIHN0YWNrYWxsb2Mgc3RhdGljIHN3aXRjaCB0aGlzIHRocm93IHRyeSB0eXBlb2YgdW5jaGVja2VkIHVuc2FmZSB1c2luZyB2aXJ0dWFsIHZvbGF0aWxlIHdoaWxlIHlpZWxkJ1xuICB9O1xuXG4gIC8vIGtleXdvcmRzXG4gIGZ1bmN0aW9uIGtleXdvcmRzVG9QYXR0ZXJuKHdvcmRzKSB7XG4gICAgcmV0dXJuICdcXFxcYig/OicgKyB3b3Jkcy50cmltKCkucmVwbGFjZSgvIC9nLCAnfCcpICsgJylcXFxcYic7XG4gIH1cbiAgdmFyIHR5cGVEZWNsYXJhdGlvbktleXdvcmRzID0ga2V5d29yZHNUb1BhdHRlcm4oa2V5d29yZEtpbmRzLnR5cGVEZWNsYXJhdGlvbik7XG4gIHZhciBrZXl3b3JkcyA9IFJlZ0V4cChrZXl3b3Jkc1RvUGF0dGVybihrZXl3b3JkS2luZHMudHlwZSArICcgJyArIGtleXdvcmRLaW5kcy50eXBlRGVjbGFyYXRpb24gKyAnICcgKyBrZXl3b3JkS2luZHMuY29udGV4dHVhbCArICcgJyArIGtleXdvcmRLaW5kcy5vdGhlcikpO1xuICB2YXIgbm9uVHlwZUtleXdvcmRzID0ga2V5d29yZHNUb1BhdHRlcm4oa2V5d29yZEtpbmRzLnR5cGVEZWNsYXJhdGlvbiArICcgJyArIGtleXdvcmRLaW5kcy5jb250ZXh0dWFsICsgJyAnICsga2V5d29yZEtpbmRzLm90aGVyKTtcbiAgdmFyIG5vbkNvbnRleHR1YWxLZXl3b3JkcyA9IGtleXdvcmRzVG9QYXR0ZXJuKGtleXdvcmRLaW5kcy50eXBlICsgJyAnICsga2V5d29yZEtpbmRzLnR5cGVEZWNsYXJhdGlvbiArICcgJyArIGtleXdvcmRLaW5kcy5vdGhlcik7XG5cbiAgLy8gdHlwZXNcbiAgdmFyIGdlbmVyaWMgPSBuZXN0ZWQoLzwoPzpbXjw+Oz0rXFwtKi8lJnxeXXw8PHNlbGY+PikqPi8uc291cmNlLCAyKTsgLy8gdGhlIGlkZWEgYmVoaW5kIHRoZSBvdGhlciBmb3JiaWRkZW4gY2hhcmFjdGVycyBpcyB0byBwcmV2ZW50IGZhbHNlIHBvc2l0aXZlcy4gU2FtZSBmb3IgdHVwbGVFbGVtZW50LlxuICB2YXIgbmVzdGVkUm91bmQgPSBuZXN0ZWQoL1xcKCg/OlteKCldfDw8c2VsZj4+KSpcXCkvLnNvdXJjZSwgMik7XG4gIHZhciBuYW1lID0gL0A/XFxiW0EtWmEtel9dXFx3KlxcYi8uc291cmNlO1xuICB2YXIgZ2VuZXJpY05hbWUgPSByZXBsYWNlKC88PDA+Pig/Olxccyo8PDE+Pik/Ly5zb3VyY2UsIFtuYW1lLCBnZW5lcmljXSk7XG4gIHZhciBpZGVudGlmaWVyID0gcmVwbGFjZSgvKD8hPDwwPj4pPDwxPj4oPzpcXHMqXFwuXFxzKjw8MT4+KSovLnNvdXJjZSwgW25vblR5cGVLZXl3b3JkcywgZ2VuZXJpY05hbWVdKTtcbiAgdmFyIGFycmF5ID0gL1xcW1xccyooPzosXFxzKikqXFxdLy5zb3VyY2U7XG4gIHZhciB0eXBlRXhwcmVzc2lvbldpdGhvdXRUdXBsZSA9IHJlcGxhY2UoLzw8MD4+KD86XFxzKig/OlxcP1xccyopPzw8MT4+KSooPzpcXHMqXFw/KT8vLnNvdXJjZSwgW2lkZW50aWZpZXIsIGFycmF5XSk7XG4gIHZhciB0dXBsZUVsZW1lbnQgPSByZXBsYWNlKC9bXiwoKTw+W1xcXTs9K1xcLSovJSZ8Xl18PDwwPj58PDwxPj58PDwyPj4vLnNvdXJjZSwgW2dlbmVyaWMsIG5lc3RlZFJvdW5kLCBhcnJheV0pO1xuICB2YXIgdHVwbGUgPSByZXBsYWNlKC9cXCg8PDA+PisoPzosPDwwPj4rKStcXCkvLnNvdXJjZSwgW3R1cGxlRWxlbWVudF0pO1xuICB2YXIgdHlwZUV4cHJlc3Npb24gPSByZXBsYWNlKC8oPzo8PDA+Pnw8PDE+PikoPzpcXHMqKD86XFw/XFxzKik/PDwyPj4pKig/OlxccypcXD8pPy8uc291cmNlLCBbdHVwbGUsIGlkZW50aWZpZXIsIGFycmF5XSk7XG4gIHZhciB0eXBlSW5zaWRlID0ge1xuICAgICdrZXl3b3JkJzoga2V5d29yZHMsXG4gICAgJ3B1bmN0dWF0aW9uJzogL1s8PigpPywuOltcXF1dL1xuICB9O1xuXG4gIC8vIHN0cmluZ3MgJiBjaGFyYWN0ZXJzXG4gIC8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL2RvdG5ldC9jc2hhcnAvbGFuZ3VhZ2UtcmVmZXJlbmNlL2xhbmd1YWdlLXNwZWNpZmljYXRpb24vbGV4aWNhbC1zdHJ1Y3R1cmUjY2hhcmFjdGVyLWxpdGVyYWxzXG4gIC8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL2RvdG5ldC9jc2hhcnAvbGFuZ3VhZ2UtcmVmZXJlbmNlL2xhbmd1YWdlLXNwZWNpZmljYXRpb24vbGV4aWNhbC1zdHJ1Y3R1cmUjc3RyaW5nLWxpdGVyYWxzXG4gIHZhciBjaGFyYWN0ZXIgPSAvJyg/OlteXFxyXFxuJ1xcXFxdfFxcXFwufFxcXFxbVXV4XVtcXGRhLWZBLUZdezEsOH0pJy8uc291cmNlOyAvLyBzaW1wbGlmaWVkIHBhdHRlcm5cbiAgdmFyIHJlZ3VsYXJTdHJpbmcgPSAvXCIoPzpcXFxcLnxbXlxcXFxcIlxcclxcbl0pKlwiLy5zb3VyY2U7XG4gIHZhciB2ZXJiYXRpbVN0cmluZyA9IC9AXCIoPzpcIlwifFxcXFxbXFxzXFxTXXxbXlxcXFxcIl0pKlwiKD8hXCIpLy5zb3VyY2U7XG4gIFByaXNtLmxhbmd1YWdlcy5jc2hhcnAgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjbGlrZScsIHtcbiAgICAnc3RyaW5nJzogW3tcbiAgICAgIHBhdHRlcm46IHJlKC8oXnxbXiRcXFxcXSk8PDA+Pi8uc291cmNlLCBbdmVyYmF0aW1TdHJpbmddKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiByZSgvKF58W15AJFxcXFxdKTw8MD4+Ly5zb3VyY2UsIFtyZWd1bGFyU3RyaW5nXSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfV0sXG4gICAgJ2NsYXNzLW5hbWUnOiBbe1xuICAgICAgLy8gVXNpbmcgc3RhdGljXG4gICAgICAvLyB1c2luZyBzdGF0aWMgU3lzdGVtLk1hdGg7XG4gICAgICBwYXR0ZXJuOiByZSgvKFxcYnVzaW5nXFxzK3N0YXRpY1xccyspPDwwPj4oPz1cXHMqOykvLnNvdXJjZSwgW2lkZW50aWZpZXJdKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IHR5cGVJbnNpZGVcbiAgICB9LCB7XG4gICAgICAvLyBVc2luZyBhbGlhcyAodHlwZSlcbiAgICAgIC8vIHVzaW5nIFByb2plY3QgPSBQQy5NeUNvbXBhbnkuUHJvamVjdDtcbiAgICAgIHBhdHRlcm46IHJlKC8oXFxidXNpbmdcXHMrPDwwPj5cXHMqPVxccyopPDwxPj4oPz1cXHMqOykvLnNvdXJjZSwgW25hbWUsIHR5cGVFeHByZXNzaW9uXSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiB0eXBlSW5zaWRlXG4gICAgfSwge1xuICAgICAgLy8gVXNpbmcgYWxpYXMgKGFsaWFzKVxuICAgICAgLy8gdXNpbmcgUHJvamVjdCA9IFBDLk15Q29tcGFueS5Qcm9qZWN0O1xuICAgICAgcGF0dGVybjogcmUoLyhcXGJ1c2luZ1xccyspPDwwPj4oPz1cXHMqPSkvLnNvdXJjZSwgW25hbWVdKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LCB7XG4gICAgICAvLyBUeXBlIGRlY2xhcmF0aW9uc1xuICAgICAgLy8gY2xhc3MgRm9vPEEsIEI+XG4gICAgICAvLyBpbnRlcmZhY2UgRm9vPG91dCBBLCBCPlxuICAgICAgcGF0dGVybjogcmUoLyhcXGI8PDA+PlxccyspPDwxPj4vLnNvdXJjZSwgW3R5cGVEZWNsYXJhdGlvbktleXdvcmRzLCBnZW5lcmljTmFtZV0pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZTogdHlwZUluc2lkZVxuICAgIH0sIHtcbiAgICAgIC8vIFNpbmdsZSBjYXRjaCBleGNlcHRpb24gZGVjbGFyYXRpb25cbiAgICAgIC8vIGNhdGNoKEZvbylcbiAgICAgIC8vICh0aGluZ3MgbGlrZSBjYXRjaChGb28gZSkgaXMgY292ZXJlZCBieSB2YXJpYWJsZSBkZWNsYXJhdGlvbilcbiAgICAgIHBhdHRlcm46IHJlKC8oXFxiY2F0Y2hcXHMqXFwoXFxzKik8PDA+Pi8uc291cmNlLCBbaWRlbnRpZmllcl0pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZTogdHlwZUluc2lkZVxuICAgIH0sIHtcbiAgICAgIC8vIE5hbWUgb2YgdGhlIHR5cGUgcGFyYW1ldGVyIG9mIGdlbmVyaWMgY29uc3RyYWludHNcbiAgICAgIC8vIHdoZXJlIEZvbyA6IGNsYXNzXG4gICAgICBwYXR0ZXJuOiByZSgvKFxcYndoZXJlXFxzKyk8PDA+Pi8uc291cmNlLCBbbmFtZV0pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIC8vIENhc3RzIGFuZCBjaGVja3MgdmlhIGFzIGFuZCBpcy5cbiAgICAgIC8vIGFzIEZvbzxBPiwgaXMgQmFyPEI+XG4gICAgICAvLyAodGhpbmdzIGxpa2UgaWYoYSBpcyBGb28gYikgaXMgY292ZXJlZCBieSB2YXJpYWJsZSBkZWNsYXJhdGlvbilcbiAgICAgIHBhdHRlcm46IHJlKC8oXFxiKD86aXMoPzpcXHMrbm90KT98YXMpXFxzKyk8PDA+Pi8uc291cmNlLCBbdHlwZUV4cHJlc3Npb25XaXRob3V0VHVwbGVdKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IHR5cGVJbnNpZGVcbiAgICB9LCB7XG4gICAgICAvLyBWYXJpYWJsZSwgZmllbGQgYW5kIHBhcmFtZXRlciBkZWNsYXJhdGlvblxuICAgICAgLy8gKEZvbyBiYXIsIEJhciBiYXosIEZvb1ssLF0gYmF5LCBGb288QmFyLCBGb29CYXI8QmFyPj4gYmF4KVxuICAgICAgcGF0dGVybjogcmUoL1xcYjw8MD4+KD89XFxzKyg/ITw8MT4+fHdpdGhcXHMqXFx7KTw8Mj4+KD86XFxzKls9LDs6eylcXF1dfFxccysoPzppbnx3aGVuKVxcYikpLy5zb3VyY2UsIFt0eXBlRXhwcmVzc2lvbiwgbm9uQ29udGV4dHVhbEtleXdvcmRzLCBuYW1lXSksXG4gICAgICBpbnNpZGU6IHR5cGVJbnNpZGVcbiAgICB9XSxcbiAgICAna2V5d29yZCc6IGtleXdvcmRzLFxuICAgIC8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL2RvdG5ldC9jc2hhcnAvbGFuZ3VhZ2UtcmVmZXJlbmNlL2xhbmd1YWdlLXNwZWNpZmljYXRpb24vbGV4aWNhbC1zdHJ1Y3R1cmUjbGl0ZXJhbHNcbiAgICAnbnVtYmVyJzogLyg/OlxcYjAoPzp4W1xcZGEtZl9dKltcXGRhLWZdfGJbMDFfXSpbMDFdKXwoPzpcXEJcXC5cXGQrKD86XytcXGQrKSp8XFxiXFxkKyg/Ol8rXFxkKykqKD86XFwuXFxkKyg/Ol8rXFxkKykqKT8pKD86ZVstK10/XFxkKyg/Ol8rXFxkKykqKT8pKD86W2RmbG11XXxsdXx1bCk/XFxiL2ksXG4gICAgJ29wZXJhdG9yJzogLz4+PT98PDw9P3xbLT1dPnwoWy0rJnxdKVxcMXx+fFxcP1xcPz0/fFstKyovJSZ8XiE9PD5dPT8vLFxuICAgICdwdW5jdHVhdGlvbic6IC9cXD9cXC4/fDo6fFt7fVtcXF07KCksLjpdL1xuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnY3NoYXJwJywgJ251bWJlcicsIHtcbiAgICAncmFuZ2UnOiB7XG4gICAgICBwYXR0ZXJuOiAvXFwuXFwuLyxcbiAgICAgIGFsaWFzOiAnb3BlcmF0b3InXG4gICAgfVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnY3NoYXJwJywgJ3B1bmN0dWF0aW9uJywge1xuICAgICduYW1lZC1wYXJhbWV0ZXInOiB7XG4gICAgICBwYXR0ZXJuOiByZSgvKFsoLF1cXHMqKTw8MD4+KD89XFxzKjopLy5zb3VyY2UsIFtuYW1lXSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6ICdwdW5jdHVhdGlvbidcbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjc2hhcnAnLCAnY2xhc3MtbmFtZScsIHtcbiAgICAnbmFtZXNwYWNlJzoge1xuICAgICAgLy8gbmFtZXNwYWNlIEZvby5CYXIge31cbiAgICAgIC8vIHVzaW5nIEZvby5CYXI7XG4gICAgICBwYXR0ZXJuOiByZSgvKFxcYig/Om5hbWVzcGFjZXx1c2luZylcXHMrKTw8MD4+KD86XFxzKlxcLlxccyo8PDA+PikqKD89XFxzKls7e10pLy5zb3VyY2UsIFtuYW1lXSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9cXC4vXG4gICAgICB9XG4gICAgfSxcbiAgICAndHlwZS1leHByZXNzaW9uJzoge1xuICAgICAgLy8gZGVmYXVsdChGb28pLCB0eXBlb2YoRm9vPEJhcj4pLCBzaXplb2YoaW50KVxuICAgICAgcGF0dGVybjogcmUoLyhcXGIoPzpkZWZhdWx0fHNpemVvZnx0eXBlb2YpXFxzKlxcKFxccyooPyFcXHMpKSg/OlteKClcXHNdfFxccyg/IVxccyl8PDwwPj4pKig/PVxccypcXCkpLy5zb3VyY2UsIFtuZXN0ZWRSb3VuZF0pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnY2xhc3MtbmFtZScsXG4gICAgICBpbnNpZGU6IHR5cGVJbnNpZGVcbiAgICB9LFxuICAgICdyZXR1cm4tdHlwZSc6IHtcbiAgICAgIC8vIEZvbzxCYXI+IEZvckJhcigpOyBGb28gSUZvby5CYXIoKSA9PiAwXG4gICAgICAvLyBpbnQgdGhpc1tpbnQgaW5kZXhdID0+IDA7IFQgSVJlYWRPbmx5TGlzdDxUPi50aGlzW2ludCBpbmRleF0gPT4gdGhpc1tpbmRleF07XG4gICAgICAvLyBpbnQgRm9vID0+IDA7IGludCBGb28geyBnZXQ7IHNldCB9ID0gMDtcbiAgICAgIHBhdHRlcm46IHJlKC88PDA+Pig/PVxccysoPzo8PDE+PlxccyooPzo9PnxbKHtdfFxcLlxccyp0aGlzXFxzKlxcWyl8dGhpc1xccypcXFspKS8uc291cmNlLCBbdHlwZUV4cHJlc3Npb24sIGlkZW50aWZpZXJdKSxcbiAgICAgIGluc2lkZTogdHlwZUluc2lkZSxcbiAgICAgIGFsaWFzOiAnY2xhc3MtbmFtZSdcbiAgICB9LFxuICAgICdjb25zdHJ1Y3Rvci1pbnZvY2F0aW9uJzoge1xuICAgICAgLy8gbmV3IExpc3Q8Rm9vPEJhcltdPj4geyB9XG4gICAgICBwYXR0ZXJuOiByZSgvKFxcYm5ld1xccyspPDwwPj4oPz1cXHMqW1soe10pLy5zb3VyY2UsIFt0eXBlRXhwcmVzc2lvbl0pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZTogdHlwZUluc2lkZSxcbiAgICAgIGFsaWFzOiAnY2xhc3MtbmFtZSdcbiAgICB9LFxuICAgIC8qJ2V4cGxpY2l0LWltcGxlbWVudGF0aW9uJzoge1xuICAgIFx0Ly8gaW50IElGb288Rm9vPi5CYXIgPT4gMDsgdm9pZCBJRm9vPEZvbzxGb28+Pi5Gb288VD4oKTtcbiAgICBcdHBhdHRlcm46IHJlcGxhY2UoL1xcYjw8MD4+KD89XFwuPDwxPj4pLywgY2xhc3NOYW1lLCBtZXRob2RPclByb3BlcnR5RGVjbGFyYXRpb24pLFxuICAgIFx0aW5zaWRlOiBjbGFzc05hbWVJbnNpZGUsXG4gICAgXHRhbGlhczogJ2NsYXNzLW5hbWUnXG4gICAgfSwqL1xuICAgICdnZW5lcmljLW1ldGhvZCc6IHtcbiAgICAgIC8vIGZvbzxCYXI+KClcbiAgICAgIHBhdHRlcm46IHJlKC88PDA+Plxccyo8PDE+Pig/PVxccypcXCgpLy5zb3VyY2UsIFtuYW1lLCBnZW5lcmljXSksXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2Z1bmN0aW9uJzogcmUoL148PDA+Pi8uc291cmNlLCBbbmFtZV0pLFxuICAgICAgICAnZ2VuZXJpYyc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiBSZWdFeHAoZ2VuZXJpYyksXG4gICAgICAgICAgYWxpYXM6ICdjbGFzcy1uYW1lJyxcbiAgICAgICAgICBpbnNpZGU6IHR5cGVJbnNpZGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ3R5cGUtbGlzdCc6IHtcbiAgICAgIC8vIFRoZSBsaXN0IG9mIHR5cGVzIGluaGVyaXRlZCBvciBvZiBnZW5lcmljIGNvbnN0cmFpbnRzXG4gICAgICAvLyBjbGFzcyBGb288Rj4gOiBCYXIsIElMaXN0PEZvb0Jhcj5cbiAgICAgIC8vIHdoZXJlIEYgOiBCYXIsIElMaXN0PGludD5cbiAgICAgIHBhdHRlcm46IHJlKC9cXGIoKD86PDwwPj5cXHMrPDwxPj58cmVjb3JkXFxzKzw8MT4+XFxzKjw8NT4+fHdoZXJlXFxzKzw8Mj4+KVxccyo6XFxzKikoPzo8PDM+Pnw8PDQ+Pnw8PDE+Plxccyo8PDU+Pnw8PDY+PikoPzpcXHMqLFxccyooPzo8PDM+Pnw8PDQ+Pnw8PDY+PikpKig/PVxccyooPzp3aGVyZXxbeztdfD0+fCQpKS8uc291cmNlLCBbdHlwZURlY2xhcmF0aW9uS2V5d29yZHMsIGdlbmVyaWNOYW1lLCBuYW1lLCB0eXBlRXhwcmVzc2lvbiwga2V5d29yZHMuc291cmNlLCBuZXN0ZWRSb3VuZCwgL1xcYm5ld1xccypcXChcXHMqXFwpLy5zb3VyY2VdKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3JlY29yZC1hcmd1bWVudHMnOiB7XG4gICAgICAgICAgcGF0dGVybjogcmUoLyheKD8hbmV3XFxzKlxcKCk8PDA+PlxccyopPDwxPj4vLnNvdXJjZSwgW2dlbmVyaWNOYW1lLCBuZXN0ZWRSb3VuZF0pLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmNzaGFycFxuICAgICAgICB9LFxuICAgICAgICAna2V5d29yZCc6IGtleXdvcmRzLFxuICAgICAgICAnY2xhc3MtbmFtZSc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiBSZWdFeHAodHlwZUV4cHJlc3Npb24pLFxuICAgICAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgICAgICBpbnNpZGU6IHR5cGVJbnNpZGVcbiAgICAgICAgfSxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1ssKCldL1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3ByZXByb2Nlc3Nvcic6IHtcbiAgICAgIHBhdHRlcm46IC8oXltcXHQgXSopIy4qL20sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6ICdwcm9wZXJ0eScsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgLy8gaGlnaGxpZ2h0IHByZXByb2Nlc3NvciBkaXJlY3RpdmVzIGFzIGtleXdvcmRzXG4gICAgICAgICdkaXJlY3RpdmUnOiB7XG4gICAgICAgICAgcGF0dGVybjogLygjKVxcYig/OmRlZmluZXxlbGlmfGVsc2V8ZW5kaWZ8ZW5kcmVnaW9ufGVycm9yfGlmfGxpbmV8bnVsbGFibGV8cHJhZ21hfHJlZ2lvbnx1bmRlZnx3YXJuaW5nKVxcYi8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICBhbGlhczogJ2tleXdvcmQnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIGF0dHJpYnV0ZXNcbiAgdmFyIHJlZ3VsYXJTdHJpbmdPckNoYXJhY3RlciA9IHJlZ3VsYXJTdHJpbmcgKyAnfCcgKyBjaGFyYWN0ZXI7XG4gIHZhciByZWd1bGFyU3RyaW5nQ2hhcmFjdGVyT3JDb21tZW50ID0gcmVwbGFjZSgvXFwvKD8hWyovXSl8XFwvXFwvW15cXHJcXG5dKltcXHJcXG5dfFxcL1xcKig/OlteKl18XFwqKD8hXFwvKSkqXFwqXFwvfDw8MD4+Ly5zb3VyY2UsIFtyZWd1bGFyU3RyaW5nT3JDaGFyYWN0ZXJdKTtcbiAgdmFyIHJvdW5kRXhwcmVzc2lvbiA9IG5lc3RlZChyZXBsYWNlKC9bXlwiJy8oKV18PDwwPj58XFwoPDxzZWxmPj4qXFwpLy5zb3VyY2UsIFtyZWd1bGFyU3RyaW5nQ2hhcmFjdGVyT3JDb21tZW50XSksIDIpO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL2RvdG5ldC9jc2hhcnAvcHJvZ3JhbW1pbmctZ3VpZGUvY29uY2VwdHMvYXR0cmlidXRlcy8jYXR0cmlidXRlLXRhcmdldHNcbiAgdmFyIGF0dHJUYXJnZXQgPSAvXFxiKD86YXNzZW1ibHl8ZXZlbnR8ZmllbGR8bWV0aG9kfG1vZHVsZXxwYXJhbXxwcm9wZXJ0eXxyZXR1cm58dHlwZSlcXGIvLnNvdXJjZTtcbiAgdmFyIGF0dHIgPSByZXBsYWNlKC88PDA+Pig/OlxccypcXCg8PDE+PipcXCkpPy8uc291cmNlLCBbaWRlbnRpZmllciwgcm91bmRFeHByZXNzaW9uXSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2NzaGFycCcsICdjbGFzcy1uYW1lJywge1xuICAgICdhdHRyaWJ1dGUnOiB7XG4gICAgICAvLyBBdHRyaWJ1dGVzXG4gICAgICAvLyBbRm9vXSwgW0ZvbygxKSwgQmFyKDIsIFByb3AgPSBcImZvb1wiKV0sIFtyZXR1cm46IEZvbygxKSwgQmFyKDIpXSwgW2Fzc2VtYmx5OiBGb28oQmFyKV1cbiAgICAgIHBhdHRlcm46IHJlKC8oKD86XnxbXlxcc1xcdz4pP10pXFxzKlxcW1xccyopKD86PDwwPj5cXHMqOlxccyopPzw8MT4+KD86XFxzKixcXHMqPDwxPj4pKig/PVxccypcXF0pLy5zb3VyY2UsIFthdHRyVGFyZ2V0LCBhdHRyXSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICd0YXJnZXQnOiB7XG4gICAgICAgICAgcGF0dGVybjogcmUoL148PDA+Pig/PVxccyo6KS8uc291cmNlLCBbYXR0clRhcmdldF0pLFxuICAgICAgICAgIGFsaWFzOiAna2V5d29yZCdcbiAgICAgICAgfSxcbiAgICAgICAgJ2F0dHJpYnV0ZS1hcmd1bWVudHMnOiB7XG4gICAgICAgICAgcGF0dGVybjogcmUoL1xcKDw8MD4+KlxcKS8uc291cmNlLCBbcm91bmRFeHByZXNzaW9uXSksXG4gICAgICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuY3NoYXJwXG4gICAgICAgIH0sXG4gICAgICAgICdjbGFzcy1uYW1lJzoge1xuICAgICAgICAgIHBhdHRlcm46IFJlZ0V4cChpZGVudGlmaWVyKSxcbiAgICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9cXC4vXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAncHVuY3R1YXRpb24nOiAvWzosXS9cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIHN0cmluZyBpbnRlcnBvbGF0aW9uXG4gIHZhciBmb3JtYXRTdHJpbmcgPSAvOltefVxcclxcbl0rLy5zb3VyY2U7XG4gIC8vIG11bHRpIGxpbmVcbiAgdmFyIG1JbnRlcnBvbGF0aW9uUm91bmQgPSBuZXN0ZWQocmVwbGFjZSgvW15cIicvKCldfDw8MD4+fFxcKDw8c2VsZj4+KlxcKS8uc291cmNlLCBbcmVndWxhclN0cmluZ0NoYXJhY3Rlck9yQ29tbWVudF0pLCAyKTtcbiAgdmFyIG1JbnRlcnBvbGF0aW9uID0gcmVwbGFjZSgvXFx7KD8hXFx7KSg/Oig/IVt9Ol0pPDwwPj4pKjw8MT4+P1xcfS8uc291cmNlLCBbbUludGVycG9sYXRpb25Sb3VuZCwgZm9ybWF0U3RyaW5nXSk7XG4gIC8vIHNpbmdsZSBsaW5lXG4gIHZhciBzSW50ZXJwb2xhdGlvblJvdW5kID0gbmVzdGVkKHJlcGxhY2UoL1teXCInLygpXXxcXC8oPyFcXCopfFxcL1xcKig/OlteKl18XFwqKD8hXFwvKSkqXFwqXFwvfDw8MD4+fFxcKDw8c2VsZj4+KlxcKS8uc291cmNlLCBbcmVndWxhclN0cmluZ09yQ2hhcmFjdGVyXSksIDIpO1xuICB2YXIgc0ludGVycG9sYXRpb24gPSByZXBsYWNlKC9cXHsoPyFcXHspKD86KD8hW306XSk8PDA+PikqPDwxPj4/XFx9Ly5zb3VyY2UsIFtzSW50ZXJwb2xhdGlvblJvdW5kLCBmb3JtYXRTdHJpbmddKTtcbiAgZnVuY3Rpb24gY3JlYXRlSW50ZXJwb2xhdGlvbkluc2lkZShpbnRlcnBvbGF0aW9uLCBpbnRlcnBvbGF0aW9uUm91bmQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ2ludGVycG9sYXRpb24nOiB7XG4gICAgICAgIHBhdHRlcm46IHJlKC8oKD86XnxbXntdKSg/Olxce1xceykqKTw8MD4+Ly5zb3VyY2UsIFtpbnRlcnBvbGF0aW9uXSksXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgICdmb3JtYXQtc3RyaW5nJzoge1xuICAgICAgICAgICAgcGF0dGVybjogcmUoLyheXFx7KD86KD8hW306XSk8PDA+PikqKTw8MT4+KD89XFx9JCkvLnNvdXJjZSwgW2ludGVycG9sYXRpb25Sb3VuZCwgZm9ybWF0U3RyaW5nXSksXG4gICAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9eOi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9eXFx7fFxcfSQvLFxuICAgICAgICAgICdleHByZXNzaW9uJzoge1xuICAgICAgICAgICAgcGF0dGVybjogL1tcXHNcXFNdKy8sXG4gICAgICAgICAgICBhbGlhczogJ2xhbmd1YWdlLWNzaGFycCcsXG4gICAgICAgICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5jc2hhcnBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnc3RyaW5nJzogL1tcXHNcXFNdKy9cbiAgICB9O1xuICB9XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2NzaGFycCcsICdzdHJpbmcnLCB7XG4gICAgJ2ludGVycG9sYXRpb24tc3RyaW5nJzogW3tcbiAgICAgIHBhdHRlcm46IHJlKC8oXnxbXlxcXFxdKSg/OlxcJEB8QFxcJClcIig/OlwiXCJ8XFxcXFtcXHNcXFNdfFxce1xce3w8PDA+PnxbXlxcXFx7XCJdKSpcIi8uc291cmNlLCBbbUludGVycG9sYXRpb25dKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IGNyZWF0ZUludGVycG9sYXRpb25JbnNpZGUobUludGVycG9sYXRpb24sIG1JbnRlcnBvbGF0aW9uUm91bmQpXG4gICAgfSwge1xuICAgICAgcGF0dGVybjogcmUoLyhefFteQFxcXFxdKVxcJFwiKD86XFxcXC58XFx7XFx7fDw8MD4+fFteXFxcXFwie10pKlwiLy5zb3VyY2UsIFtzSW50ZXJwb2xhdGlvbl0pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZTogY3JlYXRlSW50ZXJwb2xhdGlvbkluc2lkZShzSW50ZXJwb2xhdGlvbiwgc0ludGVycG9sYXRpb25Sb3VuZClcbiAgICB9XSxcbiAgICAnY2hhcic6IHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cChjaGFyYWN0ZXIpLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmRvdG5ldCA9IFByaXNtLmxhbmd1YWdlcy5jcyA9IFByaXNtLmxhbmd1YWdlcy5jc2hhcnA7XG59KShQcmlzbSk7XG5QcmlzbS5sYW5ndWFnZXMubWFya3VwID0ge1xuICAnY29tbWVudCc6IHtcbiAgICBwYXR0ZXJuOiAvPCEtLSg/Oig/ITwhLS0pW1xcc1xcU10pKj8tLT4vLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAncHJvbG9nJzoge1xuICAgIHBhdHRlcm46IC88XFw/W1xcc1xcU10rP1xcPz4vLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnZG9jdHlwZSc6IHtcbiAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIveG1sLyNOVC1kb2N0eXBlZGVjbFxuICAgIHBhdHRlcm46IC88IURPQ1RZUEUoPzpbXj5cIidbXFxdXXxcIlteXCJdKlwifCdbXiddKicpKyg/OlxcWyg/OltePFwiJ1xcXV18XCJbXlwiXSpcInwnW14nXSonfDwoPyEhLS0pfDwhLS0oPzpbXi1dfC0oPyEtPikpKi0tPikqXFxdXFxzKik/Pi9pLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdpbnRlcm5hbC1zdWJzZXQnOiB7XG4gICAgICAgIHBhdHRlcm46IC8oXlteXFxbXSpcXFspW1xcc1xcU10rKD89XFxdPiQpLyxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgICBpbnNpZGU6IG51bGwgLy8gc2VlIGJlbG93XG4gICAgICB9LFxuXG4gICAgICAnc3RyaW5nJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXCJbXlwiXSpcInwnW14nXSonLyxcbiAgICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgICB9LFxuICAgICAgJ3B1bmN0dWF0aW9uJzogL148IXw+JHxbW1xcXV0vLFxuICAgICAgJ2RvY3R5cGUtdGFnJzogL15ET0NUWVBFL2ksXG4gICAgICAnbmFtZSc6IC9bXlxcczw+J1wiXSsvXG4gICAgfVxuICB9LFxuICAnY2RhdGEnOiB7XG4gICAgcGF0dGVybjogLzwhXFxbQ0RBVEFcXFtbXFxzXFxTXSo/XFxdXFxdPi9pLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAndGFnJzoge1xuICAgIHBhdHRlcm46IC88XFwvPyg/IVxcZClbXlxccz5cXC89JDwlXSsoPzpcXHMoPzpcXHMqW15cXHM+XFwvPV0rKD86XFxzKj1cXHMqKD86XCJbXlwiXSpcInwnW14nXSonfFteXFxzJ1wiPj1dKyg/PVtcXHM+XSkpfCg/PVtcXHMvPl0pKSkrKT9cXHMqXFwvPz4vLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICd0YWcnOiB7XG4gICAgICAgIHBhdHRlcm46IC9ePFxcLz9bXlxccz5cXC9dKy8sXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9ePFxcLz8vLFxuICAgICAgICAgICduYW1lc3BhY2UnOiAvXlteXFxzPlxcLzpdKzovXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnc3BlY2lhbC1hdHRyJzogW10sXG4gICAgICAnYXR0ci12YWx1ZSc6IHtcbiAgICAgICAgcGF0dGVybjogLz1cXHMqKD86XCJbXlwiXSpcInwnW14nXSonfFteXFxzJ1wiPj1dKykvLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAncHVuY3R1YXRpb24nOiBbe1xuICAgICAgICAgICAgcGF0dGVybjogL149LyxcbiAgICAgICAgICAgIGFsaWFzOiAnYXR0ci1lcXVhbHMnXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgcGF0dGVybjogL14oXFxzKilbXCInXXxbXCInXSQvLFxuICAgICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICAgIH1dXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAncHVuY3R1YXRpb24nOiAvXFwvPz4vLFxuICAgICAgJ2F0dHItbmFtZSc6IHtcbiAgICAgICAgcGF0dGVybjogL1teXFxzPlxcL10rLyxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgJ25hbWVzcGFjZSc6IC9eW15cXHM+XFwvOl0rOi9cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgJ2VudGl0eSc6IFt7XG4gICAgcGF0dGVybjogLyZbXFxkYS16XXsxLDh9Oy9pLFxuICAgIGFsaWFzOiAnbmFtZWQtZW50aXR5J1xuICB9LCAvJiN4P1tcXGRhLWZdezEsOH07L2ldXG59O1xuUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cFsndGFnJ10uaW5zaWRlWydhdHRyLXZhbHVlJ10uaW5zaWRlWydlbnRpdHknXSA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXBbJ2VudGl0eSddO1xuUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cFsnZG9jdHlwZSddLmluc2lkZVsnaW50ZXJuYWwtc3Vic2V0J10uaW5zaWRlID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblxuLy8gUGx1Z2luIHRvIG1ha2UgZW50aXR5IHRpdGxlIHNob3cgdGhlIHJlYWwgZW50aXR5LCBpZGVhIGJ5IFJvbWFuIEtvbWFyb3ZcblByaXNtLmhvb2tzLmFkZCgnd3JhcCcsIGZ1bmN0aW9uIChlbnYpIHtcbiAgaWYgKGVudi50eXBlID09PSAnZW50aXR5Jykge1xuICAgIGVudi5hdHRyaWJ1dGVzWyd0aXRsZSddID0gZW52LmNvbnRlbnQucmVwbGFjZSgvJmFtcDsvLCAnJicpO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZywgJ2FkZElubGluZWQnLCB7XG4gIC8qKlxuICAgKiBBZGRzIGFuIGlubGluZWQgbGFuZ3VhZ2UgdG8gbWFya3VwLlxuICAgKlxuICAgKiBBbiBleGFtcGxlIG9mIGFuIGlubGluZWQgbGFuZ3VhZ2UgaXMgQ1NTIHdpdGggYDxzdHlsZT5gIHRhZ3MuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lIFRoZSBuYW1lIG9mIHRoZSB0YWcgdGhhdCBjb250YWlucyB0aGUgaW5saW5lZCBsYW5ndWFnZS4gVGhpcyBuYW1lIHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgKiBjYXNlIGluc2Vuc2l0aXZlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZyBUaGUgbGFuZ3VhZ2Uga2V5LlxuICAgKiBAZXhhbXBsZVxuICAgKiBhZGRJbmxpbmVkKCdzdHlsZScsICdjc3MnKTtcbiAgICovXG4gIHZhbHVlOiBmdW5jdGlvbiBhZGRJbmxpbmVkKHRhZ05hbWUsIGxhbmcpIHtcbiAgICB2YXIgaW5jbHVkZWRDZGF0YUluc2lkZSA9IHt9O1xuICAgIGluY2x1ZGVkQ2RhdGFJbnNpZGVbJ2xhbmd1YWdlLScgKyBsYW5nXSA9IHtcbiAgICAgIHBhdHRlcm46IC8oXjwhXFxbQ0RBVEFcXFspW1xcc1xcU10rPyg/PVxcXVxcXT4kKS9pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzW2xhbmddXG4gICAgfTtcbiAgICBpbmNsdWRlZENkYXRhSW5zaWRlWydjZGF0YSddID0gL148IVxcW0NEQVRBXFxbfFxcXVxcXT4kL2k7XG4gICAgdmFyIGluc2lkZSA9IHtcbiAgICAgICdpbmNsdWRlZC1jZGF0YSc6IHtcbiAgICAgICAgcGF0dGVybjogLzwhXFxbQ0RBVEFcXFtbXFxzXFxTXSo/XFxdXFxdPi9pLFxuICAgICAgICBpbnNpZGU6IGluY2x1ZGVkQ2RhdGFJbnNpZGVcbiAgICAgIH1cbiAgICB9O1xuICAgIGluc2lkZVsnbGFuZ3VhZ2UtJyArIGxhbmddID0ge1xuICAgICAgcGF0dGVybjogL1tcXHNcXFNdKy8sXG4gICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlc1tsYW5nXVxuICAgIH07XG4gICAgdmFyIGRlZiA9IHt9O1xuICAgIGRlZlt0YWdOYW1lXSA9IHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgvKDxfX1tePl0qPikoPzo8IVxcW0NEQVRBXFxbKD86W15cXF1dfFxcXSg/IVxcXT4pKSpcXF1cXF0+fCg/ITwhXFxbQ0RBVEFcXFspW1xcc1xcU10pKj8oPz08XFwvX18+KS8uc291cmNlLnJlcGxhY2UoL19fL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRhZ05hbWU7XG4gICAgICB9KSwgJ2knKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IGluc2lkZVxuICAgIH07XG4gICAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya3VwJywgJ2NkYXRhJywgZGVmKTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcsICdhZGRBdHRyaWJ1dGUnLCB7XG4gIC8qKlxuICAgKiBBZGRzIGFuIHBhdHRlcm4gdG8gaGlnaGxpZ2h0IGxhbmd1YWdlcyBlbWJlZGRlZCBpbiBIVE1MIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEFuIGV4YW1wbGUgb2YgYW4gaW5saW5lZCBsYW5ndWFnZSBpcyBDU1Mgd2l0aCBgc3R5bGVgIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyTmFtZSBUaGUgbmFtZSBvZiB0aGUgdGFnIHRoYXQgY29udGFpbnMgdGhlIGlubGluZWQgbGFuZ3VhZ2UuIFRoaXMgbmFtZSB3aWxsIGJlIHRyZWF0ZWQgYXNcbiAgICogY2FzZSBpbnNlbnNpdGl2ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmcgVGhlIGxhbmd1YWdlIGtleS5cbiAgICogQGV4YW1wbGVcbiAgICogYWRkQXR0cmlidXRlKCdzdHlsZScsICdjc3MnKTtcbiAgICovXG4gIHZhbHVlOiBmdW5jdGlvbiAoYXR0ck5hbWUsIGxhbmcpIHtcbiAgICBQcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZy5pbnNpZGVbJ3NwZWNpYWwtYXR0ciddLnB1c2goe1xuICAgICAgcGF0dGVybjogUmVnRXhwKC8oXnxbXCInXFxzXSkvLnNvdXJjZSArICcoPzonICsgYXR0ck5hbWUgKyAnKScgKyAvXFxzKj1cXHMqKD86XCJbXlwiXSpcInwnW14nXSonfFteXFxzJ1wiPj1dKyg/PVtcXHM+XSkpLy5zb3VyY2UsICdpJyksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdhdHRyLW5hbWUnOiAvXlteXFxzPV0rLyxcbiAgICAgICAgJ2F0dHItdmFsdWUnOiB7XG4gICAgICAgICAgcGF0dGVybjogLz1bXFxzXFxTXSsvLFxuICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgJ3ZhbHVlJzoge1xuICAgICAgICAgICAgICBwYXR0ZXJuOiAvKF49XFxzKihbXCInXXwoPyFbXCInXSkpKVxcU1tcXHNcXFNdKig/PVxcMiQpLyxcbiAgICAgICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICAgICAgYWxpYXM6IFtsYW5nLCAnbGFuZ3VhZ2UtJyArIGxhbmddLFxuICAgICAgICAgICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlc1tsYW5nXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdwdW5jdHVhdGlvbic6IFt7XG4gICAgICAgICAgICAgIHBhdHRlcm46IC9ePS8sXG4gICAgICAgICAgICAgIGFsaWFzOiAnYXR0ci1lcXVhbHMnXG4gICAgICAgICAgICB9LCAvXCJ8Jy9dXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0pO1xuUHJpc20ubGFuZ3VhZ2VzLmh0bWwgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuUHJpc20ubGFuZ3VhZ2VzLm1hdGhtbCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5QcmlzbS5sYW5ndWFnZXMuc3ZnID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblByaXNtLmxhbmd1YWdlcy54bWwgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdtYXJrdXAnLCB7fSk7XG5QcmlzbS5sYW5ndWFnZXMuc3NtbCA9IFByaXNtLmxhbmd1YWdlcy54bWw7XG5QcmlzbS5sYW5ndWFnZXMuYXRvbSA9IFByaXNtLmxhbmd1YWdlcy54bWw7XG5QcmlzbS5sYW5ndWFnZXMucnNzID0gUHJpc20ubGFuZ3VhZ2VzLnhtbDtcbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgdmFyIHN0cmluZyA9IC8oPzpcIig/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfFteXCJcXFxcXFxyXFxuXSkqXCJ8Jyg/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfFteJ1xcXFxcXHJcXG5dKSonKS87XG4gIFByaXNtLmxhbmd1YWdlcy5jc3MgPSB7XG4gICAgJ2NvbW1lbnQnOiAvXFwvXFwqW1xcc1xcU10qP1xcKlxcLy8sXG4gICAgJ2F0cnVsZSc6IHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgnQFtcXFxcdy1dKD86JyArIC9bXjt7XFxzXCInXXxcXHMrKD8hXFxzKS8uc291cmNlICsgJ3wnICsgc3RyaW5nLnNvdXJjZSArICcpKj8nICsgLyg/Ojt8KD89XFxzKlxceykpLy5zb3VyY2UpLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdydWxlJzogL15AW1xcdy1dKy8sXG4gICAgICAgICdzZWxlY3Rvci1mdW5jdGlvbi1hcmd1bWVudCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKFxcYnNlbGVjdG9yXFxzKlxcKFxccyooPyFbXFxzKV0pKSg/OlteKClcXHNdfFxccysoPyFbXFxzKV0pfFxcKCg/OlteKCldfFxcKFteKCldKlxcKSkqXFwpKSsoPz1cXHMqXFwpKS8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICBhbGlhczogJ3NlbGVjdG9yJ1xuICAgICAgICB9LFxuICAgICAgICAna2V5d29yZCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKF58W15cXHctXSkoPzphbmR8bm90fG9ubHl8b3IpKD8hW1xcdy1dKS8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIC8vIFNlZSByZXN0IGJlbG93XG4gICAgICB9XG4gICAgfSxcblxuICAgICd1cmwnOiB7XG4gICAgICAvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXZhbHVlcy0zLyN1cmxzXG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoJ1xcXFxidXJsXFxcXCgoPzonICsgc3RyaW5nLnNvdXJjZSArICd8JyArIC8oPzpbXlxcXFxcXHJcXG4oKVwiJ118XFxcXFtcXHNcXFNdKSovLnNvdXJjZSArICcpXFxcXCknLCAnaScpLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdmdW5jdGlvbic6IC9edXJsL2ksXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9eXFwofFxcKSQvLFxuICAgICAgICAnc3RyaW5nJzoge1xuICAgICAgICAgIHBhdHRlcm46IFJlZ0V4cCgnXicgKyBzdHJpbmcuc291cmNlICsgJyQnKSxcbiAgICAgICAgICBhbGlhczogJ3VybCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ3NlbGVjdG9yJzoge1xuICAgICAgcGF0dGVybjogUmVnRXhwKCcoXnxbe31cXFxcc10pW157fVxcXFxzXSg/Oltee307XCJcXCdcXFxcc118XFxcXHMrKD8hW1xcXFxze10pfCcgKyBzdHJpbmcuc291cmNlICsgJykqKD89XFxcXHMqXFxcXHspJyksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAnc3RyaW5nJzoge1xuICAgICAgcGF0dGVybjogc3RyaW5nLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSxcbiAgICAncHJvcGVydHknOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W14tXFx3XFx4QTAtXFx1RkZGRl0pKD8hXFxzKVstX2EtelxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVstXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccyo6KS9pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgJ2ltcG9ydGFudCc6IC8haW1wb3J0YW50XFxiL2ksXG4gICAgJ2Z1bmN0aW9uJzoge1xuICAgICAgcGF0dGVybjogLyhefFteLWEtejAtOV0pWy1hLXowLTldKyg/PVxcKCkvaSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICdwdW5jdHVhdGlvbic6IC9bKCl7fTs6LF0vXG4gIH07XG4gIFByaXNtLmxhbmd1YWdlcy5jc3NbJ2F0cnVsZSddLmluc2lkZS5yZXN0ID0gUHJpc20ubGFuZ3VhZ2VzLmNzcztcbiAgdmFyIG1hcmt1cCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG4gIGlmIChtYXJrdXApIHtcbiAgICBtYXJrdXAudGFnLmFkZElubGluZWQoJ3N0eWxlJywgJ2NzcycpO1xuICAgIG1hcmt1cC50YWcuYWRkQXR0cmlidXRlKCdzdHlsZScsICdjc3MnKTtcbiAgfVxufSkoUHJpc20pO1xuKGZ1bmN0aW9uIChQcmlzbSkge1xuICBQcmlzbS5sYW5ndWFnZXMuZGlmZiA9IHtcbiAgICAnY29vcmQnOiBbXG4gICAgLy8gTWF0Y2ggYWxsIGtpbmRzIG9mIGNvb3JkIGxpbmVzIChwcmVmaXhlZCBieSBcIisrK1wiLCBcIi0tLVwiIG9yIFwiKioqXCIpLlxuICAgIC9eKD86XFwqezN9fC17M318XFwrezN9KS4qJC9tLFxuICAgIC8vIE1hdGNoIFwiQEAgLi4uIEBAXCIgY29vcmQgbGluZXMgaW4gdW5pZmllZCBkaWZmLlxuICAgIC9eQEAuKkBAJC9tLFxuICAgIC8vIE1hdGNoIGNvb3JkIGxpbmVzIGluIG5vcm1hbCBkaWZmIChzdGFydHMgd2l0aCBhIG51bWJlcikuXG4gICAgL15cXGQuKiQvbV1cblxuICAgIC8vIGRlbGV0ZWQsIGluc2VydGVkLCB1bmNoYW5nZWQsIGRpZmZcbiAgfTtcblxuICAvKipcbiAgICogQSBtYXAgZnJvbSB0aGUgbmFtZSBvZiBhIGJsb2NrIHRvIGl0cyBsaW5lIHByZWZpeC5cbiAgICpcbiAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIHN0cmluZz59XG4gICAqL1xuICB2YXIgUFJFRklYRVMgPSB7XG4gICAgJ2RlbGV0ZWQtc2lnbic6ICctJyxcbiAgICAnZGVsZXRlZC1hcnJvdyc6ICc8JyxcbiAgICAnaW5zZXJ0ZWQtc2lnbic6ICcrJyxcbiAgICAnaW5zZXJ0ZWQtYXJyb3cnOiAnPicsXG4gICAgJ3VuY2hhbmdlZCc6ICcgJyxcbiAgICAnZGlmZic6ICchJ1xuICB9O1xuXG4gIC8vIGFkZCBhIHRva2VuIGZvciBlYWNoIHByZWZpeFxuICBPYmplY3Qua2V5cyhQUkVGSVhFUykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBwcmVmaXggPSBQUkVGSVhFU1tuYW1lXTtcbiAgICB2YXIgYWxpYXMgPSBbXTtcbiAgICBpZiAoIS9eXFx3KyQvLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIFwiZGVsZXRlZC1zaWduXCIgLT4gXCJkZWxldGVkXCJcbiAgICAgIGFsaWFzLnB1c2goL1xcdysvLmV4ZWMobmFtZSlbMF0pO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gJ2RpZmYnKSB7XG4gICAgICBhbGlhcy5wdXNoKCdib2xkJyk7XG4gICAgfVxuICAgIFByaXNtLmxhbmd1YWdlcy5kaWZmW25hbWVdID0ge1xuICAgICAgcGF0dGVybjogUmVnRXhwKCdeKD86WycgKyBwcmVmaXggKyAnXS4qKD86XFxyXFxuP3xcXG58KD8hW1xcXFxzXFxcXFNdKSkpKycsICdtJyksXG4gICAgICBhbGlhczogYWxpYXMsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2xpbmUnOiB7XG4gICAgICAgICAgcGF0dGVybjogLyguKSg/PVtcXHNcXFNdKS4qKD86XFxyXFxuP3xcXG4pPy8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAncHJlZml4Jzoge1xuICAgICAgICAgIHBhdHRlcm46IC9bXFxzXFxTXS8sXG4gICAgICAgICAgYWxpYXM6IC9cXHcrLy5leGVjKG5hbWUpWzBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICAvLyBtYWtlIHByZWZpeGVzIGF2YWlsYWJsZSB0byBEaWZmIHBsdWdpblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJpc20ubGFuZ3VhZ2VzLmRpZmYsICdQUkVGSVhFUycsIHtcbiAgICB2YWx1ZTogUFJFRklYRVNcbiAgfSk7XG59KShQcmlzbSk7XG5QcmlzbS5sYW5ndWFnZXMuZ28gPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjbGlrZScsIHtcbiAgJ3N0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSlcIig/OlxcXFwufFteXCJcXFxcXFxyXFxuXSkqXCJ8YFteYF0qYC8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ2tleXdvcmQnOiAvXFxiKD86YnJlYWt8Y2FzZXxjaGFufGNvbnN0fGNvbnRpbnVlfGRlZmF1bHR8ZGVmZXJ8ZWxzZXxmYWxsdGhyb3VnaHxmb3J8ZnVuY3xnbyg/OnRvKT98aWZ8aW1wb3J0fGludGVyZmFjZXxtYXB8cGFja2FnZXxyYW5nZXxyZXR1cm58c2VsZWN0fHN0cnVjdHxzd2l0Y2h8dHlwZXx2YXIpXFxiLyxcbiAgJ2Jvb2xlYW4nOiAvXFxiKD86X3xmYWxzZXxpb3RhfG5pbHx0cnVlKVxcYi8sXG4gICdudW1iZXInOiBbXG4gIC8vIGJpbmFyeSBhbmQgb2N0YWwgaW50ZWdlcnNcbiAgL1xcYjAoPzpiWzAxX10rfG9bMC03X10rKWk/XFxiL2ksXG4gIC8vIGhleGFkZWNpbWFsIGludGVnZXJzIGFuZCBmbG9hdHNcbiAgL1xcYjB4KD86W2EtZlxcZF9dKyg/OlxcLlthLWZcXGRfXSopP3xcXC5bYS1mXFxkX10rKSg/OnBbKy1dP1xcZCsoPzpfXFxkKykqKT9pPyg/IVxcdykvaSxcbiAgLy8gZGVjaW1hbCBpbnRlZ2VycyBhbmQgZmxvYXRzXG4gIC8oPzpcXGJcXGRbXFxkX10qKD86XFwuW1xcZF9dKik/fFxcQlxcLlxcZFtcXGRfXSopKD86ZVsrLV0/W1xcZF9dKyk/aT8oPyFcXHcpL2ldLFxuICAnb3BlcmF0b3InOiAvWypcXC8lXiE9XT0/fFxcK1s9K10/fC1bPS1dP3xcXHxbPXxdP3wmKD86PXwmfFxcXj0/KT98Pig/Oj49P3w9KT98PCg/Ojw9P3w9fC0pP3w6PXxcXC5cXC5cXC4vLFxuICAnYnVpbHRpbic6IC9cXGIoPzphcHBlbmR8Ym9vbHxieXRlfGNhcHxjbG9zZXxjb21wbGV4fGNvbXBsZXgoPzo2NHwxMjgpfGNvcHl8ZGVsZXRlfGVycm9yfGZsb2F0KD86MzJ8NjQpfHU/aW50KD86OHwxNnwzMnw2NCk/fGltYWd8bGVufG1ha2V8bmV3fHBhbmljfHByaW50KD86bG4pP3xyZWFsfHJlY292ZXJ8cnVuZXxzdHJpbmd8dWludHB0cilcXGIvXG59KTtcblByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2dvJywgJ3N0cmluZycsIHtcbiAgJ2NoYXInOiB7XG4gICAgcGF0dGVybjogLycoPzpcXFxcLnxbXidcXFxcXFxyXFxuXSl7MCwxMH0nLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfVxufSk7XG5kZWxldGUgUHJpc20ubGFuZ3VhZ2VzLmdvWydjbGFzcy1uYW1lJ107XG5QcmlzbS5sYW5ndWFnZXMuaW5pID0ge1xuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCBtaW1pY3MgdGhlIGJlaGF2aW9yIG9mIHRoZSBXaW4zMiBBUEkgcGFyc2VyLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vUHJpc21KUy9wcmlzbS9pc3N1ZXMvMjc3NSNpc3N1ZWNvbW1lbnQtNzg3NDc3NzIzfVxuICAgKi9cblxuICAnY29tbWVudCc6IHtcbiAgICBwYXR0ZXJuOiAvKF5bIFxcZlxcdFxcdl0qKVsjO11bXlxcblxccl0qL20sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9LFxuICAnc2VjdGlvbic6IHtcbiAgICBwYXR0ZXJuOiAvKF5bIFxcZlxcdFxcdl0qKVxcW1teXFxuXFxyXFxdXSpcXF0/L20sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdzZWN0aW9uLW5hbWUnOiB7XG4gICAgICAgIHBhdHRlcm46IC8oXlxcW1sgXFxmXFx0XFx2XSopW14gXFxmXFx0XFx2XFxdXSsoPzpbIFxcZlxcdFxcdl0rW14gXFxmXFx0XFx2XFxdXSspKi8sXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgIGFsaWFzOiAnc2VsZWN0b3InXG4gICAgICB9LFxuICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcW3xcXF0vXG4gICAgfVxuICB9LFxuICAna2V5Jzoge1xuICAgIHBhdHRlcm46IC8oXlsgXFxmXFx0XFx2XSopW14gXFxmXFxuXFxyXFx0XFx2PV0rKD86WyBcXGZcXHRcXHZdK1teIFxcZlxcblxcclxcdFxcdj1dKykqKD89WyBcXGZcXHRcXHZdKj0pL20sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBhbGlhczogJ2F0dHItbmFtZSdcbiAgfSxcbiAgJ3ZhbHVlJzoge1xuICAgIHBhdHRlcm46IC8oPVsgXFxmXFx0XFx2XSopW14gXFxmXFxuXFxyXFx0XFx2XSsoPzpbIFxcZlxcdFxcdl0rW14gXFxmXFxuXFxyXFx0XFx2XSspKi8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBhbGlhczogJ2F0dHItdmFsdWUnLFxuICAgIGluc2lkZToge1xuICAgICAgJ2lubmVyLXZhbHVlJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXihcInwnKS4rKD89XFwxJCkvLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9LFxuICAncHVuY3R1YXRpb24nOiAvPS9cbn07XG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIHZhciBrZXl3b3JkcyA9IC9cXGIoPzphYnN0cmFjdHxhc3NlcnR8Ym9vbGVhbnxicmVha3xieXRlfGNhc2V8Y2F0Y2h8Y2hhcnxjbGFzc3xjb25zdHxjb250aW51ZXxkZWZhdWx0fGRvfGRvdWJsZXxlbHNlfGVudW18ZXhwb3J0c3xleHRlbmRzfGZpbmFsfGZpbmFsbHl8ZmxvYXR8Zm9yfGdvdG98aWZ8aW1wbGVtZW50c3xpbXBvcnR8aW5zdGFuY2VvZnxpbnR8aW50ZXJmYWNlfGxvbmd8bW9kdWxlfG5hdGl2ZXxuZXd8bm9uLXNlYWxlZHxudWxsfG9wZW58b3BlbnN8cGFja2FnZXxwZXJtaXRzfHByaXZhdGV8cHJvdGVjdGVkfHByb3ZpZGVzfHB1YmxpY3xyZWNvcmQoPyFcXHMqWygpe31bXFxdPD49JX4uOiw7PytcXC0qLyZ8Xl0pfHJlcXVpcmVzfHJldHVybnxzZWFsZWR8c2hvcnR8c3RhdGljfHN0cmljdGZwfHN1cGVyfHN3aXRjaHxzeW5jaHJvbml6ZWR8dGhpc3x0aHJvd3x0aHJvd3N8dG98dHJhbnNpZW50fHRyYW5zaXRpdmV8dHJ5fHVzZXN8dmFyfHZvaWR8dm9sYXRpbGV8d2hpbGV8d2l0aHx5aWVsZClcXGIvO1xuXG4gIC8vIGZ1bGwgcGFja2FnZSAob3B0aW9uYWwpICsgcGFyZW50IGNsYXNzZXMgKG9wdGlvbmFsKVxuICB2YXIgY2xhc3NOYW1lUHJlZml4ID0gLyg/OlthLXpdXFx3KlxccypcXC5cXHMqKSooPzpbQS1aXVxcdypcXHMqXFwuXFxzKikqLy5zb3VyY2U7XG5cbiAgLy8gYmFzZWQgb24gdGhlIGphdmEgbmFtaW5nIGNvbnZlbnRpb25zXG4gIHZhciBjbGFzc05hbWUgPSB7XG4gICAgcGF0dGVybjogUmVnRXhwKC8oXnxbXlxcdy5dKS8uc291cmNlICsgY2xhc3NOYW1lUHJlZml4ICsgL1tBLVpdKD86W1xcZF9BLVpdKlthLXpdXFx3Kik/XFxiLy5zb3VyY2UpLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICAnbmFtZXNwYWNlJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXlthLXpdXFx3Kig/OlxccypcXC5cXHMqW2Etel1cXHcqKSooPzpcXHMqXFwuKT8vLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAncHVuY3R1YXRpb24nOiAvXFwuL1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcLi9cbiAgICB9XG4gIH07XG4gIFByaXNtLmxhbmd1YWdlcy5qYXZhID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY2xpa2UnLCB7XG4gICAgJ3N0cmluZyc6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKVwiKD86XFxcXC58W15cIlxcXFxcXHJcXG5dKSpcIi8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSxcbiAgICAnY2xhc3MtbmFtZSc6IFtjbGFzc05hbWUsIHtcbiAgICAgIC8vIHZhcmlhYmxlcywgcGFyYW1ldGVycywgYW5kIGNvbnN0cnVjdG9yIHJlZmVyZW5jZXNcbiAgICAgIC8vIHRoaXMgdG8gc3VwcG9ydCBjbGFzcyBuYW1lcyAob3IgZ2VuZXJpYyBwYXJhbWV0ZXJzKSB3aGljaCBkbyBub3QgY29udGFpbiBhIGxvd2VyIGNhc2UgbGV0dGVyIChhbHNvIHdvcmtzIGZvciBtZXRob2RzKVxuICAgICAgcGF0dGVybjogUmVnRXhwKC8oXnxbXlxcdy5dKS8uc291cmNlICsgY2xhc3NOYW1lUHJlZml4ICsgL1tBLVpdXFx3Kig/PVxccytcXHcrXFxzKls7LD0oKV18XFxzKig/OlxcW1tcXHMsXSpcXF1cXHMqKT86OlxccypuZXdcXGIpLy5zb3VyY2UpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZTogY2xhc3NOYW1lLmluc2lkZVxuICAgIH0sIHtcbiAgICAgIC8vIGNsYXNzIG5hbWVzIGJhc2VkIG9uIGtleXdvcmRcbiAgICAgIC8vIHRoaXMgdG8gc3VwcG9ydCBjbGFzcyBuYW1lcyAob3IgZ2VuZXJpYyBwYXJhbWV0ZXJzKSB3aGljaCBkbyBub3QgY29udGFpbiBhIGxvd2VyIGNhc2UgbGV0dGVyIChhbHNvIHdvcmtzIGZvciBtZXRob2RzKVxuICAgICAgcGF0dGVybjogUmVnRXhwKC8oXFxiKD86Y2xhc3N8ZW51bXxleHRlbmRzfGltcGxlbWVudHN8aW5zdGFuY2VvZnxpbnRlcmZhY2V8bmV3fHJlY29yZHx0aHJvd3MpXFxzKykvLnNvdXJjZSArIGNsYXNzTmFtZVByZWZpeCArIC9bQS1aXVxcdypcXGIvLnNvdXJjZSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiBjbGFzc05hbWUuaW5zaWRlXG4gICAgfV0sXG4gICAgJ2tleXdvcmQnOiBrZXl3b3JkcyxcbiAgICAnZnVuY3Rpb24nOiBbUHJpc20ubGFuZ3VhZ2VzLmNsaWtlLmZ1bmN0aW9uLCB7XG4gICAgICBwYXR0ZXJuOiAvKDo6XFxzKilbYS16X11cXHcqLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9XSxcbiAgICAnbnVtYmVyJzogL1xcYjBiWzAxXVswMV9dKkw/XFxifFxcYjB4KD86XFwuW1xcZGEtZl9wKy1dK3xbXFxkYS1mX10rKD86XFwuW1xcZGEtZl9wKy1dKyk/KVxcYnwoPzpcXGJcXGRbXFxkX10qKD86XFwuW1xcZF9dKik/fFxcQlxcLlxcZFtcXGRfXSopKD86ZVsrLV0/XFxkW1xcZF9dKik/W2RmbF0/L2ksXG4gICAgJ29wZXJhdG9yJzoge1xuICAgICAgcGF0dGVybjogLyhefFteLl0pKD86PDw9P3w+Pj4/PT98LT58LS18XFwrXFwrfCYmfFxcfFxcfHw6OnxbPzp+XXxbLSsqLyUmfF4hPTw+XT0/KS9tLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgJ2NvbnN0YW50JzogL1xcYltBLVpdW0EtWl9cXGRdK1xcYi9cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmEnLCAnc3RyaW5nJywge1xuICAgICd0cmlwbGUtcXVvdGVkLXN0cmluZyc6IHtcbiAgICAgIC8vIGh0dHA6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzU1I0Rlc2NyaXB0aW9uXG4gICAgICBwYXR0ZXJuOiAvXCJcIlwiWyBcXHRdKltcXHJcXG5dKD86KD86XCJ8XCJcIik/KD86XFxcXC58W15cIlxcXFxdKSkqXCJcIlwiLyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnc3RyaW5nJ1xuICAgIH0sXG4gICAgJ2NoYXInOiB7XG4gICAgICBwYXR0ZXJuOiAvJyg/OlxcXFwufFteJ1xcXFxcXHJcXG5dKXsxLDZ9Jy8sXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhJywgJ2NsYXNzLW5hbWUnLCB7XG4gICAgJ2Fubm90YXRpb24nOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W14uXSlAXFx3Kyg/OlxccypcXC5cXHMqXFx3KykqLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgIH0sXG4gICAgJ2dlbmVyaWNzJzoge1xuICAgICAgcGF0dGVybjogLzwoPzpbXFx3XFxzLC4/XXwmKD8hJil8PCg/OltcXHdcXHMsLj9dfCYoPyEmKXw8KD86W1xcd1xccywuP118Jig/ISYpfDwoPzpbXFx3XFxzLC4/XXwmKD8hJikpKj4pKj4pKj4pKj4vLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdjbGFzcy1uYW1lJzogY2xhc3NOYW1lLFxuICAgICAgICAna2V5d29yZCc6IGtleXdvcmRzLFxuICAgICAgICAncHVuY3R1YXRpb24nOiAvWzw+KCksLjpdLyxcbiAgICAgICAgJ29wZXJhdG9yJzogL1s/JnxdL1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2ltcG9ydCc6IFt7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoLyhcXGJpbXBvcnRcXHMrKS8uc291cmNlICsgY2xhc3NOYW1lUHJlZml4ICsgLyg/OltBLVpdXFx3KnxcXCopKD89XFxzKjspLy5zb3VyY2UpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnbmFtZXNwYWNlJzogY2xhc3NOYW1lLmluc2lkZS5uYW1lc3BhY2UsXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9cXC4vLFxuICAgICAgICAnb3BlcmF0b3InOiAvXFwqLyxcbiAgICAgICAgJ2NsYXNzLW5hbWUnOiAvXFx3Ky9cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoLyhcXGJpbXBvcnRcXHMrc3RhdGljXFxzKykvLnNvdXJjZSArIGNsYXNzTmFtZVByZWZpeCArIC8oPzpcXHcrfFxcKikoPz1cXHMqOykvLnNvdXJjZSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6ICdzdGF0aWMnLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICduYW1lc3BhY2UnOiBjbGFzc05hbWUuaW5zaWRlLm5hbWVzcGFjZSxcbiAgICAgICAgJ3N0YXRpYyc6IC9cXGJcXHcrJC8sXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9cXC4vLFxuICAgICAgICAnb3BlcmF0b3InOiAvXFwqLyxcbiAgICAgICAgJ2NsYXNzLW5hbWUnOiAvXFx3Ky9cbiAgICAgIH1cbiAgICB9XSxcbiAgICAnbmFtZXNwYWNlJzoge1xuICAgICAgcGF0dGVybjogUmVnRXhwKC8oXFxiKD86ZXhwb3J0c3xpbXBvcnQoPzpcXHMrc3RhdGljKT98bW9kdWxlfG9wZW58b3BlbnN8cGFja2FnZXxwcm92aWRlc3xyZXF1aXJlc3x0b3x0cmFuc2l0aXZlfHVzZXN8d2l0aClcXHMrKSg/ITxrZXl3b3JkPilbYS16XVxcdyooPzpcXC5bYS16XVxcdyopKlxcLj8vLnNvdXJjZS5yZXBsYWNlKC88a2V5d29yZD4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ga2V5d29yZHMuc291cmNlO1xuICAgICAgfSkpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncHVuY3R1YXRpb24nOiAvXFwuL1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59KShQcmlzbSk7XG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIHZhciBzcGVjaWFsRXNjYXBlID0ge1xuICAgIHBhdHRlcm46IC9cXFxcW1xcXFwoKXt9W1xcXV4kKyo/fC5dLyxcbiAgICBhbGlhczogJ2VzY2FwZSdcbiAgfTtcbiAgdmFyIGVzY2FwZSA9IC9cXFxcKD86eFtcXGRhLWZBLUZdezJ9fHVbXFxkYS1mQS1GXXs0fXx1XFx7W1xcZGEtZkEtRl0rXFx9fDBbMC03XXswLDJ9fFsxMjNdWzAtN117Mn18Y1thLXpBLVpdfC4pLztcbiAgdmFyIGNoYXJTZXQgPSB7XG4gICAgcGF0dGVybjogL1xcLnxcXFxcW3dzZF18XFxcXHBcXHtbXnt9XStcXH0vaSxcbiAgICBhbGlhczogJ2NsYXNzLW5hbWUnXG4gIH07XG4gIHZhciBjaGFyU2V0V2l0aG91dERvdCA9IHtcbiAgICBwYXR0ZXJuOiAvXFxcXFt3c2RdfFxcXFxwXFx7W157fV0rXFx9L2ksXG4gICAgYWxpYXM6ICdjbGFzcy1uYW1lJ1xuICB9O1xuICB2YXIgcmFuZ2VDaGFyID0gJyg/OlteXFxcXFxcXFwtXXwnICsgZXNjYXBlLnNvdXJjZSArICcpJztcbiAgdmFyIHJhbmdlID0gUmVnRXhwKHJhbmdlQ2hhciArICctJyArIHJhbmdlQ2hhcik7XG5cbiAgLy8gdGhlIG5hbWUgb2YgYSBjYXB0dXJpbmcgZ3JvdXBcbiAgdmFyIGdyb3VwTmFtZSA9IHtcbiAgICBwYXR0ZXJuOiAvKDx8JylbXjw+J10rKD89Wz4nXSQpLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGFsaWFzOiAndmFyaWFibGUnXG4gIH07XG4gIFByaXNtLmxhbmd1YWdlcy5yZWdleCA9IHtcbiAgICAnY2hhci1jbGFzcyc6IHtcbiAgICAgIHBhdHRlcm46IC8oKD86XnxbXlxcXFxdKSg/OlxcXFxcXFxcKSopXFxbKD86W15cXFxcXFxdXXxcXFxcW1xcc1xcU10pKlxcXS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdjaGFyLWNsYXNzLW5lZ2F0aW9uJzoge1xuICAgICAgICAgIHBhdHRlcm46IC8oXlxcWylcXF4vLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgYWxpYXM6ICdvcGVyYXRvcidcbiAgICAgICAgfSxcbiAgICAgICAgJ2NoYXItY2xhc3MtcHVuY3R1YXRpb24nOiB7XG4gICAgICAgICAgcGF0dGVybjogL15cXFt8XFxdJC8sXG4gICAgICAgICAgYWxpYXM6ICdwdW5jdHVhdGlvbidcbiAgICAgICAgfSxcbiAgICAgICAgJ3JhbmdlJzoge1xuICAgICAgICAgIHBhdHRlcm46IHJhbmdlLFxuICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgJ2VzY2FwZSc6IGVzY2FwZSxcbiAgICAgICAgICAgICdyYW5nZS1wdW5jdHVhdGlvbic6IHtcbiAgICAgICAgICAgICAgcGF0dGVybjogLy0vLFxuICAgICAgICAgICAgICBhbGlhczogJ29wZXJhdG9yJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgJ3NwZWNpYWwtZXNjYXBlJzogc3BlY2lhbEVzY2FwZSxcbiAgICAgICAgJ2NoYXItc2V0JzogY2hhclNldFdpdGhvdXREb3QsXG4gICAgICAgICdlc2NhcGUnOiBlc2NhcGVcbiAgICAgIH1cbiAgICB9LFxuICAgICdzcGVjaWFsLWVzY2FwZSc6IHNwZWNpYWxFc2NhcGUsXG4gICAgJ2NoYXItc2V0JzogY2hhclNldCxcbiAgICAnYmFja3JlZmVyZW5jZSc6IFt7XG4gICAgICAvLyBhIGJhY2tyZWZlcmVuY2Ugd2hpY2ggaXMgbm90IGFuIG9jdGFsIGVzY2FwZVxuICAgICAgcGF0dGVybjogL1xcXFwoPyFbMTIzXVswLTddezJ9KVsxLTldLyxcbiAgICAgIGFsaWFzOiAna2V5d29yZCdcbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvXFxcXGs8W148PiddKz4vLFxuICAgICAgYWxpYXM6ICdrZXl3b3JkJyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnZ3JvdXAtbmFtZSc6IGdyb3VwTmFtZVxuICAgICAgfVxuICAgIH1dLFxuICAgICdhbmNob3InOiB7XG4gICAgICBwYXR0ZXJuOiAvWyReXXxcXFxcW0FCYkdael0vLFxuICAgICAgYWxpYXM6ICdmdW5jdGlvbidcbiAgICB9LFxuICAgICdlc2NhcGUnOiBlc2NhcGUsXG4gICAgJ2dyb3VwJzogW3tcbiAgICAgIC8vIGh0dHBzOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS8xMC9kb2NzL2FwaS9qYXZhL3V0aWwvcmVnZXgvUGF0dGVybi5odG1sXG4gICAgICAvLyBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy9kb3RuZXQvc3RhbmRhcmQvYmFzZS10eXBlcy9yZWd1bGFyLWV4cHJlc3Npb24tbGFuZ3VhZ2UtcXVpY2stcmVmZXJlbmNlP3ZpZXc9bmV0ZnJhbWV3b3JrLTQuNy4yI2dyb3VwaW5nLWNvbnN0cnVjdHNcblxuICAgICAgLy8gKCksICg/PG5hbWU+KSwgKD8nbmFtZScpLCAoPz4pLCAoPzopLCAoPz0pLCAoPyEpLCAoPzw9KSwgKD88ISksICg/aXMtbSksICg/aS1tOilcbiAgICAgIHBhdHRlcm46IC9cXCgoPzpcXD8oPzo8W148PiddKz58J1tePD4nXSsnfFs+Ol18PD9bPSFdfFtpZG1uc3V4VV0rKD86LVtpZG1uc3V4VV0rKT86PykpPy8sXG4gICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnZ3JvdXAtbmFtZSc6IGdyb3VwTmFtZVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHBhdHRlcm46IC9cXCkvLFxuICAgICAgYWxpYXM6ICdwdW5jdHVhdGlvbidcbiAgICB9XSxcbiAgICAncXVhbnRpZmllcic6IHtcbiAgICAgIHBhdHRlcm46IC8oPzpbKyo/XXxcXHtcXGQrKD86LFxcZCopP1xcfSlbPytdPy8sXG4gICAgICBhbGlhczogJ251bWJlcidcbiAgICB9LFxuICAgICdhbHRlcm5hdGlvbic6IHtcbiAgICAgIHBhdHRlcm46IC9cXHwvLFxuICAgICAgYWxpYXM6ICdrZXl3b3JkJ1xuICAgIH1cbiAgfTtcbn0pKFByaXNtKTtcblByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0ID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY2xpa2UnLCB7XG4gICdjbGFzcy1uYW1lJzogW1ByaXNtLmxhbmd1YWdlcy5jbGlrZVsnY2xhc3MtbmFtZSddLCB7XG4gICAgcGF0dGVybjogLyhefFteJFxcd1xceEEwLVxcdUZGRkZdKSg/IVxccylbXyRBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXC4oPzpjb25zdHJ1Y3Rvcnxwcm90b3R5cGUpKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9XSxcbiAgJ2tleXdvcmQnOiBbe1xuICAgIHBhdHRlcm46IC8oKD86XnxcXH0pXFxzKiljYXRjaFxcYi8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9LCB7XG4gICAgcGF0dGVybjogLyhefFteLl18XFwuXFwuXFwuXFxzKilcXGIoPzphc3xhc3NlcnQoPz1cXHMqXFx7KXxhc3luYyg/PVxccyooPzpmdW5jdGlvblxcYnxcXCh8WyRcXHdcXHhBMC1cXHVGRkZGXXwkKSl8YXdhaXR8YnJlYWt8Y2FzZXxjbGFzc3xjb25zdHxjb250aW51ZXxkZWJ1Z2dlcnxkZWZhdWx0fGRlbGV0ZXxkb3xlbHNlfGVudW18ZXhwb3J0fGV4dGVuZHN8ZmluYWxseSg/PVxccyooPzpcXHt8JCkpfGZvcnxmcm9tKD89XFxzKig/OlsnXCJdfCQpKXxmdW5jdGlvbnwoPzpnZXR8c2V0KSg/PVxccyooPzpbI1xcWyRcXHdcXHhBMC1cXHVGRkZGXXwkKSl8aWZ8aW1wbGVtZW50c3xpbXBvcnR8aW58aW5zdGFuY2VvZnxpbnRlcmZhY2V8bGV0fG5ld3xudWxsfG9mfHBhY2thZ2V8cHJpdmF0ZXxwcm90ZWN0ZWR8cHVibGljfHJldHVybnxzdGF0aWN8c3VwZXJ8c3dpdGNofHRoaXN8dGhyb3d8dHJ5fHR5cGVvZnx1bmRlZmluZWR8dmFyfHZvaWR8d2hpbGV8d2l0aHx5aWVsZClcXGIvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfV0sXG4gIC8vIEFsbG93IGZvciBhbGwgbm9uLUFTQ0lJIGNoYXJhY3RlcnMgKFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMDA4NDQ0KVxuICAnZnVuY3Rpb24nOiAvIz8oPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKig/OlxcLlxccyooPzphcHBseXxiaW5kfGNhbGwpXFxzKik/XFwoKS8sXG4gICdudW1iZXInOiB7XG4gICAgcGF0dGVybjogUmVnRXhwKC8oXnxbXlxcdyRdKS8uc291cmNlICsgJyg/OicgKyAoXG4gICAgLy8gY29uc3RhbnRcbiAgICAvTmFOfEluZmluaXR5Ly5zb3VyY2UgKyAnfCcgK1xuICAgIC8vIGJpbmFyeSBpbnRlZ2VyXG4gICAgLzBbYkJdWzAxXSsoPzpfWzAxXSspKm4/Ly5zb3VyY2UgKyAnfCcgK1xuICAgIC8vIG9jdGFsIGludGVnZXJcbiAgICAvMFtvT11bMC03XSsoPzpfWzAtN10rKSpuPy8uc291cmNlICsgJ3wnICtcbiAgICAvLyBoZXhhZGVjaW1hbCBpbnRlZ2VyXG4gICAgLzBbeFhdW1xcZEEtRmEtZl0rKD86X1tcXGRBLUZhLWZdKykqbj8vLnNvdXJjZSArICd8JyArXG4gICAgLy8gZGVjaW1hbCBiaWdpbnRcbiAgICAvXFxkKyg/Ol9cXGQrKSpuLy5zb3VyY2UgKyAnfCcgK1xuICAgIC8vIGRlY2ltYWwgbnVtYmVyIChpbnRlZ2VyIG9yIGZsb2F0KSBidXQgbm8gYmlnaW50XG4gICAgLyg/OlxcZCsoPzpfXFxkKykqKD86XFwuKD86XFxkKyg/Ol9cXGQrKSopPyk/fFxcLlxcZCsoPzpfXFxkKykqKSg/OltFZV1bKy1dP1xcZCsoPzpfXFxkKykqKT8vLnNvdXJjZSkgKyAnKScgKyAvKD8hW1xcdyRdKS8uc291cmNlKSxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sXG4gICdvcGVyYXRvcic6IC8tLXxcXCtcXCt8XFwqXFwqPT98PT58JiY9P3xcXHxcXHw9P3xbIT1dPT18PDw9P3w+Pj4/PT98Wy0rKi8lJnxeIT08Pl09P3xcXC57M318XFw/XFw/PT98XFw/XFwuP3xbfjpdL1xufSk7XG5QcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFsnY2xhc3MtbmFtZSddWzBdLnBhdHRlcm4gPSAvKFxcYig/OmNsYXNzfGV4dGVuZHN8aW1wbGVtZW50c3xpbnN0YW5jZW9mfGludGVyZmFjZXxuZXcpXFxzKylbXFx3LlxcXFxdKy87XG5QcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ2tleXdvcmQnLCB7XG4gICdyZWdleCc6IHtcbiAgICBwYXR0ZXJuOiBSZWdFeHAoXG4gICAgLy8gbG9va2JlaGluZFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvbm8tZHVwZS1jaGFyYWN0ZXJzLWNoYXJhY3Rlci1jbGFzc1xuICAgIC8oKD86XnxbXiRcXHdcXHhBMC1cXHVGRkZGLlwiJ1xcXSlcXHNdfFxcYig/OnJldHVybnx5aWVsZCkpXFxzKikvLnNvdXJjZSArXG4gICAgLy8gUmVnZXggcGF0dGVybjpcbiAgICAvLyBUaGVyZSBhcmUgMiByZWdleCBwYXR0ZXJucyBoZXJlLiBUaGUgUmVnRXhwIHNldCBub3RhdGlvbiBwcm9wb3NhbCBhZGRlZCBzdXBwb3J0IGZvciBuZXN0ZWQgY2hhcmFjdGVyXG4gICAgLy8gY2xhc3NlcyBpZiB0aGUgYHZgIGZsYWcgaXMgcHJlc2VudC4gVW5mb3J0dW5hdGVseSwgbmVzdGVkIENDcyBhcmUgYm90aCBjb250ZXh0LWZyZWUgYW5kIGluY29tcGF0aWJsZVxuICAgIC8vIHdpdGggdGhlIG9ubHkgc3ludGF4LCBzbyB3ZSBoYXZlIHRvIGRlZmluZSAyIGRpZmZlcmVudCByZWdleCBwYXR0ZXJucy5cbiAgICAvXFwvLy5zb3VyY2UgKyAnKD86JyArIC8oPzpcXFsoPzpbXlxcXVxcXFxcXHJcXG5dfFxcXFwuKSpcXF18XFxcXC58W14vXFxcXFxcW1xcclxcbl0pK1xcL1tkZ2lteXVzXXswLDd9Ly5zb3VyY2UgKyAnfCcgK1xuICAgIC8vIGB2YCBmbGFnIHN5bnRheC4gVGhpcyBzdXBwb3J0cyAzIGxldmVscyBvZiBuZXN0ZWQgY2hhcmFjdGVyIGNsYXNzZXMuXG4gICAgLyg/OlxcWyg/OlteW1xcXVxcXFxcXHJcXG5dfFxcXFwufFxcWyg/OlteW1xcXVxcXFxcXHJcXG5dfFxcXFwufFxcWyg/OlteW1xcXVxcXFxcXHJcXG5dfFxcXFwuKSpcXF0pKlxcXSkqXFxdfFxcXFwufFteL1xcXFxcXFtcXHJcXG5dKStcXC9bZGdpbXl1c117MCw3fXZbZGdpbXl1c117MCw3fS8uc291cmNlICsgJyknICtcbiAgICAvLyBsb29rYWhlYWRcbiAgICAvKD89KD86XFxzfFxcL1xcKig/OlteKl18XFwqKD8hXFwvKSkqXFwqXFwvKSooPzokfFtcXHJcXG4sLjs6fSlcXF1dfFxcL1xcLykpLy5zb3VyY2UpLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ3JlZ2V4LXNvdXJjZSc6IHtcbiAgICAgICAgcGF0dGVybjogL14oXFwvKVtcXHNcXFNdKyg/PVxcL1thLXpdKiQpLyxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgYWxpYXM6ICdsYW5ndWFnZS1yZWdleCcsXG4gICAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLnJlZ2V4XG4gICAgICB9LFxuICAgICAgJ3JlZ2V4LWRlbGltaXRlcic6IC9eXFwvfFxcLyQvLFxuICAgICAgJ3JlZ2V4LWZsYWdzJzogL15bYS16XSskL1xuICAgIH1cbiAgfSxcbiAgLy8gVGhpcyBtdXN0IGJlIGRlY2xhcmVkIGJlZm9yZSBrZXl3b3JkIGJlY2F1c2Ugd2UgdXNlIFwiZnVuY3Rpb25cIiBpbnNpZGUgdGhlIGxvb2stZm9yd2FyZFxuICAnZnVuY3Rpb24tdmFyaWFibGUnOiB7XG4gICAgcGF0dGVybjogLyM/KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccypbPTpdXFxzKig/OmFzeW5jXFxzKik/KD86XFxiZnVuY3Rpb25cXGJ8KD86XFwoKD86W14oKV18XFwoW14oKV0qXFwpKSpcXCl8KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKilcXHMqPT4pKS8sXG4gICAgYWxpYXM6ICdmdW5jdGlvbidcbiAgfSxcbiAgJ3BhcmFtZXRlcic6IFt7XG4gICAgcGF0dGVybjogLyhmdW5jdGlvbig/OlxccysoPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKT9cXHMqXFwoXFxzKikoPyFcXHMpKD86W14oKVxcc118XFxzKyg/IVtcXHMpXSl8XFwoW14oKV0qXFwpKSsoPz1cXHMqXFwpKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvKF58W14kXFx3XFx4QTAtXFx1RkZGRl0pKD8hXFxzKVtfJGEtelxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccyo9PikvaSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcbiAgfSwge1xuICAgIHBhdHRlcm46IC8oXFwoXFxzKikoPyFcXHMpKD86W14oKVxcc118XFxzKyg/IVtcXHMpXSl8XFwoW14oKV0qXFwpKSsoPz1cXHMqXFwpXFxzKj0+KS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvKCg/OlxcYnxcXHN8XikoPyEoPzphc3xhc3luY3xhd2FpdHxicmVha3xjYXNlfGNhdGNofGNsYXNzfGNvbnN0fGNvbnRpbnVlfGRlYnVnZ2VyfGRlZmF1bHR8ZGVsZXRlfGRvfGVsc2V8ZW51bXxleHBvcnR8ZXh0ZW5kc3xmaW5hbGx5fGZvcnxmcm9tfGZ1bmN0aW9ufGdldHxpZnxpbXBsZW1lbnRzfGltcG9ydHxpbnxpbnN0YW5jZW9mfGludGVyZmFjZXxsZXR8bmV3fG51bGx8b2Z8cGFja2FnZXxwcml2YXRlfHByb3RlY3RlZHxwdWJsaWN8cmV0dXJufHNldHxzdGF0aWN8c3VwZXJ8c3dpdGNofHRoaXN8dGhyb3d8dHJ5fHR5cGVvZnx1bmRlZmluZWR8dmFyfHZvaWR8d2hpbGV8d2l0aHx5aWVsZCkoPyFbJFxcd1xceEEwLVxcdUZGRkZdKSkoPzooPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqXFxzKilcXChcXHMqfFxcXVxccypcXChcXHMqKSg/IVxccykoPzpbXigpXFxzXXxcXHMrKD8hW1xccyldKXxcXChbXigpXSpcXCkpKyg/PVxccypcXClcXHMqXFx7KS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG4gIH1dLFxuICAnY29uc3RhbnQnOiAvXFxiW0EtWl0oPzpbQS1aX118XFxkeD8pKlxcYi9cbn0pO1xuUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdzdHJpbmcnLCB7XG4gICdoYXNoYmFuZyc6IHtcbiAgICBwYXR0ZXJuOiAvXiMhLiovLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBhbGlhczogJ2NvbW1lbnQnXG4gIH0sXG4gICd0ZW1wbGF0ZS1zdHJpbmcnOiB7XG4gICAgcGF0dGVybjogL2AoPzpcXFxcW1xcc1xcU118XFwkXFx7KD86W157fV18XFx7KD86W157fV18XFx7W159XSpcXH0pKlxcfSkrXFx9fCg/IVxcJFxceylbXlxcXFxgXSkqYC8sXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ3RlbXBsYXRlLXB1bmN0dWF0aW9uJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXmB8YCQvLFxuICAgICAgICBhbGlhczogJ3N0cmluZydcbiAgICAgIH0sXG4gICAgICAnaW50ZXJwb2xhdGlvbic6IHtcbiAgICAgICAgcGF0dGVybjogLygoPzpefFteXFxcXF0pKD86XFxcXHsyfSkqKVxcJFxceyg/Oltee31dfFxceyg/Oltee31dfFxce1tefV0qXFx9KSpcXH0pK1xcfS8sXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgICdpbnRlcnBvbGF0aW9uLXB1bmN0dWF0aW9uJzoge1xuICAgICAgICAgICAgcGF0dGVybjogL15cXCRcXHt8XFx9JC8sXG4gICAgICAgICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzdDogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICdzdHJpbmcnOiAvW1xcc1xcU10rL1xuICAgIH1cbiAgfSxcbiAgJ3N0cmluZy1wcm9wZXJ0eSc6IHtcbiAgICBwYXR0ZXJuOiAvKCg/Ol58Wyx7XSlbIFxcdF0qKShbXCInXSkoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXwoPyFcXDIpW15cXFxcXFxyXFxuXSkqXFwyKD89XFxzKjopL20sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgYWxpYXM6ICdwcm9wZXJ0eSdcbiAgfVxufSk7XG5QcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ29wZXJhdG9yJywge1xuICAnbGl0ZXJhbC1wcm9wZXJ0eSc6IHtcbiAgICBwYXR0ZXJuOiAvKCg/Ol58Wyx7XSlbIFxcdF0qKSg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqOikvbSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGFsaWFzOiAncHJvcGVydHknXG4gIH1cbn0pO1xuaWYgKFByaXNtLmxhbmd1YWdlcy5tYXJrdXApIHtcbiAgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuYWRkSW5saW5lZCgnc2NyaXB0JywgJ2phdmFzY3JpcHQnKTtcblxuICAvLyBhZGQgYXR0cmlidXRlIHN1cHBvcnQgZm9yIGFsbCBET00gZXZlbnRzLlxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHMjU3RhbmRhcmRfZXZlbnRzXG4gIFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLmFkZEF0dHJpYnV0ZSgvb24oPzphYm9ydHxibHVyfGNoYW5nZXxjbGlja3xjb21wb3NpdGlvbig/OmVuZHxzdGFydHx1cGRhdGUpfGRibGNsaWNrfGVycm9yfGZvY3VzKD86aW58b3V0KT98a2V5KD86ZG93bnx1cCl8bG9hZHxtb3VzZSg/OmRvd258ZW50ZXJ8bGVhdmV8bW92ZXxvdXR8b3Zlcnx1cCl8cmVzZXR8cmVzaXplfHNjcm9sbHxzZWxlY3R8c2xvdGNoYW5nZXxzdWJtaXR8dW5sb2FkfHdoZWVsKS8uc291cmNlLCAnamF2YXNjcmlwdCcpO1xufVxuUHJpc20ubGFuZ3VhZ2VzLmpzID0gUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQ7XG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIHZhciBqYXZhc2NyaXB0ID0gUHJpc20udXRpbC5jbG9uZShQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCk7XG4gIHZhciBzcGFjZSA9IC8oPzpcXHN8XFwvXFwvLiooPyEuKXxcXC9cXCooPzpbXipdfFxcKig/IVxcLykpXFwqXFwvKS8uc291cmNlO1xuICB2YXIgYnJhY2VzID0gLyg/Olxceyg/Olxceyg/Olxce1tee31dKlxcfXxbXnt9XSkqXFx9fFtee31dKSpcXH0pLy5zb3VyY2U7XG4gIHZhciBzcHJlYWQgPSAvKD86XFx7PFM+KlxcLnszfSg/Oltee31dfDxCUkFDRVM+KSpcXH0pLy5zb3VyY2U7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmbGFnc11cbiAgICovXG4gIGZ1bmN0aW9uIHJlKHNvdXJjZSwgZmxhZ3MpIHtcbiAgICBzb3VyY2UgPSBzb3VyY2UucmVwbGFjZSgvPFM+L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzcGFjZTtcbiAgICB9KS5yZXBsYWNlKC88QlJBQ0VTPi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYnJhY2VzO1xuICAgIH0pLnJlcGxhY2UoLzxTUFJFQUQ+L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzcHJlYWQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIFJlZ0V4cChzb3VyY2UsIGZsYWdzKTtcbiAgfVxuICBzcHJlYWQgPSByZShzcHJlYWQpLnNvdXJjZTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmpzeCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ21hcmt1cCcsIGphdmFzY3JpcHQpO1xuICBQcmlzbS5sYW5ndWFnZXMuanN4LnRhZy5wYXR0ZXJuID0gcmUoLzxcXC8/KD86W1xcdy46LV0rKD86PFM+Kyg/OltcXHcuOiQtXSsoPzo9KD86XCIoPzpcXFxcW1xcc1xcU118W15cXFxcXCJdKSpcInwnKD86XFxcXFtcXHNcXFNdfFteXFxcXCddKSonfFteXFxzeydcIi8+PV0rfDxCUkFDRVM+KSk/fDxTUFJFQUQ+KSkqPFM+KlxcLz8pPz4vLnNvdXJjZSk7XG4gIFByaXNtLmxhbmd1YWdlcy5qc3gudGFnLmluc2lkZVsndGFnJ10ucGF0dGVybiA9IC9ePFxcLz9bXlxccz5cXC9dKi87XG4gIFByaXNtLmxhbmd1YWdlcy5qc3gudGFnLmluc2lkZVsnYXR0ci12YWx1ZSddLnBhdHRlcm4gPSAvPSg/IVxceykoPzpcIig/OlxcXFxbXFxzXFxTXXxbXlxcXFxcIl0pKlwifCcoPzpcXFxcW1xcc1xcU118W15cXFxcJ10pKid8W15cXHMnXCI+XSspLztcbiAgUHJpc20ubGFuZ3VhZ2VzLmpzeC50YWcuaW5zaWRlWyd0YWcnXS5pbnNpZGVbJ2NsYXNzLW5hbWUnXSA9IC9eW0EtWl1cXHcqKD86XFwuW0EtWl1cXHcqKSokLztcbiAgUHJpc20ubGFuZ3VhZ2VzLmpzeC50YWcuaW5zaWRlWydjb21tZW50J10gPSBqYXZhc2NyaXB0Wydjb21tZW50J107XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2luc2lkZScsICdhdHRyLW5hbWUnLCB7XG4gICAgJ3NwcmVhZCc6IHtcbiAgICAgIHBhdHRlcm46IHJlKC88U1BSRUFEPi8uc291cmNlKSxcbiAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmpzeFxuICAgIH1cbiAgfSwgUHJpc20ubGFuZ3VhZ2VzLmpzeC50YWcpO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdpbnNpZGUnLCAnc3BlY2lhbC1hdHRyJywge1xuICAgICdzY3JpcHQnOiB7XG4gICAgICAvLyBBbGxvdyBmb3IgdHdvIGxldmVscyBvZiBuZXN0aW5nXG4gICAgICBwYXR0ZXJuOiByZSgvPTxCUkFDRVM+Ly5zb3VyY2UpLFxuICAgICAgYWxpYXM6ICdsYW5ndWFnZS1qYXZhc2NyaXB0JyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnc2NyaXB0LXB1bmN0dWF0aW9uJzoge1xuICAgICAgICAgIHBhdHRlcm46IC9ePSg/PVxceykvLFxuICAgICAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gICAgICAgIH0sXG4gICAgICAgIHJlc3Q6IFByaXNtLmxhbmd1YWdlcy5qc3hcbiAgICAgIH1cbiAgICB9XG4gIH0sIFByaXNtLmxhbmd1YWdlcy5qc3gudGFnKTtcblxuICAvLyBUaGUgZm9sbG93aW5nIHdpbGwgaGFuZGxlIHBsYWluIHRleHQgaW5zaWRlIHRhZ3NcbiAgdmFyIHN0cmluZ2lmeVRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRva2VuLmNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdG9rZW4uY29udGVudDtcbiAgICB9XG4gICAgcmV0dXJuIHRva2VuLmNvbnRlbnQubWFwKHN0cmluZ2lmeVRva2VuKS5qb2luKCcnKTtcbiAgfTtcbiAgdmFyIHdhbGtUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW5zKSB7XG4gICAgdmFyIG9wZW5lZFRhZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgdmFyIG5vdFRhZ05vckJyYWNlID0gZmFsc2U7XG4gICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RhZycgJiYgdG9rZW4uY29udGVudFswXSAmJiB0b2tlbi5jb250ZW50WzBdLnR5cGUgPT09ICd0YWcnKSB7XG4gICAgICAgICAgLy8gV2UgZm91bmQgYSB0YWcsIG5vdyBmaW5kIGl0cyBraW5kXG5cbiAgICAgICAgICBpZiAodG9rZW4uY29udGVudFswXS5jb250ZW50WzBdLmNvbnRlbnQgPT09ICc8LycpIHtcbiAgICAgICAgICAgIC8vIENsb3NpbmcgdGFnXG4gICAgICAgICAgICBpZiAob3BlbmVkVGFncy5sZW5ndGggPiAwICYmIG9wZW5lZFRhZ3Nbb3BlbmVkVGFncy5sZW5ndGggLSAxXS50YWdOYW1lID09PSBzdHJpbmdpZnlUb2tlbih0b2tlbi5jb250ZW50WzBdLmNvbnRlbnRbMV0pKSB7XG4gICAgICAgICAgICAgIC8vIFBvcCBtYXRjaGluZyBvcGVuaW5nIHRhZ1xuICAgICAgICAgICAgICBvcGVuZWRUYWdzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodG9rZW4uY29udGVudFt0b2tlbi5jb250ZW50Lmxlbmd0aCAtIDFdLmNvbnRlbnQgPT09ICcvPicpIDsgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIE9wZW5pbmcgdGFnXG4gICAgICAgICAgICAgIG9wZW5lZFRhZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgdGFnTmFtZTogc3RyaW5naWZ5VG9rZW4odG9rZW4uY29udGVudFswXS5jb250ZW50WzFdKSxcbiAgICAgICAgICAgICAgICBvcGVuZWRCcmFjZXM6IDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9wZW5lZFRhZ3MubGVuZ3RoID4gMCAmJiB0b2tlbi50eXBlID09PSAncHVuY3R1YXRpb24nICYmIHRva2VuLmNvbnRlbnQgPT09ICd7Jykge1xuICAgICAgICAgIC8vIEhlcmUgd2UgbWlnaHQgaGF2ZSBlbnRlcmVkIGEgSlNYIGNvbnRleHQgaW5zaWRlIGEgdGFnXG4gICAgICAgICAgb3BlbmVkVGFnc1tvcGVuZWRUYWdzLmxlbmd0aCAtIDFdLm9wZW5lZEJyYWNlcysrO1xuICAgICAgICB9IGVsc2UgaWYgKG9wZW5lZFRhZ3MubGVuZ3RoID4gMCAmJiBvcGVuZWRUYWdzW29wZW5lZFRhZ3MubGVuZ3RoIC0gMV0ub3BlbmVkQnJhY2VzID4gMCAmJiB0b2tlbi50eXBlID09PSAncHVuY3R1YXRpb24nICYmIHRva2VuLmNvbnRlbnQgPT09ICd9Jykge1xuICAgICAgICAgIC8vIEhlcmUgd2UgbWlnaHQgaGF2ZSBsZWZ0IGEgSlNYIGNvbnRleHQgaW5zaWRlIGEgdGFnXG4gICAgICAgICAgb3BlbmVkVGFnc1tvcGVuZWRUYWdzLmxlbmd0aCAtIDFdLm9wZW5lZEJyYWNlcy0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vdFRhZ05vckJyYWNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vdFRhZ05vckJyYWNlIHx8IHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKG9wZW5lZFRhZ3MubGVuZ3RoID4gMCAmJiBvcGVuZWRUYWdzW29wZW5lZFRhZ3MubGVuZ3RoIC0gMV0ub3BlbmVkQnJhY2VzID09PSAwKSB7XG4gICAgICAgICAgLy8gSGVyZSB3ZSBhcmUgaW5zaWRlIGEgdGFnLCBhbmQgbm90IGluc2lkZSBhIEpTWCBjb250ZXh0LlxuICAgICAgICAgIC8vIFRoYXQncyBwbGFpbiB0ZXh0OiBkcm9wIGFueSB0b2tlbnMgbWF0Y2hlZC5cbiAgICAgICAgICB2YXIgcGxhaW5UZXh0ID0gc3RyaW5naWZ5VG9rZW4odG9rZW4pO1xuXG4gICAgICAgICAgLy8gQW5kIG1lcmdlIHRleHQgd2l0aCBhZGphY2VudCB0ZXh0XG4gICAgICAgICAgaWYgKGkgPCB0b2tlbnMubGVuZ3RoIC0gMSAmJiAodHlwZW9mIHRva2Vuc1tpICsgMV0gPT09ICdzdHJpbmcnIHx8IHRva2Vuc1tpICsgMV0udHlwZSA9PT0gJ3BsYWluLXRleHQnKSkge1xuICAgICAgICAgICAgcGxhaW5UZXh0ICs9IHN0cmluZ2lmeVRva2VuKHRva2Vuc1tpICsgMV0pO1xuICAgICAgICAgICAgdG9rZW5zLnNwbGljZShpICsgMSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpID4gMCAmJiAodHlwZW9mIHRva2Vuc1tpIC0gMV0gPT09ICdzdHJpbmcnIHx8IHRva2Vuc1tpIC0gMV0udHlwZSA9PT0gJ3BsYWluLXRleHQnKSkge1xuICAgICAgICAgICAgcGxhaW5UZXh0ID0gc3RyaW5naWZ5VG9rZW4odG9rZW5zW2kgLSAxXSkgKyBwbGFpblRleHQ7XG4gICAgICAgICAgICB0b2tlbnMuc3BsaWNlKGkgLSAxLCAxKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9rZW5zW2ldID0gbmV3IFByaXNtLlRva2VuKCdwbGFpbi10ZXh0JywgcGxhaW5UZXh0LCBudWxsLCBwbGFpblRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4uY29udGVudCAmJiB0eXBlb2YgdG9rZW4uY29udGVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgd2Fsa1Rva2Vucyh0b2tlbi5jb250ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFByaXNtLmhvb2tzLmFkZCgnYWZ0ZXItdG9rZW5pemUnLCBmdW5jdGlvbiAoZW52KSB7XG4gICAgaWYgKGVudi5sYW5ndWFnZSAhPT0gJ2pzeCcgJiYgZW52Lmxhbmd1YWdlICE9PSAndHN4Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3YWxrVG9rZW5zKGVudi50b2tlbnMpO1xuICB9KTtcbn0pKFByaXNtKTtcblxuLy8gaHR0cHM6Ly93d3cuanNvbi5vcmcvanNvbi1lbi5odG1sXG5QcmlzbS5sYW5ndWFnZXMuanNvbiA9IHtcbiAgJ3Byb3BlcnR5Jzoge1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKVwiKD86XFxcXC58W15cXFxcXCJcXHJcXG5dKSpcIig/PVxccyo6KS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ3N0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSlcIig/OlxcXFwufFteXFxcXFwiXFxyXFxuXSkqXCIoPyFcXHMqOikvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdjb21tZW50Jzoge1xuICAgIHBhdHRlcm46IC9cXC9cXC8uKnxcXC9cXCpbXFxzXFxTXSo/KD86XFwqXFwvfCQpLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ251bWJlcic6IC8tP1xcYlxcZCsoPzpcXC5cXGQrKT8oPzplWystXT9cXGQrKT9cXGIvaSxcbiAgJ3B1bmN0dWF0aW9uJzogL1t7fVtcXF0sXS8sXG4gICdvcGVyYXRvcic6IC86LyxcbiAgJ2Jvb2xlYW4nOiAvXFxiKD86ZmFsc2V8dHJ1ZSlcXGIvLFxuICAnbnVsbCc6IHtcbiAgICBwYXR0ZXJuOiAvXFxibnVsbFxcYi8sXG4gICAgYWxpYXM6ICdrZXl3b3JkJ1xuICB9XG59O1xuUHJpc20ubGFuZ3VhZ2VzLndlYm1hbmlmZXN0ID0gUHJpc20ubGFuZ3VhZ2VzLmpzb247XG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIFByaXNtLmxhbmd1YWdlcy5rb3RsaW4gPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjbGlrZScsIHtcbiAgICAna2V5d29yZCc6IHtcbiAgICAgIC8vIFRoZSBsb29rYmVoaW5kIHByZXZlbnRzIHdyb25nIGhpZ2hsaWdodGluZyBvZiBlLmcuIGtvdGxpbi5wcm9wZXJ0aWVzLmdldFxuICAgICAgcGF0dGVybjogLyhefFteLl0pXFxiKD86YWJzdHJhY3R8YWN0dWFsfGFubm90YXRpb258YXN8YnJlYWt8Ynl8Y2F0Y2h8Y2xhc3N8Y29tcGFuaW9ufGNvbnN0fGNvbnN0cnVjdG9yfGNvbnRpbnVlfGNyb3NzaW5saW5lfGRhdGF8ZG98ZHluYW1pY3xlbHNlfGVudW18ZXhwZWN0fGV4dGVybmFsfGZpbmFsfGZpbmFsbHl8Zm9yfGZ1bnxnZXR8aWZ8aW1wb3J0fGlufGluZml4fGluaXR8aW5saW5lfGlubmVyfGludGVyZmFjZXxpbnRlcm5hbHxpc3xsYXRlaW5pdHxub2lubGluZXxudWxsfG9iamVjdHxvcGVufG9wZXJhdG9yfG91dHxvdmVycmlkZXxwYWNrYWdlfHByaXZhdGV8cHJvdGVjdGVkfHB1YmxpY3xyZWlmaWVkfHJldHVybnxzZWFsZWR8c2V0fHN1cGVyfHN1c3BlbmR8dGFpbHJlY3x0aGlzfHRocm93fHRvfHRyeXx0eXBlYWxpYXN8dmFsfHZhcnx2YXJhcmd8d2hlbnx3aGVyZXx3aGlsZSlcXGIvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgJ2Z1bmN0aW9uJzogW3tcbiAgICAgIHBhdHRlcm46IC8oPzpgW15cXHJcXG5gXStgfFxcYlxcdyspKD89XFxzKlxcKCkvLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSwge1xuICAgICAgcGF0dGVybjogLyhcXC4pKD86YFteXFxyXFxuYF0rYHxcXHcrKSg/PVxccypcXHspLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9XSxcbiAgICAnbnVtYmVyJzogL1xcYig/OjBbeFhdW1xcZGEtZkEtRl0rKD86X1tcXGRhLWZBLUZdKykqfDBbYkJdWzAxXSsoPzpfWzAxXSspKnxcXGQrKD86X1xcZCspKig/OlxcLlxcZCsoPzpfXFxkKykqKT8oPzpbZUVdWystXT9cXGQrKD86X1xcZCspKik/W2ZGTF0/KVxcYi8sXG4gICAgJ29wZXJhdG9yJzogL1xcK1srPV0/fC1bLT0+XT98PT0/PT98ISg/OiF8PT0/KT98W1xcLyolPD5dPT98Wz86XTo/fFxcLlxcLnwmJnxcXHxcXHx8XFxiKD86YW5kfGludnxvcnxzaGx8c2hyfHVzaHJ8eG9yKVxcYi9cbiAgfSk7XG4gIGRlbGV0ZSBQcmlzbS5sYW5ndWFnZXMua290bGluWydjbGFzcy1uYW1lJ107XG4gIHZhciBpbnRlcnBvbGF0aW9uSW5zaWRlID0ge1xuICAgICdpbnRlcnBvbGF0aW9uLXB1bmN0dWF0aW9uJzoge1xuICAgICAgcGF0dGVybjogL15cXCRcXHs/fFxcfSQvLFxuICAgICAgYWxpYXM6ICdwdW5jdHVhdGlvbidcbiAgICB9LFxuICAgICdleHByZXNzaW9uJzoge1xuICAgICAgcGF0dGVybjogL1tcXHNcXFNdKy8sXG4gICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5rb3RsaW5cbiAgICB9XG4gIH07XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2tvdGxpbicsICdzdHJpbmcnLCB7XG4gICAgLy8gaHR0cHM6Ly9rb3RsaW5sYW5nLm9yZy9zcGVjL2V4cHJlc3Npb25zLmh0bWwjc3RyaW5nLWludGVycG9sYXRpb24tZXhwcmVzc2lvbnNcbiAgICAnc3RyaW5nLWxpdGVyYWwnOiBbe1xuICAgICAgcGF0dGVybjogL1wiXCJcIig/OlteJF18XFwkKD86KD8hXFx7KXxcXHtbXnt9XSpcXH0pKSo/XCJcIlwiLyxcbiAgICAgIGFsaWFzOiAnbXVsdGlsaW5lJyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnaW50ZXJwb2xhdGlvbic6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvXFwkKD86W2Etel9dXFx3KnxcXHtbXnt9XSpcXH0pL2ksXG4gICAgICAgICAgaW5zaWRlOiBpbnRlcnBvbGF0aW9uSW5zaWRlXG4gICAgICAgIH0sXG4gICAgICAgICdzdHJpbmcnOiAvW1xcc1xcU10rL1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHBhdHRlcm46IC9cIig/OlteXCJcXFxcXFxyXFxuJF18XFxcXC58XFwkKD86KD8hXFx7KXxcXHtbXnt9XSpcXH0pKSpcIi8sXG4gICAgICBhbGlhczogJ3NpbmdsZWxpbmUnLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdpbnRlcnBvbGF0aW9uJzoge1xuICAgICAgICAgIHBhdHRlcm46IC8oKD86XnxbXlxcXFxdKSg/OlxcXFx7Mn0pKilcXCQoPzpbYS16X11cXHcqfFxce1tee31dKlxcfSkvaSxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGluc2lkZTogaW50ZXJwb2xhdGlvbkluc2lkZVxuICAgICAgICB9LFxuICAgICAgICAnc3RyaW5nJzogL1tcXHNcXFNdKy9cbiAgICAgIH1cbiAgICB9XSxcbiAgICAnY2hhcic6IHtcbiAgICAgIC8vIGh0dHBzOi8va290bGlubGFuZy5vcmcvc3BlYy9leHByZXNzaW9ucy5odG1sI2NoYXJhY3Rlci1saXRlcmFsc1xuICAgICAgcGF0dGVybjogLycoPzpbXidcXFxcXFxyXFxuXXxcXFxcKD86Lnx1W2EtZkEtRjAtOV17MCw0fSkpJy8sXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9XG4gIH0pO1xuICBkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLmtvdGxpblsnc3RyaW5nJ107XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2tvdGxpbicsICdrZXl3b3JkJywge1xuICAgICdhbm5vdGF0aW9uJzoge1xuICAgICAgcGF0dGVybjogL1xcQkAoPzpcXHcrOik/KD86W0EtWl1cXHcqfFxcW1teXFxdXStcXF0pLyxcbiAgICAgIGFsaWFzOiAnYnVpbHRpbidcbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdrb3RsaW4nLCAnZnVuY3Rpb24nLCB7XG4gICAgJ2xhYmVsJzoge1xuICAgICAgcGF0dGVybjogL1xcYlxcdytAfEBcXHcrXFxiLyxcbiAgICAgIGFsaWFzOiAnc3ltYm9sJ1xuICAgIH1cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5rdCA9IFByaXNtLmxhbmd1YWdlcy5rb3RsaW47XG4gIFByaXNtLmxhbmd1YWdlcy5rdHMgPSBQcmlzbS5sYW5ndWFnZXMua290bGluO1xufSkoUHJpc20pO1xuXG4vKiBGSVhNRSA6XG4gOmV4dGVuZCgpIGlzIG5vdCBoYW5kbGVkIHNwZWNpZmljYWxseSA6IGl0cyBoaWdobGlnaHRpbmcgaXMgYnVnZ3kuXG4gTWl4aW4gdXNhZ2UgbXVzdCBiZSBpbnNpZGUgYSBydWxlc2V0IHRvIGJlIGhpZ2hsaWdodGVkLlxuIEF0LXJ1bGVzIChlLmcuIGltcG9ydCkgY29udGFpbmluZyBpbnRlcnBvbGF0aW9ucyBhcmUgYnVnZ3kuXG4gRGV0YWNoZWQgcnVsZXNldHMgYXJlIGhpZ2hsaWdodGVkIGFzIGF0LXJ1bGVzLlxuIEEgY29tbWVudCBiZWZvcmUgYSBtaXhpbiB1c2FnZSBwcmV2ZW50cyB0aGUgbGF0dGVyIHRvIGJlIHByb3Blcmx5IGhpZ2hsaWdodGVkLlxuICovXG5cblByaXNtLmxhbmd1YWdlcy5sZXNzID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY3NzJywge1xuICAnY29tbWVudCc6IFsvXFwvXFwqW1xcc1xcU10qP1xcKlxcLy8sIHtcbiAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSlcXC9cXC8uKi8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9XSxcbiAgJ2F0cnVsZSc6IHtcbiAgICBwYXR0ZXJuOiAvQFtcXHctXSg/OlxcKCg/OlteKCl7fV18XFwoW14oKXt9XSpcXCkpKlxcKXxbXigpe307XFxzXXxcXHMrKD8hXFxzKSkqPyg/PVxccypcXHspLyxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdwdW5jdHVhdGlvbic6IC9bOigpXS9cbiAgICB9XG4gIH0sXG4gIC8vIHNlbGVjdG9ycyBhbmQgbWl4aW5zIGFyZSBjb25zaWRlcmVkIHRoZSBzYW1lXG4gICdzZWxlY3Rvcic6IHtcbiAgICBwYXR0ZXJuOiAvKD86QFxce1tcXHctXStcXH18W157fTtcXHNAXSkoPzpAXFx7W1xcdy1dK1xcfXxcXCgoPzpbXigpe31dfFxcKFteKCl7fV0qXFwpKSpcXCl8W14oKXt9O0BcXHNdfFxccysoPyFcXHMpKSo/KD89XFxzKlxceykvLFxuICAgIGluc2lkZToge1xuICAgICAgLy8gbWl4aW4gcGFyYW1ldGVyc1xuICAgICAgJ3ZhcmlhYmxlJzogL0ArW1xcdy1dKy9cbiAgICB9XG4gIH0sXG4gICdwcm9wZXJ0eSc6IC8oPzpAXFx7W1xcdy1dK1xcfXxbXFx3LV0pKyg/OlxcK18/KT8oPz1cXHMqOikvLFxuICAnb3BlcmF0b3InOiAvWytcXC0qXFwvXS9cbn0pO1xuUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbGVzcycsICdwcm9wZXJ0eScsIHtcbiAgJ3ZhcmlhYmxlJzogW1xuICAvLyBWYXJpYWJsZSBkZWNsYXJhdGlvbiAodGhlIGNvbG9uIG11c3QgYmUgY29uc3VtZWQhKVxuICB7XG4gICAgcGF0dGVybjogL0BbXFx3LV0rXFxzKjovLFxuICAgIGluc2lkZToge1xuICAgICAgJ3B1bmN0dWF0aW9uJzogLzovXG4gICAgfVxuICB9LFxuICAvLyBWYXJpYWJsZSB1c2FnZVxuICAvQEA/W1xcdy1dKy9dLFxuICAnbWl4aW4tdXNhZ2UnOiB7XG4gICAgcGF0dGVybjogLyhbeztdXFxzKilbLiNdKD8hXFxkKVtcXHctXS4qPyg/PVsoO10pLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGFsaWFzOiAnZnVuY3Rpb24nXG4gIH1cbn0pO1xuUHJpc20ubGFuZ3VhZ2VzLmx1YSA9IHtcbiAgJ2NvbW1lbnQnOiAvXiMhLit8LS0oPzpcXFsoPSopXFxbW1xcc1xcU10qP1xcXVxcMVxcXXwuKikvbSxcbiAgLy8gXFx6IG1heSBiZSB1c2VkIHRvIHNraXAgdGhlIGZvbGxvd2luZyBzcGFjZVxuICAnc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC8oW1wiJ10pKD86KD8hXFwxKVteXFxcXFxcclxcbl18XFxcXHooPzpcXHJcXG58XFxzKXxcXFxcKD86XFxyXFxufFteel0pKSpcXDF8XFxbKD0qKVxcW1tcXHNcXFNdKj9cXF1cXDJcXF0vLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnbnVtYmVyJzogL1xcYjB4W2EtZlxcZF0rKD86XFwuW2EtZlxcZF0qKT8oPzpwWystXT9cXGQrKT9cXGJ8XFxiXFxkKyg/OlxcLlxcQnwoPzpcXC5cXGQqKT8oPzplWystXT9cXGQrKT9cXGIpfFxcQlxcLlxcZCsoPzplWystXT9cXGQrKT9cXGIvaSxcbiAgJ2tleXdvcmQnOiAvXFxiKD86YW5kfGJyZWFrfGRvfGVsc2V8ZWxzZWlmfGVuZHxmYWxzZXxmb3J8ZnVuY3Rpb258Z290b3xpZnxpbnxsb2NhbHxuaWx8bm90fG9yfHJlcGVhdHxyZXR1cm58dGhlbnx0cnVlfHVudGlsfHdoaWxlKVxcYi8sXG4gICdmdW5jdGlvbic6IC8oPyFcXGQpXFx3Kyg/PVxccyooPzpbKHtdKSkvLFxuICAnb3BlcmF0b3InOiBbL1stKyolXiZ8I118XFwvXFwvP3w8Wzw9XT98Pls+PV0/fFs9fl09Py8sIHtcbiAgICAvLyBNYXRjaCBcIi4uXCIgYnV0IGRvbid0IGJyZWFrIFwiLi4uXCJcbiAgICBwYXR0ZXJuOiAvKF58W14uXSlcXC5cXC4oPyFcXC4pLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH1dLFxuICAncHVuY3R1YXRpb24nOiAvW1xcW1xcXSgpe30sO118XFwuK3w6Ky9cbn07XG5QcmlzbS5sYW5ndWFnZXMubWFrZWZpbGUgPSB7XG4gICdjb21tZW50Jzoge1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKSMoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXlxcXFxcXHJcXG5dKSovLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSxcbiAgJ3N0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvKFtcIiddKSg/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfCg/IVxcMSlbXlxcXFxcXHJcXG5dKSpcXDEvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnYnVpbHRpbi10YXJnZXQnOiB7XG4gICAgcGF0dGVybjogL1xcLltBLVpdW146Iz1cXHNdKyg/PVxccyo6KD8hPSkpLyxcbiAgICBhbGlhczogJ2J1aWx0aW4nXG4gIH0sXG4gICd0YXJnZXQnOiB7XG4gICAgcGF0dGVybjogL14oPzpbXjo9XFxzXXxbIFxcdF0rKD8hW1xcczpdKSkrKD89XFxzKjooPyE9KSkvbSxcbiAgICBhbGlhczogJ3N5bWJvbCcsXG4gICAgaW5zaWRlOiB7XG4gICAgICAndmFyaWFibGUnOiAvXFwkKyg/Oig/IVxcJClbXigpe306Iz1cXHNdK3woPz1bKHtdKSkvXG4gICAgfVxuICB9LFxuICAndmFyaWFibGUnOiAvXFwkKyg/Oig/IVxcJClbXigpe306Iz1cXHNdK3xcXChbQColPF4rP11bREZdXFwpfCg/PVsoe10pKS8sXG4gIC8vIERpcmVjdGl2ZXNcbiAgJ2tleXdvcmQnOiAvLWluY2x1ZGVcXGJ8XFxiKD86ZGVmaW5lfGVsc2V8ZW5kZWZ8ZW5kaWZ8ZXhwb3J0fGlmbj9kZWZ8aWZuP2VxfGluY2x1ZGV8b3ZlcnJpZGV8cHJpdmF0ZXxzaW5jbHVkZXx1bmRlZmluZXx1bmV4cG9ydHx2cGF0aClcXGIvLFxuICAnZnVuY3Rpb24nOiB7XG4gICAgcGF0dGVybjogLyhcXCgpKD86YWJzcGF0aHxhZGRzdWZmaXh8YW5kfGJhc2VuYW1lfGNhbGx8ZGlyfGVycm9yfGV2YWx8ZmlsZXxmaWx0ZXIoPzotb3V0KT98ZmluZHN0cmluZ3xmaXJzdHdvcmR8Zmxhdm9yfGZvcmVhY2h8Z3VpbGV8aWZ8aW5mb3xqb2lufGxhc3R3b3JkfGxvYWR8bm90ZGlyfG9yfG9yaWdpbnxwYXRzdWJzdHxyZWFscGF0aHxzaGVsbHxzb3J0fHN0cmlwfHN1YnN0fHN1ZmZpeHx2YWx1ZXx3YXJuaW5nfHdpbGRjYXJkfHdvcmQoPzpsaXN0fHMpPykoPz1bIFxcdF0pLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sXG4gICdvcGVyYXRvcic6IC8oPzo6OnxbPzorIV0pPz18W3xAXS8sXG4gICdwdW5jdHVhdGlvbic6IC9bOjsoKXt9XS9cbn07XG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIC8vIGh0dHBzOi8veWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2MtbnMtYW5jaG9yLXByb3BlcnR5XG4gIC8vIGh0dHBzOi8veWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2MtbnMtYWxpYXMtbm9kZVxuICB2YXIgYW5jaG9yT3JBbGlhcyA9IC9bKiZdW15cXHNbXFxde30sXSsvO1xuICAvLyBodHRwczovL3lhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNjLW5zLXRhZy1wcm9wZXJ0eVxuICB2YXIgdGFnID0gLyEoPzo8W1xcd1xcLSUjOy8/OkAmPSskLC4hfionKClbXFxdXSs+fCg/OlthLXpBLVpcXGQtXSohKT9bXFx3XFwtJSM7Lz86QCY9KyQufionKCldKyk/LztcbiAgLy8gaHR0cHM6Ly95YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjYy1ucy1wcm9wZXJ0aWVzKG4sYylcbiAgdmFyIHByb3BlcnRpZXMgPSAnKD86JyArIHRhZy5zb3VyY2UgKyAnKD86WyBcXHRdKycgKyBhbmNob3JPckFsaWFzLnNvdXJjZSArICcpP3wnICsgYW5jaG9yT3JBbGlhcy5zb3VyY2UgKyAnKD86WyBcXHRdKycgKyB0YWcuc291cmNlICsgJyk/KSc7XG4gIC8vIGh0dHBzOi8veWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI25zLXBsYWluKG4sYylcbiAgLy8gVGhpcyBpcyBhIHNpbXBsaWZpZWQgdmVyc2lvbiB0aGF0IGRvZXNuJ3Qgc3VwcG9ydCBcIiNcIiBhbmQgbXVsdGlsaW5lIGtleXNcbiAgLy8gQWxsIHRoZXNlIGxvbmcgc2NhcnJ5IGNoYXJhY3RlciBjbGFzc2VzIGFyZSBzaW1wbGlmaWVkIHZlcnNpb25zIG9mIFlBTUwncyBjaGFyYWN0ZXJzXG4gIHZhciBwbGFpbktleSA9IC8oPzpbXlxcc1xceDAwLVxceDA4XFx4MGUtXFx4MWYhXCIjJSYnKixcXC06Pj9AW1xcXWB7fH1cXHg3Zi1cXHg4NFxceDg2LVxceDlmXFx1ZDgwMC1cXHVkZmZmXFx1ZmZmZVxcdWZmZmZdfFs/Oi1dPFBMQUlOPikoPzpbIFxcdF0qKD86KD8hWyM6XSk8UExBSU4+fDo8UExBSU4+KSkqLy5zb3VyY2UucmVwbGFjZSgvPFBMQUlOPi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIC9bXlxcc1xceDAwLVxceDA4XFx4MGUtXFx4MWYsW1xcXXt9XFx4N2YtXFx4ODRcXHg4Ni1cXHg5ZlxcdWQ4MDAtXFx1ZGZmZlxcdWZmZmVcXHVmZmZmXS8uc291cmNlO1xuICB9KTtcbiAgdmFyIHN0cmluZyA9IC9cIig/OlteXCJcXFxcXFxyXFxuXXxcXFxcLikqXCJ8Jyg/OlteJ1xcXFxcXHJcXG5dfFxcXFwuKSonLy5zb3VyY2U7XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZsYWdzXVxuICAgKiBAcmV0dXJucyB7UmVnRXhwfVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlVmFsdWVQYXR0ZXJuKHZhbHVlLCBmbGFncykge1xuICAgIGZsYWdzID0gKGZsYWdzIHx8ICcnKS5yZXBsYWNlKC9tL2csICcnKSArICdtJzsgLy8gYWRkIG0gZmxhZ1xuICAgIHZhciBwYXR0ZXJuID0gLyhbOlxcLSxbe11cXHMqKD86XFxzPDxwcm9wPj5bIFxcdF0rKT8pKD86PDx2YWx1ZT4+KSg/PVsgXFx0XSooPzokfCx8XFxdfFxcfXwoPzpbXFxyXFxuXVxccyopPyMpKS8uc291cmNlLnJlcGxhY2UoLzw8cHJvcD4+L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH0pLnJlcGxhY2UoLzw8dmFsdWU+Pi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gIH1cbiAgUHJpc20ubGFuZ3VhZ2VzLnlhbWwgPSB7XG4gICAgJ3NjYWxhcic6IHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgvKFtcXC06XVxccyooPzpcXHM8PHByb3A+PlsgXFx0XSspP1t8Pl0pWyBcXHRdKig/OigoPzpcXHI/XFxufFxccilbIFxcdF0rKVxcU1teXFxyXFxuXSooPzpcXDJbXlxcclxcbl0rKSopLy5zb3VyY2UucmVwbGFjZSgvPDxwcm9wPj4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICAgIH0pKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ3N0cmluZydcbiAgICB9LFxuICAgICdjb21tZW50JzogLyMuKi8sXG4gICAgJ2tleSc6IHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgvKCg/Ol58WzpcXC0sW3tcXHJcXG4/XSlbIFxcdF0qKD86PDxwcm9wPj5bIFxcdF0rKT8pPDxrZXk+Pig/PVxccyo6XFxzKS8uc291cmNlLnJlcGxhY2UoLzw8cHJvcD4+L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgICB9KS5yZXBsYWNlKC88PGtleT4+L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcoPzonICsgcGxhaW5LZXkgKyAnfCcgKyBzdHJpbmcgKyAnKSc7XG4gICAgICB9KSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgYWxpYXM6ICdhdHJ1bGUnXG4gICAgfSxcbiAgICAnZGlyZWN0aXZlJzoge1xuICAgICAgcGF0dGVybjogLyheWyBcXHRdKiklLisvbSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ2ltcG9ydGFudCdcbiAgICB9LFxuICAgICdkYXRldGltZSc6IHtcbiAgICAgIHBhdHRlcm46IGNyZWF0ZVZhbHVlUGF0dGVybigvXFxkezR9LVxcZFxcZD8tXFxkXFxkPyg/Olt0VF18WyBcXHRdKylcXGRcXGQ/OlxcZHsyfTpcXGR7Mn0oPzpcXC5cXGQqKT8oPzpbIFxcdF0qKD86WnxbLStdXFxkXFxkPyg/OjpcXGR7Mn0pPykpP3xcXGR7NH0tXFxkezJ9LVxcZHsyfXxcXGRcXGQ/OlxcZHsyfSg/OjpcXGR7Mn0oPzpcXC5cXGQqKT8pPy8uc291cmNlKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ251bWJlcidcbiAgICB9LFxuICAgICdib29sZWFuJzoge1xuICAgICAgcGF0dGVybjogY3JlYXRlVmFsdWVQYXR0ZXJuKC9mYWxzZXx0cnVlLy5zb3VyY2UsICdpJyksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6ICdpbXBvcnRhbnQnXG4gICAgfSxcbiAgICAnbnVsbCc6IHtcbiAgICAgIHBhdHRlcm46IGNyZWF0ZVZhbHVlUGF0dGVybigvbnVsbHx+Ly5zb3VyY2UsICdpJyksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6ICdpbXBvcnRhbnQnXG4gICAgfSxcbiAgICAnc3RyaW5nJzoge1xuICAgICAgcGF0dGVybjogY3JlYXRlVmFsdWVQYXR0ZXJuKHN0cmluZyksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSxcbiAgICAnbnVtYmVyJzoge1xuICAgICAgcGF0dGVybjogY3JlYXRlVmFsdWVQYXR0ZXJuKC9bKy1dPyg/OjB4W1xcZGEtZl0rfDBvWzAtN10rfCg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykoPzplWystXT9cXGQrKT98XFwuaW5mfFxcLm5hbikvLnNvdXJjZSwgJ2knKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICd0YWcnOiB0YWcsXG4gICAgJ2ltcG9ydGFudCc6IGFuY2hvck9yQWxpYXMsXG4gICAgJ3B1bmN0dWF0aW9uJzogLy0tLXxbOltcXF17fVxcLSx8Pj9dfFxcLlxcLlxcLi9cbiAgfTtcbiAgUHJpc20ubGFuZ3VhZ2VzLnltbCA9IFByaXNtLmxhbmd1YWdlcy55YW1sO1xufSkoUHJpc20pO1xuKGZ1bmN0aW9uIChQcmlzbSkge1xuICAvLyBBbGxvdyBvbmx5IG9uZSBsaW5lIGJyZWFrXG4gIHZhciBpbm5lciA9IC8oPzpcXFxcLnxbXlxcXFxcXG5cXHJdfCg/OlxcbnxcXHJcXG4/KSg/IVtcXHJcXG5dKSkvLnNvdXJjZTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBpbnRlbmRlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIHRoZSBib2xkIG9yIGl0YWxpYyBwYXR0ZXJuLlxuICAgKlxuICAgKiBUaGlzIGFsc28gYWRkcyBhIGxvb2tiZWhpbmQgZ3JvdXAgdG8gdGhlIGdpdmVuIHBhdHRlcm4gdG8gZW5zdXJlIHRoYXQgdGhlIHBhdHRlcm4gaXMgbm90IGJhY2tzbGFzaC1lc2NhcGVkLlxuICAgKlxuICAgKiBfTm90ZTpfIEtlZXAgaW4gbWluZCB0aGF0IHRoaXMgYWRkcyBhIGNhcHR1cmluZyBncm91cC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm5cbiAgICogQHJldHVybnMge1JlZ0V4cH1cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUlubGluZShwYXR0ZXJuKSB7XG4gICAgcGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZSgvPGlubmVyPi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaW5uZXI7XG4gICAgfSk7XG4gICAgcmV0dXJuIFJlZ0V4cCgvKCg/Ol58W15cXFxcXSkoPzpcXFxcezJ9KSopLy5zb3VyY2UgKyAnKD86JyArIHBhdHRlcm4gKyAnKScpO1xuICB9XG4gIHZhciB0YWJsZUNlbGwgPSAvKD86XFxcXC58YGAoPzpbXmBcXHJcXG5dfGAoPyFgKSkrYGB8YFteYFxcclxcbl0rYHxbXlxcXFx8XFxyXFxuYF0pKy8uc291cmNlO1xuICB2YXIgdGFibGVSb3cgPSAvXFx8P19fKD86XFx8X18pK1xcfD8oPzooPzpcXG58XFxyXFxuPyl8KD8hW1xcc1xcU10pKS8uc291cmNlLnJlcGxhY2UoL19fL2csIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGFibGVDZWxsO1xuICB9KTtcbiAgdmFyIHRhYmxlTGluZSA9IC9cXHw/WyBcXHRdKjo/LXszLH06P1sgXFx0XSooPzpcXHxbIFxcdF0qOj8tezMsfTo/WyBcXHRdKikrXFx8Pyg/OlxcbnxcXHJcXG4/KS8uc291cmNlO1xuICBQcmlzbS5sYW5ndWFnZXMubWFya2Rvd24gPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdtYXJrdXAnLCB7fSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmtkb3duJywgJ3Byb2xvZycsIHtcbiAgICAnZnJvbnQtbWF0dGVyLWJsb2NrJzoge1xuICAgICAgcGF0dGVybjogLyheKD86XFxzKltcXHJcXG5dKT8pLS0tKD8hLilbXFxzXFxTXSo/W1xcclxcbl0tLS0oPyEuKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9eLS0tfC0tLSQvLFxuICAgICAgICAnZnJvbnQtbWF0dGVyJzoge1xuICAgICAgICAgIHBhdHRlcm46IC9cXFMrKD86XFxzK1xcUyspKi8sXG4gICAgICAgICAgYWxpYXM6IFsneWFtbCcsICdsYW5ndWFnZS15YW1sJ10sXG4gICAgICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMueWFtbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAnYmxvY2txdW90ZSc6IHtcbiAgICAgIC8vID4gLi4uXG4gICAgICBwYXR0ZXJuOiAvXj4oPzpbXFx0IF0qPikqL20sXG4gICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgIH0sXG4gICAgJ3RhYmxlJzoge1xuICAgICAgcGF0dGVybjogUmVnRXhwKCdeJyArIHRhYmxlUm93ICsgdGFibGVMaW5lICsgJyg/OicgKyB0YWJsZVJvdyArICcpKicsICdtJyksXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3RhYmxlLWRhdGEtcm93cyc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiBSZWdFeHAoJ14oJyArIHRhYmxlUm93ICsgdGFibGVMaW5lICsgJykoPzonICsgdGFibGVSb3cgKyAnKSokJyksXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAgICd0YWJsZS1kYXRhJzoge1xuICAgICAgICAgICAgICBwYXR0ZXJuOiBSZWdFeHAodGFibGVDZWxsKSxcbiAgICAgICAgICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMubWFya2Rvd25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncHVuY3R1YXRpb24nOiAvXFx8L1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgJ3RhYmxlLWxpbmUnOiB7XG4gICAgICAgICAgcGF0dGVybjogUmVnRXhwKCdeKCcgKyB0YWJsZVJvdyArICcpJyArIHRhYmxlTGluZSArICckJyksXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9cXHx8Oj8tezMsfTo/L1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgJ3RhYmxlLWhlYWRlci1yb3cnOiB7XG4gICAgICAgICAgcGF0dGVybjogUmVnRXhwKCdeJyArIHRhYmxlUm93ICsgJyQnKSxcbiAgICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAgICd0YWJsZS1oZWFkZXInOiB7XG4gICAgICAgICAgICAgIHBhdHRlcm46IFJlZ0V4cCh0YWJsZUNlbGwpLFxuICAgICAgICAgICAgICBhbGlhczogJ2ltcG9ydGFudCcsXG4gICAgICAgICAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLm1hcmtkb3duXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcfC9cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdjb2RlJzogW3tcbiAgICAgIC8vIFByZWZpeGVkIGJ5IDQgc3BhY2VzIG9yIDEgdGFiIGFuZCBwcmVjZWRlZCBieSBhbiBlbXB0eSBsaW5lXG4gICAgICBwYXR0ZXJuOiAvKCg/Ol58XFxuKVsgXFx0XSpcXG58KD86XnxcXHJcXG4/KVsgXFx0XSpcXHJcXG4/KSg/OiB7NH18XFx0KS4rKD86KD86XFxufFxcclxcbj8pKD86IHs0fXxcXHQpLispKi8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6ICdrZXl3b3JkJ1xuICAgIH0sIHtcbiAgICAgIC8vIGBgYG9wdGlvbmFsIGxhbmd1YWdlXG4gICAgICAvLyBjb2RlIGJsb2NrXG4gICAgICAvLyBgYGBcbiAgICAgIHBhdHRlcm46IC9eYGBgW1xcc1xcU10qP15gYGAkL20sXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2NvZGUtYmxvY2snOiB7XG4gICAgICAgICAgcGF0dGVybjogL14oYGBgLiooPzpcXG58XFxyXFxuPykpW1xcc1xcU10rPyg/PSg/OlxcbnxcXHJcXG4/KV5gYGAkKS9tLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgJ2NvZGUtbGFuZ3VhZ2UnOiB7XG4gICAgICAgICAgcGF0dGVybjogL14oYGBgKS4rLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9gYGAvXG4gICAgICB9XG4gICAgfV0sXG4gICAgJ3RpdGxlJzogW3tcbiAgICAgIC8vIHRpdGxlIDFcbiAgICAgIC8vID09PT09PT1cblxuICAgICAgLy8gdGl0bGUgMlxuICAgICAgLy8gLS0tLS0tLVxuICAgICAgcGF0dGVybjogL1xcUy4qKD86XFxufFxcclxcbj8pKD86PT0rfC0tKykoPz1bIFxcdF0qJCkvbSxcbiAgICAgIGFsaWFzOiAnaW1wb3J0YW50JyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICBwdW5jdHVhdGlvbjogLz09KyR8LS0rJC9cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICAvLyAjIHRpdGxlIDFcbiAgICAgIC8vICMjIyMjIyB0aXRsZSA2XG4gICAgICBwYXR0ZXJuOiAvKF5cXHMqKSMuKy9tLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnaW1wb3J0YW50JyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICBwdW5jdHVhdGlvbjogL14jK3wjKyQvXG4gICAgICB9XG4gICAgfV0sXG4gICAgJ2hyJzoge1xuICAgICAgLy8gKioqXG4gICAgICAvLyAtLS1cbiAgICAgIC8vICogKiAqXG4gICAgICAvLyAtLS0tLS0tLS0tLVxuICAgICAgcGF0dGVybjogLyheXFxzKikoWyotXSkoPzpbXFx0IF0qXFwyKXsyLH0oPz1cXHMqJCkvbSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgIH0sXG4gICAgJ2xpc3QnOiB7XG4gICAgICAvLyAqIGl0ZW1cbiAgICAgIC8vICsgaXRlbVxuICAgICAgLy8gLSBpdGVtXG4gICAgICAvLyAxLiBpdGVtXG4gICAgICBwYXR0ZXJuOiAvKF5cXHMqKSg/OlsqKy1dfFxcZCtcXC4pKD89W1xcdCBdLikvbSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgIH0sXG4gICAgJ3VybC1yZWZlcmVuY2UnOiB7XG4gICAgICAvLyBbaWRdOiBodHRwOi8vZXhhbXBsZS5jb20gXCJPcHRpb25hbCB0aXRsZVwiXG4gICAgICAvLyBbaWRdOiBodHRwOi8vZXhhbXBsZS5jb20gJ09wdGlvbmFsIHRpdGxlJ1xuICAgICAgLy8gW2lkXTogaHR0cDovL2V4YW1wbGUuY29tIChPcHRpb25hbCB0aXRsZSlcbiAgICAgIC8vIFtpZF06IDxodHRwOi8vZXhhbXBsZS5jb20+IFwiT3B0aW9uYWwgdGl0bGVcIlxuICAgICAgcGF0dGVybjogLyE/XFxbW15cXF1dK1xcXTpbXFx0IF0rKD86XFxTK3w8KD86XFxcXC58W14+XFxcXF0pKz4pKD86W1xcdCBdKyg/OlwiKD86XFxcXC58W15cIlxcXFxdKSpcInwnKD86XFxcXC58W14nXFxcXF0pKid8XFwoKD86XFxcXC58W14pXFxcXF0pKlxcKSkpPy8sXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3ZhcmlhYmxlJzoge1xuICAgICAgICAgIHBhdHRlcm46IC9eKCE/XFxbKVteXFxdXSsvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgJ3N0cmluZyc6IC8oPzpcIig/OlxcXFwufFteXCJcXFxcXSkqXCJ8Jyg/OlxcXFwufFteJ1xcXFxdKSonfFxcKCg/OlxcXFwufFteKVxcXFxdKSpcXCkpJC8sXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9eW1xcW1xcXSE6XXxbPD5dL1xuICAgICAgfSxcbiAgICAgIGFsaWFzOiAndXJsJ1xuICAgIH0sXG4gICAgJ2JvbGQnOiB7XG4gICAgICAvLyAqKnN0cm9uZyoqXG4gICAgICAvLyBfX3N0cm9uZ19fXG5cbiAgICAgIC8vIGFsbG93IG9uZSBuZXN0ZWQgaW5zdGFuY2Ugb2YgaXRhbGljIHRleHQgdXNpbmcgdGhlIHNhbWUgZGVsaW1pdGVyXG4gICAgICBwYXR0ZXJuOiBjcmVhdGVJbmxpbmUoL1xcYl9fKD86KD8hXyk8aW5uZXI+fF8oPzooPyFfKTxpbm5lcj4pK18pK19fXFxifFxcKlxcKig/Oig/IVxcKik8aW5uZXI+fFxcKig/Oig/IVxcKik8aW5uZXI+KStcXCopK1xcKlxcKi8uc291cmNlKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2NvbnRlbnQnOiB7XG4gICAgICAgICAgcGF0dGVybjogLyheLi4pW1xcc1xcU10rKD89Li4kKS8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICBpbnNpZGU6IHt9IC8vIHNlZSBiZWxvd1xuICAgICAgICB9LFxuXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9cXCpcXCp8X18vXG4gICAgICB9XG4gICAgfSxcbiAgICAnaXRhbGljJzoge1xuICAgICAgLy8gKmVtKlxuICAgICAgLy8gX2VtX1xuXG4gICAgICAvLyBhbGxvdyBvbmUgbmVzdGVkIGluc3RhbmNlIG9mIGJvbGQgdGV4dCB1c2luZyB0aGUgc2FtZSBkZWxpbWl0ZXJcbiAgICAgIHBhdHRlcm46IGNyZWF0ZUlubGluZSgvXFxiXyg/Oig/IV8pPGlubmVyPnxfXyg/Oig/IV8pPGlubmVyPikrX18pK19cXGJ8XFwqKD86KD8hXFwqKTxpbm5lcj58XFwqXFwqKD86KD8hXFwqKTxpbm5lcj4pK1xcKlxcKikrXFwqLy5zb3VyY2UpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnY29udGVudCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKF4uKVtcXHNcXFNdKyg/PS4kKS8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICBpbnNpZGU6IHt9IC8vIHNlZSBiZWxvd1xuICAgICAgICB9LFxuXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9bKl9dL1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3N0cmlrZSc6IHtcbiAgICAgIC8vIH5+c3RyaWtlIHRocm91Z2h+flxuICAgICAgLy8gfnN0cmlrZX5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvc3RyaWN0XG4gICAgICBwYXR0ZXJuOiBjcmVhdGVJbmxpbmUoLyh+fj8pKD86KD8hfik8aW5uZXI+KStcXDIvLnNvdXJjZSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdjb250ZW50Jzoge1xuICAgICAgICAgIHBhdHRlcm46IC8oXn5+PylbXFxzXFxTXSsoPz1cXDEkKS8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICBpbnNpZGU6IHt9IC8vIHNlZSBiZWxvd1xuICAgICAgICB9LFxuXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9+fj8vXG4gICAgICB9XG4gICAgfSxcbiAgICAnY29kZS1zbmlwcGV0Jzoge1xuICAgICAgLy8gYGNvZGVgXG4gICAgICAvLyBgYGNvZGVgYFxuICAgICAgcGF0dGVybjogLyhefFteXFxcXGBdKSg/OmBgW15gXFxyXFxuXSsoPzpgW15gXFxyXFxuXSspKmBgKD8hYCl8YFteYFxcclxcbl0rYCg/IWApKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgYWxpYXM6IFsnY29kZScsICdrZXl3b3JkJ11cbiAgICB9LFxuICAgICd1cmwnOiB7XG4gICAgICAvLyBbZXhhbXBsZV0oaHR0cDovL2V4YW1wbGUuY29tIFwiT3B0aW9uYWwgdGl0bGVcIilcbiAgICAgIC8vIFtleGFtcGxlXVtpZF1cbiAgICAgIC8vIFtleGFtcGxlXSBbaWRdXG4gICAgICBwYXR0ZXJuOiBjcmVhdGVJbmxpbmUoLyE/XFxbKD86KD8hXFxdKTxpbm5lcj4pK1xcXSg/OlxcKFteXFxzKV0rKD86W1xcdCBdK1wiKD86XFxcXC58W15cIlxcXFxdKSpcIik/XFwpfFsgXFx0XT9cXFsoPzooPyFcXF0pPGlubmVyPikrXFxdKS8uc291cmNlKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ29wZXJhdG9yJzogL14hLyxcbiAgICAgICAgJ2NvbnRlbnQnOiB7XG4gICAgICAgICAgcGF0dGVybjogLyheXFxbKVteXFxdXSsoPz1cXF0pLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGluc2lkZToge30gLy8gc2VlIGJlbG93XG4gICAgICAgIH0sXG5cbiAgICAgICAgJ3ZhcmlhYmxlJzoge1xuICAgICAgICAgIHBhdHRlcm46IC8oXlxcXVsgXFx0XT9cXFspW15cXF1dKyg/PVxcXSQpLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICd1cmwnOiB7XG4gICAgICAgICAgcGF0dGVybjogLyheXFxdXFwoKVteXFxzKV0rLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICdzdHJpbmcnOiB7XG4gICAgICAgICAgcGF0dGVybjogLyheWyBcXHRdKylcIig/OlxcXFwufFteXCJcXFxcXSkqXCIoPz1cXCkkKS8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgWyd1cmwnLCAnYm9sZCcsICdpdGFsaWMnLCAnc3RyaWtlJ10uZm9yRWFjaChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICBbJ3VybCcsICdib2xkJywgJ2l0YWxpYycsICdzdHJpa2UnLCAnY29kZS1zbmlwcGV0J10uZm9yRWFjaChmdW5jdGlvbiAoaW5zaWRlKSB7XG4gICAgICBpZiAodG9rZW4gIT09IGluc2lkZSkge1xuICAgICAgICBQcmlzbS5sYW5ndWFnZXMubWFya2Rvd25bdG9rZW5dLmluc2lkZS5jb250ZW50Lmluc2lkZVtpbnNpZGVdID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmtkb3duW2luc2lkZV07XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBQcmlzbS5ob29rcy5hZGQoJ2FmdGVyLXRva2VuaXplJywgZnVuY3Rpb24gKGVudikge1xuICAgIGlmIChlbnYubGFuZ3VhZ2UgIT09ICdtYXJrZG93bicgJiYgZW52Lmxhbmd1YWdlICE9PSAnbWQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhbGtUb2tlbnModG9rZW5zKSB7XG4gICAgICBpZiAoIXRva2VucyB8fCB0eXBlb2YgdG9rZW5zID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gJ2NvZGUnKSB7XG4gICAgICAgICAgd2Fsa1Rva2Vucyh0b2tlbi5jb250ZW50KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIEFkZCB0aGUgY29ycmVjdCBgbGFuZ3VhZ2UteHh4eGAgY2xhc3MgdG8gdGhpcyBjb2RlIGJsb2NrLiBLZWVwIGluIG1pbmQgdGhhdCB0aGUgYGNvZGUtbGFuZ3VhZ2VgIHRva2VuXG4gICAgICAgICAqIGlzIG9wdGlvbmFsLiBCdXQgdGhlIGdyYW1tYXIgaXMgZGVmaW5lZCBzbyB0aGF0IHRoZXJlIGlzIG9ubHkgb25lIGNhc2Ugd2UgaGF2ZSB0byBoYW5kbGU6XG4gICAgICAgICAqXG4gICAgICAgICAqIHRva2VuLmNvbnRlbnQgPSBbXG4gICAgICAgICAqICAgICA8c3BhbiBjbGFzcz1cInB1bmN0dWF0aW9uXCI+YGBgPC9zcGFuPixcbiAgICAgICAgICogICAgIDxzcGFuIGNsYXNzPVwiY29kZS1sYW5ndWFnZVwiPnh4eHg8L3NwYW4+LFxuICAgICAgICAgKiAgICAgJ1xcbicsIC8vIGV4YWN0bHkgb25lIG5ldyBsaW5lcyAoXFxyIG9yIFxcbiBvciBcXHJcXG4pXG4gICAgICAgICAqICAgICA8c3BhbiBjbGFzcz1cImNvZGUtYmxvY2tcIj4uLi48L3NwYW4+LFxuICAgICAgICAgKiAgICAgJ1xcbicsIC8vIGV4YWN0bHkgb25lIG5ldyBsaW5lcyBhZ2FpblxuICAgICAgICAgKiAgICAgPHNwYW4gY2xhc3M9XCJwdW5jdHVhdGlvblwiPmBgYDwvc3Bhbj5cbiAgICAgICAgICogXTtcbiAgICAgICAgICovXG5cbiAgICAgICAgdmFyIGNvZGVMYW5nID0gdG9rZW4uY29udGVudFsxXTtcbiAgICAgICAgdmFyIGNvZGVCbG9jayA9IHRva2VuLmNvbnRlbnRbM107XG4gICAgICAgIGlmIChjb2RlTGFuZyAmJiBjb2RlQmxvY2sgJiYgY29kZUxhbmcudHlwZSA9PT0gJ2NvZGUtbGFuZ3VhZ2UnICYmIGNvZGVCbG9jay50eXBlID09PSAnY29kZS1ibG9jaycgJiYgdHlwZW9mIGNvZGVMYW5nLmNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gdGhpcyBtaWdodCBiZSBhIGxhbmd1YWdlIHRoYXQgUHJpc20gZG9lcyBub3Qgc3VwcG9ydFxuXG4gICAgICAgICAgLy8gZG8gc29tZSByZXBsYWNlbWVudHMgdG8gc3VwcG9ydCBDKyssIEMjLCBhbmQgRiNcbiAgICAgICAgICB2YXIgbGFuZyA9IGNvZGVMYW5nLmNvbnRlbnQucmVwbGFjZSgvXFxiIy9nLCAnc2hhcnAnKS5yZXBsYWNlKC9cXGJcXCtcXCsvZywgJ3BwJyk7XG4gICAgICAgICAgLy8gb25seSB1c2UgdGhlIGZpcnN0IHdvcmRcbiAgICAgICAgICBsYW5nID0gKC9bYS16XVtcXHctXSovaS5leGVjKGxhbmcpIHx8IFsnJ10pWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgdmFyIGFsaWFzID0gJ2xhbmd1YWdlLScgKyBsYW5nO1xuXG4gICAgICAgICAgLy8gYWRkIGFsaWFzXG4gICAgICAgICAgaWYgKCFjb2RlQmxvY2suYWxpYXMpIHtcbiAgICAgICAgICAgIGNvZGVCbG9jay5hbGlhcyA9IFthbGlhc107XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29kZUJsb2NrLmFsaWFzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29kZUJsb2NrLmFsaWFzID0gW2NvZGVCbG9jay5hbGlhcywgYWxpYXNdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlQmxvY2suYWxpYXMucHVzaChhbGlhcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHdhbGtUb2tlbnMoZW52LnRva2Vucyk7XG4gIH0pO1xuICBQcmlzbS5ob29rcy5hZGQoJ3dyYXAnLCBmdW5jdGlvbiAoZW52KSB7XG4gICAgaWYgKGVudi50eXBlICE9PSAnY29kZS1ibG9jaycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvZGVMYW5nID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbnYuY2xhc3Nlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjbHMgPSBlbnYuY2xhc3Nlc1tpXTtcbiAgICAgIHZhciBtYXRjaCA9IC9sYW5ndWFnZS0oLispLy5leGVjKGNscyk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgY29kZUxhbmcgPSBtYXRjaFsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBncmFtbWFyID0gUHJpc20ubGFuZ3VhZ2VzW2NvZGVMYW5nXTtcbiAgICBpZiAoIWdyYW1tYXIpIHtcbiAgICAgIGlmIChjb2RlTGFuZyAmJiBjb2RlTGFuZyAhPT0gJ25vbmUnICYmIFByaXNtLnBsdWdpbnMuYXV0b2xvYWRlcikge1xuICAgICAgICB2YXIgaWQgPSAnbWQtJyArIG5ldyBEYXRlKCkudmFsdWVPZigpICsgJy0nICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMWUxNik7XG4gICAgICAgIGVudi5hdHRyaWJ1dGVzWydpZCddID0gaWQ7XG4gICAgICAgIFByaXNtLnBsdWdpbnMuYXV0b2xvYWRlci5sb2FkTGFuZ3VhZ2VzKGNvZGVMYW5nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgICBpZiAoZWxlKSB7XG4gICAgICAgICAgICBlbGUuaW5uZXJIVE1MID0gUHJpc20uaGlnaGxpZ2h0KGVsZS50ZXh0Q29udGVudCwgUHJpc20ubGFuZ3VhZ2VzW2NvZGVMYW5nXSwgY29kZUxhbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudi5jb250ZW50ID0gUHJpc20uaGlnaGxpZ2h0KHRleHRDb250ZW50KGVudi5jb250ZW50KSwgZ3JhbW1hciwgY29kZUxhbmcpO1xuICAgIH1cbiAgfSk7XG4gIHZhciB0YWdQYXR0ZXJuID0gUmVnRXhwKFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLnBhdHRlcm4uc291cmNlLCAnZ2knKTtcblxuICAvKipcbiAgICogQSBsaXN0IG9mIGtub3duIGVudGl0eSBuYW1lcy5cbiAgICpcbiAgICogVGhpcyB3aWxsIGFsd2F5cyBiZSBpbmNvbXBsZXRlIHRvIHNhdmUgc3BhY2UuIFRoZSBjdXJyZW50IGxpc3QgaXMgdGhlIG9uZSB1c2VkIGJ5IGxvd2Rhc2gncyB1bmVzY2FwZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi8yZGEwMjRjM2I0Zjk5NDdhNDg1MTc2MzlkZTc1NjA0NTdjZDRlYzZjL3VuZXNjYXBlLmpzI0wyfVxuICAgKi9cbiAgdmFyIEtOT1dOX0VOVElUWV9OQU1FUyA9IHtcbiAgICAnYW1wJzogJyYnLFxuICAgICdsdCc6ICc8JyxcbiAgICAnZ3QnOiAnPicsXG4gICAgJ3F1b3QnOiAnXCInXG4gIH07XG5cbiAgLy8gSUUgMTEgZG9lc24ndCBzdXBwb3J0IGBTdHJpbmcuZnJvbUNvZGVQb2ludGBcbiAgdmFyIGZyb21Db2RlUG9pbnQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCB8fCBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0ZXh0IGNvbnRlbnQgb2YgYSBnaXZlbiBIVE1MIHNvdXJjZSBjb2RlIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGZ1bmN0aW9uIHRleHRDb250ZW50KGh0bWwpIHtcbiAgICAvLyByZW1vdmUgYWxsIHRhZ3NcbiAgICB2YXIgdGV4dCA9IGh0bWwucmVwbGFjZSh0YWdQYXR0ZXJuLCAnJyk7XG5cbiAgICAvLyBkZWNvZGUga25vd24gZW50aXRpZXNcbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8mKFxcd3sxLDh9fCN4P1tcXGRhLWZdezEsOH0pOy9naSwgZnVuY3Rpb24gKG0sIGNvZGUpIHtcbiAgICAgIGNvZGUgPSBjb2RlLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoY29kZVswXSA9PT0gJyMnKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKGNvZGVbMV0gPT09ICd4Jykge1xuICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoY29kZS5zbGljZSgyKSwgMTYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gTnVtYmVyKGNvZGUuc2xpY2UoMSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcm9tQ29kZVBvaW50KHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrbm93biA9IEtOT1dOX0VOVElUWV9OQU1FU1tjb2RlXTtcbiAgICAgICAgaWYgKGtub3duKSB7XG4gICAgICAgICAgcmV0dXJuIGtub3duO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdW5hYmxlIHRvIGRlY29kZVxuICAgICAgICByZXR1cm4gbTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuICBQcmlzbS5sYW5ndWFnZXMubWQgPSBQcmlzbS5sYW5ndWFnZXMubWFya2Rvd247XG59KShQcmlzbSk7XG5QcmlzbS5sYW5ndWFnZXMub2JqZWN0aXZlYyA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2MnLCB7XG4gICdzdHJpbmcnOiB7XG4gICAgcGF0dGVybjogL0A/XCIoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXlwiXFxcXFxcclxcbl0pKlwiLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ2tleXdvcmQnOiAvXFxiKD86YXNtfGF1dG98YnJlYWt8Y2FzZXxjaGFyfGNvbnN0fGNvbnRpbnVlfGRlZmF1bHR8ZG98ZG91YmxlfGVsc2V8ZW51bXxleHRlcm58ZmxvYXR8Zm9yfGdvdG98aWZ8aW58aW5saW5lfGludHxsb25nfHJlZ2lzdGVyfHJldHVybnxzZWxmfHNob3J0fHNpZ25lZHxzaXplb2Z8c3RhdGljfHN0cnVjdHxzdXBlcnxzd2l0Y2h8dHlwZWRlZnx0eXBlb2Z8dW5pb258dW5zaWduZWR8dm9pZHx2b2xhdGlsZXx3aGlsZSlcXGJ8KD86QGludGVyZmFjZXxAZW5kfEBpbXBsZW1lbnRhdGlvbnxAcHJvdG9jb2x8QGNsYXNzfEBwdWJsaWN8QHByb3RlY3RlZHxAcHJpdmF0ZXxAcHJvcGVydHl8QHRyeXxAY2F0Y2h8QGZpbmFsbHl8QHRocm93fEBzeW50aGVzaXplfEBkeW5hbWljfEBzZWxlY3RvcilcXGIvLFxuICAnb3BlcmF0b3InOiAvLVstPl0/fFxcK1xcKz98IT0/fDw8Pz0/fD4+Pz0/fD09P3wmJj98XFx8XFx8P3xbfl4lPypcXC9AXS9cbn0pO1xuZGVsZXRlIFByaXNtLmxhbmd1YWdlcy5vYmplY3RpdmVjWydjbGFzcy1uYW1lJ107XG5QcmlzbS5sYW5ndWFnZXMub2JqYyA9IFByaXNtLmxhbmd1YWdlcy5vYmplY3RpdmVjO1xuKGZ1bmN0aW9uIChQcmlzbSkge1xuICB2YXIgYnJhY2tldHMgPSAvKD86XFwoKD86W14oKVxcXFxdfFxcXFxbXFxzXFxTXSkqXFwpfFxceyg/Oltee31cXFxcXXxcXFxcW1xcc1xcU10pKlxcfXxcXFsoPzpbXltcXF1cXFxcXXxcXFxcW1xcc1xcU10pKlxcXXw8KD86W148PlxcXFxdfFxcXFxbXFxzXFxTXSkqPikvLnNvdXJjZTtcbiAgUHJpc20ubGFuZ3VhZ2VzLnBlcmwgPSB7XG4gICAgJ2NvbW1lbnQnOiBbe1xuICAgICAgLy8gUE9EXG4gICAgICBwYXR0ZXJuOiAvKF5cXHMqKT1cXHdbXFxzXFxTXSo/PWN1dC4qL20sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSwge1xuICAgICAgcGF0dGVybjogLyhefFteXFxcXCRdKSMuKi8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfV0sXG4gICAgLy8gVE9ETyBDb3VsZCBiZSBuaWNlIHRvIGhhbmRsZSBIZXJlZG9jIHRvby5cbiAgICAnc3RyaW5nJzogW3tcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgvXFxiKD86cXxxcXxxd3xxeCkoPyFbYS16QS1aMC05XSlcXHMqLy5zb3VyY2UgKyAnKD86JyArIFtcbiAgICAgIC8vIHEvLi4uL1xuICAgICAgLyhbXmEtekEtWjAtOVxcc3soXFxbPF0pKD86KD8hXFwxKVteXFxcXF18XFxcXFtcXHNcXFNdKSpcXDEvLnNvdXJjZSxcbiAgICAgIC8vIHEgYS4uLmFcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvc3RyaWN0XG4gICAgICAvKFthLXpBLVowLTldKSg/Oig/IVxcMilbXlxcXFxdfFxcXFxbXFxzXFxTXSkqXFwyLy5zb3VyY2UsXG4gICAgICAvLyBxKC4uLilcbiAgICAgIC8vIHF7Li4ufVxuICAgICAgLy8gcVsuLi5dXG4gICAgICAvLyBxPC4uLj5cbiAgICAgIGJyYWNrZXRzXS5qb2luKCd8JykgKyAnKScpLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSxcbiAgICAvLyBcIi4uLlwiLCBgLi4uYFxuICAgIHtcbiAgICAgIHBhdHRlcm46IC8oXCJ8YCkoPzooPyFcXDEpW15cXFxcXXxcXFxcW1xcc1xcU10pKlxcMS8sXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LFxuICAgIC8vICcuLi4nXG4gICAgLy8gRklYTUUgTXVsdGktbGluZSBzaW5nbGUtcXVvdGVkIHN0cmluZ3MgYXJlIG5vdCBzdXBwb3J0ZWQgYXMgdGhleSB3b3VsZCBicmVhayB2YXJpYWJsZXMgY29udGFpbmluZyAnXG4gICAge1xuICAgICAgcGF0dGVybjogLycoPzpbXidcXFxcXFxyXFxuXXxcXFxcLikqJy8sXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9XSxcbiAgICAncmVnZXgnOiBbe1xuICAgICAgcGF0dGVybjogUmVnRXhwKC9cXGIoPzptfHFyKSg/IVthLXpBLVowLTldKVxccyovLnNvdXJjZSArICcoPzonICsgW1xuICAgICAgLy8gbS8uLi4vXG4gICAgICAvKFteYS16QS1aMC05XFxzeyhcXFs8XSkoPzooPyFcXDEpW15cXFxcXXxcXFxcW1xcc1xcU10pKlxcMS8uc291cmNlLFxuICAgICAgLy8gbSBhLi4uYVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9zdHJpY3RcbiAgICAgIC8oW2EtekEtWjAtOV0pKD86KD8hXFwyKVteXFxcXF18XFxcXFtcXHNcXFNdKSpcXDIvLnNvdXJjZSxcbiAgICAgIC8vIG0oLi4uKVxuICAgICAgLy8gbXsuLi59XG4gICAgICAvLyBtWy4uLl1cbiAgICAgIC8vIG08Li4uPlxuICAgICAgYnJhY2tldHNdLmpvaW4oJ3wnKSArICcpJyArIC9bbXNpeHBvZHVhbG5nY10qLy5zb3VyY2UpLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSxcbiAgICAvLyBUaGUgbG9va2JlaGluZHMgcHJldmVudCAtcyBmcm9tIGJyZWFraW5nXG4gICAge1xuICAgICAgcGF0dGVybjogUmVnRXhwKC8oXnxbXi1dKVxcYig/OnN8dHJ8eSkoPyFbYS16QS1aMC05XSlcXHMqLy5zb3VyY2UgKyAnKD86JyArIFtcbiAgICAgIC8vIHMvLi4uLy4uLi9cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvc3RyaWN0XG4gICAgICAvKFteYS16QS1aMC05XFxzeyhcXFs8XSkoPzooPyFcXDIpW15cXFxcXXxcXFxcW1xcc1xcU10pKlxcMig/Oig/IVxcMilbXlxcXFxdfFxcXFxbXFxzXFxTXSkqXFwyLy5zb3VyY2UsXG4gICAgICAvLyBzIGEuLi5hLi4uYVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9zdHJpY3RcbiAgICAgIC8oW2EtekEtWjAtOV0pKD86KD8hXFwzKVteXFxcXF18XFxcXFtcXHNcXFNdKSpcXDMoPzooPyFcXDMpW15cXFxcXXxcXFxcW1xcc1xcU10pKlxcMy8uc291cmNlLFxuICAgICAgLy8gcyguLi4pKC4uLilcbiAgICAgIC8vIHN7Li4ufXsuLi59XG4gICAgICAvLyBzWy4uLl1bLi4uXVxuICAgICAgLy8gczwuLi4+PC4uLj5cbiAgICAgIC8vIHMoLi4uKVsuLi5dXG4gICAgICBicmFja2V0cyArIC9cXHMqLy5zb3VyY2UgKyBicmFja2V0c10uam9pbignfCcpICsgJyknICsgL1ttc2l4cG9kdWFsbmdjZXJdKi8uc291cmNlKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LFxuICAgIC8vIC8uLi4vXG4gICAgLy8gVGhlIGxvb2stYWhlYWQgdHJpZXMgdG8gcHJldmVudCB0d28gZGl2aXNpb25zIG9uXG4gICAgLy8gdGhlIHNhbWUgbGluZSBmcm9tIGJlaW5nIGhpZ2hsaWdodGVkIGFzIHJlZ2V4LlxuICAgIC8vIFRoaXMgZG9lcyBub3Qgc3VwcG9ydCBtdWx0aS1saW5lIHJlZ2V4LlxuICAgIHtcbiAgICAgIHBhdHRlcm46IC9cXC8oPzpbXlxcL1xcXFxcXHJcXG5dfFxcXFwuKSpcXC9bbXNpeHBvZHVhbG5nY10qKD89XFxzKig/OiR8W1xcclxcbiwuO30pJnxcXC0rKn48PiE/Xl18KD86YW5kfGNtcHxlcXxnZXxndHxsZXxsdHxuZXxub3R8b3J8eHx4b3IpXFxiKSkvLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfV0sXG4gICAgLy8gRklYTUUgTm90IHN1cmUgYWJvdXQgdGhlIGhhbmRsaW5nIG9mIDo6LCAnLCBhbmQgI1xuICAgICd2YXJpYWJsZSc6IFtcbiAgICAvLyAke15QT1NUTUFUQ0h9XG4gICAgL1smKiRAJV1cXHtcXF5bQS1aXStcXH0vLFxuICAgIC8vICReVlxuICAgIC9bJiokQCVdXFxeW0EtWl9dLyxcbiAgICAvLyAkey4uLn1cbiAgICAvWyYqJEAlXSM/KD89XFx7KS8sXG4gICAgLy8gJGZvb1xuICAgIC9bJiokQCVdIz8oPzooPzo6OikqJz8oPyFcXGQpW1xcdyRdKyg/IVtcXHckXSkpKyg/Ojo6KSovLFxuICAgIC8vICQxXG4gICAgL1smKiRAJV1cXGQrLyxcbiAgICAvLyAkXywgQF8sICUhXG4gICAgLy8gVGhlIG5lZ2F0aXZlIGxvb2thaGVhZCBwcmV2ZW50cyBmcm9tIGJyZWFraW5nIHRoZSAlPSBvcGVyYXRvclxuICAgIC8oPyElPSlbJEAlXVshXCIjJCUmJygpKissXFwtLlxcLzo7PD0+P0BbXFxcXFxcXV5fYHt8fX5dL10sXG4gICAgJ2ZpbGVoYW5kbGUnOiB7XG4gICAgICAvLyA8PiwgPEZPTz4sIF9cbiAgICAgIHBhdHRlcm46IC88KD8hWzw9XSlcXFMqPz58XFxiX1xcYi8sXG4gICAgICBhbGlhczogJ3N5bWJvbCdcbiAgICB9LFxuICAgICd2LXN0cmluZyc6IHtcbiAgICAgIC8vIHYxLjIsIDEuMi4zXG4gICAgICBwYXR0ZXJuOiAvdlxcZCsoPzpcXC5cXGQrKSp8XFxkKyg/OlxcLlxcZCspezIsfS8sXG4gICAgICBhbGlhczogJ3N0cmluZydcbiAgICB9LFxuICAgICdmdW5jdGlvbic6IHtcbiAgICAgIHBhdHRlcm46IC8oXFxic3ViWyBcXHRdKylcXHcrLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICdrZXl3b3JkJzogL1xcYig/OmFueXxicmVha3xjb250aW51ZXxkZWZhdWx0fGRlbGV0ZXxkaWV8ZG98ZWxzZXxlbHNpZnxldmFsfGZvcnxmb3JlYWNofGdpdmVufGdvdG98aWZ8bGFzdHxsb2NhbHxteXxuZXh0fG91cnxwYWNrYWdlfHByaW50fHJlZG98cmVxdWlyZXxyZXR1cm58c2F5fHN0YXRlfHN1Ynxzd2l0Y2h8dW5kZWZ8dW5sZXNzfHVudGlsfHVzZXx3aGVufHdoaWxlKVxcYi8sXG4gICAgJ251bWJlcic6IC9cXGIoPzoweFtcXGRBLUZhLWZdKD86Xz9bXFxkQS1GYS1mXSkqfDBiWzAxXSg/Ol8/WzAxXSkqfCg/Oig/OlxcZCg/Ol8/XFxkKSopP1xcLik/XFxkKD86Xz9cXGQpKig/OltFZV1bKy1dP1xcZCspPylcXGIvLFxuICAgICdvcGVyYXRvcic6IC8tW3J3eG9SV1hPZXpzZmRscFNiY3R1Z2tUQk1BQ11cXGJ8XFwrWys9XT98LVstPT5dP3xcXCpcXCo/PT98XFwvXFwvPz0/fD1bPX4+XT98flt+PV0/fFxcfFxcfD89P3wmJj89P3w8KD86PT4/fDw9Pyk/fD4+Pz0/fCFbfj1dP3xbJV5dPT98XFwuKD86PXxcXC5cXC4/KT98W1xcXFw/XXxcXGJ4KD86PXxcXGIpfFxcYig/OmFuZHxjbXB8ZXF8Z2V8Z3R8bGV8bHR8bmV8bm90fG9yfHhvcilcXGIvLFxuICAgICdwdW5jdHVhdGlvbic6IC9be31bXFxdOygpLDpdL1xuICB9O1xufSkoUHJpc20pO1xuKGZ1bmN0aW9uIChQcmlzbSkge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGxhY2Vob2xkZXIgZm9yIHRoZSBnaXZlbiBsYW5ndWFnZSBpZCBhbmQgaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRQbGFjZWhvbGRlcihsYW5ndWFnZSwgaW5kZXgpIHtcbiAgICByZXR1cm4gJ19fXycgKyBsYW5ndWFnZS50b1VwcGVyQ2FzZSgpICsgaW5kZXggKyAnX19fJztcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhQcmlzbS5sYW5ndWFnZXNbJ21hcmt1cC10ZW1wbGF0aW5nJ10gPSB7fSwge1xuICAgIGJ1aWxkUGxhY2Vob2xkZXJzOiB7XG4gICAgICAvKipcbiAgICAgICAqIFRva2VuaXplIGFsbCBpbmxpbmUgdGVtcGxhdGluZyBleHByZXNzaW9ucyBtYXRjaGluZyBgcGxhY2Vob2xkZXJQYXR0ZXJuYC5cbiAgICAgICAqXG4gICAgICAgKiBJZiBgcmVwbGFjZUZpbHRlcmAgaXMgcHJvdmlkZWQsIG9ubHkgbWF0Y2hlcyBvZiBgcGxhY2Vob2xkZXJQYXR0ZXJuYCBmb3Igd2hpY2ggYHJlcGxhY2VGaWx0ZXJgIHJldHVybnNcbiAgICAgICAqIGB0cnVlYCB3aWxsIGJlIHJlcGxhY2VkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBlbnYgVGhlIGVudmlyb25tZW50IG9mIHRoZSBgYmVmb3JlLXRva2VuaXplYCBob29rLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlIFRoZSBsYW5ndWFnZSBpZC5cbiAgICAgICAqIEBwYXJhbSB7UmVnRXhwfSBwbGFjZWhvbGRlclBhdHRlcm4gVGhlIG1hdGNoZXMgb2YgdGhpcyBwYXR0ZXJuIHdpbGwgYmUgcmVwbGFjZWQgYnkgcGxhY2Vob2xkZXJzLlxuICAgICAgICogQHBhcmFtIHsobWF0Y2g6IHN0cmluZykgPT4gYm9vbGVhbn0gW3JlcGxhY2VGaWx0ZXJdXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoZW52LCBsYW5ndWFnZSwgcGxhY2Vob2xkZXJQYXR0ZXJuLCByZXBsYWNlRmlsdGVyKSB7XG4gICAgICAgIGlmIChlbnYubGFuZ3VhZ2UgIT09IGxhbmd1YWdlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b2tlblN0YWNrID0gZW52LnRva2VuU3RhY2sgPSBbXTtcbiAgICAgICAgZW52LmNvZGUgPSBlbnYuY29kZS5yZXBsYWNlKHBsYWNlaG9sZGVyUGF0dGVybiwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlRmlsdGVyID09PSAnZnVuY3Rpb24nICYmICFyZXBsYWNlRmlsdGVyKG1hdGNoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaSA9IHRva2VuU3RhY2subGVuZ3RoO1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlcjtcblxuICAgICAgICAgIC8vIENoZWNrIGZvciBleGlzdGluZyBzdHJpbmdzXG4gICAgICAgICAgd2hpbGUgKGVudi5jb2RlLmluZGV4T2YocGxhY2Vob2xkZXIgPSBnZXRQbGFjZWhvbGRlcihsYW5ndWFnZSwgaSkpICE9PSAtMSkge1xuICAgICAgICAgICAgKytpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENyZWF0ZSBhIHNwYXJzZSBhcnJheVxuICAgICAgICAgIHRva2VuU3RhY2tbaV0gPSBtYXRjaDtcbiAgICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFN3aXRjaCB0aGUgZ3JhbW1hciB0byBtYXJrdXBcbiAgICAgICAgZW52LmdyYW1tYXIgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuICAgICAgfVxuICAgIH0sXG4gICAgdG9rZW5pemVQbGFjZWhvbGRlcnM6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVwbGFjZSBwbGFjZWhvbGRlcnMgd2l0aCBwcm9wZXIgdG9rZW5zIGFmdGVyIHRva2VuaXppbmcuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IGVudiBUaGUgZW52aXJvbm1lbnQgb2YgdGhlIGBhZnRlci10b2tlbml6ZWAgaG9vay5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZSBUaGUgbGFuZ3VhZ2UgaWQuXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoZW52LCBsYW5ndWFnZSkge1xuICAgICAgICBpZiAoZW52Lmxhbmd1YWdlICE9PSBsYW5ndWFnZSB8fCAhZW52LnRva2VuU3RhY2spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTd2l0Y2ggdGhlIGdyYW1tYXIgYmFja1xuICAgICAgICBlbnYuZ3JhbW1hciA9IFByaXNtLmxhbmd1YWdlc1tsYW5ndWFnZV07XG4gICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhlbnYudG9rZW5TdGFjayk7XG4gICAgICAgIGZ1bmN0aW9uIHdhbGtUb2tlbnModG9rZW5zKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGFsbCBwbGFjZWhvbGRlcnMgYXJlIHJlcGxhY2VkIGFscmVhZHlcbiAgICAgICAgICAgIGlmIChqID49IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycgfHwgdG9rZW4uY29udGVudCAmJiB0eXBlb2YgdG9rZW4uY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdmFyIGsgPSBrZXlzW2pdO1xuICAgICAgICAgICAgICB2YXIgdCA9IGVudi50b2tlblN0YWNrW2tdO1xuICAgICAgICAgICAgICB2YXIgcyA9IHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycgPyB0b2tlbiA6IHRva2VuLmNvbnRlbnQ7XG4gICAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IGdldFBsYWNlaG9sZGVyKGxhbmd1YWdlLCBrKTtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcy5pbmRleE9mKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICAgICAgdmFyIGJlZm9yZSA9IHMuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB2YXIgbWlkZGxlID0gbmV3IFByaXNtLlRva2VuKGxhbmd1YWdlLCBQcmlzbS50b2tlbml6ZSh0LCBlbnYuZ3JhbW1hciksICdsYW5ndWFnZS0nICsgbGFuZ3VhZ2UsIHQpO1xuICAgICAgICAgICAgICAgIHZhciBhZnRlciA9IHMuc3Vic3RyaW5nKGluZGV4ICsgcGxhY2Vob2xkZXIubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5wdXNoLmFwcGx5KHJlcGxhY2VtZW50LCB3YWxrVG9rZW5zKFtiZWZvcmVdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnB1c2gobWlkZGxlKTtcbiAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnB1c2guYXBwbHkocmVwbGFjZW1lbnQsIHdhbGtUb2tlbnMoW2FmdGVyXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgdG9rZW5zLnNwbGljZS5hcHBseSh0b2tlbnMsIFtpLCAxXS5jb25jYXQocmVwbGFjZW1lbnQpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi5jb250ZW50IC8qICYmIHR5cGVvZiB0b2tlbi5jb250ZW50ICE9PSAnc3RyaW5nJyAqLykge1xuICAgICAgICAgICAgICB3YWxrVG9rZW5zKHRva2VuLmNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICB9XG4gICAgICAgIHdhbGtUb2tlbnMoZW52LnRva2Vucyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn0pKFByaXNtKTtcblxuLyoqXG4gKiBPcmlnaW5hbCBieSBBYXJvbiBIYXJ1bjogaHR0cDovL2FhaGFjcmVhdGl2ZS5jb20vMjAxMi8wNy8zMS9waHAtc3ludGF4LWhpZ2hsaWdodGluZy1wcmlzbS9cbiAqIE1vZGlmaWVkIGJ5IE1pbGVzIEpvaG5zb246IGh0dHA6Ly9taWxlc2oubWVcbiAqIFJld3JpdHRlbiBieSBUb20gUGF2ZWxlY1xuICpcbiAqIFN1cHBvcnRzIFBIUCA1LjMgLSA4LjBcbiAqL1xuKGZ1bmN0aW9uIChQcmlzbSkge1xuICB2YXIgY29tbWVudCA9IC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvfFxcL1xcLy4qfCMoPyFcXFspLiovO1xuICB2YXIgY29uc3RhbnQgPSBbe1xuICAgIHBhdHRlcm46IC9cXGIoPzpmYWxzZXx0cnVlKVxcYi9pLFxuICAgIGFsaWFzOiAnYm9vbGVhbidcbiAgfSwge1xuICAgIHBhdHRlcm46IC8oOjpcXHMqKVxcYlthLXpfXVxcdypcXGIoPyFcXHMqXFwoKS9pLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvKFxcYig/OmNhc2V8Y29uc3QpXFxzKylcXGJbYS16X11cXHcqKD89XFxzKls7PV0pL2ksXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSwgL1xcYig/Om51bGwpXFxiL2ksIC9cXGJbQS1aX11bQS1aMC05X10qXFxiKD8hXFxzKlxcKCkvXTtcbiAgdmFyIG51bWJlciA9IC9cXGIwYlswMV0rKD86X1swMV0rKSpcXGJ8XFxiMG9bMC03XSsoPzpfWzAtN10rKSpcXGJ8XFxiMHhbXFxkYS1mXSsoPzpfW1xcZGEtZl0rKSpcXGJ8KD86XFxiXFxkKyg/Ol9cXGQrKSpcXC4/KD86XFxkKyg/Ol9cXGQrKSopP3xcXEJcXC5cXGQrKSg/OmVbKy1dP1xcZCspPy9pO1xuICB2YXIgb3BlcmF0b3IgPSAvPD89PnxcXD9cXD89P3xcXC57M318XFw/Py0+fFshPV09Pz0/fDo6fFxcKlxcKj0/fC0tfFxcK1xcK3wmJnxcXHxcXHx8PDx8Pj58Wz9+XXxbL158JSomPD4uKy1dPT8vO1xuICB2YXIgcHVuY3R1YXRpb24gPSAvW3t9XFxbXFxdKCksOjtdLztcbiAgUHJpc20ubGFuZ3VhZ2VzLnBocCA9IHtcbiAgICAnZGVsaW1pdGVyJzoge1xuICAgICAgcGF0dGVybjogL1xcPz4kfF48XFw/KD86cGhwKD89XFxzKXw9KT8vaSxcbiAgICAgIGFsaWFzOiAnaW1wb3J0YW50J1xuICAgIH0sXG4gICAgJ2NvbW1lbnQnOiBjb21tZW50LFxuICAgICd2YXJpYWJsZSc6IC9cXCQrKD86XFx3K1xcYnwoPz1cXHspKS8sXG4gICAgJ3BhY2thZ2UnOiB7XG4gICAgICBwYXR0ZXJuOiAvKG5hbWVzcGFjZVxccyt8dXNlXFxzKyg/OmZ1bmN0aW9uXFxzKyk/KSg/OlxcXFw/XFxiW2Etel9dXFx3KikrXFxiKD8hXFxcXCkvaSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcXFwvXG4gICAgICB9XG4gICAgfSxcbiAgICAnY2xhc3MtbmFtZS1kZWZpbml0aW9uJzoge1xuICAgICAgcGF0dGVybjogLyhcXGIoPzpjbGFzc3xlbnVtfGludGVyZmFjZXx0cmFpdClcXHMrKVxcYlthLXpfXVxcdyooPyFcXFxcKVxcYi9pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnY2xhc3MtbmFtZSdcbiAgICB9LFxuICAgICdmdW5jdGlvbi1kZWZpbml0aW9uJzoge1xuICAgICAgcGF0dGVybjogLyhcXGJmdW5jdGlvblxccyspW2Etel9dXFx3Kig/PVxccypcXCgpL2ksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6ICdmdW5jdGlvbidcbiAgICB9LFxuICAgICdrZXl3b3JkJzogW3tcbiAgICAgIHBhdHRlcm46IC8oXFwoXFxzKilcXGIoPzphcnJheXxib29sfGJvb2xlYW58ZmxvYXR8aW50fGludGVnZXJ8b2JqZWN0fHN0cmluZylcXGIoPz1cXHMqXFwpKS9pLFxuICAgICAgYWxpYXM6ICd0eXBlLWNhc3RpbmcnLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHBhdHRlcm46IC8oWygsP11cXHMqKVxcYig/OmFycmF5KD8hXFxzKlxcKCl8Ym9vbHxjYWxsYWJsZXwoPzpmYWxzZXxudWxsKSg/PVxccypcXHwpfGZsb2F0fGludHxpdGVyYWJsZXxtaXhlZHxvYmplY3R8c2VsZnxzdGF0aWN8c3RyaW5nKVxcYig/PVxccypcXCQpL2ksXG4gICAgICBhbGlhczogJ3R5cGUtaGludCcsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSwge1xuICAgICAgcGF0dGVybjogLyhcXClcXHMqOlxccyooPzpcXD9cXHMqKT8pXFxiKD86YXJyYXkoPyFcXHMqXFwoKXxib29sfGNhbGxhYmxlfCg/OmZhbHNlfG51bGwpKD89XFxzKlxcfCl8ZmxvYXR8aW50fGl0ZXJhYmxlfG1peGVkfG5ldmVyfG9iamVjdHxzZWxmfHN0YXRpY3xzdHJpbmd8dm9pZClcXGIvaSxcbiAgICAgIGFsaWFzOiAncmV0dXJuLXR5cGUnLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHBhdHRlcm46IC9cXGIoPzphcnJheSg/IVxccypcXCgpfGJvb2x8ZmxvYXR8aW50fGl0ZXJhYmxlfG1peGVkfG9iamVjdHxzdHJpbmd8dm9pZClcXGIvaSxcbiAgICAgIGFsaWFzOiAndHlwZS1kZWNsYXJhdGlvbicsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvKFxcfFxccyopKD86ZmFsc2V8bnVsbClcXGJ8XFxiKD86ZmFsc2V8bnVsbCkoPz1cXHMqXFx8KS9pLFxuICAgICAgYWxpYXM6ICd0eXBlLWRlY2xhcmF0aW9uJyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvXFxiKD86cGFyZW50fHNlbGZ8c3RhdGljKSg/PVxccyo6OikvaSxcbiAgICAgIGFsaWFzOiAnc3RhdGljLWNvbnRleHQnLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSwge1xuICAgICAgLy8geWllbGQgZnJvbVxuICAgICAgcGF0dGVybjogLyhcXGJ5aWVsZFxccyspZnJvbVxcYi9pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgLy8gYGNsYXNzYCBpcyBhbHdheXMgYSBrZXl3b3JkIHVubGlrZSBvdGhlciBrZXl3b3Jkc1xuICAgIC9cXGJjbGFzc1xcYi9pLCB7XG4gICAgICAvLyBodHRwczovL3d3dy5waHAubmV0L21hbnVhbC9lbi9yZXNlcnZlZC5rZXl3b3Jkcy5waHBcbiAgICAgIC8vXG4gICAgICAvLyBrZXl3b3JkcyBjYW5ub3QgYmUgcHJlY2VkZWQgYnkgXCItPlwiXG4gICAgICAvLyB0aGUgY29tcGxleCBsb29rYmVoaW5kIG1lYW5zIGAoPzwhKD86LT58OjopXFxzKilgXG4gICAgICBwYXR0ZXJuOiAvKCg/Ol58W15cXHM+Ol18KD86XnxbXi1dKT58KD86XnxbXjpdKTopXFxzKilcXGIoPzphYnN0cmFjdHxhbmR8YXJyYXl8YXN8YnJlYWt8Y2FsbGFibGV8Y2FzZXxjYXRjaHxjbG9uZXxjb25zdHxjb250aW51ZXxkZWNsYXJlfGRlZmF1bHR8ZGllfGRvfGVjaG98ZWxzZXxlbHNlaWZ8ZW1wdHl8ZW5kZGVjbGFyZXxlbmRmb3J8ZW5kZm9yZWFjaHxlbmRpZnxlbmRzd2l0Y2h8ZW5kd2hpbGV8ZW51bXxldmFsfGV4aXR8ZXh0ZW5kc3xmaW5hbHxmaW5hbGx5fGZufGZvcnxmb3JlYWNofGZ1bmN0aW9ufGdsb2JhbHxnb3RvfGlmfGltcGxlbWVudHN8aW5jbHVkZXxpbmNsdWRlX29uY2V8aW5zdGFuY2VvZnxpbnN0ZWFkb2Z8aW50ZXJmYWNlfGlzc2V0fGxpc3R8bWF0Y2h8bmFtZXNwYWNlfG5ldmVyfG5ld3xvcnxwYXJlbnR8cHJpbnR8cHJpdmF0ZXxwcm90ZWN0ZWR8cHVibGljfHJlYWRvbmx5fHJlcXVpcmV8cmVxdWlyZV9vbmNlfHJldHVybnxzZWxmfHN0YXRpY3xzd2l0Y2h8dGhyb3d8dHJhaXR8dHJ5fHVuc2V0fHVzZXx2YXJ8d2hpbGV8eG9yfHlpZWxkfF9faGFsdF9jb21waWxlcilcXGIvaSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9XSxcbiAgICAnYXJndW1lbnQtbmFtZSc6IHtcbiAgICAgIHBhdHRlcm46IC8oWygsXVxccyopXFxiW2Etel9dXFx3Kig/PVxccyo6KD8hOikpL2ksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAnY2xhc3MtbmFtZSc6IFt7XG4gICAgICBwYXR0ZXJuOiAvKFxcYig/OmV4dGVuZHN8aW1wbGVtZW50c3xpbnN0YW5jZW9mfG5ldyg/IVxccytzZWxmfFxccytzdGF0aWMpKVxccyt8XFxiY2F0Y2hcXHMqXFwoKVxcYlthLXpfXVxcdyooPyFcXFxcKVxcYi9pLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHBhdHRlcm46IC8oXFx8XFxzKilcXGJbYS16X11cXHcqKD8hXFxcXClcXGIvaSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvXFxiW2Etel9dXFx3Kig/IVxcXFwpXFxiKD89XFxzKlxcfCkvaSxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHBhdHRlcm46IC8oXFx8XFxzKikoPzpcXFxcP1xcYlthLXpfXVxcdyopK1xcYi9pLFxuICAgICAgYWxpYXM6ICdjbGFzcy1uYW1lLWZ1bGx5LXF1YWxpZmllZCcsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9cXFxcL1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHBhdHRlcm46IC8oPzpcXFxcP1xcYlthLXpfXVxcdyopK1xcYig/PVxccypcXHwpL2ksXG4gICAgICBhbGlhczogJ2NsYXNzLW5hbWUtZnVsbHktcXVhbGlmaWVkJyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncHVuY3R1YXRpb24nOiAvXFxcXC9cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvKFxcYig/OmV4dGVuZHN8aW1wbGVtZW50c3xpbnN0YW5jZW9mfG5ldyg/IVxccytzZWxmXFxifFxccytzdGF0aWNcXGIpKVxccyt8XFxiY2F0Y2hcXHMqXFwoKSg/OlxcXFw/XFxiW2Etel9dXFx3KikrXFxiKD8hXFxcXCkvaSxcbiAgICAgIGFsaWFzOiAnY2xhc3MtbmFtZS1mdWxseS1xdWFsaWZpZWQnLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncHVuY3R1YXRpb24nOiAvXFxcXC9cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvXFxiW2Etel9dXFx3Kig/PVxccypcXCQpL2ksXG4gICAgICBhbGlhczogJ3R5cGUtZGVjbGFyYXRpb24nLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSwge1xuICAgICAgcGF0dGVybjogLyg/OlxcXFw/XFxiW2Etel9dXFx3KikrKD89XFxzKlxcJCkvaSxcbiAgICAgIGFsaWFzOiBbJ2NsYXNzLW5hbWUtZnVsbHktcXVhbGlmaWVkJywgJ3R5cGUtZGVjbGFyYXRpb24nXSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncHVuY3R1YXRpb24nOiAvXFxcXC9cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvXFxiW2Etel9dXFx3Kig/PVxccyo6OikvaSxcbiAgICAgIGFsaWFzOiAnc3RhdGljLWNvbnRleHQnLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSwge1xuICAgICAgcGF0dGVybjogLyg/OlxcXFw/XFxiW2Etel9dXFx3KikrKD89XFxzKjo6KS9pLFxuICAgICAgYWxpYXM6IFsnY2xhc3MtbmFtZS1mdWxseS1xdWFsaWZpZWQnLCAnc3RhdGljLWNvbnRleHQnXSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncHVuY3R1YXRpb24nOiAvXFxcXC9cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvKFsoLD9dXFxzKilbYS16X11cXHcqKD89XFxzKlxcJCkvaSxcbiAgICAgIGFsaWFzOiAndHlwZS1oaW50JyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvKFsoLD9dXFxzKikoPzpcXFxcP1xcYlthLXpfXVxcdyopKyg/PVxccypcXCQpL2ksXG4gICAgICBhbGlhczogWydjbGFzcy1uYW1lLWZ1bGx5LXF1YWxpZmllZCcsICd0eXBlLWhpbnQnXSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcXFwvXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgcGF0dGVybjogLyhcXClcXHMqOlxccyooPzpcXD9cXHMqKT8pXFxiW2Etel9dXFx3Kig/IVxcXFwpXFxiL2ksXG4gICAgICBhbGlhczogJ3JldHVybi10eXBlJyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvKFxcKVxccyo6XFxzKig/OlxcP1xccyopPykoPzpcXFxcP1xcYlthLXpfXVxcdyopK1xcYig/IVxcXFwpL2ksXG4gICAgICBhbGlhczogWydjbGFzcy1uYW1lLWZ1bGx5LXF1YWxpZmllZCcsICdyZXR1cm4tdHlwZSddLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncHVuY3R1YXRpb24nOiAvXFxcXC9cbiAgICAgIH1cbiAgICB9XSxcbiAgICAnY29uc3RhbnQnOiBjb25zdGFudCxcbiAgICAnZnVuY3Rpb24nOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W15cXFxcXFx3XSlcXFxcP1thLXpfXSg/OltcXHdcXFxcXSpcXHcpPyg/PVxccypcXCgpL2ksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9cXFxcL1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3Byb3BlcnR5Jzoge1xuICAgICAgcGF0dGVybjogLygtPlxccyopXFx3Ky8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAnbnVtYmVyJzogbnVtYmVyLFxuICAgICdvcGVyYXRvcic6IG9wZXJhdG9yLFxuICAgICdwdW5jdHVhdGlvbic6IHB1bmN0dWF0aW9uXG4gIH07XG4gIHZhciBzdHJpbmdfaW50ZXJwb2xhdGlvbiA9IHtcbiAgICBwYXR0ZXJuOiAvXFx7XFwkKD86XFx7KD86XFx7W157fV0rXFx9fFtee31dKylcXH18W157fV0pK1xcfXwoXnxbXlxcXFx7XSlcXCQrKD86XFx3Kyg/OlxcW1teXFxyXFxuXFxbXFxdXStcXF18LT5cXHcrKT8pLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLnBocFxuICB9O1xuICB2YXIgc3RyaW5nID0gW3tcbiAgICBwYXR0ZXJuOiAvPDw8JyhbXiddKyknW1xcclxcbl0oPzouKltcXHJcXG5dKSo/XFwxOy8sXG4gICAgYWxpYXM6ICdub3dkb2Mtc3RyaW5nJyxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICAnZGVsaW1pdGVyJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXjw8PCdbXiddKyd8W2Etel9dXFx3KjskL2ksXG4gICAgICAgIGFsaWFzOiAnc3ltYm9sJyxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgJ3B1bmN0dWF0aW9uJzogL148PDwnP3xbJztdJC9cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIHBhdHRlcm46IC88PDwoPzpcIihbXlwiXSspXCJbXFxyXFxuXSg/Oi4qW1xcclxcbl0pKj9cXDE7fChbYS16X11cXHcqKVtcXHJcXG5dKD86LipbXFxyXFxuXSkqP1xcMjspL2ksXG4gICAgYWxpYXM6ICdoZXJlZG9jLXN0cmluZycsXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ2RlbGltaXRlcic6IHtcbiAgICAgICAgcGF0dGVybjogL148PDwoPzpcIlteXCJdK1wifFthLXpfXVxcdyopfFthLXpfXVxcdyo7JC9pLFxuICAgICAgICBhbGlhczogJ3N5bWJvbCcsXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9ePDw8XCI/fFtcIjtdJC9cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICdpbnRlcnBvbGF0aW9uJzogc3RyaW5nX2ludGVycG9sYXRpb25cbiAgICB9XG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvYCg/OlxcXFxbXFxzXFxTXXxbXlxcXFxgXSkqYC8sXG4gICAgYWxpYXM6ICdiYWNrdGljay1xdW90ZWQtc3RyaW5nJyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSwge1xuICAgIHBhdHRlcm46IC8nKD86XFxcXFtcXHNcXFNdfFteXFxcXCddKSonLyxcbiAgICBhbGlhczogJ3NpbmdsZS1xdW90ZWQtc3RyaW5nJyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSwge1xuICAgIHBhdHRlcm46IC9cIig/OlxcXFxbXFxzXFxTXXxbXlxcXFxcIl0pKlwiLyxcbiAgICBhbGlhczogJ2RvdWJsZS1xdW90ZWQtc3RyaW5nJyxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICAnaW50ZXJwb2xhdGlvbic6IHN0cmluZ19pbnRlcnBvbGF0aW9uXG4gICAgfVxuICB9XTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgncGhwJywgJ3ZhcmlhYmxlJywge1xuICAgICdzdHJpbmcnOiBzdHJpbmcsXG4gICAgJ2F0dHJpYnV0ZSc6IHtcbiAgICAgIHBhdHRlcm46IC8jXFxbKD86W15cIidcXC8jXXxcXC8oPyFbKi9dKXxcXC9cXC8uKiR8Iyg/IVxcWykuKiR8XFwvXFwqKD86W14qXXxcXCooPyFcXC8pKSpcXCpcXC98XCIoPzpcXFxcW1xcc1xcU118W15cXFxcXCJdKSpcInwnKD86XFxcXFtcXHNcXFNdfFteXFxcXCddKSonKStcXF0oPz1cXHMqW2EteiQjXSkvaW0sXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2F0dHJpYnV0ZS1jb250ZW50Jzoge1xuICAgICAgICAgIHBhdHRlcm46IC9eKCNcXFspW1xcc1xcU10rKD89XFxdJCkvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgLy8gaW5zaWRlIGNhbiBhcHBlYXIgc3Vic2V0IG9mIHBocFxuICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgJ2NvbW1lbnQnOiBjb21tZW50LFxuICAgICAgICAgICAgJ3N0cmluZyc6IHN0cmluZyxcbiAgICAgICAgICAgICdhdHRyaWJ1dGUtY2xhc3MtbmFtZSc6IFt7XG4gICAgICAgICAgICAgIHBhdHRlcm46IC8oW146XXxeKVxcYlthLXpfXVxcdyooPyFcXFxcKVxcYi9pLFxuICAgICAgICAgICAgICBhbGlhczogJ2NsYXNzLW5hbWUnLFxuICAgICAgICAgICAgICBncmVlZHk6IHRydWUsXG4gICAgICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgcGF0dGVybjogLyhbXjpdfF4pKD86XFxcXD9cXGJbYS16X11cXHcqKSsvaSxcbiAgICAgICAgICAgICAgYWxpYXM6IFsnY2xhc3MtbmFtZScsICdjbGFzcy1uYW1lLWZ1bGx5LXF1YWxpZmllZCddLFxuICAgICAgICAgICAgICBncmVlZHk6IHRydWUsXG4gICAgICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9cXFxcL1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICdjb25zdGFudCc6IGNvbnN0YW50LFxuICAgICAgICAgICAgJ251bWJlcic6IG51bWJlcixcbiAgICAgICAgICAgICdvcGVyYXRvcic6IG9wZXJhdG9yLFxuICAgICAgICAgICAgJ3B1bmN0dWF0aW9uJzogcHVuY3R1YXRpb25cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICdkZWxpbWl0ZXInOiB7XG4gICAgICAgICAgcGF0dGVybjogL14jXFxbfFxcXSQvLFxuICAgICAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBQcmlzbS5ob29rcy5hZGQoJ2JlZm9yZS10b2tlbml6ZScsIGZ1bmN0aW9uIChlbnYpIHtcbiAgICBpZiAoIS88XFw/Ly50ZXN0KGVudi5jb2RlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcGhwUGF0dGVybiA9IC88XFw/KD86W15cIicvI118XFwvKD8hWyovXSl8KFwifCcpKD86XFxcXFtcXHNcXFNdfCg/IVxcMSlbXlxcXFxdKSpcXDF8KD86XFwvXFwvfCMoPyFcXFspKSg/OlteP1xcblxccl18XFw/KD8hPikpKig/PSR8XFw/PnxbXFxyXFxuXSl8I1xcW3xcXC9cXCooPzpbXipdfFxcKig/IVxcLykpKig/OlxcKlxcL3wkKSkqPyg/OlxcPz58JCkvZztcbiAgICBQcmlzbS5sYW5ndWFnZXNbJ21hcmt1cC10ZW1wbGF0aW5nJ10uYnVpbGRQbGFjZWhvbGRlcnMoZW52LCAncGhwJywgcGhwUGF0dGVybik7XG4gIH0pO1xuICBQcmlzbS5ob29rcy5hZGQoJ2FmdGVyLXRva2VuaXplJywgZnVuY3Rpb24gKGVudikge1xuICAgIFByaXNtLmxhbmd1YWdlc1snbWFya3VwLXRlbXBsYXRpbmcnXS50b2tlbml6ZVBsYWNlaG9sZGVycyhlbnYsICdwaHAnKTtcbiAgfSk7XG59KShQcmlzbSk7XG5QcmlzbS5sYW5ndWFnZXMucHl0aG9uID0ge1xuICAnY29tbWVudCc6IHtcbiAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSkjLiovLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdzdHJpbmctaW50ZXJwb2xhdGlvbic6IHtcbiAgICBwYXR0ZXJuOiAvKD86ZnxmcnxyZikoPzooXCJcIlwifCcnJylbXFxzXFxTXSo/XFwxfChcInwnKSg/OlxcXFwufCg/IVxcMilbXlxcXFxcXHJcXG5dKSpcXDIpL2ksXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ2ludGVycG9sYXRpb24nOiB7XG4gICAgICAgIC8vIFwie1wiIDxleHByZXNzaW9uPiA8b3B0aW9uYWwgXCIhc1wiLCBcIiFyXCIsIG9yIFwiIWFcIj4gPG9wdGlvbmFsIFwiOlwiIGZvcm1hdCBzcGVjaWZpZXI+IFwifVwiXG4gICAgICAgIHBhdHRlcm46IC8oKD86XnxbXntdKSg/Olxce1xceykqKVxceyg/IVxceykoPzpbXnt9XXxcXHsoPyFcXHspKD86W157fV18XFx7KD8hXFx7KSg/Oltee31dKStcXH0pK1xcfSkrXFx9LyxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgJ2Zvcm1hdC1zcGVjJzoge1xuICAgICAgICAgICAgcGF0dGVybjogLyg6KVteOigpe31dKyg/PVxcfSQpLyxcbiAgICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgICdjb252ZXJzaW9uLW9wdGlvbic6IHtcbiAgICAgICAgICAgIHBhdHRlcm46IC8hW3NyYV0oPz1bOn1dJCkvLFxuICAgICAgICAgICAgYWxpYXM6ICdwdW5jdHVhdGlvbidcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc3Q6IG51bGxcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICdzdHJpbmcnOiAvW1xcc1xcU10rL1xuICAgIH1cbiAgfSxcbiAgJ3RyaXBsZS1xdW90ZWQtc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC8oPzpbcnViXXxicnxyYik/KFwiXCJcInwnJycpW1xcc1xcU10qP1xcMS9pLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBhbGlhczogJ3N0cmluZydcbiAgfSxcbiAgJ3N0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvKD86W3J1Yl18YnJ8cmIpPyhcInwnKSg/OlxcXFwufCg/IVxcMSlbXlxcXFxcXHJcXG5dKSpcXDEvaSxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ2Z1bmN0aW9uJzoge1xuICAgIHBhdHRlcm46IC8oKD86XnxcXHMpZGVmWyBcXHRdKylbYS16QS1aX11cXHcqKD89XFxzKlxcKCkvZyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sXG4gICdjbGFzcy1uYW1lJzoge1xuICAgIHBhdHRlcm46IC8oXFxiY2xhc3NcXHMrKVxcdysvaSxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sXG4gICdkZWNvcmF0b3InOiB7XG4gICAgcGF0dGVybjogLyheW1xcdCBdKilAXFx3Kyg/OlxcLlxcdyspKi9tLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgYWxpYXM6IFsnYW5ub3RhdGlvbicsICdwdW5jdHVhdGlvbiddLFxuICAgIGluc2lkZToge1xuICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcLi9cbiAgICB9XG4gIH0sXG4gICdrZXl3b3JkJzogL1xcYig/Ol8oPz1cXHMqOil8YW5kfGFzfGFzc2VydHxhc3luY3xhd2FpdHxicmVha3xjYXNlfGNsYXNzfGNvbnRpbnVlfGRlZnxkZWx8ZWxpZnxlbHNlfGV4Y2VwdHxleGVjfGZpbmFsbHl8Zm9yfGZyb218Z2xvYmFsfGlmfGltcG9ydHxpbnxpc3xsYW1iZGF8bWF0Y2h8bm9ubG9jYWx8bm90fG9yfHBhc3N8cHJpbnR8cmFpc2V8cmV0dXJufHRyeXx3aGlsZXx3aXRofHlpZWxkKVxcYi8sXG4gICdidWlsdGluJzogL1xcYig/Ol9faW1wb3J0X198YWJzfGFsbHxhbnl8YXBwbHl8YXNjaWl8YmFzZXN0cmluZ3xiaW58Ym9vbHxidWZmZXJ8Ynl0ZWFycmF5fGJ5dGVzfGNhbGxhYmxlfGNocnxjbGFzc21ldGhvZHxjbXB8Y29lcmNlfGNvbXBpbGV8Y29tcGxleHxkZWxhdHRyfGRpY3R8ZGlyfGRpdm1vZHxlbnVtZXJhdGV8ZXZhbHxleGVjZmlsZXxmaWxlfGZpbHRlcnxmbG9hdHxmb3JtYXR8ZnJvemVuc2V0fGdldGF0dHJ8Z2xvYmFsc3xoYXNhdHRyfGhhc2h8aGVscHxoZXh8aWR8aW5wdXR8aW50fGludGVybnxpc2luc3RhbmNlfGlzc3ViY2xhc3N8aXRlcnxsZW58bGlzdHxsb2NhbHN8bG9uZ3xtYXB8bWF4fG1lbW9yeXZpZXd8bWlufG5leHR8b2JqZWN0fG9jdHxvcGVufG9yZHxwb3d8cHJvcGVydHl8cmFuZ2V8cmF3X2lucHV0fHJlZHVjZXxyZWxvYWR8cmVwcnxyZXZlcnNlZHxyb3VuZHxzZXR8c2V0YXR0cnxzbGljZXxzb3J0ZWR8c3RhdGljbWV0aG9kfHN0cnxzdW18c3VwZXJ8dHVwbGV8dHlwZXx1bmljaHJ8dW5pY29kZXx2YXJzfHhyYW5nZXx6aXApXFxiLyxcbiAgJ2Jvb2xlYW4nOiAvXFxiKD86RmFsc2V8Tm9uZXxUcnVlKVxcYi8sXG4gICdudW1iZXInOiAvXFxiMCg/OmIoPzpfP1swMV0pK3xvKD86Xz9bMC03XSkrfHgoPzpfP1thLWYwLTldKSspXFxifCg/OlxcYlxcZCsoPzpfXFxkKykqKD86XFwuKD86XFxkKyg/Ol9cXGQrKSopPyk/fFxcQlxcLlxcZCsoPzpfXFxkKykqKSg/OmVbKy1dP1xcZCsoPzpfXFxkKykqKT9qPyg/IVxcdykvaSxcbiAgJ29wZXJhdG9yJzogL1stKyU9XT0/fCE9fDo9fFxcKlxcKj89P3xcXC9cXC8/PT98PFs8PT5dP3w+Wz0+XT98WyZ8Xn5dLyxcbiAgJ3B1bmN0dWF0aW9uJzogL1t7fVtcXF07KCksLjpdL1xufTtcblByaXNtLmxhbmd1YWdlcy5weXRob25bJ3N0cmluZy1pbnRlcnBvbGF0aW9uJ10uaW5zaWRlWydpbnRlcnBvbGF0aW9uJ10uaW5zaWRlLnJlc3QgPSBQcmlzbS5sYW5ndWFnZXMucHl0aG9uO1xuUHJpc20ubGFuZ3VhZ2VzLnB5ID0gUHJpc20ubGFuZ3VhZ2VzLnB5dGhvbjtcblByaXNtLmxhbmd1YWdlcy5yID0ge1xuICAnY29tbWVudCc6IC8jLiovLFxuICAnc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC8oWydcIl0pKD86XFxcXC58KD8hXFwxKVteXFxcXFxcclxcbl0pKlxcMS8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdwZXJjZW50LW9wZXJhdG9yJzoge1xuICAgIC8vIEluY2x1ZGVzIHVzZXItZGVmaW5lZCBvcGVyYXRvcnNcbiAgICAvLyBhbmQgJSUsICUqJSwgJS8lLCAlaW4lLCAlbyUsICV4JVxuICAgIHBhdHRlcm46IC8lW14lXFxzXSolLyxcbiAgICBhbGlhczogJ29wZXJhdG9yJ1xuICB9LFxuICAnYm9vbGVhbic6IC9cXGIoPzpGQUxTRXxUUlVFKVxcYi8sXG4gICdlbGxpcHNpcyc6IC9cXC5cXC4oPzpcXC58XFxkKykvLFxuICAnbnVtYmVyJzogWy9cXGIoPzpJbmZ8TmFOKVxcYi8sIC8oPzpcXGIweFtcXGRBLUZhLWZdKyg/OlxcLlxcZCopP3xcXGJcXGQrKD86XFwuXFxkKik/fFxcQlxcLlxcZCspKD86W0VlUHBdWystXT9cXGQrKT9baUxdPy9dLFxuICAna2V5d29yZCc6IC9cXGIoPzpOQXxOQV9jaGFyYWN0ZXJffE5BX2NvbXBsZXhffE5BX2ludGVnZXJffE5BX3JlYWxffE5VTEx8YnJlYWt8ZWxzZXxmb3J8ZnVuY3Rpb258aWZ8aW58bmV4dHxyZXBlYXR8d2hpbGUpXFxiLyxcbiAgJ29wZXJhdG9yJzogLy0+Pz4/fDwoPzo9fDw/LSk/fFs+PSFdPT98Ojo/fCYmP3xcXHxcXHw/fFsrKlxcL14kQH5dLyxcbiAgJ3B1bmN0dWF0aW9uJzogL1soKXt9XFxbXFxdLDtdL1xufTtcblxuLyoqXG4gKiBPcmlnaW5hbCBieSBTYW11ZWwgRmxvcmVzXG4gKlxuICogQWRkcyB0aGUgZm9sbG93aW5nIG5ldyB0b2tlbiBjbGFzc2VzOlxuICogICAgIGNvbnN0YW50LCBidWlsdGluLCB2YXJpYWJsZSwgc3ltYm9sLCByZWdleFxuICovXG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIFByaXNtLmxhbmd1YWdlcy5ydWJ5ID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY2xpa2UnLCB7XG4gICAgJ2NvbW1lbnQnOiB7XG4gICAgICBwYXR0ZXJuOiAvIy4qfF49YmVnaW5cXHNbXFxzXFxTXSo/Xj1lbmQvbSxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH0sXG4gICAgJ2NsYXNzLW5hbWUnOiB7XG4gICAgICBwYXR0ZXJuOiAvKFxcYig/OmNsYXNzfG1vZHVsZSlcXHMrfFxcYmNhdGNoXFxzK1xcKClbXFx3LlxcXFxdK3xcXGJbQS1aX11cXHcqKD89XFxzKlxcLlxccypuZXdcXGIpLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1suXFxcXF0vXG4gICAgICB9XG4gICAgfSxcbiAgICAna2V5d29yZCc6IC9cXGIoPzpCRUdJTnxFTkR8YWxpYXN8YW5kfGJlZ2lufGJyZWFrfGNhc2V8Y2xhc3N8ZGVmfGRlZmluZV9tZXRob2R8ZGVmaW5lZHxkb3xlYWNofGVsc2V8ZWxzaWZ8ZW5kfGVuc3VyZXxleHRlbmR8Zm9yfGlmfGlufGluY2x1ZGV8bW9kdWxlfG5ld3xuZXh0fG5pbHxub3R8b3J8cHJlcGVuZHxwcml2YXRlfHByb3RlY3RlZHxwdWJsaWN8cmFpc2V8cmVkb3xyZXF1aXJlfHJlc2N1ZXxyZXRyeXxyZXR1cm58c2VsZnxzdXBlcnx0aGVufHRocm93fHVuZGVmfHVubGVzc3x1bnRpbHx3aGVufHdoaWxlfHlpZWxkKVxcYi8sXG4gICAgJ29wZXJhdG9yJzogL1xcLnsyLDN9fCZcXC58PT09fDw/PT58WyE9XT9+fCg/OiYmfFxcfFxcfHw8PHw+PnxcXCpcXCp8WytcXC0qLyU8PiFeJnw9XSk9P3xbPzpdLyxcbiAgICAncHVuY3R1YXRpb24nOiAvWygpe31bXFxdLiw7XS9cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ3J1YnknLCAnb3BlcmF0b3InLCB7XG4gICAgJ2RvdWJsZS1jb2xvbic6IHtcbiAgICAgIHBhdHRlcm46IC86Oi8sXG4gICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgIH1cbiAgfSk7XG4gIHZhciBpbnRlcnBvbGF0aW9uID0ge1xuICAgIHBhdHRlcm46IC8oKD86XnxbXlxcXFxdKSg/OlxcXFx7Mn0pKikjXFx7KD86W157fV18XFx7W157fV0qXFx9KSpcXH0vLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICAnY29udGVudCc6IHtcbiAgICAgICAgcGF0dGVybjogL14oI1xceylbXFxzXFxTXSsoPz1cXH0kKS8sXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLnJ1YnlcbiAgICAgIH0sXG4gICAgICAnZGVsaW1pdGVyJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXiNcXHt8XFx9JC8sXG4gICAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gICAgICB9XG4gICAgfVxuICB9O1xuICBkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLnJ1YnkuZnVuY3Rpb247XG4gIHZhciBwZXJjZW50RXhwcmVzc2lvbiA9ICcoPzonICsgWy8oW15hLXpBLVowLTlcXHN7KFxcWzw9XSkoPzooPyFcXDEpW15cXFxcXXxcXFxcW1xcc1xcU10pKlxcMS8uc291cmNlLCAvXFwoKD86W14oKVxcXFxdfFxcXFxbXFxzXFxTXXxcXCgoPzpbXigpXFxcXF18XFxcXFtcXHNcXFNdKSpcXCkpKlxcKS8uc291cmNlLCAvXFx7KD86W157fVxcXFxdfFxcXFxbXFxzXFxTXXxcXHsoPzpbXnt9XFxcXF18XFxcXFtcXHNcXFNdKSpcXH0pKlxcfS8uc291cmNlLCAvXFxbKD86W15cXFtcXF1cXFxcXXxcXFxcW1xcc1xcU118XFxbKD86W15cXFtcXF1cXFxcXXxcXFxcW1xcc1xcU10pKlxcXSkqXFxdLy5zb3VyY2UsIC88KD86W148PlxcXFxdfFxcXFxbXFxzXFxTXXw8KD86W148PlxcXFxdfFxcXFxbXFxzXFxTXSkqPikqPi8uc291cmNlXS5qb2luKCd8JykgKyAnKSc7XG4gIHZhciBzeW1ib2xOYW1lID0gLyg/OlwiKD86XFxcXC58W15cIlxcXFxcXHJcXG5dKSpcInwoPzpcXGJbYS16QS1aX11cXHcqfFteXFxzXFwwLVxceDdGXSspWz8hXT98XFwkLikvLnNvdXJjZTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgncnVieScsICdrZXl3b3JkJywge1xuICAgICdyZWdleC1saXRlcmFsJzogW3tcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgvJXIvLnNvdXJjZSArIHBlcmNlbnRFeHByZXNzaW9uICsgL1tlZ2ltbm9zdXhdezAsNn0vLnNvdXJjZSksXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2ludGVycG9sYXRpb24nOiBpbnRlcnBvbGF0aW9uLFxuICAgICAgICAncmVnZXgnOiAvW1xcc1xcU10rL1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXi9dKVxcLyg/IVxcLykoPzpcXFtbXlxcclxcblxcXV0rXFxdfFxcXFwufFteWy9cXFxcXFxyXFxuXSkrXFwvW2VnaW1ub3N1eF17MCw2fSg/PVxccyooPzokfFtcXHJcXG4sLjt9KSNdKSkvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnaW50ZXJwb2xhdGlvbic6IGludGVycG9sYXRpb24sXG4gICAgICAgICdyZWdleCc6IC9bXFxzXFxTXSsvXG4gICAgICB9XG4gICAgfV0sXG4gICAgJ3ZhcmlhYmxlJzogL1tAJF0rW2EtekEtWl9dXFx3Kig/Ols/IV18XFxiKS8sXG4gICAgJ3N5bWJvbCc6IFt7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoLyhefFteOl0pOi8uc291cmNlICsgc3ltYm9sTmFtZSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSwge1xuICAgICAgcGF0dGVybjogUmVnRXhwKC8oW1xcclxcbnsoLF1bIFxcdF0qKS8uc291cmNlICsgc3ltYm9sTmFtZSArIC8oPz06KD8hOikpLy5zb3VyY2UpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH1dLFxuICAgICdtZXRob2QtZGVmaW5pdGlvbic6IHtcbiAgICAgIHBhdHRlcm46IC8oXFxiZGVmXFxzKylcXHcrKD86XFxzKlxcLlxccypcXHcrKT8vLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnZnVuY3Rpb24nOiAvXFxiXFx3KyQvLFxuICAgICAgICAna2V5d29yZCc6IC9ec2VsZlxcYi8sXG4gICAgICAgICdjbGFzcy1uYW1lJzogL15cXHcrLyxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcLi9cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdydWJ5JywgJ3N0cmluZycsIHtcbiAgICAnc3RyaW5nLWxpdGVyYWwnOiBbe1xuICAgICAgcGF0dGVybjogUmVnRXhwKC8lW3FRaUl3V3NdPy8uc291cmNlICsgcGVyY2VudEV4cHJlc3Npb24pLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdpbnRlcnBvbGF0aW9uJzogaW50ZXJwb2xhdGlvbixcbiAgICAgICAgJ3N0cmluZyc6IC9bXFxzXFxTXSsvXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgcGF0dGVybjogLyhcInwnKSg/OiNcXHtbXn1dK1xcfXwjKD8hXFx7KXxcXFxcKD86XFxyXFxufFtcXHNcXFNdKXwoPyFcXDEpW15cXFxcI1xcclxcbl0pKlxcMS8sXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2ludGVycG9sYXRpb24nOiBpbnRlcnBvbGF0aW9uLFxuICAgICAgICAnc3RyaW5nJzogL1tcXHNcXFNdKy9cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvPDxbLX5dPyhbYS16X11cXHcqKVtcXHJcXG5dKD86LipbXFxyXFxuXSkqP1tcXHQgXSpcXDEvaSxcbiAgICAgIGFsaWFzOiAnaGVyZWRvYy1zdHJpbmcnLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdkZWxpbWl0ZXInOiB7XG4gICAgICAgICAgcGF0dGVybjogL148PFstfl0/W2Etel9dXFx3KnxcXGJbYS16X11cXHcqJC9pLFxuICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IC9cXGJcXHcrLyxcbiAgICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9ePDxbLX5dPy9cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICdpbnRlcnBvbGF0aW9uJzogaW50ZXJwb2xhdGlvbixcbiAgICAgICAgJ3N0cmluZyc6IC9bXFxzXFxTXSsvXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgcGF0dGVybjogLzw8Wy1+XT8nKFthLXpfXVxcdyopJ1tcXHJcXG5dKD86LipbXFxyXFxuXSkqP1tcXHQgXSpcXDEvaSxcbiAgICAgIGFsaWFzOiAnaGVyZWRvYy1zdHJpbmcnLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdkZWxpbWl0ZXInOiB7XG4gICAgICAgICAgcGF0dGVybjogL148PFstfl0/J1thLXpfXVxcdyonfFxcYlthLXpfXVxcdyokL2ksXG4gICAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogL1xcYlxcdysvLFxuICAgICAgICAgICAgJ3B1bmN0dWF0aW9uJzogL148PFstfl0/J3wnJC9cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICdzdHJpbmcnOiAvW1xcc1xcU10rL1xuICAgICAgfVxuICAgIH1dLFxuICAgICdjb21tYW5kLWxpdGVyYWwnOiBbe1xuICAgICAgcGF0dGVybjogUmVnRXhwKC8leC8uc291cmNlICsgcGVyY2VudEV4cHJlc3Npb24pLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdpbnRlcnBvbGF0aW9uJzogaW50ZXJwb2xhdGlvbixcbiAgICAgICAgJ2NvbW1hbmQnOiB7XG4gICAgICAgICAgcGF0dGVybjogL1tcXHNcXFNdKy8sXG4gICAgICAgICAgYWxpYXM6ICdzdHJpbmcnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvYCg/OiNcXHtbXn1dK1xcfXwjKD8hXFx7KXxcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXlxcXFxgI1xcclxcbl0pKmAvLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdpbnRlcnBvbGF0aW9uJzogaW50ZXJwb2xhdGlvbixcbiAgICAgICAgJ2NvbW1hbmQnOiB7XG4gICAgICAgICAgcGF0dGVybjogL1tcXHNcXFNdKy8sXG4gICAgICAgICAgYWxpYXM6ICdzdHJpbmcnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XVxuICB9KTtcbiAgZGVsZXRlIFByaXNtLmxhbmd1YWdlcy5ydWJ5LnN0cmluZztcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgncnVieScsICdudW1iZXInLCB7XG4gICAgJ2J1aWx0aW4nOiAvXFxiKD86QXJyYXl8QmlnbnVtfEJpbmRpbmd8Q2xhc3N8Q29udGludWF0aW9ufERpcnxFeGNlcHRpb258RmFsc2VDbGFzc3xGaWxlfEZpeG51bXxGbG9hdHxIYXNofElPfEludGVnZXJ8TWF0Y2hEYXRhfE1ldGhvZHxNb2R1bGV8TmlsQ2xhc3N8TnVtZXJpY3xPYmplY3R8UHJvY3xSYW5nZXxSZWdleHB8U3RhdHxTdHJpbmd8U3RydWN0fFN5bWJvbHxUTVN8VGhyZWFkfFRocmVhZEdyb3VwfFRpbWV8VHJ1ZUNsYXNzKVxcYi8sXG4gICAgJ2NvbnN0YW50JzogL1xcYltBLVpdW0EtWjAtOV9dKig/Ols/IV18XFxiKS9cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5yYiA9IFByaXNtLmxhbmd1YWdlcy5ydWJ5O1xufSkoUHJpc20pO1xuKGZ1bmN0aW9uIChQcmlzbSkge1xuICB2YXIgbXVsdGlsaW5lQ29tbWVudCA9IC9cXC9cXCooPzpbXiovXXxcXCooPyFcXC8pfFxcLyg/IVxcKil8PHNlbGY+KSpcXCpcXC8vLnNvdXJjZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAvLyBzdXBwb3J0IDQgbGV2ZWxzIG9mIG5lc3RlZCBjb21tZW50c1xuICAgIG11bHRpbGluZUNvbW1lbnQgPSBtdWx0aWxpbmVDb21tZW50LnJlcGxhY2UoLzxzZWxmPi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbXVsdGlsaW5lQ29tbWVudDtcbiAgICB9KTtcbiAgfVxuICBtdWx0aWxpbmVDb21tZW50ID0gbXVsdGlsaW5lQ29tbWVudC5yZXBsYWNlKC88c2VsZj4vZywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAvW15cXHNcXFNdLy5zb3VyY2U7XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMucnVzdCA9IHtcbiAgICAnY29tbWVudCc6IFt7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoLyhefFteXFxcXF0pLy5zb3VyY2UgKyBtdWx0aWxpbmVDb21tZW50KSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvKF58W15cXFxcOl0pXFwvXFwvLiovLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH1dLFxuICAgICdzdHJpbmcnOiB7XG4gICAgICBwYXR0ZXJuOiAvYj9cIig/OlxcXFxbXFxzXFxTXXxbXlxcXFxcIl0pKlwifGI/cigjKilcIig/OlteXCJdfFwiKD8hXFwxKSkqXCJcXDEvLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSxcbiAgICAnY2hhcic6IHtcbiAgICAgIHBhdHRlcm46IC9iPycoPzpcXFxcKD86eFswLTddW1xcZGEtZkEtRl18dVxceyg/OltcXGRhLWZBLUZdXyopezEsNn1cXH18Lil8W15cXFxcXFxyXFxuXFx0J10pJy8sXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LFxuICAgICdhdHRyaWJ1dGUnOiB7XG4gICAgICBwYXR0ZXJuOiAvIyE/XFxbKD86W15cXFtcXF1cIl18XCIoPzpcXFxcW1xcc1xcU118W15cXFxcXCJdKSpcIikqXFxdLyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnYXR0ci1uYW1lJyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnc3RyaW5nJzogbnVsbCAvLyBzZWUgYmVsb3dcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gQ2xvc3VyZSBwYXJhbXMgc2hvdWxkIG5vdCBiZSBjb25mdXNlZCB3aXRoIGJpdHdpc2UgT1IgfFxuICAgICdjbG9zdXJlLXBhcmFtcyc6IHtcbiAgICAgIHBhdHRlcm46IC8oWz0oLDpdXFxzKnxcXGJtb3ZlXFxzKilcXHxbXnxdKlxcfHxcXHxbXnxdKlxcfCg/PVxccyooPzpcXHt8LT4pKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdjbG9zdXJlLXB1bmN0dWF0aW9uJzoge1xuICAgICAgICAgIHBhdHRlcm46IC9eXFx8fFxcfCQvLFxuICAgICAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gICAgICAgIH0sXG4gICAgICAgIHJlc3Q6IG51bGwgLy8gc2VlIGJlbG93XG4gICAgICB9XG4gICAgfSxcblxuICAgICdsaWZldGltZS1hbm5vdGF0aW9uJzoge1xuICAgICAgcGF0dGVybjogLydcXHcrLyxcbiAgICAgIGFsaWFzOiAnc3ltYm9sJ1xuICAgIH0sXG4gICAgJ2ZyYWdtZW50LXNwZWNpZmllcic6IHtcbiAgICAgIHBhdHRlcm46IC8oXFwkXFx3KzopW2Etel0rLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgIH0sXG4gICAgJ3ZhcmlhYmxlJzogL1xcJFxcdysvLFxuICAgICdmdW5jdGlvbi1kZWZpbml0aW9uJzoge1xuICAgICAgcGF0dGVybjogLyhcXGJmblxccyspXFx3Ky8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6ICdmdW5jdGlvbidcbiAgICB9LFxuICAgICd0eXBlLWRlZmluaXRpb24nOiB7XG4gICAgICBwYXR0ZXJuOiAvKFxcYig/OmVudW18c3RydWN0fHRyYWl0fHR5cGV8dW5pb24pXFxzKylcXHcrLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ2NsYXNzLW5hbWUnXG4gICAgfSxcbiAgICAnbW9kdWxlLWRlY2xhcmF0aW9uJzogW3tcbiAgICAgIHBhdHRlcm46IC8oXFxiKD86Y3JhdGV8bW9kKVxccyspW2Etel1bYS16X1xcZF0qLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ25hbWVzcGFjZSdcbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvKFxcYig/OmNyYXRlfHNlbGZ8c3VwZXIpXFxzKik6OlxccypbYS16XVthLXpfXFxkXSpcXGIoPzpcXHMqOjooPzpcXHMqW2Etel1bYS16X1xcZF0qXFxzKjo6KSopPy8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6ICduYW1lc3BhY2UnLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdwdW5jdHVhdGlvbic6IC86Oi9cbiAgICAgIH1cbiAgICB9XSxcbiAgICAna2V5d29yZCc6IFtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcnVzdC1sYW5nL3JlZmVyZW5jZS9ibG9iL21hc3Rlci9zcmMva2V5d29yZHMubWRcbiAgICAvXFxiKD86U2VsZnxhYnN0cmFjdHxhc3xhc3luY3xhd2FpdHxiZWNvbWV8Ym94fGJyZWFrfGNvbnN0fGNvbnRpbnVlfGNyYXRlfGRvfGR5bnxlbHNlfGVudW18ZXh0ZXJufGZpbmFsfGZufGZvcnxpZnxpbXBsfGlufGxldHxsb29wfG1hY3JvfG1hdGNofG1vZHxtb3ZlfG11dHxvdmVycmlkZXxwcml2fHB1YnxyZWZ8cmV0dXJufHNlbGZ8c3RhdGljfHN0cnVjdHxzdXBlcnx0cmFpdHx0cnl8dHlwZXx0eXBlb2Z8dW5pb258dW5zYWZlfHVuc2l6ZWR8dXNlfHZpcnR1YWx8d2hlcmV8d2hpbGV8eWllbGQpXFxiLyxcbiAgICAvLyBwcmltaXRpdmVzIGFuZCBzdHJcbiAgICAvLyBodHRwczovL2RvYy5ydXN0LWxhbmcub3JnL3N0YWJsZS9ydXN0LWJ5LWV4YW1wbGUvcHJpbWl0aXZlcy5odG1sXG4gICAgL1xcYig/OmJvb2x8Y2hhcnxmKD86MzJ8NjQpfFt1aV0oPzo4fDE2fDMyfDY0fDEyOHxzaXplKXxzdHIpXFxiL10sXG4gICAgLy8gZnVuY3Rpb25zIGNhbiB0ZWNobmljYWxseSBzdGFydCB3aXRoIGFuIHVwcGVyLWNhc2UgbGV0dGVyLCBidXQgdGhpcyB3aWxsIGludHJvZHVjZSBhIGxvdCBvZiBmYWxzZSBwb3NpdGl2ZXNcbiAgICAvLyBhbmQgUnVzdCdzIG5hbWluZyBjb252ZW50aW9ucyByZWNvbW1lbmQgc25ha2VfY2FzZSBhbnl3YXkuXG4gICAgLy8gaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy8xLjAuMC9zdHlsZS9zdHlsZS9uYW1pbmcvUkVBRE1FLmh0bWxcbiAgICAnZnVuY3Rpb24nOiAvXFxiW2Etel9dXFx3Kig/PVxccyooPzo6Olxccyo8fFxcKCkpLyxcbiAgICAnbWFjcm8nOiB7XG4gICAgICBwYXR0ZXJuOiAvXFxiXFx3KyEvLFxuICAgICAgYWxpYXM6ICdwcm9wZXJ0eSdcbiAgICB9LFxuICAgICdjb25zdGFudCc6IC9cXGJbQS1aX11bQS1aX1xcZF0rXFxiLyxcbiAgICAnY2xhc3MtbmFtZSc6IC9cXGJbQS1aXVxcdypcXGIvLFxuICAgICduYW1lc3BhY2UnOiB7XG4gICAgICBwYXR0ZXJuOiAvKD86XFxiW2Etel1bYS16X1xcZF0qXFxzKjo6XFxzKikqXFxiW2Etel1bYS16X1xcZF0qXFxzKjo6KD8hXFxzKjwpLyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncHVuY3R1YXRpb24nOiAvOjovXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBIZXgsIG9jdCwgYmluLCBkZWMgbnVtYmVycyB3aXRoIHZpc3VhbCBzZXBhcmF0b3JzIGFuZCB0eXBlIHN1ZmZpeFxuICAgICdudW1iZXInOiAvXFxiKD86MHhbXFxkQS1GYS1mXSg/Ol8/W1xcZEEtRmEtZl0pKnwwb1swLTddKD86Xz9bMC03XSkqfDBiWzAxXSg/Ol8/WzAxXSkqfCg/Oig/OlxcZCg/Ol8/XFxkKSopP1xcLik/XFxkKD86Xz9cXGQpKig/OltFZV1bKy1dP1xcZCspPykoPzpfPyg/OmYzMnxmNjR8W2l1XSg/Ojh8MTZ8MzJ8NjR8c2l6ZSk/KSk/XFxiLyxcbiAgICAnYm9vbGVhbic6IC9cXGIoPzpmYWxzZXx0cnVlKVxcYi8sXG4gICAgJ3B1bmN0dWF0aW9uJzogLy0+fFxcLlxcLj18XFwuezEsM318Ojp8W3t9W1xcXTsoKSw6XS8sXG4gICAgJ29wZXJhdG9yJzogL1stKypcXC8lIV5dPT98PVs9Pl0/fCZbJj1dP3xcXHxbfD1dP3w8PD89P3w+Pj89P3xbQD9dL1xuICB9O1xuICBQcmlzbS5sYW5ndWFnZXMucnVzdFsnY2xvc3VyZS1wYXJhbXMnXS5pbnNpZGUucmVzdCA9IFByaXNtLmxhbmd1YWdlcy5ydXN0O1xuICBQcmlzbS5sYW5ndWFnZXMucnVzdFsnYXR0cmlidXRlJ10uaW5zaWRlWydzdHJpbmcnXSA9IFByaXNtLmxhbmd1YWdlcy5ydXN0WydzdHJpbmcnXTtcbn0pKFByaXNtKTtcbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgUHJpc20ubGFuZ3VhZ2VzLnNhc3MgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjc3MnLCB7XG4gICAgLy8gU2FzcyBjb21tZW50cyBkb24ndCBuZWVkIHRvIGJlIGNsb3NlZCwgb25seSBpbmRlbnRlZFxuICAgICdjb21tZW50Jzoge1xuICAgICAgcGF0dGVybjogL14oWyBcXHRdKilcXC9bXFwvKl0uKig/Oig/Olxccj9cXG58XFxyKVxcMVsgXFx0XS4rKSovbSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdzYXNzJywgJ2F0cnVsZScsIHtcbiAgICAvLyBXZSB3YW50IHRvIGNvbnN1bWUgdGhlIHdob2xlIGxpbmVcbiAgICAnYXRydWxlLWxpbmUnOiB7XG4gICAgICAvLyBJbmNsdWRlcyBzdXBwb3J0IGZvciA9IGFuZCArIHNob3J0Y3V0c1xuICAgICAgcGF0dGVybjogL14oPzpbIFxcdF0qKVtAKz1dLisvbSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnYXRydWxlJzogLyg/OkBbXFx3LV0rfFsrPV0pL1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGRlbGV0ZSBQcmlzbS5sYW5ndWFnZXMuc2Fzcy5hdHJ1bGU7XG4gIHZhciB2YXJpYWJsZSA9IC9cXCRbLVxcd10rfCNcXHtcXCRbLVxcd10rXFx9LztcbiAgdmFyIG9wZXJhdG9yID0gWy9bKypcXC8lXXxbPSFdPXw8PT98Pj0/fFxcYig/OmFuZHxub3R8b3IpXFxiLywge1xuICAgIHBhdHRlcm46IC8oXFxzKS0oPz1cXHMpLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH1dO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdzYXNzJywgJ3Byb3BlcnR5Jywge1xuICAgIC8vIFdlIHdhbnQgdG8gY29uc3VtZSB0aGUgd2hvbGUgbGluZVxuICAgICd2YXJpYWJsZS1saW5lJzoge1xuICAgICAgcGF0dGVybjogL15bIFxcdF0qXFwkLisvbSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncHVuY3R1YXRpb24nOiAvOi8sXG4gICAgICAgICd2YXJpYWJsZSc6IHZhcmlhYmxlLFxuICAgICAgICAnb3BlcmF0b3InOiBvcGVyYXRvclxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gV2Ugd2FudCB0byBjb25zdW1lIHRoZSB3aG9sZSBsaW5lXG4gICAgJ3Byb3BlcnR5LWxpbmUnOiB7XG4gICAgICBwYXR0ZXJuOiAvXlsgXFx0XSooPzpbXjpcXHNdKyAqOi4qfDpbXjpcXHNdLiopL20sXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3Byb3BlcnR5JzogWy9bXjpcXHNdKyg/PVxccyo6KS8sIHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKDopW146XFxzXSsvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgfV0sXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC86LyxcbiAgICAgICAgJ3ZhcmlhYmxlJzogdmFyaWFibGUsXG4gICAgICAgICdvcGVyYXRvcic6IG9wZXJhdG9yLFxuICAgICAgICAnaW1wb3J0YW50JzogUHJpc20ubGFuZ3VhZ2VzLnNhc3MuaW1wb3J0YW50XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgZGVsZXRlIFByaXNtLmxhbmd1YWdlcy5zYXNzLnByb3BlcnR5O1xuICBkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLnNhc3MuaW1wb3J0YW50O1xuXG4gIC8vIE5vdyB0aGF0IHdob2xlIGxpbmVzIGZvciBvdGhlciBwYXR0ZXJucyBhcmUgY29uc3VtZWQsXG4gIC8vIHdoYXQncyBsZWZ0IHNob3VsZCBiZSBzZWxlY3RvcnNcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnc2FzcycsICdwdW5jdHVhdGlvbicsIHtcbiAgICAnc2VsZWN0b3InOiB7XG4gICAgICBwYXR0ZXJuOiAvXihbIFxcdF0qKVxcUyg/OixbXixcXHJcXG5dK3xbXixcXHJcXG5dKikoPzosW14sXFxyXFxuXSspKig/OiwoPzpcXHI/XFxufFxccilcXDFbIFxcdF0rXFxTKD86LFteLFxcclxcbl0rfFteLFxcclxcbl0qKSg/OixbXixcXHJcXG5dKykqKSovbSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9XG4gIH0pO1xufSkoUHJpc20pO1xuUHJpc20ubGFuZ3VhZ2VzLnNjc3MgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjc3MnLCB7XG4gICdjb21tZW50Jzoge1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKSg/OlxcL1xcKltcXHNcXFNdKj9cXCpcXC98XFwvXFwvLiopLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sXG4gICdhdHJ1bGUnOiB7XG4gICAgcGF0dGVybjogL0BbXFx3LV0oPzpcXChbXigpXStcXCl8W14oKVxcc118XFxzKyg/IVxccykpKj8oPz1cXHMrW3s7XSkvLFxuICAgIGluc2lkZToge1xuICAgICAgJ3J1bGUnOiAvQFtcXHctXSsvXG4gICAgICAvLyBTZWUgcmVzdCBiZWxvd1xuICAgIH1cbiAgfSxcblxuICAvLyB1cmwsIGNvbXBhc3NpZmllZFxuICAndXJsJzogLyg/OlstYS16XSstKT91cmwoPz1cXCgpL2ksXG4gIC8vIENTUyBzZWxlY3RvciByZWdleCBpcyBub3QgYXBwcm9wcmlhdGUgZm9yIFNhc3NcbiAgLy8gc2luY2UgdGhlcmUgY2FuIGJlIGxvdCBtb3JlIHRoaW5ncyAodmFyLCBAIGRpcmVjdGl2ZSwgbmVzdGluZy4uKVxuICAvLyBhIHNlbGVjdG9yIG11c3Qgc3RhcnQgYXQgdGhlIGVuZCBvZiBhIHByb3BlcnR5IG9yIGFmdGVyIGEgYnJhY2UgKGVuZCBvZiBvdGhlciBydWxlcyBvciBuZXN0aW5nKVxuICAvLyBpdCBjYW4gY29udGFpbiBzb21lIGNoYXJhY3RlcnMgdGhhdCBhcmVuJ3QgdXNlZCBmb3IgZGVmaW5pbmcgcnVsZXMgb3IgZW5kIG9mIHNlbGVjdG9yLCAmIChwYXJlbnQgc2VsZWN0b3IpLCBvciBpbnRlcnBvbGF0ZWQgdmFyaWFibGVcbiAgLy8gdGhlIGVuZCBvZiBhIHNlbGVjdG9yIGlzIGZvdW5kIHdoZW4gdGhlcmUgaXMgbm8gcnVsZXMgaW4gaXQgKCB7fSBvciB7XFxzfSkgb3IgaWYgdGhlcmUgaXMgYSBwcm9wZXJ0eSAoYmVjYXVzZSBhbiBpbnRlcnBvbGF0ZWQgdmFyXG4gIC8vIGNhbiBcInBhc3NcIiBhcyBhIHNlbGVjdG9yLSBlLmc6IHByb3BlciN7JGVydHl9KVxuICAvLyB0aGlzIG9uZSB3YXMgaGFyZCB0byBkbywgc28gcGxlYXNlIGJlIGNhcmVmdWwgaWYgeW91IGVkaXQgdGhpcyBvbmUgOilcbiAgJ3NlbGVjdG9yJzoge1xuICAgIC8vIEluaXRpYWwgbG9vay1haGVhZCBpcyB1c2VkIHRvIHByZXZlbnQgbWF0Y2hpbmcgb2YgYmxhbmsgc2VsZWN0b3JzXG4gICAgcGF0dGVybjogLyg/PVxcUylbXkA7e30oKV0/KD86W15AO3t9KClcXHNdfFxccysoPyFcXHMpfCNcXHtcXCRbLVxcd10rXFx9KSsoPz1cXHMqXFx7KD86XFx9fFxcc3xbXn1dW146e31dKls6e11bXn1dKSkvLFxuICAgIGluc2lkZToge1xuICAgICAgJ3BhcmVudCc6IHtcbiAgICAgICAgcGF0dGVybjogLyYvLFxuICAgICAgICBhbGlhczogJ2ltcG9ydGFudCdcbiAgICAgIH0sXG4gICAgICAncGxhY2Vob2xkZXInOiAvJVstXFx3XSsvLFxuICAgICAgJ3ZhcmlhYmxlJzogL1xcJFstXFx3XSt8I1xce1xcJFstXFx3XStcXH0vXG4gICAgfVxuICB9LFxuICAncHJvcGVydHknOiB7XG4gICAgcGF0dGVybjogLyg/OlstXFx3XXxcXCRbLVxcd118I1xce1xcJFstXFx3XStcXH0pKyg/PVxccyo6KS8sXG4gICAgaW5zaWRlOiB7XG4gICAgICAndmFyaWFibGUnOiAvXFwkWy1cXHddK3wjXFx7XFwkWy1cXHddK1xcfS9cbiAgICB9XG4gIH1cbn0pO1xuUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnc2NzcycsICdhdHJ1bGUnLCB7XG4gICdrZXl3b3JkJzogWy9AKD86Y29udGVudHxkZWJ1Z3xlYWNofGVsc2UoPzogaWYpP3xleHRlbmR8Zm9yfGZvcndhcmR8ZnVuY3Rpb258aWZ8aW1wb3J0fGluY2x1ZGV8bWl4aW58cmV0dXJufHVzZXx3YXJufHdoaWxlKVxcYi9pLCB7XG4gICAgcGF0dGVybjogLyggKSg/OmZyb218dGhyb3VnaCkoPz0gKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9XVxufSk7XG5QcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdzY3NzJywgJ2ltcG9ydGFudCcsIHtcbiAgLy8gdmFyIGFuZCBpbnRlcnBvbGF0ZWQgdmFyc1xuICAndmFyaWFibGUnOiAvXFwkWy1cXHddK3wjXFx7XFwkWy1cXHddK1xcfS9cbn0pO1xuUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnc2NzcycsICdmdW5jdGlvbicsIHtcbiAgJ21vZHVsZS1tb2RpZmllcic6IHtcbiAgICBwYXR0ZXJuOiAvXFxiKD86YXN8aGlkZXxzaG93fHdpdGgpXFxiL2ksXG4gICAgYWxpYXM6ICdrZXl3b3JkJ1xuICB9LFxuICAncGxhY2Vob2xkZXInOiB7XG4gICAgcGF0dGVybjogLyVbLVxcd10rLyxcbiAgICBhbGlhczogJ3NlbGVjdG9yJ1xuICB9LFxuICAnc3RhdGVtZW50Jzoge1xuICAgIHBhdHRlcm46IC9cXEIhKD86ZGVmYXVsdHxvcHRpb25hbClcXGIvaSxcbiAgICBhbGlhczogJ2tleXdvcmQnXG4gIH0sXG4gICdib29sZWFuJzogL1xcYig/OmZhbHNlfHRydWUpXFxiLyxcbiAgJ251bGwnOiB7XG4gICAgcGF0dGVybjogL1xcYm51bGxcXGIvLFxuICAgIGFsaWFzOiAna2V5d29yZCdcbiAgfSxcbiAgJ29wZXJhdG9yJzoge1xuICAgIHBhdHRlcm46IC8oXFxzKSg/OlstKypcXC8lXXxbPSFdPXw8PT98Pj0/fGFuZHxub3R8b3IpKD89XFxzKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9XG59KTtcblByaXNtLmxhbmd1YWdlcy5zY3NzWydhdHJ1bGUnXS5pbnNpZGUucmVzdCA9IFByaXNtLmxhbmd1YWdlcy5zY3NzO1xuUHJpc20ubGFuZ3VhZ2VzLnNxbCA9IHtcbiAgJ2NvbW1lbnQnOiB7XG4gICAgcGF0dGVybjogLyhefFteXFxcXF0pKD86XFwvXFwqW1xcc1xcU10qP1xcKlxcL3woPzotLXxcXC9cXC98IykuKikvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSxcbiAgJ3ZhcmlhYmxlJzogW3tcbiAgICBwYXR0ZXJuOiAvQChbXCInYF0pKD86XFxcXFtcXHNcXFNdfCg/IVxcMSlbXlxcXFxdKStcXDEvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LCAvQFtcXHcuJF0rL10sXG4gICdzdHJpbmcnOiB7XG4gICAgcGF0dGVybjogLyhefFteQFxcXFxdKShcInwnKSg/OlxcXFxbXFxzXFxTXXwoPyFcXDIpW15cXFxcXXxcXDJcXDIpKlxcMi8sXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSxcbiAgJ2lkZW50aWZpZXInOiB7XG4gICAgcGF0dGVybjogLyhefFteQFxcXFxdKWAoPzpcXFxcW1xcc1xcU118W15gXFxcXF18YGApKmAvLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ3B1bmN0dWF0aW9uJzogL15gfGAkL1xuICAgIH1cbiAgfSxcbiAgJ2Z1bmN0aW9uJzogL1xcYig/OkFWR3xDT1VOVHxGSVJTVHxGT1JNQVR8TEFTVHxMQ0FTRXxMRU58TUFYfE1JRHxNSU58TU9EfE5PV3xST1VORHxTVU18VUNBU0UpKD89XFxzKlxcKCkvaSxcbiAgLy8gU2hvdWxkIHdlIGhpZ2hsaWdodCB1c2VyIGRlZmluZWQgZnVuY3Rpb25zIHRvbz9cbiAgJ2tleXdvcmQnOiAvXFxiKD86QUNUSU9OfEFERHxBRlRFUnxBTEdPUklUSE18QUxMfEFMVEVSfEFOQUxZWkV8QU5ZfEFQUExZfEFTfEFTQ3xBVVRIT1JJWkFUSU9OfEFVVE9fSU5DUkVNRU5UfEJBQ0tVUHxCREJ8QkVHSU58QkVSS0VMRVlEQnxCSUdJTlR8QklOQVJZfEJJVHxCTE9CfEJPT0x8Qk9PTEVBTnxCUkVBS3xCUk9XU0V8QlRSRUV8QlVMS3xCWXxDQUxMfENBU0NBREVEP3xDQVNFfENIQUlOfENIQVIoPzpBQ1RFUnxTRVQpP3xDSEVDSyg/OlBPSU5UKT98Q0xPU0V8Q0xVU1RFUkVEfENPQUxFU0NFfENPTExBVEV8Q09MVU1OUz98Q09NTUVOVHxDT01NSVQoPzpURUQpP3xDT01QVVRFfENPTk5FQ1R8Q09OU0lTVEVOVHxDT05TVFJBSU5UfENPTlRBSU5TKD86VEFCTEUpP3xDT05USU5VRXxDT05WRVJUfENSRUFURXxDUk9TU3xDVVJSRU5UKD86X0RBVEV8X1RJTUV8X1RJTUVTVEFNUHxfVVNFUik/fENVUlNPUnxDWUNMRXxEQVRBKD86QkFTRVM/KT98REFURSg/OlRJTUUpP3xEQVl8REJDQ3xERUFMTE9DQVRFfERFQ3xERUNJTUFMfERFQ0xBUkV8REVGQVVMVHxERUZJTkVSfERFTEFZRUR8REVMRVRFfERFTElNSVRFUlM/fERFTll8REVTQ3xERVNDUklCRXxERVRFUk1JTklTVElDfERJU0FCTEV8RElTQ0FSRHxESVNLfERJU1RJTkNUfERJU1RJTkNUUk9XfERJU1RSSUJVVEVEfERPfERPVUJMRXxEUk9QfERVTU1ZfERVTVAoPzpGSUxFKT98RFVQTElDQVRFfEVMU0UoPzpJRik/fEVOQUJMRXxFTkNMT1NFRHxFTkR8RU5HSU5FfEVOVU18RVJSTFZMfEVSUk9SU3xFU0NBUEVEP3xFWENFUFR8RVhFQyg/OlVURSk/fEVYSVNUU3xFWElUfEVYUExBSU58RVhURU5ERUR8RkVUQ0h8RklFTERTfEZJTEV8RklMTEZBQ1RPUnxGSVJTVHxGSVhFRHxGTE9BVHxGT0xMT1dJTkd8Rk9SKD86IEVBQ0ggUk9XKT98Rk9SQ0V8Rk9SRUlHTnxGUkVFVEVYVCg/OlRBQkxFKT98RlJPTXxGVUxMfEZVTkNUSU9OfEdFT01FVFJZKD86Q09MTEVDVElPTik/fEdMT0JBTHxHT1RPfEdSQU5UfEdST1VQfEhBTkRMRVJ8SEFTSHxIQVZJTkd8SE9MRExPQ0t8SE9VUnxJREVOVElUWSg/OkNPTHxfSU5TRVJUKT98SUZ8SUdOT1JFfElNUE9SVHxJTkRFWHxJTkZJTEV8SU5ORVJ8SU5OT0RCfElOT1VUfElOU0VSVHxJTlR8SU5URUdFUnxJTlRFUlNFQ1R8SU5URVJWQUx8SU5UT3xJTlZPS0VSfElTT0xBVElPTnxJVEVSQVRFfEpPSU58S0VZUz98S0lMTHxMQU5HVUFHRXxMQVNUfExFQVZFfExFRlR8TEVWRUx8TElNSVR8TElORU5PfExJTkVTfExJTkVTVFJJTkd8TE9BRHxMT0NBTHxMT0NLfExPTkcoPzpCTE9CfFRFWFQpfExPT1B8TUFUQ0goPzpFRCk/fE1FRElVTSg/OkJMT0J8SU5UfFRFWFQpfE1FUkdFfE1JRERMRUlOVHxNSU5VVEV8TU9ERXxNT0RJRklFU3xNT0RJRll8TU9OVEh8TVVMVEkoPzpMSU5FU1RSSU5HfFBPSU5UfFBPTFlHT04pfE5BVElPTkFMfE5BVFVSQUx8TkNIQVJ8TkVYVHxOT3xOT05DTFVTVEVSRUR8TlVMTElGfE5VTUVSSUN8T0ZGP3xPRkZTRVRTP3xPTnxPUEVOKD86REFUQVNPVVJDRXxRVUVSWXxST1dTRVQpP3xPUFRJTUlaRXxPUFRJT04oPzpBTExZKT98T1JERVJ8T1VUKD86RVJ8RklMRSk/fE9WRVJ8UEFSVElBTHxQQVJUSVRJT058UEVSQ0VOVHxQSVZPVHxQTEFOfFBPSU5UfFBPTFlHT058UFJFQ0VESU5HfFBSRUNJU0lPTnxQUkVQQVJFfFBSRVZ8UFJJTUFSWXxQUklOVHxQUklWSUxFR0VTfFBST0MoPzpFRFVSRSk/fFBVQkxJQ3xQVVJHRXxRVUlDS3xSQUlTRVJST1J8UkVBRFM/fFJFQUx8UkVDT05GSUdVUkV8UkVGRVJFTkNFU3xSRUxFQVNFfFJFTkFNRXxSRVBFQVQoPzpBQkxFKT98UkVQTEFDRXxSRVBMSUNBVElPTnxSRVFVSVJFfFJFU0lHTkFMfFJFU1RPUkV8UkVTVFJJQ1R8UkVUVVJOKD86SU5HfFMpP3xSRVZPS0V8UklHSFR8Uk9MTEJBQ0t8Uk9VVElORXxST1coPzpDT1VOVHxHVUlEQ09MfFMpP3xSVFJFRXxSVUxFfFNBVkUoPzpQT0lOVCk/fFNDSEVNQXxTRUNPTkR8U0VMRUNUfFNFUklBTCg/OklaQUJMRSk/fFNFU1NJT04oPzpfVVNFUik/fFNFVCg/OlVTRVIpP3xTSEFSRXxTSE9XfFNIVVRET1dOfFNJTVBMRXxTTUFMTElOVHxTTkFQU0hPVHxTT01FfFNPTkFNRXxTUUx8U1RBUlQoPzpJTkcpP3xTVEFUSVNUSUNTfFNUQVRVU3xTVFJJUEVEfFNZU1RFTV9VU0VSfFRBQkxFUz98VEFCTEVTUEFDRXxURU1QKD86T1JBUll8VEFCTEUpP3xURVJNSU5BVEVEfFRFWFQoPzpTSVpFKT98VEhFTnxUSU1FKD86U1RBTVApP3xUSU5ZKD86QkxPQnxJTlR8VEVYVCl8VE9QP3xUUkFOKD86U0FDVElPTlM/KT98VFJJR0dFUnxUUlVOQ0FURXxUU0VRVUFMfFRZUEVTP3xVTkJPVU5ERUR8VU5DT01NSVRURUR8VU5ERUZJTkVEfFVOSU9OfFVOSVFVRXxVTkxPQ0t8VU5QSVZPVHxVTlNJR05FRHxVUERBVEUoPzpURVhUKT98VVNBR0V8VVNFfFVTRVJ8VVNJTkd8VkFMVUVTP3xWQVIoPzpCSU5BUll8Q0hBUnxDSEFSQUNURVJ8WUlORyl8VklFV3xXQUlURk9SfFdBUk5JTkdTfFdIRU58V0hFUkV8V0hJTEV8V0lUSCg/OiBST0xMVVB8SU4pP3xXT1JLfFdSSVRFKD86VEVYVCk/fFlFQVIpXFxiL2ksXG4gICdib29sZWFuJzogL1xcYig/OkZBTFNFfE5VTEx8VFJVRSlcXGIvaSxcbiAgJ251bWJlcic6IC9cXGIweFtcXGRhLWZdK1xcYnxcXGJcXGQrKD86XFwuXFxkKik/fFxcQlxcLlxcZCtcXGIvaSxcbiAgJ29wZXJhdG9yJzogL1stKypcXC89JV5+XXwmJj98XFx8XFx8P3whPT98PCg/Oj0+P3w8fD4pP3w+Wz49XT98XFxiKD86QU5EfEJFVFdFRU58RElWfElMSUtFfElOfElTfExJS0V8Tk9UfE9SfFJFR0VYUHxSTElLRXxTT1VORFMgTElLRXxYT1IpXFxiL2ksXG4gICdwdW5jdHVhdGlvbic6IC9bO1tcXF0oKWAsLl0vXG59O1xuUHJpc20ubGFuZ3VhZ2VzLnN3aWZ0ID0ge1xuICAnY29tbWVudCc6IHtcbiAgICAvLyBOZXN0ZWQgY29tbWVudHMgYXJlIHN1cHBvcnRlZCB1cCB0byAyIGxldmVsc1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFw6XSkoPzpcXC9cXC8uKnxcXC9cXCooPzpbXi8qXXxcXC8oPyFcXCopfFxcKig/IVxcLyl8XFwvXFwqKD86W14qXXxcXCooPyFcXC8pKSpcXCpcXC8pKlxcKlxcLykvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdzdHJpbmctbGl0ZXJhbCc6IFtcbiAgLy8gaHR0cHM6Ly9kb2NzLnN3aWZ0Lm9yZy9zd2lmdC1ib29rL0xhbmd1YWdlR3VpZGUvU3RyaW5nc0FuZENoYXJhY3RlcnMuaHRtbFxuICB7XG4gICAgcGF0dGVybjogUmVnRXhwKC8oXnxbXlwiI10pLy5zb3VyY2UgKyAnKD86J1xuICAgIC8vIHNpbmdsZS1saW5lIHN0cmluZ1xuICAgICsgL1wiKD86XFxcXCg/OlxcKCg/OlteKCldfFxcKFteKCldKlxcKSkqXFwpfFxcclxcbnxbXihdKXxbXlxcXFxcXHJcXG5cIl0pKlwiLy5zb3VyY2UgKyAnfCdcbiAgICAvLyBtdWx0aS1saW5lIHN0cmluZ1xuICAgICsgL1wiXCJcIig/OlxcXFwoPzpcXCgoPzpbXigpXXxcXChbXigpXSpcXCkpKlxcKXxbXihdKXxbXlxcXFxcIl18XCIoPyFcIlwiKSkqXCJcIlwiLy5zb3VyY2UgKyAnKScgKyAvKD8hW1wiI10pLy5zb3VyY2UpLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ2ludGVycG9sYXRpb24nOiB7XG4gICAgICAgIHBhdHRlcm46IC8oXFxcXFxcKCkoPzpbXigpXXxcXChbXigpXSpcXCkpKig/PVxcKSkvLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICBpbnNpZGU6IG51bGwgLy8gc2VlIGJlbG93XG4gICAgICB9LFxuXG4gICAgICAnaW50ZXJwb2xhdGlvbi1wdW5jdHVhdGlvbic6IHtcbiAgICAgICAgcGF0dGVybjogL15cXCl8XFxcXFxcKCQvLFxuICAgICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgICAgfSxcbiAgICAgICdwdW5jdHVhdGlvbic6IC9cXFxcKD89W1xcclxcbl0pLyxcbiAgICAgICdzdHJpbmcnOiAvW1xcc1xcU10rL1xuICAgIH1cbiAgfSwge1xuICAgIHBhdHRlcm46IFJlZ0V4cCgvKF58W15cIiNdKSgjKykvLnNvdXJjZSArICcoPzonXG4gICAgLy8gc2luZ2xlLWxpbmUgc3RyaW5nXG4gICAgKyAvXCIoPzpcXFxcKD86IytcXCgoPzpbXigpXXxcXChbXigpXSpcXCkpKlxcKXxcXHJcXG58W14jXSl8W15cXFxcXFxyXFxuXSkqP1wiLy5zb3VyY2UgKyAnfCdcbiAgICAvLyBtdWx0aS1saW5lIHN0cmluZ1xuICAgICsgL1wiXCJcIig/OlxcXFwoPzojK1xcKCg/OlteKCldfFxcKFteKCldKlxcKSkqXFwpfFteI10pfFteXFxcXF0pKj9cIlwiXCIvLnNvdXJjZSArICcpJyArICdcXFxcMicpLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ2ludGVycG9sYXRpb24nOiB7XG4gICAgICAgIHBhdHRlcm46IC8oXFxcXCMrXFwoKSg/OlteKCldfFxcKFteKCldKlxcKSkqKD89XFwpKS8sXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgIGluc2lkZTogbnVsbCAvLyBzZWUgYmVsb3dcbiAgICAgIH0sXG5cbiAgICAgICdpbnRlcnBvbGF0aW9uLXB1bmN0dWF0aW9uJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXlxcKXxcXFxcIytcXCgkLyxcbiAgICAgICAgYWxpYXM6ICdwdW5jdHVhdGlvbidcbiAgICAgIH0sXG4gICAgICAnc3RyaW5nJzogL1tcXHNcXFNdKy9cbiAgICB9XG4gIH1dLFxuICAnZGlyZWN0aXZlJzoge1xuICAgIC8vIGRpcmVjdGl2ZXMgd2l0aCBjb25kaXRpb25zXG4gICAgcGF0dGVybjogUmVnRXhwKC8jLy5zb3VyY2UgKyAnKD86JyArICgvKD86ZWxzZWlmfGlmKVxcYi8uc291cmNlICsgJyg/OlsgXFx0XSonXG4gICAgLy8gVGhpcyByZWdleCBpcyBhIGxpdHRsZSBjb21wbGV4LiBJdCdzIGVxdWl2YWxlbnQgdG8gdGhpczpcbiAgICAvLyAgICg/OiFbIFxcdF0qKT8oPzpcXGJcXHcrXFxiKD86WyBcXHRdKjxyb3VuZD4pP3w8cm91bmQ+KSg/OlsgXFx0XSooPzomJnxcXHxcXHwpKT9cbiAgICAvLyB3aGVyZSA8cm91bmQ+IGlzIGEgZ2VuZXJhbCBwYXJlbnRoZXNlcyBleHByZXNzaW9uLlxuICAgICsgLyg/OiFbIFxcdF0qKT8oPzpcXGJcXHcrXFxiKD86WyBcXHRdKlxcKCg/OlteKCldfFxcKFteKCldKlxcKSkqXFwpKT98XFwoKD86W14oKV18XFwoW14oKV0qXFwpKSpcXCkpKD86WyBcXHRdKig/OiYmfFxcfFxcfCkpPy8uc291cmNlICsgJykrJykgKyAnfCcgKyAvKD86ZWxzZXxlbmRpZilcXGIvLnNvdXJjZSArICcpJyksXG4gICAgYWxpYXM6ICdwcm9wZXJ0eScsXG4gICAgaW5zaWRlOiB7XG4gICAgICAnZGlyZWN0aXZlLW5hbWUnOiAvXiNcXHcrLyxcbiAgICAgICdib29sZWFuJzogL1xcYig/OmZhbHNlfHRydWUpXFxiLyxcbiAgICAgICdudW1iZXInOiAvXFxiXFxkKyg/OlxcLlxcZCspKlxcYi8sXG4gICAgICAnb3BlcmF0b3InOiAvIXwmJnxcXHxcXHx8Wzw+XT0/LyxcbiAgICAgICdwdW5jdHVhdGlvbic6IC9bKCksXS9cbiAgICB9XG4gIH0sXG4gICdsaXRlcmFsJzoge1xuICAgIHBhdHRlcm46IC8jKD86Y29sb3JMaXRlcmFsfGNvbHVtbnxkc29oYW5kbGV8ZmlsZSg/OklEfExpdGVyYWx8UGF0aCk/fGZ1bmN0aW9ufGltYWdlTGl0ZXJhbHxsaW5lKVxcYi8sXG4gICAgYWxpYXM6ICdjb25zdGFudCdcbiAgfSxcbiAgJ290aGVyLWRpcmVjdGl2ZSc6IHtcbiAgICBwYXR0ZXJuOiAvI1xcdytcXGIvLFxuICAgIGFsaWFzOiAncHJvcGVydHknXG4gIH0sXG4gICdhdHRyaWJ1dGUnOiB7XG4gICAgcGF0dGVybjogL0BcXHcrLyxcbiAgICBhbGlhczogJ2F0cnVsZSdcbiAgfSxcbiAgJ2Z1bmN0aW9uLWRlZmluaXRpb24nOiB7XG4gICAgcGF0dGVybjogLyhcXGJmdW5jXFxzKylcXHcrLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGFsaWFzOiAnZnVuY3Rpb24nXG4gIH0sXG4gICdsYWJlbCc6IHtcbiAgICAvLyBodHRwczovL2RvY3Muc3dpZnQub3JnL3N3aWZ0LWJvb2svTGFuZ3VhZ2VHdWlkZS9Db250cm9sRmxvdy5odG1sI0lEMTQxXG4gICAgcGF0dGVybjogL1xcYihicmVha3xjb250aW51ZSlcXHMrXFx3K3xcXGJbYS16QS1aX11cXHcqKD89XFxzKjpcXHMqKD86Zm9yfHJlcGVhdHx3aGlsZSlcXGIpLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGFsaWFzOiAnaW1wb3J0YW50J1xuICB9LFxuICAna2V5d29yZCc6IC9cXGIoPzpBbnl8UHJvdG9jb2x8U2VsZnxUeXBlfGFjdG9yfGFzfGFzc2lnbm1lbnR8YXNzb2NpYXRlZHR5cGV8YXNzb2NpYXRpdml0eXxhc3luY3xhd2FpdHxicmVha3xjYXNlfGNhdGNofGNsYXNzfGNvbnRpbnVlfGNvbnZlbmllbmNlfGRlZmF1bHR8ZGVmZXJ8ZGVpbml0fGRpZFNldHxkb3xkeW5hbWljfGVsc2V8ZW51bXxleHRlbnNpb258ZmFsbHRocm91Z2h8ZmlsZXByaXZhdGV8ZmluYWx8Zm9yfGZ1bmN8Z2V0fGd1YXJkfGhpZ2hlclRoYW58aWZ8aW1wb3J0fGlufGluZGlyZWN0fGluZml4fGluaXR8aW5vdXR8aW50ZXJuYWx8aXN8aXNvbGF0ZWR8bGF6eXxsZWZ0fGxldHxsb3dlclRoYW58bXV0YXRpbmd8bm9uZXxub25pc29sYXRlZHxub25tdXRhdGluZ3xvcGVufG9wZXJhdG9yfG9wdGlvbmFsfG92ZXJyaWRlfHBvc3RmaXh8cHJlY2VkZW5jZWdyb3VwfHByZWZpeHxwcml2YXRlfHByb3RvY29sfHB1YmxpY3xyZXBlYXR8cmVxdWlyZWR8cmV0aHJvd3N8cmV0dXJufHJpZ2h0fHNhZmV8c2VsZnxzZXR8c29tZXxzdGF0aWN8c3RydWN0fHN1YnNjcmlwdHxzdXBlcnxzd2l0Y2h8dGhyb3d8dGhyb3dzfHRyeXx0eXBlYWxpYXN8dW5vd25lZHx1bnNhZmV8dmFyfHdlYWt8d2hlcmV8d2hpbGV8d2lsbFNldClcXGIvLFxuICAnYm9vbGVhbic6IC9cXGIoPzpmYWxzZXx0cnVlKVxcYi8sXG4gICduaWwnOiB7XG4gICAgcGF0dGVybjogL1xcYm5pbFxcYi8sXG4gICAgYWxpYXM6ICdjb25zdGFudCdcbiAgfSxcbiAgJ3Nob3J0LWFyZ3VtZW50JzogL1xcJFxcZCtcXGIvLFxuICAnb21pdCc6IHtcbiAgICBwYXR0ZXJuOiAvXFxiX1xcYi8sXG4gICAgYWxpYXM6ICdrZXl3b3JkJ1xuICB9LFxuICAnbnVtYmVyJzogL1xcYig/OltcXGRfXSsoPzpcXC5bXFxkZV9dKyk/fDB4W2EtZjAtOV9dKyg/OlxcLlthLWYwLTlwX10rKT98MGJbMDFfXSt8MG9bMC03X10rKVxcYi9pLFxuICAvLyBBIGNsYXNzIG5hbWUgbXVzdCBzdGFydCB3aXRoIGFuIHVwcGVyLWNhc2UgbGV0dGVyIGFuZCBiZSBlaXRoZXIgMSBsZXR0ZXIgbG9uZyBvciBjb250YWluIGEgbG93ZXItY2FzZSBsZXR0ZXIuXG4gICdjbGFzcy1uYW1lJzogL1xcYltBLVpdKD86W0EtWl9cXGRdKlthLXpdXFx3Kik/XFxiLyxcbiAgJ2Z1bmN0aW9uJzogL1xcYlthLXpfXVxcdyooPz1cXHMqXFwoKS9pLFxuICAnY29uc3RhbnQnOiAvXFxiKD86W0EtWl9dezIsfXxrW0EtWl1bQS1aYS16X10rKVxcYi8sXG4gIC8vIE9wZXJhdG9ycyBhcmUgZ2VuZXJpYyBpbiBTd2lmdC4gRGV2ZWxvcGVycyBjYW4gZXZlbiBjcmVhdGUgbmV3IG9wZXJhdG9ycyAoZS5nLiArKyspLlxuICAvLyBodHRwczovL2RvY3Muc3dpZnQub3JnL3N3aWZ0LWJvb2svUmVmZXJlbmNlTWFudWFsL3p6U3VtbWFyeU9mVGhlR3JhbW1hci5odG1sI0lENDgxXG4gIC8vIFRoaXMgcmVnZXggb25seSBzdXBwb3J0cyBBU0NJSSBvcGVyYXRvcnMuXG4gICdvcGVyYXRvcic6IC9bLSsqLyU9ITw+Jnxefj9dK3xcXC5bLlxcLSsqLyU9ITw+Jnxefj9dKy8sXG4gICdwdW5jdHVhdGlvbic6IC9be31bXFxdKCk7LC46XFxcXF0vXG59O1xuUHJpc20ubGFuZ3VhZ2VzLnN3aWZ0WydzdHJpbmctbGl0ZXJhbCddLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgcnVsZS5pbnNpZGVbJ2ludGVycG9sYXRpb24nXS5pbnNpZGUgPSBQcmlzbS5sYW5ndWFnZXMuc3dpZnQ7XG59KTtcbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHQgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdqYXZhc2NyaXB0Jywge1xuICAgICdjbGFzcy1uYW1lJzoge1xuICAgICAgcGF0dGVybjogLyhcXGIoPzpjbGFzc3xleHRlbmRzfGltcGxlbWVudHN8aW5zdGFuY2VvZnxpbnRlcmZhY2V8bmV3fHR5cGUpXFxzKykoPyFrZXlvZlxcYikoPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD86XFxzKjwoPzpbXjw+XXw8KD86W148Pl18PFtePD5dKj4pKj4pKj4pPy8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiBudWxsIC8vIHNlZSBiZWxvd1xuICAgIH0sXG5cbiAgICAnYnVpbHRpbic6IC9cXGIoPzpBcnJheXxGdW5jdGlvbnxQcm9taXNlfGFueXxib29sZWFufGNvbnNvbGV8bmV2ZXJ8bnVtYmVyfHN0cmluZ3xzeW1ib2x8dW5rbm93bilcXGIvXG4gIH0pO1xuXG4gIC8vIFRoZSBrZXl3b3JkcyBUeXBlU2NyaXB0IGFkZHMgdG8gSmF2YVNjcmlwdFxuICBQcmlzbS5sYW5ndWFnZXMudHlwZXNjcmlwdC5rZXl3b3JkLnB1c2goL1xcYig/OmFic3RyYWN0fGRlY2xhcmV8aXN8a2V5b2Z8cmVhZG9ubHl8cmVxdWlyZSlcXGIvLFxuICAvLyBrZXl3b3JkcyB0aGF0IGhhdmUgdG8gYmUgZm9sbG93ZWQgYnkgYW4gaWRlbnRpZmllclxuICAvXFxiKD86YXNzZXJ0c3xpbmZlcnxpbnRlcmZhY2V8bW9kdWxlfG5hbWVzcGFjZXx0eXBlKVxcYig/PVxccyooPzpbe18kYS16QS1aXFx4QTAtXFx1RkZGRl18JCkpLyxcbiAgLy8gVGhpcyBpcyBmb3IgYGltcG9ydCB0eXBlICosIHt9YFxuICAvXFxidHlwZVxcYig/PVxccyooPzpbXFx7Kl18JCkpLyk7XG5cbiAgLy8gZG9lc24ndCB3b3JrIHdpdGggVFMgYmVjYXVzZSBUUyBpcyB0b28gY29tcGxleFxuICBkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHRbJ3BhcmFtZXRlciddO1xuICBkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHRbJ2xpdGVyYWwtcHJvcGVydHknXTtcblxuICAvLyBhIHZlcnNpb24gb2YgdHlwZXNjcmlwdCBzcGVjaWZpY2FsbHkgZm9yIGhpZ2hsaWdodGluZyB0eXBlc1xuICB2YXIgdHlwZUluc2lkZSA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ3R5cGVzY3JpcHQnLCB7fSk7XG4gIGRlbGV0ZSB0eXBlSW5zaWRlWydjbGFzcy1uYW1lJ107XG4gIFByaXNtLmxhbmd1YWdlcy50eXBlc2NyaXB0WydjbGFzcy1uYW1lJ10uaW5zaWRlID0gdHlwZUluc2lkZTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgndHlwZXNjcmlwdCcsICdmdW5jdGlvbicsIHtcbiAgICAnZGVjb3JhdG9yJzoge1xuICAgICAgcGF0dGVybjogL0BbJFxcd1xceEEwLVxcdUZGRkZdKy8sXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2F0Jzoge1xuICAgICAgICAgIHBhdHRlcm46IC9eQC8sXG4gICAgICAgICAgYWxpYXM6ICdvcGVyYXRvcidcbiAgICAgICAgfSxcbiAgICAgICAgJ2Z1bmN0aW9uJzogL15bXFxzXFxTXSsvXG4gICAgICB9XG4gICAgfSxcbiAgICAnZ2VuZXJpYy1mdW5jdGlvbic6IHtcbiAgICAgIC8vIGUuZy4gZm9vPFQgZXh0ZW5kcyBcImJhclwiIHwgXCJiYXpcIj4oIC4uLlxuICAgICAgcGF0dGVybjogLyM/KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKlxccyo8KD86W148Pl18PCg/OltePD5dfDxbXjw+XSo+KSo+KSo+KD89XFxzKlxcKCkvLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdmdW5jdGlvbic6IC9eIz8oPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqLyxcbiAgICAgICAgJ2dlbmVyaWMnOiB7XG4gICAgICAgICAgcGF0dGVybjogLzxbXFxzXFxTXSsvLFxuICAgICAgICAgIC8vIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IDxcbiAgICAgICAgICBhbGlhczogJ2NsYXNzLW5hbWUnLFxuICAgICAgICAgIGluc2lkZTogdHlwZUluc2lkZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLnRzID0gUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHQ7XG59KShQcmlzbSk7XG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIHZhciB0eXBlc2NyaXB0ID0gUHJpc20udXRpbC5jbG9uZShQcmlzbS5sYW5ndWFnZXMudHlwZXNjcmlwdCk7XG4gIFByaXNtLmxhbmd1YWdlcy50c3ggPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdqc3gnLCB0eXBlc2NyaXB0KTtcblxuICAvLyBkb2Vzbid0IHdvcmsgd2l0aCBUUyBiZWNhdXNlIFRTIGlzIHRvbyBjb21wbGV4XG4gIGRlbGV0ZSBQcmlzbS5sYW5ndWFnZXMudHN4WydwYXJhbWV0ZXInXTtcbiAgZGVsZXRlIFByaXNtLmxhbmd1YWdlcy50c3hbJ2xpdGVyYWwtcHJvcGVydHknXTtcblxuICAvLyBUaGlzIHdpbGwgcHJldmVudCBjb2xsaXNpb25zIGJldHdlZW4gVFNYIHRhZ3MgYW5kIFRTIGdlbmVyaWMgdHlwZXMuXG4gIC8vIElkZWEgYnkgaHR0cHM6Ly9naXRodWIuY29tL2thcmxob3JreVxuICAvLyBEaXNjdXNzaW9uOiBodHRwczovL2dpdGh1Yi5jb20vUHJpc21KUy9wcmlzbS9pc3N1ZXMvMjU5NCNpc3N1ZWNvbW1lbnQtNzEwNjY2OTI4XG4gIHZhciB0YWcgPSBQcmlzbS5sYW5ndWFnZXMudHN4LnRhZztcbiAgdGFnLnBhdHRlcm4gPSBSZWdFeHAoLyhefFteXFx3JF18KD89PFxcLykpLy5zb3VyY2UgKyAnKD86JyArIHRhZy5wYXR0ZXJuLnNvdXJjZSArICcpJywgdGFnLnBhdHRlcm4uZmxhZ3MpO1xuICB0YWcubG9va2JlaGluZCA9IHRydWU7XG59KShQcmlzbSk7XG5QcmlzbS5sYW5ndWFnZXMuYmFzaWMgPSB7XG4gICdjb21tZW50Jzoge1xuICAgIHBhdHRlcm46IC8oPzohfFJFTVxcYikuKy9pLFxuICAgIGluc2lkZToge1xuICAgICAgJ2tleXdvcmQnOiAvXlJFTS9pXG4gICAgfVxuICB9LFxuICAnc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC9cIig/OlwiXCJ8WyEjJCUmJygpKixcXC86Ozw9Pj9eXFx3ICtcXC0uXSkqXCIvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnbnVtYmVyJzogLyg/OlxcYlxcZCsoPzpcXC5cXGQqKT98XFxCXFwuXFxkKykoPzpFWystXT9cXGQrKT8vaSxcbiAgJ2tleXdvcmQnOiAvXFxiKD86QVN8QkVFUHxCTE9BRHxCU0FWRXxDQUxMKD86IEFCU09MVVRFKT98Q0FTRXxDSEFJTnxDSERJUnxDTEVBUnxDTE9TRXxDTFN8Q09NfENPTU1PTnxDT05TVHxEQVRBfERFQ0xBUkV8REVGKD86IEZOfCBTRUd8REJMfElOVHxMTkd8U05HfFNUUil8RElNfERPfERPVUJMRXxFTFNFfEVMU0VJRnxFTkR8RU5WSVJPTnxFUkFTRXxFUlJPUnxFWElUfEZJRUxEfEZJTEVTfEZPUnxGVU5DVElPTnxHRVR8R09TVUJ8R09UT3xJRnxJTlBVVHxJTlRFR0VSfElPQ1RMfEtFWXxLSUxMfExJTkUgSU5QVVR8TE9DQVRFfExPQ0t8TE9OR3xMT09QfExTRVR8TUtESVJ8TkFNRXxORVhUfE9GRnxPTig/OiBDT018IEVSUk9SfCBLRVl8IFRJTUVSKT98T1BFTnxPUFRJT04gQkFTRXxPVVR8UE9LRXxQVVR8UkVBRHxSRURJTXxSRU18UkVTVE9SRXxSRVNVTUV8UkVUVVJOfFJNRElSfFJTRVR8UlVOfFNFTEVDVCBDQVNFfFNIQVJFRHxTSEVMTHxTSU5HTEV8U0xFRVB8U1RBVElDfFNURVB8U1RPUHxTVFJJTkd8U1VCfFNXQVB8U1lTVEVNfFRIRU58VElNRVJ8VE98VFJPRkZ8VFJPTnxUWVBFfFVOTE9DS3xVTlRJTHxVU0lOR3xWSUVXIFBSSU5UfFdBSVR8V0VORHxXSElMRXxXUklURSkoPzpcXCR8XFxiKS9pLFxuICAnZnVuY3Rpb24nOiAvXFxiKD86QUJTfEFDQ0VTU3xBQ09TfEFOR0xFfEFSRUF8QVJJVEhNRVRJQ3xBUlJBWXxBU0lOfEFTS3xBVHxBVE58QkFTRXxCRUdJTnxCUkVBS3xDQVVTRXxDRUlMfENIUnxDTElQfENPTExBVEV8Q09MT1J8Q09OfENPU3xDT1NIfENPVHxDU0N8REFURXxEQVRVTXxERUJVR3xERUNJTUFMfERFRnxERUd8REVHUkVFU3xERUxFVEV8REVUfERFVklDRXxESVNQTEFZfERPVHxFTEFQU0VEfEVQU3xFUkFTQUJMRXxFWExJTkV8RVhQfEVYVEVSTkFMfEVYVFlQRXxGSUxFVFlQRXxGSVhFRHxGUHxHT3xHUkFQSHxIQU5ETEVSfElETnxJTUFHRXxJTnxJTlR8SU5URVJOQUx8SVB8SVN8S0VZRUR8TEJPVU5EfExDQVNFfExFRlR8TEVOfExFTkdUSHxMRVR8TElORXxMSU5FU3xMT0d8TE9HMTB8TE9HMnxMVFJJTXxNQVJHSU58TUFUfE1BWHxNQVhOVU18TUlEfE1JTnxNSVNTSU5HfE1PRHxOQVRJVkV8TlVMfE5VTUVSSUN8T0Z8T1BUSU9OfE9SRHxPUkdBTklaQVRJT058T1VUSU58T1VUUFVUfFBJfFBPSU5UfFBPSU5URVJ8UE9JTlRTfFBPU3xQUklOVHxQUk9HUkFNfFBST01QVHxSQUR8UkFESUFOU3xSQU5ET01JWkV8UkVDT1JEfFJFQ1NJWkV8UkVDVFlQRXxSRUxBVElWRXxSRU1BSU5ERVJ8UkVQRUFUfFJFU1R8UkVUUll8UkVXUklURXxSSUdIVHxSTkR8Uk9VTkR8UlRSSU18U0FNRXxTRUN8U0VMRUNUfFNFUVVFTlRJQUx8U0VUfFNFVFRFUnxTR058U0lOfFNJTkh8U0laRXxTS0lQfFNRUnxTVEFOREFSRHxTVEFUVVN8U1RSfFNUUkVBTXxTVFlMRXxUQUJ8VEFOfFRBTkh8VEVNUExBVEV8VEVYVHxUSEVSRXxUSU1FfFRJTUVPVVR8VFJBQ0V8VFJBTlNGT1JNfFRSVU5DQVRFfFVCT1VORHxVQ0FTRXxVU0V8VkFMfFZBUklBQkxFfFZJRVdQT1JUfFdIRU58V0lORE9XfFdJVEh8WkVSfFpPTkVXSURUSCkoPzpcXCR8XFxiKS9pLFxuICAnb3BlcmF0b3InOiAvPFs9Pl0/fD49P3xbK1xcLSpcXC9ePSZdfFxcYig/OkFORHxFUVZ8SU1QfE5PVHxPUnxYT1IpXFxiL2ksXG4gICdwdW5jdHVhdGlvbic6IC9bLDs6KCldL1xufTtcblByaXNtLmxhbmd1YWdlcy52Ym5ldCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2Jhc2ljJywge1xuICAnY29tbWVudCc6IFt7XG4gICAgcGF0dGVybjogLyg/OiF8UkVNXFxiKS4rL2ksXG4gICAgaW5zaWRlOiB7XG4gICAgICAna2V5d29yZCc6IC9eUkVNL2lcbiAgICB9XG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvKF58W15cXFxcOl0pJy4qLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9XSxcbiAgJ3N0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvKF58W15cIl0pXCIoPzpcIlwifFteXCJdKSpcIig/IVwiKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ2tleXdvcmQnOiAvKD86XFxiKD86QURESEFORExFUnxBRERSRVNTT0Z8QUxJQVN8QU5EfEFOREFMU098QVN8QkVFUHxCTE9BRHxCT09MRUFOfEJTQVZFfEJZUkVGfEJZVEV8QllWQUx8Q0FMTCg/OiBBQlNPTFVURSk/fENBU0V8Q0FUQ0h8Q0JPT0x8Q0JZVEV8Q0NIQVJ8Q0RBVEV8Q0RCTHxDREVDfENIQUlOfENIQVJ8Q0hESVJ8Q0lOVHxDTEFTU3xDTEVBUnxDTE5HfENMT1NFfENMU3xDT0JKfENPTXxDT01NT058Q09OU1R8Q09OVElOVUV8Q1NCWVRFfENTSE9SVHxDU05HfENTVFJ8Q1RZUEV8Q1VJTlR8Q1VMTkd8Q1VTSE9SVHxEQVRBfERBVEV8REVDSU1BTHxERUNMQVJFfERFRig/OiBGTnwgU0VHfERCTHxJTlR8TE5HfFNOR3xTVFIpfERFRkFVTFR8REVMRUdBVEV8RElNfERJUkVDVENBU1R8RE98RE9VQkxFfEVMU0V8RUxTRUlGfEVORHxFTlVNfEVOVklST058RVJBU0V8RVJST1J8RVZFTlR8RVhJVHxGQUxTRXxGSUVMRHxGSUxFU3xGSU5BTExZfEZPUig/OiBFQUNIKT98RlJJRU5EfEZVTkNUSU9OfEdFVHxHRVRUWVBFfEdFVFhNTE5BTUVTUEFDRXxHTE9CQUx8R09TVUJ8R09UT3xIQU5ETEVTfElGfElNUExFTUVOVFN8SU1QT1JUU3xJTnxJTkhFUklUU3xJTlBVVHxJTlRFR0VSfElOVEVSRkFDRXxJT0NUTHxJU3xJU05PVHxLRVl8S0lMTHxMRVR8TElCfExJS0V8TElORSBJTlBVVHxMT0NBVEV8TE9DS3xMT05HfExPT1B8TFNFVHxNRXxNS0RJUnxNT0R8TU9EVUxFfE1VU1RJTkhFUklUfE1VU1RPVkVSUklERXxNWUJBU0V8TVlDTEFTU3xOQU1FfE5BTUVTUEFDRXxOQVJST1dJTkd8TkVXfE5FWFR8Tk9UfE5PVEhJTkd8Tk9USU5IRVJJVEFCTEV8Tk9UT1ZFUlJJREFCTEV8T0JKRUNUfE9GfE9GRnxPTig/OiBDT018IEVSUk9SfCBLRVl8IFRJTUVSKT98T1BFTnxPUEVSQVRPUnxPUFRJT04oPzogQkFTRSk/fE9QVElPTkFMfE9SfE9SRUxTRXxPVVR8T1ZFUkxPQURTfE9WRVJSSURBQkxFfE9WRVJSSURFU3xQQVJBTUFSUkFZfFBBUlRJQUx8UE9LRXxQUklWQVRFfFBST1BFUlRZfFBST1RFQ1RFRHxQVUJMSUN8UFVUfFJBSVNFRVZFTlR8UkVBRHxSRUFET05MWXxSRURJTXxSRU18UkVNT1ZFSEFORExFUnxSRVNUT1JFfFJFU1VNRXxSRVRVUk58Uk1ESVJ8UlNFVHxSVU58U0JZVEV8U0VMRUNUKD86IENBU0UpP3xTRVR8U0hBRE9XU3xTSEFSRUR8U0hFTEx8U0hPUlR8U0lOR0xFfFNMRUVQfFNUQVRJQ3xTVEVQfFNUT1B8U1RSSU5HfFNUUlVDVFVSRXxTVUJ8U1dBUHxTWU5DTE9DS3xTWVNURU18VEhFTnxUSFJPV3xUSU1FUnxUT3xUUk9GRnxUUk9OfFRSVUV8VFJZfFRSWUNBU1R8VFlQRXxUWVBFT0Z8VUlOVEVHRVJ8VUxPTkd8VU5MT0NLfFVOVElMfFVTSE9SVHxVU0lOR3xWSUVXIFBSSU5UfFdBSVR8V0VORHxXSEVOfFdISUxFfFdJREVOSU5HfFdJVEh8V0lUSEVWRU5UU3xXUklURXxXUklURU9OTFl8WE9SKXxcXEIoPzojQ09OU1R8I0VMU0V8I0VMU0VJRnwjRU5EfCNJRikpKD86XFwkfFxcYikvaSxcbiAgJ3B1bmN0dWF0aW9uJzogL1ssOzooKXt9XS9cbn0pO1xuXG5jb25zdCBsYW5ndWFnZXMgPSBbe1xuICBsYWJlbDogJ0MnLFxuICB2YWx1ZTogJ2MnXG59LCB7XG4gIGxhYmVsOiAnQysrJyxcbiAgdmFsdWU6ICdjcHAnXG59LCB7XG4gIGxhYmVsOiAnQXJkdWlubycsXG4gIHZhbHVlOiAnYXJkdWlubydcbn0sIHtcbiAgbGFiZWw6ICdCYXNoJyxcbiAgdmFsdWU6ICdiYXNoJ1xufSwge1xuICBsYWJlbDogJ0MjJyxcbiAgdmFsdWU6ICdjc2hhcnAnXG59LCB7XG4gIGxhYmVsOiAnQ1NTJyxcbiAgdmFsdWU6ICdjc3MnXG59LCB7XG4gIGxhYmVsOiAnRGlmZicsXG4gIHZhbHVlOiAnZGlmZidcbn0sIHtcbiAgbGFiZWw6ICdHbycsXG4gIHZhbHVlOiAnZ28nXG59LCB7XG4gIGxhYmVsOiAnSU5JJyxcbiAgdmFsdWU6ICdpbmknXG59LCB7XG4gIGxhYmVsOiAnSmF2YScsXG4gIHZhbHVlOiAnamF2YSdcbn0sIHtcbiAgbGFiZWw6ICdKYXZhU2NyaXB0JyxcbiAgdmFsdWU6ICdqYXZhc2NyaXB0J1xufSwge1xuICBsYWJlbDogJ0pTWCcsXG4gIHZhbHVlOiAnanN4J1xufSwge1xuICBsYWJlbDogJ0pTT04nLFxuICB2YWx1ZTogJ2pzb24nXG59LCB7XG4gIGxhYmVsOiAnS290bGluJyxcbiAgdmFsdWU6ICdrb3RsaW4nXG59LCB7XG4gIGxhYmVsOiAnTGVzcycsXG4gIHZhbHVlOiAnbGVzcydcbn0sIHtcbiAgbGFiZWw6ICdMdWEnLFxuICB2YWx1ZTogJ2x1YSdcbn0sIHtcbiAgbGFiZWw6ICdNYWtlZmlsZScsXG4gIHZhbHVlOiAnbWFrZWZpbGUnXG59LCB7XG4gIGxhYmVsOiAnTWFya2Rvd24nLFxuICB2YWx1ZTogJ21hcmtkb3duJ1xufSwge1xuICBsYWJlbDogJ09iamVjdGl2ZS1DJyxcbiAgdmFsdWU6ICdvYmplY3RpdmVjJ1xufSwge1xuICBsYWJlbDogJ1BlcmwnLFxuICB2YWx1ZTogJ3BlcmwnXG59LCB7XG4gIGxhYmVsOiAnUEhQJyxcbiAgdmFsdWU6ICdwaHAnXG59LCB7XG4gIGxhYmVsOiAnUHl0aG9uJyxcbiAgdmFsdWU6ICdweXRob24nXG59LCB7XG4gIGxhYmVsOiAnUicsXG4gIHZhbHVlOiAncidcbn0sIHtcbiAgbGFiZWw6ICdSdWJ5JyxcbiAgdmFsdWU6ICdydWJ5J1xufSwge1xuICBsYWJlbDogJ1J1c3QnLFxuICB2YWx1ZTogJ3J1c3QnXG59LCB7XG4gIGxhYmVsOiAnU2FzcycsXG4gIHZhbHVlOiAnc2Fzcydcbn0sIHtcbiAgbGFiZWw6ICdTQ1NTJyxcbiAgdmFsdWU6ICdzY3NzJ1xufSwge1xuICBsYWJlbDogJ1NRTCcsXG4gIHZhbHVlOiAnc3FsJ1xufSwge1xuICBsYWJlbDogJ1N3aWZ0JyxcbiAgdmFsdWU6ICdzd2lmdCdcbn0sIHtcbiAgbGFiZWw6ICdUeXBlU2NyaXB0JyxcbiAgdmFsdWU6ICd0eXBlc2NyaXB0J1xufSwge1xuICBsYWJlbDogJ1RTWCcsXG4gIHZhbHVlOiAndHN4J1xufSwge1xuICBsYWJlbDogJ1ZCLk5FVCcsXG4gIHZhbHVlOiAndmJuZXQnXG59LCB7XG4gIGxhYmVsOiAnWUFNTCcsXG4gIHZhbHVlOiAneWFtbCdcbn1dO1xuY29uc3QgY2Fub25pY2FsTmFtZVRvTGFiZWwgPSBuZXcgTWFwKGxhbmd1YWdlcy5tYXAoeCA9PiBbeC52YWx1ZSwgeC5sYWJlbF0pKTtcbm5ldyBNYXAobGFuZ3VhZ2VzLm1hcCh4ID0+IFt4LmxhYmVsLCB4LnZhbHVlXSkpO1xuY29uc3QgbGFuZ3VhZ2VUb0Nhbm9uaWNhbE5hbWUgPSBuZXcgTWFwKGxhbmd1YWdlcy5tYXAobGFuZyA9PiBbUHJpc20ubGFuZ3VhZ2VzW2xhbmcudmFsdWVdLCBsYW5nLnZhbHVlXSkpO1xuY29uc3QgYWxpYXNlc1RvQ2Fub25pY2FsTmFtZSA9IG5ldyBNYXAoT2JqZWN0LmtleXMoUHJpc20ubGFuZ3VhZ2VzKS5mbGF0TWFwKGxhbmcgPT4ge1xuICBjb25zdCBjYW5vbmljYWxOYW1lID0gbGFuZ3VhZ2VUb0Nhbm9uaWNhbE5hbWUuZ2V0KFByaXNtLmxhbmd1YWdlc1tsYW5nXSk7XG4gIGlmIChjYW5vbmljYWxOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIFtbbGFuZywgY2Fub25pY2FsTmFtZV1dO1xufSkpO1xuY29uc3QgbGFuZ3VhZ2VzVG9BbGlhc2VzID0gbmV3IE1hcChsYW5ndWFnZXMubWFwKGxhbmcgPT4gW2xhbmcudmFsdWUsIFtdXSkpO1xuZm9yIChjb25zdCBbYWxpYXMsIGNhbm9uaWNhbE5hbWVdIG9mIGFsaWFzZXNUb0Nhbm9uaWNhbE5hbWUpIHtcbiAgbGFuZ3VhZ2VzVG9BbGlhc2VzLmdldChjYW5vbmljYWxOYW1lKS5wdXNoKGFsaWFzKTtcbn1cblt7XG4gIGxhYmVsOiAnUGxhaW4gdGV4dCcsXG4gIHZhbHVlOiAncGxhaW4nLFxuICBhbGlhc2VzOiBbXVxufSwgLi4uWy4uLmxhbmd1YWdlc1RvQWxpYXNlc10ubWFwKChbY2Fub25pY2FsTmFtZSwgYWxpYXNlc10pID0+ICh7XG4gIGxhYmVsOiBjYW5vbmljYWxOYW1lVG9MYWJlbC5nZXQoY2Fub25pY2FsTmFtZSksXG4gIHZhbHVlOiBjYW5vbmljYWxOYW1lLFxuICBhbGlhc2VzXG59KSldO1xubmV3IE1hcChbLi4uYWxpYXNlc1RvQ2Fub25pY2FsTmFtZV0ubWFwKChbYWxpYXMsIGNhbm9uaWNhbE5hbWVdKSA9PiBbYWxpYXMsIGNhbm9uaWNhbE5hbWVUb0xhYmVsLmdldChjYW5vbmljYWxOYW1lKV0pKTtcblxuY29uc3QgY29kZUJsb2NrU2hvcnRjdXRQYXR0ZXJuID0gL15gYGAoXFx3Kyk/ID8kLztcbmZ1bmN0aW9uIHdpdGhDb2RlQmxvY2soZG9jdW1lbnRGZWF0dXJlcywgY29tcG9uZW50QmxvY2tzLCBlZGl0b3IpIHtcbiAgY29uc3Qge1xuICAgIGluc2VydEJyZWFrLFxuICAgIG5vcm1hbGl6ZU5vZGUsXG4gICAgaW5zZXJ0VGV4dFxuICB9ID0gZWRpdG9yO1xuICBmdW5jdGlvbiBjb2RlQmxvY2tTaG9ydGN1dChibG9jaykge1xuICAgIHZhciBfYWxpYXNlc1RvQ2Fub25pY2FsTmE7XG4gICAgaWYgKChibG9jayA9PT0gbnVsbCB8fCBibG9jayA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmxvY2tbMF0udHlwZSkgIT09ICdwYXJhZ3JhcGgnIHx8IGJsb2NrWzBdLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBibG9ja1swXS5jaGlsZHJlblswXS50eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2ggPSBjb2RlQmxvY2tTaG9ydGN1dFBhdHRlcm4uZXhlYyhibG9ja1swXS5jaGlsZHJlblswXS50ZXh0KTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGxvY2F0aW9uRG9jdW1lbnRGZWF0dXJlcyA9IGdldEFuY2VzdG9yQ29tcG9uZW50Q2hpbGRGaWVsZERvY3VtZW50RmVhdHVyZXMoZWRpdG9yLCBkb2N1bWVudEZlYXR1cmVzLCBjb21wb25lbnRCbG9ja3MpO1xuICAgIGlmIChsb2NhdGlvbkRvY3VtZW50RmVhdHVyZXMgJiYgKGxvY2F0aW9uRG9jdW1lbnRGZWF0dXJlcy5raW5kID09PSAnaW5saW5lJyB8fCAhbG9jYXRpb25Eb2N1bWVudEZlYXR1cmVzLmRvY3VtZW50RmVhdHVyZXMuZm9ybWF0dGluZy5ibG9ja1R5cGVzLmNvZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gc28gdGhhdCB0aGlzIHN0YXJ0cyBhIG5ldyB1bmRvIGdyb3VwXG4gICAgZWRpdG9yLmhpc3RvcnkudW5kb3MucHVzaCh7XG4gICAgICBvcGVyYXRpb25zOiBbXSxcbiAgICAgIHNlbGVjdGlvbkJlZm9yZTogZWRpdG9yLnNlbGVjdGlvblxuICAgIH0pO1xuICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgYmxvY2tbMV0pO1xuICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvcik7XG4gICAgVHJhbnNmb3Jtcy53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICB0eXBlOiAnY29kZScsXG4gICAgICAuLi4obWF0Y2hbMV0gPyB7XG4gICAgICAgIGxhbmd1YWdlOiAoX2FsaWFzZXNUb0Nhbm9uaWNhbE5hID0gYWxpYXNlc1RvQ2Fub25pY2FsTmFtZS5nZXQobWF0Y2hbMV0udG9Mb3dlckNhc2UoKSkpICE9PSBudWxsICYmIF9hbGlhc2VzVG9DYW5vbmljYWxOYSAhPT0gdm9pZCAwID8gX2FsaWFzZXNUb0Nhbm9uaWNhbE5hIDogbWF0Y2hbMV1cbiAgICAgIH0gOiB7fSksXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9LCB7XG4gICAgICBtYXRjaDogbm9kZSA9PiBub2RlLnR5cGUgPT09ICdwYXJhZ3JhcGgnXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZWRpdG9yLmluc2VydEJyZWFrID0gKCkgPT4ge1xuICAgIGNvbnN0IGJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IGlzQmxvY2tcbiAgICB9KTtcbiAgICBpZiAoKGJsb2NrID09PSBudWxsIHx8IGJsb2NrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBibG9ja1swXS50eXBlKSA9PT0gJ2NvZGUnICYmIFRleHQuaXNUZXh0KGJsb2NrWzBdLmNoaWxkcmVuWzBdKSkge1xuICAgICAgY29uc3QgdGV4dCA9IGJsb2NrWzBdLmNoaWxkcmVuWzBdLnRleHQ7XG4gICAgICBpZiAodGV4dFt0ZXh0Lmxlbmd0aCAtIDFdID09PSAnXFxuJyAmJiBlZGl0b3Iuc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pICYmIFBvaW50LmVxdWFscyhFZGl0b3IuZW5kKGVkaXRvciwgYmxvY2tbMV0pLCBlZGl0b3Iuc2VsZWN0aW9uLmFuY2hvcikpIHtcbiAgICAgICAgaW5zZXJ0QnJlYWsoKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgfSk7XG4gICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgIGRpc3RhbmNlOiAxLFxuICAgICAgICAgIGF0OiB7XG4gICAgICAgICAgICBwYXRoOiBbLi4uYmxvY2tbMV0sIDBdLFxuICAgICAgICAgICAgb2Zmc2V0OiB0ZXh0Lmxlbmd0aCAtIDFcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlZGl0b3IuaW5zZXJ0VGV4dCgnXFxuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pICYmIGNvZGVCbG9ja1Nob3J0Y3V0KGJsb2NrKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnNlcnRCcmVhaygpO1xuICB9O1xuICBlZGl0b3IuaW5zZXJ0VGV4dCA9IHRleHQgPT4ge1xuICAgIGluc2VydFRleHQodGV4dCk7XG4gICAgaWYgKHRleHQgPT09ICcgJyAmJiBlZGl0b3Iuc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pKSB7XG4gICAgICBjb2RlQmxvY2tTaG9ydGN1dChFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBpc0Jsb2NrXG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuICBlZGl0b3Iubm9ybWFsaXplTm9kZSA9IChbbm9kZSwgcGF0aF0pID0+IHtcbiAgICBpZiAobm9kZS50eXBlID09PSAnY29kZScgJiYgRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSkge1xuICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGNoaWxkTm9kZV0gb2Ygbm9kZS5jaGlsZHJlbi5lbnRyaWVzKCkpIHtcbiAgICAgICAgaWYgKCFUZXh0LmlzVGV4dChjaGlsZE5vZGUpKSB7XG4gICAgICAgICAgaWYgKGVkaXRvci5pc1ZvaWQoY2hpbGROb2RlKSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IFsuLi5wYXRoLCBpbmRleF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogWy4uLnBhdGgsIGluZGV4XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXJrcyA9IE9iamVjdC5rZXlzKGNoaWxkTm9kZSkuZmlsdGVyKHggPT4geCAhPT0gJ3RleHQnKTtcbiAgICAgICAgaWYgKG1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgIFRyYW5zZm9ybXMudW5zZXROb2RlcyhlZGl0b3IsIG1hcmtzLCB7XG4gICAgICAgICAgICBhdDogWy4uLnBhdGgsIGluZGV4XVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBub3JtYWxpemVOb2RlKFtub2RlLCBwYXRoXSk7XG4gIH07XG4gIHJldHVybiBlZGl0b3I7XG59XG5cbmZ1bmN0aW9uIGZpbmRDaGlsZFByb3BQYXRoc0ZvclByb3AodmFsdWUsIHNjaGVtYSwgcGF0aCkge1xuICBzd2l0Y2ggKHNjaGVtYS5raW5kKSB7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICByZXR1cm4gW107XG4gICAgY2FzZSAnY2hpbGQnOlxuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIG9wdGlvbnM6IHNjaGVtYS5vcHRpb25zXG4gICAgICB9XTtcbiAgICBjYXNlICdjb25kaXRpb25hbCc6XG4gICAgICByZXR1cm4gZmluZENoaWxkUHJvcFBhdGhzRm9yUHJvcCh2YWx1ZS52YWx1ZSwgc2NoZW1hLnZhbHVlc1t2YWx1ZS5kaXNjcmltaW5hbnRdLCBwYXRoLmNvbmNhdCgndmFsdWUnKSk7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHtcbiAgICAgICAgY29uc3QgcGF0aHMgPSBbXTtcbiAgICAgICAgT2JqZWN0LmtleXMoc2NoZW1hLmZpZWxkcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgIHBhdGhzLnB1c2goLi4uZmluZENoaWxkUHJvcFBhdGhzRm9yUHJvcCh2YWx1ZVtrZXldLCBzY2hlbWEuZmllbGRzW2tleV0sIHBhdGguY29uY2F0KGtleSkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXRocztcbiAgICAgIH1cbiAgICBjYXNlICdhcnJheSc6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IHBhdGhzID0gW107XG4gICAgICAgIHZhbHVlLmZvckVhY2goKHZhbCwgaSkgPT4ge1xuICAgICAgICAgIHBhdGhzLnB1c2goLi4uZmluZENoaWxkUHJvcFBhdGhzRm9yUHJvcCh2YWwsIHNjaGVtYS5lbGVtZW50LCBwYXRoLmNvbmNhdChpKSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhdGhzO1xuICAgICAgfVxuICB9XG59XG5mdW5jdGlvbiBmaW5kQ2hpbGRQcm9wUGF0aHModmFsdWUsIHByb3BzKSB7XG4gIGNvbnN0IHByb3BQYXRocyA9IGZpbmRDaGlsZFByb3BQYXRoc0ZvclByb3AodmFsdWUsIHtcbiAgICBraW5kOiAnb2JqZWN0JyxcbiAgICBmaWVsZHM6IHByb3BzXG4gIH0sIFtdKTtcbiAgaWYgKCFwcm9wUGF0aHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIFt7XG4gICAgICBwYXRoOiB1bmRlZmluZWQsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGtpbmQ6ICdpbmxpbmUnLFxuICAgICAgICBwbGFjZWhvbGRlcjogJydcbiAgICAgIH1cbiAgICB9XTtcbiAgfVxuICByZXR1cm4gcHJvcFBhdGhzO1xufVxuXG5mdW5jdGlvbiBnZXRBbmNlc3RvckNvbXBvbmVudEJsb2NrKGVkaXRvcikge1xuICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgIGNvbnN0IGFuY2VzdG9yRW50cnkgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICBtYXRjaDogbm9kZSA9PiBpc0Jsb2NrKG5vZGUpICYmIG5vZGUudHlwZSAhPT0gJ3BhcmFncmFwaCdcbiAgICB9KTtcbiAgICBpZiAoYW5jZXN0b3JFbnRyeSAmJiAoYW5jZXN0b3JFbnRyeVswXS50eXBlID09PSAnY29tcG9uZW50LWJsb2NrLXByb3AnIHx8IGFuY2VzdG9yRW50cnlbMF0udHlwZSA9PT0gJ2NvbXBvbmVudC1pbmxpbmUtcHJvcCcpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc0luc2lkZTogdHJ1ZSxcbiAgICAgICAgY29tcG9uZW50QmxvY2s6IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBhbmNlc3RvckVudHJ5WzFdKSxcbiAgICAgICAgcHJvcDogYW5jZXN0b3JFbnRyeVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc0luc2lkZTogZmFsc2VcbiAgfTtcbn1cbmNvbnN0IGFscmVhZHlOb3JtYWxpemVkVGhpbmdzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZU5vZGVXaXRoaW5Db21wb25lbnRQcm9wKFtub2RlLCBwYXRoXSwgZWRpdG9yLCBmaWVsZE9wdGlvbnMpIHtcbiAgbGV0IGFscmVhZHlOb3JtYWxpemVkTm9kZXMgPSBhbHJlYWR5Tm9ybWFsaXplZFRoaW5ncy5nZXQoZmllbGRPcHRpb25zKTtcbiAgaWYgKCFhbHJlYWR5Tm9ybWFsaXplZE5vZGVzKSB7XG4gICAgYWxyZWFkeU5vcm1hbGl6ZWROb2RlcyA9IG5ldyBXZWFrU2V0KCk7XG4gICAgYWxyZWFkeU5vcm1hbGl6ZWRUaGluZ3Muc2V0KGZpZWxkT3B0aW9ucywgYWxyZWFkeU5vcm1hbGl6ZWROb2Rlcyk7XG4gIH1cbiAgaWYgKGFscmVhZHlOb3JtYWxpemVkTm9kZXMuaGFzKG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBkaWROb3JtYWxpemF0aW9uID0gZmFsc2U7XG4gIGlmIChmaWVsZE9wdGlvbnMuaW5saW5lTWFya3MgIT09ICdpbmhlcml0JyAmJiBUZXh0LmlzVGV4dChub2RlKSkge1xuICAgIGRpZE5vcm1hbGl6YXRpb24gPSBub3JtYWxpemVUZXh0QmFzZWRPbklubGluZU1hcmtzQW5kU29mdEJyZWFrcyhbbm9kZSwgcGF0aF0sIGVkaXRvciwgZmllbGRPcHRpb25zLmlubGluZU1hcmtzLCBmaWVsZE9wdGlvbnMuc29mdEJyZWFrcyk7XG4gIH1cbiAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkpIHtcbiAgICBsZXQgY2hpbGRyZW5IYXNDaGFuZ2VkID0gbm9kZS5jaGlsZHJlbi5tYXAoKG5vZGUsIGkpID0+IG5vcm1hbGl6ZU5vZGVXaXRoaW5Db21wb25lbnRQcm9wKFtub2RlLCBbLi4ucGF0aCwgaV1dLCBlZGl0b3IsIGZpZWxkT3B0aW9ucykpXG4gICAgLy8gLm1hcCB0aGVuIC5zb21lIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBleGl0IGVhcmx5XG4gICAgLnNvbWUoeCA9PiB4KTtcbiAgICBpZiAoZmllbGRPcHRpb25zLmtpbmQgPT09ICdibG9jaycpIHtcbiAgICAgIGlmIChub2RlLnR5cGUgPT09ICdjb21wb25lbnQtYmxvY2snKSB7XG4gICAgICAgIGlmICghZmllbGRPcHRpb25zLmNvbXBvbmVudEJsb2Nrcykge1xuICAgICAgICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRpZE5vcm1hbGl6YXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWROb3JtYWxpemF0aW9uID0gbm9ybWFsaXplRWxlbWVudEJhc2VkT25Eb2N1bWVudEZlYXR1cmVzKFtub2RlLCBwYXRoXSwgZWRpdG9yLCBmaWVsZE9wdGlvbnMuZG9jdW1lbnRGZWF0dXJlcykgfHwgY2hpbGRyZW5IYXNDaGFuZ2VkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkaWROb3JtYWxpemF0aW9uID0gbm9ybWFsaXplSW5saW5lQmFzZWRPbkxpbmtzKFtub2RlLCBwYXRoXSwgZWRpdG9yLCBmaWVsZE9wdGlvbnMuZG9jdW1lbnRGZWF0dXJlcy5saW5rcyk7XG4gICAgfVxuICB9XG4gIGlmIChkaWROb3JtYWxpemF0aW9uID09PSBmYWxzZSkge1xuICAgIGFscmVhZHlOb3JtYWxpemVkTm9kZXMuYWRkKG5vZGUpO1xuICB9XG4gIHJldHVybiBkaWROb3JtYWxpemF0aW9uO1xufVxuZnVuY3Rpb24gY2FuU2NoZW1hQ29udGFpbkNoaWxkRmllbGQocm9vdFNjaGVtYSkge1xuICBjb25zdCBxdWV1ZSA9IG5ldyBTZXQoW3Jvb3RTY2hlbWFdKTtcbiAgZm9yIChjb25zdCBzY2hlbWEgb2YgcXVldWUpIHtcbiAgICBpZiAoc2NoZW1hLmtpbmQgPT09ICdmb3JtJykgOyBlbHNlIGlmIChzY2hlbWEua2luZCA9PT0gJ2NoaWxkJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChzY2hlbWEua2luZCA9PT0gJ2FycmF5Jykge1xuICAgICAgcXVldWUuYWRkKHNjaGVtYS5lbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHNjaGVtYS5raW5kID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yIChjb25zdCBpbm5lclByb3Agb2YgT2JqZWN0LnZhbHVlcyhzY2hlbWEuZmllbGRzKSkge1xuICAgICAgICBxdWV1ZS5hZGQoaW5uZXJQcm9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNjaGVtYS5raW5kID09PSAnY29uZGl0aW9uYWwnKSB7XG4gICAgICBmb3IgKGNvbnN0IGlubmVyUHJvcCBvZiBPYmplY3QudmFsdWVzKHNjaGVtYS52YWx1ZXMpKSB7XG4gICAgICAgIHF1ZXVlLmFkZChpbm5lclByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnROZXZlcihzY2hlbWEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkb2VzU2NoZW1hT25seUV2ZXJDb250YWluQVNpbmdsZUNoaWxkRmllbGQocm9vdFNjaGVtYSkge1xuICBjb25zdCBxdWV1ZSA9IG5ldyBTZXQoW3Jvb3RTY2hlbWFdKTtcbiAgbGV0IGhhc0ZvdW5kQ2hpbGRGaWVsZCA9IGZhbHNlO1xuICBmb3IgKGNvbnN0IHNjaGVtYSBvZiBxdWV1ZSkge1xuICAgIGlmIChzY2hlbWEua2luZCA9PT0gJ2Zvcm0nKSA7IGVsc2UgaWYgKHNjaGVtYS5raW5kID09PSAnY2hpbGQnKSB7XG4gICAgICBpZiAoaGFzRm91bmRDaGlsZEZpZWxkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGhhc0ZvdW5kQ2hpbGRGaWVsZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChzY2hlbWEua2luZCA9PT0gJ2FycmF5Jykge1xuICAgICAgaWYgKGNhblNjaGVtYUNvbnRhaW5DaGlsZEZpZWxkKHNjaGVtYS5lbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzY2hlbWEua2luZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAoY29uc3QgaW5uZXJQcm9wIG9mIE9iamVjdC52YWx1ZXMoc2NoZW1hLmZpZWxkcykpIHtcbiAgICAgICAgcXVldWUuYWRkKGlubmVyUHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzY2hlbWEua2luZCA9PT0gJ2NvbmRpdGlvbmFsJykge1xuICAgICAgZm9yIChjb25zdCBpbm5lclByb3Agb2YgT2JqZWN0LnZhbHVlcyhzY2hlbWEudmFsdWVzKSkge1xuICAgICAgICBxdWV1ZS5hZGQoaW5uZXJQcm9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0TmV2ZXIoc2NoZW1hKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc0ZvdW5kQ2hpbGRGaWVsZDtcbn1cbmZ1bmN0aW9uIGZpbmRBcnJheUZpZWxkc1dpdGhTaW5nbGVDaGlsZEZpZWxkKHNjaGVtYSwgdmFsdWUpIHtcbiAgY29uc3QgcHJvcFBhdGhzID0gW107XG4gIHRyYXZlcnNlUHJvcHMoc2NoZW1hLCB2YWx1ZSwgKHNjaGVtYSwgdmFsdWUsIHBhdGgpID0+IHtcbiAgICBpZiAoc2NoZW1hLmtpbmQgPT09ICdhcnJheScgJiYgZG9lc1NjaGVtYU9ubHlFdmVyQ29udGFpbkFTaW5nbGVDaGlsZEZpZWxkKHNjaGVtYS5lbGVtZW50KSkge1xuICAgICAgcHJvcFBhdGhzLnB1c2goW3BhdGgsIHNjaGVtYV0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwcm9wUGF0aHM7XG59XG5mdW5jdGlvbiBpc0VtcHR5Q2hpbGRGaWVsZE5vZGUoZWxlbWVudCkge1xuICBjb25zdCBmaXJzdENoaWxkID0gZWxlbWVudC5jaGlsZHJlblswXTtcbiAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIChlbGVtZW50LnR5cGUgPT09ICdjb21wb25lbnQtaW5saW5lLXByb3AnICYmIGZpcnN0Q2hpbGQudHlwZSA9PT0gdW5kZWZpbmVkICYmIGZpcnN0Q2hpbGQudGV4dCA9PT0gJycgfHwgZWxlbWVudC50eXBlID09PSAnY29tcG9uZW50LWJsb2NrLXByb3AnICYmIGZpcnN0Q2hpbGQudHlwZSA9PT0gJ3BhcmFncmFwaCcgJiYgZmlyc3RDaGlsZC5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgZmlyc3RDaGlsZC5jaGlsZHJlblswXS50eXBlID09PSB1bmRlZmluZWQgJiYgZmlyc3RDaGlsZC5jaGlsZHJlblswXS50ZXh0ID09PSAnJyk7XG59XG5mdW5jdGlvbiB3aXRoQ29tcG9uZW50QmxvY2tzKGJsb2NrQ29tcG9uZW50cywgZWRpdG9yRG9jdW1lbnRGZWF0dXJlcywgZWRpdG9yKSB7XG4gIC8vIG5vdGUgdGhhdCBjb25mbGljdHMgYmV0d2VlbiB0aGUgZWRpdG9yIGRvY3VtZW50IGZlYXR1cmVzXG4gIC8vIGFuZCB0aGUgY2hpbGQgZmllbGQgZG9jdW1lbnQgZmVhdHVyZXMgYXJlIGRlYWx0IHdpdGggZWxzZXdoZXJlXG4gIGNvbnN0IG1lbW9pemVkR2V0RG9jdW1lbnRGZWF0dXJlc0ZvckNoaWxkRmllbGQgPSB3ZWFrTWVtb2l6ZShvcHRpb25zID0+IHtcbiAgICByZXR1cm4gZ2V0RG9jdW1lbnRGZWF0dXJlc0ZvckNoaWxkRmllbGQoZWRpdG9yRG9jdW1lbnRGZWF0dXJlcywgb3B0aW9ucyk7XG4gIH0pO1xuICBjb25zdCB7XG4gICAgbm9ybWFsaXplTm9kZSxcbiAgICBkZWxldGVCYWNrd2FyZCxcbiAgICBpbnNlcnRCcmVha1xuICB9ID0gZWRpdG9yO1xuICBlZGl0b3IuZGVsZXRlQmFja3dhcmQgPSB1bml0ID0+IHtcbiAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgY29uc3QgYW5jZXN0b3JDb21wb25lbnRCbG9jayA9IGdldEFuY2VzdG9yQ29tcG9uZW50QmxvY2soZWRpdG9yKTtcbiAgICAgIGlmIChhbmNlc3RvckNvbXBvbmVudEJsb2NrLmlzSW5zaWRlICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pICYmIEVkaXRvci5pc1N0YXJ0KGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbi5hbmNob3IsIGFuY2VzdG9yQ29tcG9uZW50QmxvY2sucHJvcFsxXSkgJiYgYW5jZXN0b3JDb21wb25lbnRCbG9jay5wcm9wWzFdW2FuY2VzdG9yQ29tcG9uZW50QmxvY2sucHJvcFsxXS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgICBUcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBhbmNlc3RvckNvbXBvbmVudEJsb2NrLmNvbXBvbmVudEJsb2NrWzFdXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZUJhY2t3YXJkKHVuaXQpO1xuICB9O1xuICBlZGl0b3IuaW5zZXJ0QnJlYWsgPSAoKSA9PiB7XG4gICAgY29uc3QgYW5jZXN0b3JDb21wb25lbnRCbG9jayA9IGdldEFuY2VzdG9yQ29tcG9uZW50QmxvY2soZWRpdG9yKTtcbiAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbiAmJiBhbmNlc3RvckNvbXBvbmVudEJsb2NrLmlzSW5zaWRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHByb3A6IFtjb21wb25lbnRQcm9wTm9kZSwgY29tcG9uZW50UHJvcFBhdGhdLFxuICAgICAgICBjb21wb25lbnRCbG9jazogW2NvbXBvbmVudEJsb2NrTm9kZSwgY29tcG9uZW50QmxvY2tQYXRoXVxuICAgICAgfSA9IGFuY2VzdG9yQ29tcG9uZW50QmxvY2s7XG4gICAgICBjb25zdCBpc0xhc3RQcm9wID0gY29tcG9uZW50UHJvcFBhdGhbY29tcG9uZW50UHJvcFBhdGgubGVuZ3RoIC0gMV0gPT09IGNvbXBvbmVudEJsb2NrTm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgaWYgKGNvbXBvbmVudFByb3BOb2RlLnR5cGUgPT09ICdjb21wb25lbnQtYmxvY2stcHJvcCcpIHtcbiAgICAgICAgY29uc3QgW1twYXJhZ3JhcGhOb2RlLCBwYXJhZ3JhcGhQYXRoXV0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgbWF0Y2g6IG5vZGUgPT4gbm9kZS50eXBlID09PSAncGFyYWdyYXBoJ1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaXNMYXN0UGFyYWdyYXBoID0gcGFyYWdyYXBoUGF0aFtwYXJhZ3JhcGhQYXRoLmxlbmd0aCAtIDFdID09PSBjb21wb25lbnRQcm9wTm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoTm9kZS5zdHJpbmcocGFyYWdyYXBoTm9kZSkgPT09ICcnICYmIGlzTGFzdFBhcmFncmFwaCkge1xuICAgICAgICAgIGlmIChpc0xhc3RQcm9wKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IHBhcmFncmFwaFBhdGgsXG4gICAgICAgICAgICAgIHRvOiBQYXRoLm5leHQoYW5jZXN0b3JDb21wb25lbnRCbG9jay5jb21wb25lbnRCbG9ja1sxXSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGRpc3RhbmNlOiAxLFxuICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IHBhcmFncmFwaFBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb21wb25lbnRQcm9wTm9kZS50eXBlID09PSAnY29tcG9uZW50LWlubGluZS1wcm9wJykge1xuICAgICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbXBvbmVudEJsb2NrID0gYmxvY2tDb21wb25lbnRzW2NvbXBvbmVudEJsb2NrTm9kZS5jb21wb25lbnRdO1xuICAgICAgICAgIGlmIChjb21wb25lbnRQcm9wTm9kZS5wcm9wUGF0aCAhPT0gdW5kZWZpbmVkICYmIGNvbXBvbmVudEJsb2NrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3RTY2hlbWEgPSB7XG4gICAgICAgICAgICAgIGtpbmQ6ICdvYmplY3QnLFxuICAgICAgICAgICAgICBmaWVsZHM6IGNvbXBvbmVudEJsb2NrLnNjaGVtYVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGFuY2VzdG9yRmllbGRzID0gZ2V0QW5jZXN0b3JTY2hlbWFzKHJvb3RTY2hlbWEsIGNvbXBvbmVudFByb3BOb2RlLnByb3BQYXRoLCBjb21wb25lbnRCbG9ja05vZGUucHJvcHMpO1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gWy4uLmFuY2VzdG9yRmllbGRzXS5yZXZlcnNlKCkuZmluZEluZGV4KGl0ZW0gPT4gaXRlbS5raW5kID09PSAnYXJyYXknKTtcbiAgICAgICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFycmF5RmllbGRJZHggPSBhbmNlc3RvckZpZWxkcy5sZW5ndGggLSAxIC0gaWR4O1xuICAgICAgICAgICAgICBjb25zdCBhcnJheUZpZWxkID0gYW5jZXN0b3JGaWVsZHNbYXJyYXlGaWVsZElkeF07XG4gICAgICAgICAgICAgIGFzc2VydChhcnJheUZpZWxkLmtpbmQgPT09ICdhcnJheScpO1xuICAgICAgICAgICAgICBjb25zdCB2YWwgPSBnZXRWYWx1ZUF0UHJvcFBhdGgoY29tcG9uZW50QmxvY2tOb2RlLnByb3BzLCBjb21wb25lbnRQcm9wTm9kZS5wcm9wUGF0aC5zbGljZSgwLCBhcnJheUZpZWxkSWR4KSk7XG4gICAgICAgICAgICAgIGlmIChkb2VzU2NoZW1hT25seUV2ZXJDb250YWluQVNpbmdsZUNoaWxkRmllbGQoYXJyYXlGaWVsZC5lbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIGlmIChOb2RlLnN0cmluZyhjb21wb25lbnRQcm9wTm9kZSkgPT09ICcnICYmIHZhbC5sZW5ndGggLSAxID09PSBjb21wb25lbnRQcm9wTm9kZS5wcm9wUGF0aFthcnJheUZpZWxkSWR4XSkge1xuICAgICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICAgICAgYXQ6IGNvbXBvbmVudFByb3BQYXRoXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc0xhc3RQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICBhdDogUGF0aC5uZXh0KGNvbXBvbmVudEJsb2NrUGF0aClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgUGF0aC5uZXh0KGNvbXBvbmVudEJsb2NrUGF0aCkpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiAxLFxuICAgICAgICAgICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0QnJlYWsoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGFsd2F5czogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHNwbGl0Tm9kZVBhdGggPSBQYXRoLm5leHQoY29tcG9uZW50UHJvcFBhdGgpO1xuICAgICAgICAgIGlmIChpc0xhc3RQcm9wKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IHNwbGl0Tm9kZVBhdGgsXG4gICAgICAgICAgICAgIHRvOiBQYXRoLm5leHQoY29tcG9uZW50QmxvY2tQYXRoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vdmVDaGlsZHJlbihlZGl0b3IsIHNwbGl0Tm9kZVBhdGgsIFsuLi5QYXRoLm5leHQoc3BsaXROb2RlUGF0aCksIDBdKTtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiBzcGxpdE5vZGVQYXRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGluc2VydEJyZWFrKCk7XG4gIH07XG4gIGVkaXRvci5ub3JtYWxpemVOb2RlID0gZW50cnkgPT4ge1xuICAgIGNvbnN0IFtub2RlLCBwYXRoXSA9IGVudHJ5O1xuICAgIGlmIChub2RlLnR5cGUgPT09ICdjb21wb25lbnQtaW5saW5lLXByb3AnICYmICFub2RlLnByb3BQYXRoICYmIChub2RlLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCAhVGV4dC5pc1RleHQobm9kZS5jaGlsZHJlblswXSkgfHwgbm9kZS5jaGlsZHJlblswXS50ZXh0ICE9PSAnJykpIHtcbiAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBwYXRoXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ2NvbXBvbmVudC1ibG9jaycpIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudEJsb2NrID0gYmxvY2tDb21wb25lbnRzW25vZGUuY29tcG9uZW50XTtcbiAgICAgIGlmIChjb21wb25lbnRCbG9jaykge1xuICAgICAgICBjb25zdCByb290U2NoZW1hID0ge1xuICAgICAgICAgIGtpbmQ6ICdvYmplY3QnLFxuICAgICAgICAgIGZpZWxkczogY29tcG9uZW50QmxvY2suc2NoZW1hXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9wcyA9IGFkZE1pc3NpbmdGaWVsZHMobm9kZS5wcm9wcywgcm9vdFNjaGVtYSk7XG4gICAgICAgIGlmICh1cGRhdGVkUHJvcHMgIT09IG5vZGUucHJvcHMpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgcHJvcHM6IHVwZGF0ZWRQcm9wc1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW3Byb3BQYXRoLCBhcnJheUZpZWxkXSBvZiBmaW5kQXJyYXlGaWVsZHNXaXRoU2luZ2xlQ2hpbGRGaWVsZChyb290U2NoZW1hLCBub2RlLnByb3BzKSkge1xuICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBub2RlLmNoaWxkcmVuWzBdLnR5cGUgPT09ICdjb21wb25lbnQtaW5saW5lLXByb3AnICYmIG5vZGUuY2hpbGRyZW5bMF0ucHJvcFBhdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5vZGVzV2l0aGluID0gW107XG4gICAgICAgICAgZm9yIChjb25zdCBbaWR4LCBjaGlsZE5vZGVdIG9mIG5vZGUuY2hpbGRyZW4uZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAoKGNoaWxkTm9kZS50eXBlID09PSAnY29tcG9uZW50LWJsb2NrLXByb3AnIHx8IGNoaWxkTm9kZS50eXBlID09PSAnY29tcG9uZW50LWlubGluZS1wcm9wJykgJiYgY2hpbGROb2RlLnByb3BQYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3ViUGF0aCA9IGNoaWxkTm9kZS5wcm9wUGF0aC5jb25jYXQoKTtcbiAgICAgICAgICAgICAgd2hpbGUgKHN1YlBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdWJQYXRoLnBvcCgpID09PSAnbnVtYmVyJykgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGFyZUFycmF5c0VxdWFsKHByb3BQYXRoLCBzdWJQYXRoKSkge1xuICAgICAgICAgICAgICAgIG5vZGVzV2l0aGluLnB1c2goW2lkeCwgY2hpbGROb2RlXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYXJyVmFsID0gZ2V0VmFsdWVBdFByb3BQYXRoKG5vZGUucHJvcHMsIHByb3BQYXRoKTtcbiAgICAgICAgICBjb25zdCBwcmV2S2V5cyA9IGdldEtleXNGb3JBcnJheVZhbHVlKGFyclZhbCk7XG4gICAgICAgICAgY29uc3QgcHJldktleXNTZXQgPSBuZXcgU2V0KHByZXZLZXlzKTtcbiAgICAgICAgICBjb25zdCBhbHJlYWR5VXNlZEluZGljaWVzID0gbmV3IFNldCgpO1xuICAgICAgICAgIGNvbnN0IG5ld1ZhbCA9IFtdO1xuICAgICAgICAgIGNvbnN0IG5ld0tleXMgPSBbXTtcbiAgICAgICAgICBjb25zdCBnZXROZXdLZXkgPSAoKSA9PiB7XG4gICAgICAgICAgICBsZXQga2V5ID0gZ2V0TmV3QXJyYXlFbGVtZW50S2V5KCk7XG4gICAgICAgICAgICB3aGlsZSAocHJldktleXNTZXQuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAga2V5ID0gZ2V0TmV3QXJyYXlFbGVtZW50S2V5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgIH07XG4gICAgICAgICAgZm9yIChjb25zdCBbLCBub2RlXSBvZiBub2Rlc1dpdGhpbikge1xuICAgICAgICAgICAgY29uc3QgaWR4RnJvbVZhbHVlID0gbm9kZS5wcm9wUGF0aFtwcm9wUGF0aC5sZW5ndGhdO1xuICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiBpZHhGcm9tVmFsdWUgPT09ICdudW1iZXInKTtcbiAgICAgICAgICAgIGlmIChhcnJWYWwubGVuZ3RoIDw9IGlkeEZyb21WYWx1ZSB8fCBhbHJlYWR5VXNlZEluZGljaWVzLmhhcyhpZHhGcm9tVmFsdWUpICYmIGlzRW1wdHlDaGlsZEZpZWxkTm9kZShub2RlKSkge1xuICAgICAgICAgICAgICBuZXdWYWwucHVzaChnZXRJbml0aWFsUHJvcHNWYWx1ZShhcnJheUZpZWxkLmVsZW1lbnQpKTtcbiAgICAgICAgICAgICAgbmV3S2V5cy5wdXNoKGdldE5ld0tleSgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFscmVhZHlVc2VkSW5kaWNpZXMuYWRkKGlkeEZyb21WYWx1ZSk7XG4gICAgICAgICAgICAgIG5ld1ZhbC5wdXNoKGFyclZhbFtpZHhGcm9tVmFsdWVdKTtcbiAgICAgICAgICAgICAgbmV3S2V5cy5wdXNoKGFscmVhZHlVc2VkSW5kaWNpZXMuaGFzKGlkeEZyb21WYWx1ZSkgPyBnZXROZXdLZXkoKSA6IHByZXZLZXlzW2lkeEZyb21WYWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRLZXlzRm9yQXJyYXlWYWx1ZShuZXdWYWwsIG5ld0tleXMpO1xuICAgICAgICAgIGlmICghYXJlQXJyYXlzRXF1YWwoYXJyVmFsLCBuZXdWYWwpKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFByb3BzID0gcmVwbGFjZVZhbHVlQXRQcm9wUGF0aChyb290U2NoZW1hLCBub2RlLnByb3BzLCBuZXdWYWwsIHByb3BQYXRoKTtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHByb3BzOiB0cmFuc2Zvcm1lZFByb3BzXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2lkeCwgW2lkeEluQ2hpbGRyZW5PZkJsb2NrLCBub2RlV2l0aGluXV0gb2Ygbm9kZXNXaXRoaW4uZW50cmllcygpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5ld1Byb3BQYXRoID0gWy4uLm5vZGVXaXRoaW4ucHJvcFBhdGhdO1xuICAgICAgICAgICAgICBuZXdQcm9wUGF0aFtwcm9wUGF0aC5sZW5ndGhdID0gaWR4O1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIHByb3BQYXRoOiBuZXdQcm9wUGF0aFxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgYXQ6IFsuLi5wYXRoLCBpZHhJbkNoaWxkcmVuT2ZCbG9ja11cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pc3NpbmdLZXlzID0gbmV3IE1hcChmaW5kQ2hpbGRQcm9wUGF0aHMobm9kZS5wcm9wcywgY29tcG9uZW50QmxvY2suc2NoZW1hKS5tYXAoeCA9PiBbSlNPTi5zdHJpbmdpZnkoeC5wYXRoKSwgeC5vcHRpb25zLmtpbmRdKSk7XG4gICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICBhc3NlcnQobm9kZS50eXBlID09PSAnY29tcG9uZW50LWJsb2NrLXByb3AnIHx8IG5vZGUudHlwZSA9PT0gJ2NvbXBvbmVudC1pbmxpbmUtcHJvcCcpO1xuICAgICAgICAgIG1pc3NpbmdLZXlzLmRlbGV0ZShKU09OLnN0cmluZ2lmeShub2RlLnByb3BQYXRoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobWlzc2luZ0tleXMuc2l6ZSkge1xuICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBbLi4ubWlzc2luZ0tleXNdLm1hcCgoW3Byb3AsIGtpbmRdKSA9PiAoe1xuICAgICAgICAgICAgdHlwZTogYGNvbXBvbmVudC0ke2tpbmR9LXByb3BgLFxuICAgICAgICAgICAgcHJvcFBhdGg6IHByb3AgPyBKU09OLnBhcnNlKHByb3ApIDogcHJvcCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9KSksIHtcbiAgICAgICAgICAgIGF0OiBbLi4ucGF0aCwgbm9kZS5jaGlsZHJlbi5sZW5ndGhdXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvdW5kUHJvcHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkSW5saW5lUHJvcFBhdGhzID0ge307XG4gICAgICAgIGZpbmRDaGlsZFByb3BQYXRocyhub2RlLnByb3BzLCBibG9ja0NvbXBvbmVudHNbbm9kZS5jb21wb25lbnRdLnNjaGVtYSkuZm9yRWFjaCgoeCwgaW5kZXgpID0+IHtcbiAgICAgICAgICBzdHJpbmdpZmllZElubGluZVByb3BQYXRoc1tKU09OLnN0cmluZ2lmeSh4LnBhdGgpXSA9IHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHgub3B0aW9ucyxcbiAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoY29uc3QgW2luZGV4LCBjaGlsZE5vZGVdIG9mIG5vZGUuY2hpbGRyZW4uZW50cmllcygpKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIC8vIGNoaWxkcmVuIHRoYXQgYXJlIG5vdCB0aGVzZSB3aWxsIGJlIGhhbmRsZWQgYnlcbiAgICAgICAgICAvLyB0aGUgZ2VuZXJpYyBhbGxvd2VkQ2hpbGRyZW4gbm9ybWFsaXphdGlvblxuICAgICAgICAgIGNoaWxkTm9kZS50eXBlICE9PSAnY29tcG9uZW50LWlubGluZS1wcm9wJyAmJiBjaGlsZE5vZGUudHlwZSAhPT0gJ2NvbXBvbmVudC1ibG9jay1wcm9wJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IFsuLi5wYXRoLCBpbmRleF07XG4gICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRQcm9wUGF0aCA9IEpTT04uc3RyaW5naWZ5KGNoaWxkTm9kZS5wcm9wUGF0aCk7XG4gICAgICAgICAgaWYgKHN0cmluZ2lmaWVkSW5saW5lUHJvcFBhdGhzW3N0cmluZ2lmaWVkUHJvcFBhdGhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiBjaGlsZFBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZm91bmRQcm9wcy5oYXMoc3RyaW5naWZpZWRQcm9wUGF0aCkpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiBjaGlsZFBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3VuZFByb3BzLmFkZChzdHJpbmdpZmllZFByb3BQYXRoKTtcbiAgICAgICAgICBjb25zdCBwcm9wSW5mbyA9IHN0cmluZ2lmaWVkSW5saW5lUHJvcFBhdGhzW3N0cmluZ2lmaWVkUHJvcFBhdGhdO1xuICAgICAgICAgIGNvbnN0IGV4cGVjdGVkSW5kZXggPSBwcm9wSW5mby5pbmRleDtcbiAgICAgICAgICBpZiAoaW5kZXggIT09IGV4cGVjdGVkSW5kZXgpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogY2hpbGRQYXRoLFxuICAgICAgICAgICAgICB0bzogWy4uLnBhdGgsIGV4cGVjdGVkSW5kZXhdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZXhwZWN0ZWRDaGlsZE5vZGVUeXBlID0gYGNvbXBvbmVudC0ke3Byb3BJbmZvLm9wdGlvbnMua2luZH0tcHJvcGA7XG4gICAgICAgICAgaWYgKGNoaWxkTm9kZS50eXBlICE9PSBleHBlY3RlZENoaWxkTm9kZVR5cGUpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHR5cGU6IGV4cGVjdGVkQ2hpbGROb2RlVHlwZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBhdDogY2hpbGRQYXRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZG9jdW1lbnRGZWF0dXJlcyA9IG1lbW9pemVkR2V0RG9jdW1lbnRGZWF0dXJlc0ZvckNoaWxkRmllbGQocHJvcEluZm8ub3B0aW9ucyk7XG4gICAgICAgICAgaWYgKG5vcm1hbGl6ZU5vZGVXaXRoaW5Db21wb25lbnRQcm9wKFtjaGlsZE5vZGUsIGNoaWxkUGF0aF0sIGVkaXRvciwgZG9jdW1lbnRGZWF0dXJlcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbm9ybWFsaXplTm9kZShlbnRyeSk7XG4gIH07XG4gIHJldHVybiBlZGl0b3I7XG59XG5cbi8vIHRoZSBvbmx5IHRoaW5nIHRoYXQgdGhpcyB3aWxsIGZpeCBpcyBhIG5ldyBmaWVsZCBiZWluZyBhZGRlZCB0byBhbiBvYmplY3QgZmllbGQsIG5vdGhpbmcgZWxzZS5cbmZ1bmN0aW9uIGFkZE1pc3NpbmdGaWVsZHModmFsdWUsIHNjaGVtYSkge1xuICBpZiAoc2NoZW1hLmtpbmQgPT09ICdjaGlsZCcgfHwgc2NoZW1hLmtpbmQgPT09ICdmb3JtJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoc2NoZW1hLmtpbmQgPT09ICdjb25kaXRpb25hbCcpIHtcbiAgICBjb25zdCBjb25kaXRpb25hbFZhbHVlID0gdmFsdWU7XG4gICAgY29uc3QgdXBkYXRlZElubmVyVmFsdWUgPSBhZGRNaXNzaW5nRmllbGRzKGNvbmRpdGlvbmFsVmFsdWUudmFsdWUsIHNjaGVtYS52YWx1ZXNbY29uZGl0aW9uYWxWYWx1ZS5kaXNjcmltaW5hbnQudG9TdHJpbmcoKV0pO1xuICAgIGlmICh1cGRhdGVkSW5uZXJWYWx1ZSA9PT0gY29uZGl0aW9uYWxWYWx1ZS52YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZGlzY3JpbWluYW50OiBjb25kaXRpb25hbFZhbHVlLmRpc2NyaW1pbmFudCxcbiAgICAgIHZhbHVlOiB1cGRhdGVkSW5uZXJWYWx1ZVxuICAgIH07XG4gIH1cbiAgaWYgKHNjaGVtYS5raW5kID09PSAnYXJyYXknKSB7XG4gICAgY29uc3QgYXJyVmFsdWUgPSB2YWx1ZTtcbiAgICBjb25zdCBuZXdBcnJWYWx1ZSA9IGFyclZhbHVlLm1hcCh4ID0+IGFkZE1pc3NpbmdGaWVsZHMoeCwgc2NoZW1hLmVsZW1lbnQpKTtcbiAgICBpZiAoYXJlQXJyYXlzRXF1YWwoYXJyVmFsdWUsIG5ld0FyclZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3QXJyVmFsdWU7XG4gIH1cbiAgaWYgKHNjaGVtYS5raW5kID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IG9iamVjdFZhbHVlID0gdmFsdWU7XG4gICAgbGV0IGhhc0NoYW5nZWQgPSBmYWxzZTtcbiAgICBjb25zdCBuZXdPYmplY3RWYWx1ZSA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgaW5uZXJTY2hlbWFdIG9mIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5maWVsZHMpKSB7XG4gICAgICBjb25zdCBpbm5lclZhbHVlID0gb2JqZWN0VmFsdWVba2V5XTtcbiAgICAgIGlmIChpbm5lclZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIG5ld09iamVjdFZhbHVlW2tleV0gPSBnZXRJbml0aWFsUHJvcHNWYWx1ZShpbm5lclNjaGVtYSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3SW5uZXJWYWx1ZSA9IGFkZE1pc3NpbmdGaWVsZHMoaW5uZXJWYWx1ZSwgaW5uZXJTY2hlbWEpO1xuICAgICAgaWYgKG5ld0lubmVyVmFsdWUgIT09IGlubmVyVmFsdWUpIHtcbiAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBuZXdPYmplY3RWYWx1ZVtrZXldID0gbmV3SW5uZXJWYWx1ZTtcbiAgICB9XG4gICAgaWYgKGhhc0NoYW5nZWQpIHtcbiAgICAgIHJldHVybiBuZXdPYmplY3RWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGFzc2VydE5ldmVyKHNjaGVtYSk7XG59XG5cbmNvbnN0IHBhcmFncmFwaEVsZW1lbnQgPSAoKSA9PiAoe1xuICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgY2hpbGRyZW46IFt7XG4gICAgdGV4dDogJydcbiAgfV1cbn0pO1xuZnVuY3Rpb24gd2l0aFBhcmFncmFwaHMoZWRpdG9yKSB7XG4gIGNvbnN0IHtcbiAgICBub3JtYWxpemVOb2RlXG4gIH0gPSBlZGl0b3I7XG4gIGVkaXRvci5ub3JtYWxpemVOb2RlID0gZW50cnkgPT4ge1xuICAgIGNvbnN0IFtub2RlLCBwYXRoXSA9IGVudHJ5O1xuICAgIGlmIChFZGl0b3IuaXNFZGl0b3Iobm9kZSkpIHtcbiAgICAgIGxldCBsYXN0Tm9kZSA9IG5vZGUuY2hpbGRyZW5bbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgIGlmICgobGFzdE5vZGUgPT09IG51bGwgfHwgbGFzdE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3ROb2RlLnR5cGUpICE9PSAncGFyYWdyYXBoJykge1xuICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgcGFyYWdyYXBoRWxlbWVudCgpLCB7XG4gICAgICAgICAgYXQ6IFsuLi5wYXRoLCBub2RlLmNoaWxkcmVuLmxlbmd0aF1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgbm9ybWFsaXplTm9kZShlbnRyeSk7XG4gIH07XG4gIHJldHVybiBlZGl0b3I7XG59XG5cbmZ1bmN0aW9uIHdpdGhMYXlvdXRzKGVkaXRvcikge1xuICBjb25zdCB7XG4gICAgbm9ybWFsaXplTm9kZSxcbiAgICBkZWxldGVCYWNrd2FyZFxuICB9ID0gZWRpdG9yO1xuICBlZGl0b3IuZGVsZXRlQmFja3dhcmQgPSB1bml0ID0+IHtcbiAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSAmJlxuICAgIC8vIHRoaXMgaXMganVzdCBhbiBsaXR0bGUgb3B0aW1pc2F0aW9uXG4gICAgLy8gd2UncmUgb25seSBkb2luZyB0aGluZ3MgaWYgd2UncmUgYXQgdGhlIHN0YXJ0IG9mIGEgbGF5b3V0IGFyZWFcbiAgICAvLyBhbmQgdGhlIHN0YXJ0IG9mIGFueXRoaW5nIHdpbGwgYWx3YXlzIGJlIG9mZnNldCAwXG4gICAgLy8gc28gd2UnbGwgYmFpbG91dCBpZiB3ZSdyZSBub3QgYXQgb2Zmc2V0IDBcbiAgICBlZGl0b3Iuc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgPT09IDApIHtcbiAgICAgIGNvbnN0IFthYm92ZU5vZGUsIGFib3ZlUGF0aF0gPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBub2RlID0+IG5vZGUudHlwZSA9PT0gJ2xheW91dC1hcmVhJ1xuICAgICAgfSkgfHwgW2VkaXRvciwgW11dO1xuICAgICAgaWYgKGFib3ZlTm9kZS50eXBlID09PSAnbGF5b3V0LWFyZWEnICYmIFBvaW50LmVxdWFscyhFZGl0b3Iuc3RhcnQoZWRpdG9yLCBhYm92ZVBhdGgpLCBlZGl0b3Iuc2VsZWN0aW9uLmFuY2hvcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBkZWxldGVCYWNrd2FyZCh1bml0KTtcbiAgfTtcbiAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUgPSBlbnRyeSA9PiB7XG4gICAgY29uc3QgW25vZGUsIHBhdGhdID0gZW50cnk7XG4gICAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgbm9kZS50eXBlID09PSAnbGF5b3V0Jykge1xuICAgICAgaWYgKG5vZGUubGF5b3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy51bndyYXBOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoIDwgbm9kZS5sYXlvdXQubGVuZ3RoKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBBcnJheS5mcm9tKHtcbiAgICAgICAgICBsZW5ndGg6IG5vZGUubGF5b3V0Lmxlbmd0aCAtIG5vZGUuY2hpbGRyZW4ubGVuZ3RoXG4gICAgICAgIH0pLm1hcCgoKSA9PiAoe1xuICAgICAgICAgIHR5cGU6ICdsYXlvdXQtYXJlYScsXG4gICAgICAgICAgY2hpbGRyZW46IFtwYXJhZ3JhcGhFbGVtZW50KCldXG4gICAgICAgIH0pKSwge1xuICAgICAgICAgIGF0OiBbLi4ucGF0aCwgbm9kZS5jaGlsZHJlbi5sZW5ndGhdXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPiBub2RlLmxheW91dC5sZW5ndGgpIHtcbiAgICAgICAgQXJyYXkuZnJvbSh7XG4gICAgICAgICAgbGVuZ3RoOiBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIG5vZGUubGF5b3V0Lmxlbmd0aFxuICAgICAgICB9KS5tYXAoKF8sIGkpID0+IGkpLnJldmVyc2UoKS5mb3JFYWNoKGkgPT4ge1xuICAgICAgICAgIGNvbnN0IGxheW91dEFyZWFUb1JlbW92ZVBhdGggPSBbLi4ucGF0aCwgaSArIG5vZGUubGF5b3V0Lmxlbmd0aF07XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2kgKyBub2RlLmxheW91dC5sZW5ndGhdO1xuICAgICAgICAgIG1vdmVDaGlsZHJlbihlZGl0b3IsIGxheW91dEFyZWFUb1JlbW92ZVBhdGgsIFsuLi5wYXRoLCBub2RlLmxheW91dC5sZW5ndGggLSAxLCBub2RlLmNoaWxkcmVuW25vZGUubGF5b3V0Lmxlbmd0aCAtIDFdLmNoaWxkcmVuLmxlbmd0aF0sIG5vZGUgPT4gbm9kZS50eXBlICE9PSAncGFyYWdyYXBoJyB8fCBOb2RlLnN0cmluZyhjaGlsZCkgIT09ICcnKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IGxheW91dEFyZWFUb1JlbW92ZVBhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgbm9ybWFsaXplTm9kZShlbnRyeSk7XG4gIH07XG4gIHJldHVybiBlZGl0b3I7XG59XG5cbmNvbnN0IG1hcmtkb3duTGlua1BhdHRlcm4gPSAvKF58XFxzKVxcWyguKz8pXFxdXFwoKFxcUyspXFwpJC87XG5mdW5jdGlvbiB3aXRoTGluayhlZGl0b3JEb2N1bWVudEZlYXR1cmVzLCBjb21wb25lbnRCbG9ja3MsIGVkaXRvcikge1xuICBjb25zdCB7XG4gICAgaW5zZXJ0VGV4dCxcbiAgICBpc0lubGluZSxcbiAgICBub3JtYWxpemVOb2RlXG4gIH0gPSBlZGl0b3I7XG4gIGVkaXRvci5pc0lubGluZSA9IGVsZW1lbnQgPT4ge1xuICAgIHJldHVybiBlbGVtZW50LnR5cGUgPT09ICdsaW5rJyA/IHRydWUgOiBpc0lubGluZShlbGVtZW50KTtcbiAgfTtcbiAgaWYgKGVkaXRvckRvY3VtZW50RmVhdHVyZXMubGlua3MpIHtcbiAgICBlZGl0b3IuaW5zZXJ0VGV4dCA9IHRleHQgPT4ge1xuICAgICAgaW5zZXJ0VGV4dCh0ZXh0KTtcbiAgICAgIGlmICh0ZXh0ICE9PSAnKScgfHwgIWVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnRPZkJsb2NrID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICBtYXRjaDogaXNCbG9ja1xuICAgICAgfSlbMV0pO1xuICAgICAgY29uc3Qgc3RhcnRPZkJsb2NrVG9FbmRPZlNob3J0Y3V0U3RyaW5nID0gRWRpdG9yLnN0cmluZyhlZGl0b3IsIHtcbiAgICAgICAgYW5jaG9yOiBlZGl0b3Iuc2VsZWN0aW9uLmFuY2hvcixcbiAgICAgICAgZm9jdXM6IHN0YXJ0T2ZCbG9ja1xuICAgICAgfSk7XG4gICAgICBjb25zdCBtYXRjaCA9IG1hcmtkb3duTGlua1BhdHRlcm4uZXhlYyhzdGFydE9mQmxvY2tUb0VuZE9mU2hvcnRjdXRTdHJpbmcpO1xuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBhbmNlc3RvckNvbXBvbmVudENoaWxkRmllbGREb2N1bWVudEZlYXR1cmVzID0gZ2V0QW5jZXN0b3JDb21wb25lbnRDaGlsZEZpZWxkRG9jdW1lbnRGZWF0dXJlcyhlZGl0b3IsIGVkaXRvckRvY3VtZW50RmVhdHVyZXMsIGNvbXBvbmVudEJsb2Nrcyk7XG4gICAgICBpZiAoKGFuY2VzdG9yQ29tcG9uZW50Q2hpbGRGaWVsZERvY3VtZW50RmVhdHVyZXMgPT09IG51bGwgfHwgYW5jZXN0b3JDb21wb25lbnRDaGlsZEZpZWxkRG9jdW1lbnRGZWF0dXJlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYW5jZXN0b3JDb21wb25lbnRDaGlsZEZpZWxkRG9jdW1lbnRGZWF0dXJlcy5kb2N1bWVudEZlYXR1cmVzLmxpbmtzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgWywgbWF5YmVXaGl0ZXNwYWNlLCBsaW5rVGV4dCwgaHJlZl0gPSBtYXRjaDtcbiAgICAgIC8vIGJ5IGRvaW5nIHRoaXMsIHRoZSBpbnNlcnRUZXh0KCcpJykgYWJvdmUgd2lsbCBoYXBwZW4gaW4gYSBkaWZmZXJlbnQgdW5kbyB0aGFuIHRoZSBsaW5rIHJlcGxhY2VtZW50XG4gICAgICAvLyBzbyB0aGF0IG1lYW5zIHRoYXQgd2hlbiBzb21lb25lIGRvZXMgYW4gdW5kbyBhZnRlciB0aGlzXG4gICAgICAvLyBpdCB3aWxsIHVuZG8gdG8gdGhlIHN0YXRlIG9mIFwiW2NvbnRlbnRdKGxpbmspXCIgcmF0aGVyIHRoYW4gXCJbY29udGVudF0obGlua1wiIChub3RlIHRoZSBtaXNzaW5nIGNsb3NpbmcgYnJhY2tldClcbiAgICAgIGVkaXRvci5oaXN0b3J5LnVuZG9zLnB1c2goe1xuICAgICAgICBvcGVyYXRpb25zOiBbXSxcbiAgICAgICAgc2VsZWN0aW9uQmVmb3JlOiBlZGl0b3Iuc2VsZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHN0YXJ0T2ZTaG9ydGN1dCA9IG1hdGNoLmluZGV4ID09PSAwID8gc3RhcnRPZkJsb2NrIDogRWRpdG9yQWZ0ZXJCdXRJZ25vcmluZ2luZ1BvaW50c1dpdGhOb0NvbnRlbnQoZWRpdG9yLCBzdGFydE9mQmxvY2ssIHtcbiAgICAgICAgZGlzdGFuY2U6IG1hdGNoLmluZGV4XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHN0YXJ0T2ZMaW5rVGV4dCA9IEVkaXRvckFmdGVyQnV0SWdub3JpbmdpbmdQb2ludHNXaXRoTm9Db250ZW50KGVkaXRvciwgc3RhcnRPZlNob3J0Y3V0LCB7XG4gICAgICAgIGRpc3RhbmNlOiBtYXliZVdoaXRlc3BhY2UgPT09ICcnID8gMSA6IDJcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZW5kT2ZMaW5rVGV4dCA9IEVkaXRvckFmdGVyQnV0SWdub3JpbmdpbmdQb2ludHNXaXRoTm9Db250ZW50KGVkaXRvciwgc3RhcnRPZkxpbmtUZXh0LCB7XG4gICAgICAgIGRpc3RhbmNlOiBsaW5rVGV4dC5sZW5ndGhcbiAgICAgIH0pO1xuICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgIGF0OiB7XG4gICAgICAgICAgYW5jaG9yOiBlbmRPZkxpbmtUZXh0LFxuICAgICAgICAgIGZvY3VzOiBlZGl0b3Iuc2VsZWN0aW9uLmFuY2hvclxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICBhdDoge1xuICAgICAgICAgIGFuY2hvcjogc3RhcnRPZlNob3J0Y3V0LFxuICAgICAgICAgIGZvY3VzOiBzdGFydE9mTGlua1RleHRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBUcmFuc2Zvcm1zLndyYXBOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgICBocmVmLFxuICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgIH0sIHtcbiAgICAgICAgYXQ6IHtcbiAgICAgICAgICBhbmNob3I6IGVkaXRvci5zZWxlY3Rpb24uYW5jaG9yLFxuICAgICAgICAgIGZvY3VzOiBzdGFydE9mU2hvcnRjdXRcbiAgICAgICAgfSxcbiAgICAgICAgc3BsaXQ6IHRydWVcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbmV4dE5vZGUgPSBFZGl0b3IubmV4dChlZGl0b3IpO1xuICAgICAgaWYgKG5leHROb2RlKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgbmV4dE5vZGVbMV0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUgPSAoW25vZGUsIHBhdGhdKSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ2xpbmsnKSB7XG4gICAgICBpZiAoTm9kZS5zdHJpbmcobm9kZSkgPT09ICcnKSB7XG4gICAgICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW2lkeCwgY2hpbGRdIG9mIG5vZGUuY2hpbGRyZW4uZW50cmllcygpKSB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnbGluaycpIHtcbiAgICAgICAgICAvLyBsaW5rcyBjYW5ub3QgY29udGFpbiBsaW5rc1xuICAgICAgICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogWy4uLnBhdGgsIGlkeF1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzSW5saW5lQ29udGFpbmVyKG5vZGUpKSB7XG4gICAgICBsZXQgbGFzdE1lcmdhYmxlTGluayA9IG51bGw7XG4gICAgICBmb3IgKGNvbnN0IFtpZHgsIGNoaWxkXSBvZiBub2RlLmNoaWxkcmVuLmVudHJpZXMoKSkge1xuICAgICAgICB2YXIgX2xhc3RNZXJnYWJsZUxpbms7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnbGluaycgJiYgY2hpbGQuaHJlZiA9PT0gKChfbGFzdE1lcmdhYmxlTGluayA9IGxhc3RNZXJnYWJsZUxpbmspID09PSBudWxsIHx8IF9sYXN0TWVyZ2FibGVMaW5rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbGFzdE1lcmdhYmxlTGluay5ub2RlLmhyZWYpKSB7XG4gICAgICAgICAgY29uc3QgZmlyc3RMaW5rUGF0aCA9IFsuLi5wYXRoLCBsYXN0TWVyZ2FibGVMaW5rLmluZGV4XTtcbiAgICAgICAgICBjb25zdCBzZWNvbmRMaW5rUGF0aCA9IFsuLi5wYXRoLCBpZHhdO1xuICAgICAgICAgIGNvbnN0IHRvID0gWy4uLmZpcnN0TGlua1BhdGgsIGxhc3RNZXJnYWJsZUxpbmsubm9kZS5jaGlsZHJlbi5sZW5ndGhdO1xuICAgICAgICAgIC8vIG5vdGUgdGhpcyBpcyBnb2luZyBpbiByZXZlcnNlLCBqcyBkb2Vzbid0IGhhdmUgZG91YmxlLWVuZGVkIGl0ZXJhdG9ycyBzbyBpdCdzIGEgZm9yKDs7KVxuICAgICAgICAgIGZvciAobGV0IGkgPSBjaGlsZC5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gWy4uLnNlY29uZExpbmtQYXRoLCBpXTtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogY2hpbGRQYXRoLFxuICAgICAgICAgICAgICB0b1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogc2Vjb25kTGlua1BhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFUZXh0LmlzVGV4dChjaGlsZCkgfHwgY2hpbGQudGV4dCAhPT0gJycpIHtcbiAgICAgICAgICBsYXN0TWVyZ2FibGVMaW5rID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ2xpbmsnKSB7XG4gICAgICAgICAgbGFzdE1lcmdhYmxlTGluayA9IHtcbiAgICAgICAgICAgIGluZGV4OiBpZHgsXG4gICAgICAgICAgICBub2RlOiBjaGlsZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbm9ybWFsaXplTm9kZShbbm9kZSwgcGF0aF0pO1xuICB9O1xuICByZXR1cm4gZWRpdG9yO1xufVxuXG5jb25zdCBpc0xpc3RUeXBlID0gdHlwZSA9PiB0eXBlID09PSAnb3JkZXJlZC1saXN0JyB8fCB0eXBlID09PSAndW5vcmRlcmVkLWxpc3QnO1xuY29uc3QgaXNMaXN0Tm9kZSA9IG5vZGUgPT4gaXNMaXN0VHlwZShub2RlLnR5cGUpO1xuZnVuY3Rpb24gZ2V0QW5jZXN0b3JMaXN0KGVkaXRvcikge1xuICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgIGNvbnN0IGxpc3RJdGVtID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IG5vZGVUeXBlTWF0Y2hlcignbGlzdC1pdGVtJylcbiAgICB9KTtcbiAgICBjb25zdCBsaXN0ID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IGlzTGlzdE5vZGVcbiAgICB9KTtcbiAgICBpZiAobGlzdEl0ZW0gJiYgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNJbnNpZGU6IHRydWUsXG4gICAgICAgIGxpc3RJdGVtLFxuICAgICAgICBsaXN0XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGlzSW5zaWRlOiBmYWxzZVxuICB9O1xufVxuZnVuY3Rpb24gd2l0aExpc3QoZWRpdG9yKSB7XG4gIGNvbnN0IHtcbiAgICBpbnNlcnRCcmVhayxcbiAgICBub3JtYWxpemVOb2RlLFxuICAgIGRlbGV0ZUJhY2t3YXJkXG4gIH0gPSBlZGl0b3I7XG4gIGVkaXRvci5kZWxldGVCYWNrd2FyZCA9IHVuaXQgPT4ge1xuICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICBjb25zdCBhbmNlc3Rvckxpc3QgPSBnZXRBbmNlc3Rvckxpc3QoZWRpdG9yKTtcbiAgICAgIGlmIChhbmNlc3Rvckxpc3QuaXNJbnNpZGUgJiYgUmFuZ2UuaXNDb2xsYXBzZWQoZWRpdG9yLnNlbGVjdGlvbikgJiYgRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLmFuY2hvciwgYW5jZXN0b3JMaXN0Lmxpc3RbMV0pKSB7XG4gICAgICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgbWF0Y2g6IGlzTGlzdE5vZGUsXG4gICAgICAgICAgc3BsaXQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlQmFja3dhcmQodW5pdCk7XG4gIH07XG4gIGVkaXRvci5pbnNlcnRCcmVhayA9ICgpID0+IHtcbiAgICBjb25zdCBbbGlzdEl0ZW1dID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IG5vZGUgPT4gbm9kZS50eXBlID09PSAnbGlzdC1pdGVtJyxcbiAgICAgIG1vZGU6ICdsb3dlc3QnXG4gICAgfSk7XG4gICAgaWYgKGxpc3RJdGVtICYmIE5vZGUuc3RyaW5nKGxpc3RJdGVtWzBdKSA9PT0gJycpIHtcbiAgICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBpc0xpc3ROb2RlLFxuICAgICAgICBzcGxpdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGluc2VydEJyZWFrKCk7XG4gIH07XG4gIGVkaXRvci5ub3JtYWxpemVOb2RlID0gZW50cnkgPT4ge1xuICAgIGNvbnN0IFtub2RlLCBwYXRoXSA9IGVudHJ5O1xuICAgIGlmIChFbGVtZW50JDEuaXNFbGVtZW50KG5vZGUpIHx8IEVkaXRvci5pc0VkaXRvcihub2RlKSkge1xuICAgICAgY29uc3QgaXNFbGVtZW50QmVpbmdOb3JtYWxpemVkQUxpc3QgPSBpc0xpc3ROb2RlKG5vZGUpO1xuICAgICAgZm9yIChjb25zdCBbY2hpbGROb2RlLCBjaGlsZFBhdGhdIG9mIE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBwYXRoKSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGNoaWxkUGF0aFtjaGlsZFBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIC8vIG1lcmdlIHNpYmxpbmcgbGlzdHNcbiAgICAgICAgaWYgKGlzTGlzdE5vZGUoY2hpbGROb2RlKSkge1xuICAgICAgICAgIHZhciBfbm9kZSRjaGlsZHJlbjtcbiAgICAgICAgICBpZiAoKChfbm9kZSRjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW5bY2hpbGRQYXRoW2NoaWxkUGF0aC5sZW5ndGggLSAxXSArIDFdKSA9PT0gbnVsbCB8fCBfbm9kZSRjaGlsZHJlbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkY2hpbGRyZW4udHlwZSkgPT09IGNoaWxkTm9kZS50eXBlKSB7XG4gICAgICAgICAgICBjb25zdCBzaWJsaW5nTm9kZVBhdGggPSBQYXRoLm5leHQoY2hpbGRQYXRoKTtcbiAgICAgICAgICAgIG1vdmVDaGlsZHJlbihlZGl0b3IsIHNpYmxpbmdOb2RlUGF0aCwgWy4uLmNoaWxkUGF0aCwgY2hpbGROb2RlLmNoaWxkcmVuLmxlbmd0aF0pO1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IHNpYmxpbmdOb2RlUGF0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0VsZW1lbnRCZWluZ05vcm1hbGl6ZWRBTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNDaGlsZCA9IG5vZGUuY2hpbGRyZW5baW5kZXggLSAxXTtcbiAgICAgICAgICAgIGlmIChFbGVtZW50JDEuaXNFbGVtZW50KHByZXZpb3VzQ2hpbGQpKSB7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGF0OiBjaGlsZFBhdGgsXG4gICAgICAgICAgICAgICAgdG86IFsuLi5QYXRoLnByZXZpb3VzKGNoaWxkUGF0aCksIHByZXZpb3VzQ2hpbGQuY2hpbGRyZW4ubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGF0OiBjaGlsZFBhdGhcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdsaXN0LWl0ZW0nICYmIGNoaWxkTm9kZS50eXBlICE9PSAnbGlzdC1pdGVtLWNvbnRlbnQnICYmIGluZGV4ID09PSAwICYmIGlzQmxvY2soY2hpbGROb2RlKSkge1xuICAgICAgICAgIGlmIChwYXRoW3BhdGgubGVuZ3RoIC0gMV0gIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzQ2hpbGQgPSBOb2RlLmdldChlZGl0b3IsIFBhdGgucHJldmlvdXMocGF0aCkpO1xuICAgICAgICAgICAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQocHJldmlvdXNDaGlsZCkpIHtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgICAgICAgdG86IFsuLi5QYXRoLnByZXZpb3VzKHBhdGgpLCBwcmV2aW91c0NoaWxkLmNoaWxkcmVuLmxlbmd0aF1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgVHJhbnNmb3Jtcy51bndyYXBOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBjaGlsZFBhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2xpc3QtaXRlbScgJiYgY2hpbGROb2RlLnR5cGUgPT09ICdsaXN0LWl0ZW0tY29udGVudCcgJiYgaW5kZXggIT09IDApIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogY2hpbGRQYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5vcm1hbGl6ZU5vZGUoZW50cnkpO1xuICB9O1xuICByZXR1cm4gZWRpdG9yO1xufVxuXG5mdW5jdGlvbiBvcmRlcihhLCBiKSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IE1hdGgubWluKGEsIGIpLFxuICAgIGVuZDogTWF0aC5tYXgoYSwgYilcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFJlbGF0aXZlUm93UGF0aChoYXNIZWFkLCByb3dJbmRleCkge1xuICByZXR1cm4gaGFzSGVhZCA/IHJvd0luZGV4ID09PSAwID8gWzAsIDBdIDogWzEsIHJvd0luZGV4IC0gMV0gOiBbMCwgcm93SW5kZXhdO1xufVxuZnVuY3Rpb24gZ2V0U2VsZWN0ZWRUYWJsZUFyZWEoZWRpdG9yKSB7XG4gIHZhciBfRWRpdG9yJGFib3ZlLCBfZWRpdG9yJHNlbGVjdGlvbiwgX0VkaXRvciRhYm92ZTIsIF9lZGl0b3Ikc2VsZWN0aW9uMjtcbiAgY29uc3QgYW5jaG9yID0gKF9FZGl0b3IkYWJvdmUgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgbWF0Y2g6IG5vZGVUeXBlTWF0Y2hlcigndGFibGUtY2VsbCcpLFxuICAgIGF0OiAoX2VkaXRvciRzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uKSA9PT0gbnVsbCB8fCBfZWRpdG9yJHNlbGVjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VkaXRvciRzZWxlY3Rpb24uYW5jaG9yLnBhdGhcbiAgfSkpID09PSBudWxsIHx8IF9FZGl0b3IkYWJvdmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9FZGl0b3IkYWJvdmVbMV07XG4gIGNvbnN0IGZvY3VzID0gKF9FZGl0b3IkYWJvdmUyID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgIG1hdGNoOiBub2RlVHlwZU1hdGNoZXIoJ3RhYmxlLWNlbGwnKSxcbiAgICBhdDogKF9lZGl0b3Ikc2VsZWN0aW9uMiA9IGVkaXRvci5zZWxlY3Rpb24pID09PSBudWxsIHx8IF9lZGl0b3Ikc2VsZWN0aW9uMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VkaXRvciRzZWxlY3Rpb24yLmZvY3VzLnBhdGhcbiAgfSkpID09PSBudWxsIHx8IF9FZGl0b3IkYWJvdmUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfRWRpdG9yJGFib3ZlMlsxXTtcbiAgY29uc3QgdGFibGUgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgbWF0Y2g6IG5vZGVUeXBlTWF0Y2hlcigndGFibGUnKVxuICB9KTtcbiAgaWYgKGVkaXRvci5zZWxlY3Rpb24gJiYgdGFibGUgJiYgRWxlbWVudCQxLmlzRWxlbWVudCh0YWJsZVswXS5jaGlsZHJlblswXSkgJiYgYW5jaG9yICYmIGZvY3VzICYmIFBhdGguZXF1YWxzKGFuY2hvci5zbGljZSgwLCAtMyksIGZvY3VzLnNsaWNlKDAsIC0zKSkpIHtcbiAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBFZGl0b3IuZWRnZXMoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgdGFibGVQYXRoOiB0YWJsZVsxXSxcbiAgICAgIHRhYmxlOiB0YWJsZVswXSxcbiAgICAgIHNpbmdsZUNlbGw6IFBhdGguZXF1YWxzKGFuY2hvciwgZm9jdXMpID8gUG9pbnQuZXF1YWxzKEVkaXRvci5zdGFydChlZGl0b3IsIGFuY2hvciksIHN0YXJ0KSAmJiBQb2ludC5lcXVhbHMoRWRpdG9yLmVuZChlZGl0b3IsIGFuY2hvciksIGVuZCkgJiYgIVBvaW50LmVxdWFscyhzdGFydCwgZW5kKSA/ICdzZWxlY3RlZCcgOiAnbm90LXNlbGVjdGVkJyA6ICdtYW55JyxcbiAgICAgIHJvdzogb3JkZXIoYW5jaG9yW2FuY2hvci5sZW5ndGggLSAyXSArIGFuY2hvclthbmNob3IubGVuZ3RoIC0gM10sIGZvY3VzW2ZvY3VzLmxlbmd0aCAtIDJdICsgZm9jdXNbYW5jaG9yLmxlbmd0aCAtIDNdKSxcbiAgICAgIGNvbHVtbjogb3JkZXIoYW5jaG9yW2FuY2hvci5sZW5ndGggLSAxXSwgZm9jdXNbZm9jdXMubGVuZ3RoIC0gMV0pXG4gICAgfTtcbiAgfVxufVxuY29uc3QgY2VsbCA9IGhlYWRlciA9PiAoe1xuICB0eXBlOiAndGFibGUtY2VsbCcsXG4gIC4uLihoZWFkZXIgPyB7XG4gICAgaGVhZGVyOiB0cnVlXG4gIH0gOiB7fSksXG4gIGNoaWxkcmVuOiBbe1xuICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgIGNoaWxkcmVuOiBbe1xuICAgICAgdGV4dDogJydcbiAgICB9XVxuICB9XVxufSk7XG5mdW5jdGlvbiBjbG9uZURlc2NlbmRhbnQobm9kZSkge1xuICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHJldHVybiB7XG4gICAgLi4ubm9kZVxuICB9O1xuICByZXR1cm4ge1xuICAgIC4uLm5vZGUsXG4gICAgY2hpbGRyZW46IG5vZGUuY2hpbGRyZW4ubWFwKGNsb25lRGVzY2VuZGFudClcbiAgfTtcbn1cbmZ1bmN0aW9uIHdpdGhUYWJsZShlZGl0b3IpIHtcbiAgY29uc3Qge1xuICAgIGRlbGV0ZUZyYWdtZW50LFxuICAgIG5vcm1hbGl6ZU5vZGUsXG4gICAgZ2V0RnJhZ21lbnQsXG4gICAgaW5zZXJ0RnJhZ21lbnQsXG4gICAgZGVsZXRlQmFja3dhcmRcbiAgfSA9IGVkaXRvcjtcbiAgZWRpdG9yLmluc2VydEZyYWdtZW50ID0gZnJhZ21lbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGVkVGFibGVBcmVhID0gZ2V0U2VsZWN0ZWRUYWJsZUFyZWEoZWRpdG9yKTtcbiAgICBpZiAoIXNlbGVjdGVkVGFibGVBcmVhIHx8IGZyYWdtZW50Lmxlbmd0aCAhPT0gMSB8fCBmcmFnbWVudFswXS50eXBlICE9PSAndGFibGUnKSB7XG4gICAgICBpbnNlcnRGcmFnbWVudChmcmFnbWVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5ld1Jvd3MgPSBmcmFnbWVudFswXS5jaGlsZHJlbi5mbGF0TWFwKGNoaWxkID0+IGNoaWxkLnR5cGUgPT09ICd0YWJsZS1oZWFkJyB8fCBjaGlsZC50eXBlID09PSAndGFibGUtYm9keScgPyBjaGlsZC5jaGlsZHJlbiA6IFtdKTtcbiAgICBpZiAoIW5ld1Jvd3MuZXZlcnkobm9kZVR5cGVNYXRjaGVyKCd0YWJsZS1yb3cnKSkpIHtcbiAgICAgIGluc2VydEZyYWdtZW50KGZyYWdtZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHtcbiAgICAgIHJvdyxcbiAgICAgIGNvbHVtbixcbiAgICAgIHRhYmxlUGF0aCxcbiAgICAgIHRhYmxlXG4gICAgfSA9IHNlbGVjdGVkVGFibGVBcmVhO1xuICAgIGNvbnN0IGV4aXN0aW5nQm9keSA9IHNlbGVjdGVkVGFibGVBcmVhLnRhYmxlLmNoaWxkcmVuW3NlbGVjdGVkVGFibGVBcmVhLnRhYmxlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSA/IDAgOiAxXTtcbiAgICBpZiAobmV3Um93c1swXS50eXBlICE9PSAndGFibGUtcm93JyB8fCBleGlzdGluZ0JvZHkudHlwZSAhPT0gJ3RhYmxlLWJvZHknIHx8IGV4aXN0aW5nQm9keS5jaGlsZHJlblswXS50eXBlICE9PSAndGFibGUtcm93Jykge1xuICAgICAgaW5zZXJ0RnJhZ21lbnQoZnJhZ21lbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoYXNIZWFkID0gdGFibGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gJ3RhYmxlLWhlYWQnO1xuICAgIGlmIChzZWxlY3RlZFRhYmxlQXJlYS5zaW5nbGVDZWxsICE9PSAnbWFueScpIHtcbiAgICAgIHJvdyA9IHtcbiAgICAgICAgc3RhcnQ6IHJvdy5zdGFydCxcbiAgICAgICAgZW5kOiBNYXRoLm1pbihyb3cuc3RhcnQgKyBuZXdSb3dzLmxlbmd0aCAtIDEsIGV4aXN0aW5nQm9keS5jaGlsZHJlbi5sZW5ndGggLSAxICsgKGhhc0hlYWQgPyAxIDogMCkpXG4gICAgICB9O1xuICAgICAgY29sdW1uID0ge1xuICAgICAgICBzdGFydDogY29sdW1uLnN0YXJ0LFxuICAgICAgICBlbmQ6IE1hdGgubWluKGNvbHVtbi5zdGFydCArIG5ld1Jvd3NbMF0uY2hpbGRyZW4ubGVuZ3RoIC0gMSwgZXhpc3RpbmdCb2R5LmNoaWxkcmVuWzBdLmNoaWxkcmVuLmxlbmd0aCAtIDEpXG4gICAgICB9O1xuICAgIH1cbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgZm9yIChsZXQgcm93SW5kZXggPSByb3cuc3RhcnQ7IHJvd0luZGV4IDw9IHJvdy5lbmQ7IHJvd0luZGV4KyspIHtcbiAgICAgICAgY29uc3QgbmV3Um93ID0gbmV3Um93c1socm93SW5kZXggLSByb3cuc3RhcnQpICUgbmV3Um93cy5sZW5ndGhdO1xuICAgICAgICBmb3IgKGxldCBjZWxsSW5kZXggPSBjb2x1bW4uc3RhcnQ7IGNlbGxJbmRleCA8PSBjb2x1bW4uZW5kOyBjZWxsSW5kZXgrKykge1xuICAgICAgICAgIGNvbnN0IHJlbGF0aXZlQ2VsbFBhdGggPSBbLi4uZ2V0UmVsYXRpdmVSb3dQYXRoKGhhc0hlYWQsIHJvd0luZGV4KSwgY2VsbEluZGV4XTtcbiAgICAgICAgICBjb25zdCBjZWxsID0gTm9kZS5nZXQodGFibGUsIHJlbGF0aXZlQ2VsbFBhdGgpO1xuICAgICAgICAgIGNvbnN0IG5ld0NlbGwgPSBuZXdSb3cuY2hpbGRyZW5bKGNlbGxJbmRleCAtIGNvbHVtbi5zdGFydCkgJSBuZXdSb3cuY2hpbGRyZW4ubGVuZ3RoXTtcbiAgICAgICAgICBpZiAoY2VsbC50eXBlICE9PSAndGFibGUtY2VsbCcgfHwgbmV3Q2VsbC50eXBlICE9PSAndGFibGUtY2VsbCcpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjZWxsUGF0aCA9IFsuLi50YWJsZVBhdGgsIC4uLnJlbGF0aXZlQ2VsbFBhdGhdO1xuICAgICAgICAgIGZvciAoY29uc3QgY2hpbGRJZHggb2YgWy4uLmNlbGwuY2hpbGRyZW4ua2V5cygpXS5yZXZlcnNlKCkpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiBbLi4uY2VsbFBhdGgsIGNoaWxkSWR4XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBuZXdDZWxsLmNoaWxkcmVuLm1hcChjbG9uZURlc2NlbmRhbnQpLCB7XG4gICAgICAgICAgICBhdDogWy4uLmNlbGxQYXRoLCAwXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHtcbiAgICAgICAgYW5jaG9yOiBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBbLi4udGFibGVQYXRoLCAuLi5nZXRSZWxhdGl2ZVJvd1BhdGgoaGFzSGVhZCwgcm93LnN0YXJ0KSwgY29sdW1uLnN0YXJ0XSksXG4gICAgICAgIGZvY3VzOiBFZGl0b3IuZW5kKGVkaXRvciwgWy4uLnRhYmxlUGF0aCwgLi4uZ2V0UmVsYXRpdmVSb3dQYXRoKGhhc0hlYWQsIHJvdy5lbmQpLCBjb2x1bW4uZW5kXSlcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBlZGl0b3IuZGVsZXRlQmFja3dhcmQgPSB1bml0ID0+IHtcbiAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSAmJiBlZGl0b3Iuc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgPT09IDApIHtcbiAgICAgIGNvbnN0IHRhYmxlQ2VsbCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IG5vZGVUeXBlTWF0Y2hlcigndGFibGUtY2VsbCcpXG4gICAgICB9KTtcbiAgICAgIGlmICh0YWJsZUNlbGwgJiYgdGFibGVDZWxsWzBdLmNoaWxkcmVuWzBdLnR5cGUgPT09ICdwYXJhZ3JhcGgnICYmIHRhYmxlQ2VsbFswXS5jaGlsZHJlblswXS5jaGlsZHJlblswXS50eXBlID09PSB1bmRlZmluZWQgJiYgUGF0aC5lcXVhbHMoZWRpdG9yLnNlbGVjdGlvbi5hbmNob3IucGF0aCwgWy4uLnRhYmxlQ2VsbFsxXSwgMCwgMF0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlQmFja3dhcmQodW5pdCk7XG4gIH07XG4gIGVkaXRvci5nZXRGcmFnbWVudCA9ICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3RlZFRhYmxlQXJlYSA9IGdldFNlbGVjdGVkVGFibGVBcmVhKGVkaXRvcik7XG4gICAgaWYgKHNlbGVjdGVkVGFibGVBcmVhICYmIHNlbGVjdGVkVGFibGVBcmVhLnNpbmdsZUNlbGwgIT09ICdub3Qtc2VsZWN0ZWQnKSB7XG4gICAgICB2YXIgX3RhYmxlJGNoaWxkcmVuJDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdGFibGVcbiAgICAgIH0gPSBzZWxlY3RlZFRhYmxlQXJlYTtcbiAgICAgIGNvbnN0IGZpcnN0ID0gdGFibGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gJ3RhYmxlLWhlYWQnIHx8IHRhYmxlLmNoaWxkcmVuWzBdLnR5cGUgPT09ICd0YWJsZS1ib2R5JyA/IHRhYmxlLmNoaWxkcmVuWzBdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICByZXR1cm4gZ2V0RnJhZ21lbnQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlY29uZCA9ICgoX3RhYmxlJGNoaWxkcmVuJCA9IHRhYmxlLmNoaWxkcmVuWzFdKSA9PT0gbnVsbCB8fCBfdGFibGUkY2hpbGRyZW4kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGFibGUkY2hpbGRyZW4kLnR5cGUpID09PSAndGFibGUtYm9keScgPyB0YWJsZS5jaGlsZHJlblsxXSA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IGJvZHkgPSBzZWNvbmQgfHwgZmlyc3Q7XG4gICAgICBjb25zdCBoYXNIZWFkID0gZmlyc3QudHlwZSA9PT0gJ3RhYmxlLWhlYWQnO1xuICAgICAgY29uc3QgaXNTZWxlY3Rpb25JbkhlYWQgPSBzZWxlY3RlZFRhYmxlQXJlYS5yb3cuc3RhcnQgPT09IDAgJiYgISFzZWNvbmQ7XG4gICAgICBjb25zdCBjb2x1bW5MZW5ndGggPSBzZWxlY3RlZFRhYmxlQXJlYS5jb2x1bW4uZW5kIC0gc2VsZWN0ZWRUYWJsZUFyZWEuY29sdW1uLnN0YXJ0ICsgMTtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICBjaGlsZHJlbjogWy4uLihpc1NlbGVjdGlvbkluSGVhZCA/IFt7XG4gICAgICAgICAgdHlwZTogJ3RhYmxlLWhlYWQnLFxuICAgICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgICAgdHlwZTogJ3RhYmxlLXJvdycsXG4gICAgICAgICAgICBjaGlsZHJlbjogQXJyYXkuZnJvbSh7XG4gICAgICAgICAgICAgIGxlbmd0aDogY29sdW1uTGVuZ3RoXG4gICAgICAgICAgICB9KS5tYXAoKF8sIGNvbHVtbkluZGV4KSA9PiBmaXJzdC5jaGlsZHJlblswXS5jaGlsZHJlbltjb2x1bW5JbmRleCArIHNlbGVjdGVkVGFibGVBcmVhLmNvbHVtbi5zdGFydF0pXG4gICAgICAgICAgfV1cbiAgICAgICAgfV0gOiBbXSksIHtcbiAgICAgICAgICB0eXBlOiAndGFibGUtYm9keScsXG4gICAgICAgICAgY2hpbGRyZW46IEFycmF5LmZyb20oe1xuICAgICAgICAgICAgbGVuZ3RoOiBzZWxlY3RlZFRhYmxlQXJlYS5yb3cuZW5kIC0gc2VsZWN0ZWRUYWJsZUFyZWEucm93LnN0YXJ0ICsgKGlzU2VsZWN0aW9uSW5IZWFkID8gMCA6IDEpXG4gICAgICAgICAgfSkubWFwKChfLCByb3dJbmRleCkgPT4gKHtcbiAgICAgICAgICAgIHR5cGU6ICd0YWJsZS1yb3cnLFxuICAgICAgICAgICAgY2hpbGRyZW46IEFycmF5LmZyb20oe1xuICAgICAgICAgICAgICBsZW5ndGg6IGNvbHVtbkxlbmd0aFxuICAgICAgICAgICAgfSkubWFwKChfLCBjb2x1bW5JbmRleCkgPT4gYm9keS5jaGlsZHJlbltyb3dJbmRleCArIHNlbGVjdGVkVGFibGVBcmVhLnJvdy5zdGFydCAtIChoYXNIZWFkICYmICFpc1NlbGVjdGlvbkluSGVhZCA/IDEgOiAwKV0uY2hpbGRyZW5bY29sdW1uSW5kZXggKyBzZWxlY3RlZFRhYmxlQXJlYS5jb2x1bW4uc3RhcnRdKVxuICAgICAgICAgIH0pKVxuICAgICAgICB9XVxuICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiBnZXRGcmFnbWVudCgpO1xuICB9O1xuICBlZGl0b3IuZGVsZXRlRnJhZ21lbnQgPSBkaXJlY3Rpb24gPT4ge1xuICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbiB8fCBSYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSkge1xuICAgICAgZGVsZXRlRnJhZ21lbnQoZGlyZWN0aW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWRUYWJsZUFyZWEgPSBnZXRTZWxlY3RlZFRhYmxlQXJlYShlZGl0b3IpO1xuICAgIGlmICghc2VsZWN0ZWRUYWJsZUFyZWEgfHwgc2VsZWN0ZWRUYWJsZUFyZWEuc2luZ2xlQ2VsbCA9PT0gJ25vdC1zZWxlY3RlZCcpIHtcbiAgICAgIGRlbGV0ZUZyYWdtZW50KGRpcmVjdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhlYWRPckJvZHkgPSBzZWxlY3RlZFRhYmxlQXJlYS50YWJsZS5jaGlsZHJlblswXTtcbiAgICBpZiAoIUVsZW1lbnQkMS5pc0VsZW1lbnQoaGVhZE9yQm9keSkgfHwgIUVsZW1lbnQkMS5pc0VsZW1lbnQoaGVhZE9yQm9keS5jaGlsZHJlblswXSkpIHtcbiAgICAgIGRlbGV0ZUZyYWdtZW50KGRpcmVjdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1heFJvd0lkeCA9IHNlbGVjdGVkVGFibGVBcmVhLnRhYmxlLmNoaWxkcmVuLnJlZHVjZSgoc3VtLCBoZWFkT3JCb2R5KSA9PiBzdW0gKyAoaGVhZE9yQm9keS50eXBlID09PSAndGFibGUtaGVhZCcgfHwgaGVhZE9yQm9keS50eXBlID09PSAndGFibGUtYm9keScgPyBoZWFkT3JCb2R5LmNoaWxkcmVuLmxlbmd0aCA6IDApLCAwKSAtIDE7XG4gICAgY29uc3Qge1xuICAgICAgcm93LFxuICAgICAgY29sdW1uLFxuICAgICAgdGFibGVQYXRoXG4gICAgfSA9IHNlbGVjdGVkVGFibGVBcmVhO1xuICAgIC8vIG5vdGUgdGhlIGZhY3QgdGhhdCBoYXNXaG9sZUNvbHVtblNlbGVjdGVkIHVzZXMgcm93IGFuZCBoYXNXaG9sZVJvd1NlbGVjdGVkIHVzZXMgY29sdW1uXG4gICAgLy8gaXMgbm90IGEgbWlzdGFrZS4gaWYgYSB3aG9sZSBjb2x1bW4gaGFzIGJlZW4gc2VsZWN0ZWQsIHRoZW4gdGhlIHN0YXJ0aW5nIHJvdyBpcyAwIGFuZCB0aGUgZW5kIGlzIHRoZSBsYXN0IHJvd1xuICAgIGNvbnN0IGhhc1dob2xlQ29sdW1uU2VsZWN0ZWQgPSByb3cuc3RhcnQgPT09IDAgJiYgcm93LmVuZCA9PT0gbWF4Um93SWR4O1xuICAgIGNvbnN0IGhhc1dob2xlUm93U2VsZWN0ZWQgPSBjb2x1bW4uc3RhcnQgPT09IDAgJiYgY29sdW1uLmVuZCA9PT0gaGVhZE9yQm9keS5jaGlsZHJlblswXS5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgIGlmIChoYXNXaG9sZUNvbHVtblNlbGVjdGVkICYmIGhhc1dob2xlUm93U2VsZWN0ZWQpIHtcbiAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiB0YWJsZVBhdGhcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoYXNIZWFkID0gaGVhZE9yQm9keS50eXBlID09PSAndGFibGUtaGVhZCc7XG4gICAgaWYgKGhhc1dob2xlUm93U2VsZWN0ZWQpIHtcbiAgICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSByb3cuZW5kOyBpID49IHJvdy5zdGFydDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGhhc0hlYWQpIHtcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgYXQ6IFsuLi50YWJsZVBhdGgsIDBdXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiBbLi4udGFibGVQYXRoLCAxLCBpIC0gMV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogWy4uLnRhYmxlUGF0aCwgMCwgaV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChoYXNXaG9sZUNvbHVtblNlbGVjdGVkKSB7XG4gICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gY29sdW1uLmVuZDsgaSA+PSBjb2x1bW4uc3RhcnQ7IGktLSkge1xuICAgICAgICAgIGZvciAobGV0IHJvd0lkeCA9IDA7IHJvd0lkeCA8PSBtYXhSb3dJZHg7IHJvd0lkeCsrKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogWy4uLnRhYmxlUGF0aCwgLi4uZ2V0UmVsYXRpdmVSb3dQYXRoKGhhc0hlYWQsIHJvd0lkeCksIGldXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uUGF0aCA9IFsuLi50YWJsZVBhdGgsIDAsIDAsIGNvbHVtbi5zdGFydF07XG4gICAgICAgIGNvbnN0IHBvaW50ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgY29sdW1uLnN0YXJ0ID09PSAwID8gc2VsZWN0aW9uUGF0aCA6IFBhdGgucHJldmlvdXMoc2VsZWN0aW9uUGF0aCkpO1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHBvaW50KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb25TdGFydCA9IEVkaXRvci5zdGFydChlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24pLnBhdGg7XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIGZvciAobGV0IHJvd0luZGV4ID0gcm93LnN0YXJ0OyByb3dJbmRleCA8PSByb3cuZW5kOyByb3dJbmRleCsrKSB7XG4gICAgICAgIGZvciAobGV0IGNlbGxJbmRleCA9IGNvbHVtbi5zdGFydDsgY2VsbEluZGV4IDw9IGNvbHVtbi5lbmQ7IGNlbGxJbmRleCsrKSB7XG4gICAgICAgICAgY29uc3QgcmVsYXRpdmVDZWxsUGF0aCA9IFsuLi5nZXRSZWxhdGl2ZVJvd1BhdGgoaGFzSGVhZCwgcm93SW5kZXgpLCBjZWxsSW5kZXhdO1xuICAgICAgICAgIGNvbnN0IGNlbGwgPSBOb2RlLmdldChzZWxlY3RlZFRhYmxlQXJlYS50YWJsZSwgcmVsYXRpdmVDZWxsUGF0aCk7XG4gICAgICAgICAgaWYgKCFFbGVtZW50JDEuaXNFbGVtZW50KGNlbGwpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY2VsbFBhdGggPSBbLi4udGFibGVQYXRoLCAuLi5yZWxhdGl2ZUNlbGxQYXRoXTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IFsuLi5jZWxsUGF0aCwgMF1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkSWR4IG9mIFsuLi5jZWxsLmNoaWxkcmVuLmtleXMoKV0ucmV2ZXJzZSgpKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogWy4uLmNlbGxQYXRoLCBjaGlsZElkeCArIDFdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2VsZWN0aW9uU3RhcnQpO1xuICAgIH0pO1xuICB9O1xuICBlZGl0b3Iubm9ybWFsaXplTm9kZSA9IGVudHJ5ID0+IHtcbiAgICBjb25zdCBbbm9kZSwgcGF0aF0gPSBlbnRyeTtcbiAgICBpZiAobm9kZS50eXBlID09PSAndGFibGUtaGVhZCcgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICBtb3ZlQ2hpbGRyZW4oZWRpdG9yLCBwYXRoLCBQYXRoLm5leHQocGF0aCksIChfLCBpKSA9PiBpICE9PSAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGRpZFVwZGF0ZVRoaW5ncyA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgcGFyZW50IG9mIFsndGFibGUtYm9keScsICd0YWJsZS1oZWFkJ10pIHtcbiAgICAgIGlmIChub2RlLnR5cGUgPT09IHBhcmVudCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtyb3dJZHgsIHJvd10gb2Ygbm9kZS5jaGlsZHJlbi5lbnRyaWVzKCkpIHtcbiAgICAgICAgICBpZiAocm93LnR5cGUgPT09ICd0YWJsZS1yb3cnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtjZWxsSWR4LCBjZWxsXSBvZiByb3cuY2hpbGRyZW4uZW50cmllcygpKSB7XG4gICAgICAgICAgICAgIGlmIChjZWxsLnR5cGUgPT09ICd0YWJsZS1jZWxsJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0ID0gWy4uLnBhdGgsIHJvd0lkeCwgY2VsbElkeF07XG4gICAgICAgICAgICAgICAgaWYgKGNlbGwuaGVhZGVyICYmIHBhcmVudCA9PT0gJ3RhYmxlLWJvZHknKSB7XG4gICAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnVuc2V0Tm9kZXMoZWRpdG9yLCAnaGVhZGVyJywge1xuICAgICAgICAgICAgICAgICAgICBhdFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBkaWRVcGRhdGVUaGluZ3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNlbGwuaGVhZGVyICYmIHBhcmVudCA9PT0gJ3RhYmxlLWhlYWQnKSB7XG4gICAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXI6IHRydWVcbiAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgYXRcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgZGlkVXBkYXRlVGhpbmdzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRpZFVwZGF0ZVRoaW5ncykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobm9kZS50eXBlID09PSAndGFibGUnKSB7XG4gICAgICBjb25zdCBtYXhSb3dDb3VudCA9IG5vZGUuY2hpbGRyZW4ucmVkdWNlKChtYXgsIG5vZGUpID0+IG5vZGUudHlwZSA9PT0gJ3RhYmxlLWhlYWQnIHx8IG5vZGUudHlwZSA9PT0gJ3RhYmxlLWJvZHknID8gbm9kZS5jaGlsZHJlbi5yZWR1Y2UoKG1heCwgbm9kZSkgPT4gbm9kZS50eXBlID09PSAndGFibGUtcm93JyA/IE1hdGgubWF4KG1heCwgbm9kZS5jaGlsZHJlbi5sZW5ndGgpIDogbWF4LCBtYXgpIDogbWF4LCAwKTtcbiAgICAgIGxldCBkaWRJbnNlcnQgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgW2lkeCwgY2hpbGRdIG9mIG5vZGUuY2hpbGRyZW4uZW50cmllcygpKSB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSAndGFibGUtYm9keScgfHwgY2hpbGQudHlwZSA9PT0gJ3RhYmxlLWhlYWQnKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBbcm93SWR4LCByb3ddIG9mIGNoaWxkLmNoaWxkcmVuLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKHJvdy50eXBlID09PSAndGFibGUtcm93JyAmJiByb3cuY2hpbGRyZW4ubGVuZ3RoICE9PSBtYXhSb3dDb3VudCkge1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgQXJyYXkuZnJvbSh7XG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBtYXhSb3dDb3VudCAtIHJvdy5jaGlsZHJlbi5sZW5ndGhcbiAgICAgICAgICAgICAgfSwgKCkgPT4gY2VsbChjaGlsZC50eXBlID09PSAndGFibGUtaGVhZCcpKSwge1xuICAgICAgICAgICAgICAgIGF0OiBbLi4ucGF0aCwgaWR4LCByb3dJZHgsIHJvdy5jaGlsZHJlbi5sZW5ndGhdXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBkaWRJbnNlcnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpZEluc2VydCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAndGFibGUtaGVhZCcpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICB0eXBlOiAndGFibGUtYm9keScsXG4gICAgICAgICAgY2hpbGRyZW46IEFycmF5LmZyb20oe1xuICAgICAgICAgICAgbGVuZ3RoOiBub2RlLmNoaWxkcmVuWzBdLmNoaWxkcmVuLmxlbmd0aFxuICAgICAgICAgIH0sICgpID0+IGNlbGwoZmFsc2UpKVxuICAgICAgICB9LCB7XG4gICAgICAgICAgYXQ6IFsuLi5wYXRoLCAxXVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAyICYmIG5vZGUuY2hpbGRyZW5bMV0udHlwZSA9PT0gJ3RhYmxlLWhlYWQnKSB7XG4gICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBbLi4ucGF0aCwgMV0sXG4gICAgICAgICAgdG86IFsuLi5wYXRoLCAwXVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMikge1xuICAgICAgICBtb3ZlQ2hpbGRyZW4oZWRpdG9yLCBwYXRoLCBQYXRoLm5leHQocGF0aCksIChfLCBpKSA9PiBpICE9PSAwICYmIGkgIT09IDEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIG5vcm1hbGl6ZU5vZGUoZW50cnkpO1xuICB9O1xuICByZXR1cm4gZWRpdG9yO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEb2N1bWVudEVkaXRvckZvck5vcm1hbGl6YXRpb24oZG9jdW1lbnRGZWF0dXJlcywgY29tcG9uZW50QmxvY2tzKSB7XG4gIHJldHVybiBfY3JlYXRlRG9jdW1lbnRFZGl0b3IoY3JlYXRlRWRpdG9yKCksIGRvY3VtZW50RmVhdHVyZXMsIGNvbXBvbmVudEJsb2Nrcyk7XG59XG5mdW5jdGlvbiBfY3JlYXRlRG9jdW1lbnRFZGl0b3IoYmFzZUVkaXRvciwgZG9jdW1lbnRGZWF0dXJlcywgY29tcG9uZW50QmxvY2tzKSB7XG4gIHJldHVybiB3aXRoQmxvY2tzU2NoZW1hKHdpdGhQYXJhZ3JhcGhzKHdpdGhMaW5rKGRvY3VtZW50RmVhdHVyZXMsIGNvbXBvbmVudEJsb2Nrcywgd2l0aExpc3Qod2l0aFRhYmxlKHdpdGhDb21wb25lbnRCbG9ja3MoY29tcG9uZW50QmxvY2tzLCBkb2N1bWVudEZlYXR1cmVzLCB3aXRoVm9pZEVsZW1lbnRzKHdpdGhMYXlvdXRzKHdpdGhDb2RlQmxvY2soZG9jdW1lbnRGZWF0dXJlcywgY29tcG9uZW50QmxvY2tzLCB3aXRoRG9jdW1lbnRGZWF0dXJlc05vcm1hbGl6YXRpb24oZG9jdW1lbnRGZWF0dXJlcywgYmFzZUVkaXRvcikpKSkpKSkpKSk7XG59XG5mdW5jdGlvbiB3aXRoQmxvY2tzU2NoZW1hKGVkaXRvcikge1xuICBjb25zdCB7XG4gICAgbm9ybWFsaXplTm9kZVxuICB9ID0gZWRpdG9yO1xuICBlZGl0b3Iubm9ybWFsaXplTm9kZSA9IChbbm9kZSwgcGF0aF0pID0+IHtcbiAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpICYmIG5vZGUudHlwZSAhPT0gJ2xpbmsnKSB7XG4gICAgICBjb25zdCBub2RlVHlwZSA9IEVkaXRvci5pc0VkaXRvcihub2RlKSA/ICdlZGl0b3InIDogbm9kZS50eXBlO1xuICAgICAgaWYgKHR5cGVvZiBub2RlVHlwZSAhPT0gJ3N0cmluZycgfHwgZWRpdG9yU2NoZW1hW25vZGVUeXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluZm8gPSBlZGl0b3JTY2hlbWFbbm9kZVR5cGVdO1xuICAgICAgaWYgKGluZm8ua2luZCA9PT0gJ2Jsb2NrcycgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggIT09IDAgJiYgbm9kZS5jaGlsZHJlbi5ldmVyeShjaGlsZCA9PiAhaXNCbG9jayhjaGlsZCkpKSB7XG4gICAgICAgIFRyYW5zZm9ybXMud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIHR5cGU6IGluZm8uYmxvY2tUb1dyYXBJbmxpbmVzSW4sXG4gICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICBtYXRjaDogbm9kZSA9PiAhaXNCbG9jayhub2RlKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGRpZFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGNoaWxkTm9kZV0gb2YgWy4uLm5vZGUuY2hpbGRyZW4uZW50cmllcygpXS5yZXZlcnNlKCkpIHtcbiAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gWy4uLnBhdGgsIGluZGV4XTtcbiAgICAgICAgaWYgKGluZm8ua2luZCA9PT0gJ2lubGluZXMnKSB7XG4gICAgICAgICAgaWYgKCFUZXh0LmlzVGV4dChjaGlsZE5vZGUpICYmIGlzQmxvY2soY2hpbGROb2RlKSkge1xuICAgICAgICAgICAgaGFuZGxlTm9kZUluSW52YWxpZFBvc2l0aW9uKGVkaXRvciwgW2NoaWxkTm9kZSwgY2hpbGRQYXRoXSwgcGF0aCk7XG4gICAgICAgICAgICBkaWRVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghaXNCbG9jayhjaGlsZE5vZGUpKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLndyYXBOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdHlwZTogaW5mby5ibG9ja1RvV3JhcElubGluZXNJbixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGF0OiBjaGlsZFBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGlkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWluZm8uYWxsb3dlZENoaWxkcmVuLmhhcyhjaGlsZE5vZGUudHlwZSkpIHtcbiAgICAgICAgICAgIGhhbmRsZU5vZGVJbkludmFsaWRQb3NpdGlvbihlZGl0b3IsIFtjaGlsZE5vZGUsIGNoaWxkUGF0aF0sIHBhdGgpO1xuICAgICAgICAgICAgZGlkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpZFVwZGF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIG5vcm1hbGl6ZU5vZGUoW25vZGUsIHBhdGhdKTtcbiAgfTtcbiAgcmV0dXJuIGVkaXRvcjtcbn1cbmZ1bmN0aW9uIGhhbmRsZU5vZGVJbkludmFsaWRQb3NpdGlvbihlZGl0b3IsIFtub2RlLCBwYXRoXSwgYW5jZXN0b3JQYXRoKSB7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuICBjb25zdCBjaGlsZE5vZGVJbmZvID0gZWRpdG9yU2NoZW1hW25vZGVUeXBlXTtcbiAgLy8gdGhlIHBhcmVudCBvZiBhIGJsb2NrIHdpbGwgbmV2ZXIgYmUgYW4gaW5saW5lIHNvIHRoaXMgY2FzdGluZyBpcyBva2F5XG4gIGNvbnN0IGFuY2VzdG9yTm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgYW5jZXN0b3JQYXRoKTtcbiAgY29uc3QgcGFyZW50Tm9kZVR5cGUgPSBFZGl0b3IuaXNFZGl0b3IoYW5jZXN0b3JOb2RlKSA/ICdlZGl0b3InIDogYW5jZXN0b3JOb2RlLnR5cGU7XG4gIGNvbnN0IHBhcmVudE5vZGVJbmZvID0gZWRpdG9yU2NoZW1hW3BhcmVudE5vZGVUeXBlXTtcbiAgaWYgKCFjaGlsZE5vZGVJbmZvIHx8IGNoaWxkTm9kZUluZm8uaW52YWxpZFBvc2l0aW9uSGFuZGxlTW9kZSA9PT0gJ3Vud3JhcCcpIHtcbiAgICBpZiAocGFyZW50Tm9kZUluZm8ua2luZCA9PT0gJ2Jsb2NrcycgJiYgcGFyZW50Tm9kZUluZm8uYmxvY2tUb1dyYXBJbmxpbmVzSW4pIHtcbiAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIHR5cGU6IHBhcmVudE5vZGVJbmZvLmJsb2NrVG9XcmFwSW5saW5lc0luLFxuICAgICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmtleXMobm9kZSkuZmlsdGVyKGtleSA9PiBrZXkgIT09ICd0eXBlJyAmJiBrZXkgIT09ICdjaGlsZHJlbicpLm1hcChrZXkgPT4gW2tleSwgbnVsbF0pKSAvLyB0aGUgU2xhdGUgdHlwZXMgZG9uJ3QgdW5kZXJzdGFuZCB0aGF0IG51bGwgaXMgYWxsb3dlZCBhbmQgaXQgd2lsbCB1bnNldCBwcm9wZXJ0aWVzIHdpdGggc2V0Tm9kZXNcbiAgICAgIH0sIHtcbiAgICAgICAgYXQ6IHBhdGhcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBUcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IHBhdGhcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaW5mbyA9IGVkaXRvclNjaGVtYVthbmNlc3Rvck5vZGUudHlwZSB8fCAnZWRpdG9yJ107XG4gIGlmICgoaW5mbyA9PT0gbnVsbCB8fCBpbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbmZvLmtpbmQpID09PSAnYmxvY2tzJyAmJiBpbmZvLmFsbG93ZWRDaGlsZHJlbi5oYXMobm9kZVR5cGUpKSB7XG4gICAgaWYgKGFuY2VzdG9yUGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgdG86IFtwYXRoWzBdICsgMV1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgIHRvOiBQYXRoLm5leHQoYW5jZXN0b3JQYXRoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBpZiAoRWRpdG9yLmlzRWRpdG9yKGFuY2VzdG9yTm9kZSkpIHtcbiAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBwYXRoLFxuICAgICAgdG86IFtwYXRoWzBdICsgMV1cbiAgICB9KTtcbiAgICBUcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IFtwYXRoWzBdICsgMV1cbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgaGFuZGxlTm9kZUluSW52YWxpZFBvc2l0aW9uKGVkaXRvciwgW25vZGUsIHBhdGhdLCBhbmNlc3RvclBhdGguc2xpY2UoMCwgLTEpKTtcbn1cbmZ1bmN0aW9uIHdpdGhWb2lkRWxlbWVudHMoZWRpdG9yKSB7XG4gIGNvbnN0IHtcbiAgICBpc1ZvaWRcbiAgfSA9IGVkaXRvcjtcbiAgZWRpdG9yLmlzVm9pZCA9IG5vZGUgPT4ge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdkaXZpZGVyJyB8fCBub2RlLnR5cGUgPT09ICdpbWFnZScgfHwgaXNWb2lkKG5vZGUpO1xuICB9O1xuICByZXR1cm4gZWRpdG9yO1xufVxuXG5jb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbmNvbnN0IGRlZmF1bHRBbHRGaWVsZCA9IHRleHQoe1xuICBsYWJlbDogJ0FsdCB0ZXh0JyxcbiAgZGVzY3JpcHRpb246ICdUaGlzIHRleHQgd2lsbCBiZSB1c2VkIGJ5IHNjcmVlbiByZWFkZXJzIGFuZCBzZWFyY2ggZW5naW5lcy4nXG59KTtcbmNvbnN0IGVtcHR5VGl0bGVGaWVsZCA9IGJhc2ljRm9ybUZpZWxkV2l0aFNpbXBsZVJlYWRlclBhcnNlKHtcbiAgSW5wdXQoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH0sXG4gIHBhcnNlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEZpZWxkRGF0YUVycm9yKCdNdXN0IGJlIHN0cmluZycpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBzZXJpYWxpemUodmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59KTtcbmZ1bmN0aW9uIG5vcm1hbGlzZURvY3VtZW50RmVhdHVyZXMoY29uZmlnKSB7XG4gIHZhciBfY29uZmlnJGZvcm1hdHRpbmcsIF9mb3JtYXR0aW5nJGFsaWdubWVudCwgX2Zvcm1hdHRpbmckYWxpZ25tZW50MiwgX2Zvcm1hdHRpbmckYmxvY2tUeXBlLCBfZm9ybWF0dGluZyRpbmxpbmVNYXIsIF9mb3JtYXR0aW5nJGlubGluZU1hcjIsIF9mb3JtYXR0aW5nJGlubGluZU1hcjMsIF9mb3JtYXR0aW5nJGlubGluZU1hcjQsIF9mb3JtYXR0aW5nJGlubGluZU1hcjUsIF9mb3JtYXR0aW5nJGlubGluZU1hcjYsIF9mb3JtYXR0aW5nJGlubGluZU1hcjcsIF9mb3JtYXR0aW5nJGlubGluZU1hcjgsIF9mb3JtYXR0aW5nJGxpc3RUeXBlcywgX2Zvcm1hdHRpbmckbGlzdFR5cGVzMiwgX2ltYWdlc0NvbmZpZyRzY2hlbWEkLCBfaW1hZ2VzQ29uZmlnJHNjaGVtYSwgX2ltYWdlc0NvbmZpZyRzY2hlbWEkMiwgX2ltYWdlc0NvbmZpZyRzY2hlbWEyO1xuICBjb25zdCBmb3JtYXR0aW5nID0gY29uZmlnLmZvcm1hdHRpbmcgPT09IHRydWUgPyB7XG4gICAgLy8gYWxpZ25tZW50OiB0cnVlLCAvLyBub3Qgc3VwcG9ydGVkIG5hdGl2ZWx5IGluIG1hcmtkb3duXG4gICAgYmxvY2tUeXBlczogdHJ1ZSxcbiAgICBoZWFkaW5nTGV2ZWxzOiB0cnVlLFxuICAgIGlubGluZU1hcmtzOiB0cnVlLFxuICAgIGxpc3RUeXBlczogdHJ1ZSxcbiAgICBzb2Z0QnJlYWtzOiB0cnVlXG4gIH0gOiAoX2NvbmZpZyRmb3JtYXR0aW5nID0gY29uZmlnLmZvcm1hdHRpbmcpICE9PSBudWxsICYmIF9jb25maWckZm9ybWF0dGluZyAhPT0gdm9pZCAwID8gX2NvbmZpZyRmb3JtYXR0aW5nIDoge307XG4gIGNvbnN0IGltYWdlc0NvbmZpZyA9IGNvbmZpZy5pbWFnZXMgPT09IHRydWUgPyB7fSA6IGNvbmZpZy5pbWFnZXM7XG4gIHJldHVybiB7XG4gICAgZm9ybWF0dGluZzoge1xuICAgICAgYWxpZ25tZW50OiBmb3JtYXR0aW5nLmFsaWdubWVudCA9PT0gdHJ1ZSA/IHtcbiAgICAgICAgY2VudGVyOiB0cnVlLFxuICAgICAgICBlbmQ6IHRydWVcbiAgICAgIH0gOiB7XG4gICAgICAgIGNlbnRlcjogISEoKF9mb3JtYXR0aW5nJGFsaWdubWVudCA9IGZvcm1hdHRpbmcuYWxpZ25tZW50KSAhPT0gbnVsbCAmJiBfZm9ybWF0dGluZyRhbGlnbm1lbnQgIT09IHZvaWQgMCAmJiBfZm9ybWF0dGluZyRhbGlnbm1lbnQuY2VudGVyKSxcbiAgICAgICAgZW5kOiAhISgoX2Zvcm1hdHRpbmckYWxpZ25tZW50MiA9IGZvcm1hdHRpbmcuYWxpZ25tZW50KSAhPT0gbnVsbCAmJiBfZm9ybWF0dGluZyRhbGlnbm1lbnQyICE9PSB2b2lkIDAgJiYgX2Zvcm1hdHRpbmckYWxpZ25tZW50Mi5lbmQpXG4gICAgICB9LFxuICAgICAgYmxvY2tUeXBlczogKGZvcm1hdHRpbmcgPT09IG51bGwgfHwgZm9ybWF0dGluZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9ybWF0dGluZy5ibG9ja1R5cGVzKSA9PT0gdHJ1ZSA/IHtcbiAgICAgICAgYmxvY2txdW90ZTogdHJ1ZSxcbiAgICAgICAgY29kZToge1xuICAgICAgICAgIHNjaGVtYTogb2JqZWN0KHt9KVxuICAgICAgICB9XG4gICAgICB9IDoge1xuICAgICAgICBibG9ja3F1b3RlOiAhISgoX2Zvcm1hdHRpbmckYmxvY2tUeXBlID0gZm9ybWF0dGluZy5ibG9ja1R5cGVzKSAhPT0gbnVsbCAmJiBfZm9ybWF0dGluZyRibG9ja1R5cGUgIT09IHZvaWQgMCAmJiBfZm9ybWF0dGluZyRibG9ja1R5cGUuYmxvY2txdW90ZSksXG4gICAgICAgIGNvZGU6IChfZm9ybWF0dGluZyRibG9ja1R5cGUyID0+IHtcbiAgICAgICAgICBpZiAoKChfZm9ybWF0dGluZyRibG9ja1R5cGUyID0gZm9ybWF0dGluZy5ibG9ja1R5cGVzKSA9PT0gbnVsbCB8fCBfZm9ybWF0dGluZyRibG9ja1R5cGUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZm9ybWF0dGluZyRibG9ja1R5cGUyLmNvZGUpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZvcm1hdHRpbmcuYmxvY2tUeXBlcy5jb2RlID09PSB0cnVlIHx8ICFmb3JtYXR0aW5nLmJsb2NrVHlwZXMuY29kZS5zY2hlbWEpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNjaGVtYTogb2JqZWN0KHt9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgWyd0eXBlJywgJ2NoaWxkcmVuJywgJ2xhbmd1YWdlJ10pIHtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gZm9ybWF0dGluZy5ibG9ja1R5cGVzLmNvZGUuc2NoZW1hKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke2tleX1cIiBjYW5ub3QgYmUgYSBrZXkgaW4gdGhlIHNjaGVtYSBmb3IgY29kZSBibG9ja3NgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNjaGVtYTogb2JqZWN0KGZvcm1hdHRpbmcuYmxvY2tUeXBlcy5jb2RlLnNjaGVtYSlcbiAgICAgICAgICB9O1xuICAgICAgICB9KSgpXG4gICAgICB9LFxuICAgICAgaGVhZGluZ3M6IChfb2JqJHNjaGVtYSA9PiB7XG4gICAgICAgIGNvbnN0IG9wdCA9IGZvcm1hdHRpbmcgPT09IG51bGwgfHwgZm9ybWF0dGluZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9ybWF0dGluZy5oZWFkaW5nTGV2ZWxzO1xuICAgICAgICBjb25zdCBvYmogPSB0eXBlb2Ygb3B0ID09PSAnb2JqZWN0JyAmJiAnbGV2ZWxzJyBpbiBvcHQgPyBvcHQgOiB7XG4gICAgICAgICAgbGV2ZWxzOiBvcHQsXG4gICAgICAgICAgc2NoZW1hOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9iai5zY2hlbWEpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBbJ3R5cGUnLCAnY2hpbGRyZW4nLCAnbGV2ZWwnLCAndGV4dEFsaWduJ10pIHtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gb2JqLnNjaGVtYSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtrZXl9XCIgY2Fubm90IGJlIGEga2V5IGluIHRoZSBzY2hlbWEgZm9yIGhlYWRpbmdzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGV2ZWxzOiBbLi4ubmV3IFNldChvYmoubGV2ZWxzID09PSB0cnVlID8gWzEsIDIsIDMsIDQsIDUsIDZdIDogb2JqLmxldmVscyldLFxuICAgICAgICAgIHNjaGVtYTogb2JqZWN0KChfb2JqJHNjaGVtYSA9IG9iai5zY2hlbWEpICE9PSBudWxsICYmIF9vYmokc2NoZW1hICE9PSB2b2lkIDAgPyBfb2JqJHNjaGVtYSA6IHt9KVxuICAgICAgICB9O1xuICAgICAgfSkoKSxcbiAgICAgIGlubGluZU1hcmtzOiBmb3JtYXR0aW5nLmlubGluZU1hcmtzID09PSB0cnVlID8ge1xuICAgICAgICBib2xkOiB0cnVlLFxuICAgICAgICBjb2RlOiB0cnVlLFxuICAgICAgICBpdGFsaWM6IHRydWUsXG4gICAgICAgIGtleWJvYXJkOiBmYWxzZSxcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBuYXRpdmVseSBpbiBtYXJrZG93blxuICAgICAgICBzdHJpa2V0aHJvdWdoOiB0cnVlLFxuICAgICAgICBzdWJzY3JpcHQ6IGZhbHNlLFxuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIG5hdGl2ZWx5IGluIG1hcmtkb3duXG4gICAgICAgIHN1cGVyc2NyaXB0OiBmYWxzZSxcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBuYXRpdmVseSBpbiBtYXJrZG93blxuICAgICAgICB1bmRlcmxpbmU6IGZhbHNlIC8vIG5vdCBzdXBwb3J0ZWQgbmF0aXZlbHkgaW4gbWFya2Rvd25cbiAgICAgIH0gOiB7XG4gICAgICAgIGJvbGQ6ICEhKChfZm9ybWF0dGluZyRpbmxpbmVNYXIgPSBmb3JtYXR0aW5nLmlubGluZU1hcmtzKSAhPT0gbnVsbCAmJiBfZm9ybWF0dGluZyRpbmxpbmVNYXIgIT09IHZvaWQgMCAmJiBfZm9ybWF0dGluZyRpbmxpbmVNYXIuYm9sZCksXG4gICAgICAgIGNvZGU6ICEhKChfZm9ybWF0dGluZyRpbmxpbmVNYXIyID0gZm9ybWF0dGluZy5pbmxpbmVNYXJrcykgIT09IG51bGwgJiYgX2Zvcm1hdHRpbmckaW5saW5lTWFyMiAhPT0gdm9pZCAwICYmIF9mb3JtYXR0aW5nJGlubGluZU1hcjIuY29kZSksXG4gICAgICAgIGl0YWxpYzogISEoKF9mb3JtYXR0aW5nJGlubGluZU1hcjMgPSBmb3JtYXR0aW5nLmlubGluZU1hcmtzKSAhPT0gbnVsbCAmJiBfZm9ybWF0dGluZyRpbmxpbmVNYXIzICE9PSB2b2lkIDAgJiYgX2Zvcm1hdHRpbmckaW5saW5lTWFyMy5pdGFsaWMpLFxuICAgICAgICBzdHJpa2V0aHJvdWdoOiAhISgoX2Zvcm1hdHRpbmckaW5saW5lTWFyNCA9IGZvcm1hdHRpbmcuaW5saW5lTWFya3MpICE9PSBudWxsICYmIF9mb3JtYXR0aW5nJGlubGluZU1hcjQgIT09IHZvaWQgMCAmJiBfZm9ybWF0dGluZyRpbmxpbmVNYXI0LnN0cmlrZXRocm91Z2gpLFxuICAgICAgICB1bmRlcmxpbmU6ICEhKChfZm9ybWF0dGluZyRpbmxpbmVNYXI1ID0gZm9ybWF0dGluZy5pbmxpbmVNYXJrcykgIT09IG51bGwgJiYgX2Zvcm1hdHRpbmckaW5saW5lTWFyNSAhPT0gdm9pZCAwICYmIF9mb3JtYXR0aW5nJGlubGluZU1hcjUudW5kZXJsaW5lKSxcbiAgICAgICAga2V5Ym9hcmQ6ICEhKChfZm9ybWF0dGluZyRpbmxpbmVNYXI2ID0gZm9ybWF0dGluZy5pbmxpbmVNYXJrcykgIT09IG51bGwgJiYgX2Zvcm1hdHRpbmckaW5saW5lTWFyNiAhPT0gdm9pZCAwICYmIF9mb3JtYXR0aW5nJGlubGluZU1hcjYua2V5Ym9hcmQpLFxuICAgICAgICBzdWJzY3JpcHQ6ICEhKChfZm9ybWF0dGluZyRpbmxpbmVNYXI3ID0gZm9ybWF0dGluZy5pbmxpbmVNYXJrcykgIT09IG51bGwgJiYgX2Zvcm1hdHRpbmckaW5saW5lTWFyNyAhPT0gdm9pZCAwICYmIF9mb3JtYXR0aW5nJGlubGluZU1hcjcuc3Vic2NyaXB0KSxcbiAgICAgICAgc3VwZXJzY3JpcHQ6ICEhKChfZm9ybWF0dGluZyRpbmxpbmVNYXI4ID0gZm9ybWF0dGluZy5pbmxpbmVNYXJrcykgIT09IG51bGwgJiYgX2Zvcm1hdHRpbmckaW5saW5lTWFyOCAhPT0gdm9pZCAwICYmIF9mb3JtYXR0aW5nJGlubGluZU1hcjguc3VwZXJzY3JpcHQpXG4gICAgICB9LFxuICAgICAgbGlzdFR5cGVzOiBmb3JtYXR0aW5nLmxpc3RUeXBlcyA9PT0gdHJ1ZSA/IHtcbiAgICAgICAgb3JkZXJlZDogdHJ1ZSxcbiAgICAgICAgdW5vcmRlcmVkOiB0cnVlXG4gICAgICB9IDoge1xuICAgICAgICBvcmRlcmVkOiAhISgoX2Zvcm1hdHRpbmckbGlzdFR5cGVzID0gZm9ybWF0dGluZy5saXN0VHlwZXMpICE9PSBudWxsICYmIF9mb3JtYXR0aW5nJGxpc3RUeXBlcyAhPT0gdm9pZCAwICYmIF9mb3JtYXR0aW5nJGxpc3RUeXBlcy5vcmRlcmVkKSxcbiAgICAgICAgdW5vcmRlcmVkOiAhISgoX2Zvcm1hdHRpbmckbGlzdFR5cGVzMiA9IGZvcm1hdHRpbmcubGlzdFR5cGVzKSAhPT0gbnVsbCAmJiBfZm9ybWF0dGluZyRsaXN0VHlwZXMyICE9PSB2b2lkIDAgJiYgX2Zvcm1hdHRpbmckbGlzdFR5cGVzMi51bm9yZGVyZWQpXG4gICAgICB9LFxuICAgICAgc29mdEJyZWFrczogISFmb3JtYXR0aW5nLnNvZnRCcmVha3NcbiAgICB9LFxuICAgIGxpbmtzOiAhIWNvbmZpZy5saW5rcyxcbiAgICBsYXlvdXRzOiBbLi4ubmV3IFNldCgoY29uZmlnLmxheW91dHMgfHwgW10pLm1hcCh4ID0+IEpTT04uc3RyaW5naWZ5KHgpKSldLm1hcCh4ID0+IEpTT04ucGFyc2UoeCkpLFxuICAgIGRpdmlkZXJzOiAhIWNvbmZpZy5kaXZpZGVycyxcbiAgICBpbWFnZXM6IGltYWdlc0NvbmZpZyA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiB7XG4gICAgICAuLi5pbWFnZXNDb25maWcsXG4gICAgICBzY2hlbWE6IHtcbiAgICAgICAgYWx0OiAoX2ltYWdlc0NvbmZpZyRzY2hlbWEkID0gKF9pbWFnZXNDb25maWckc2NoZW1hID0gaW1hZ2VzQ29uZmlnLnNjaGVtYSkgPT09IG51bGwgfHwgX2ltYWdlc0NvbmZpZyRzY2hlbWEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9pbWFnZXNDb25maWckc2NoZW1hLmFsdCkgIT09IG51bGwgJiYgX2ltYWdlc0NvbmZpZyRzY2hlbWEkICE9PSB2b2lkIDAgPyBfaW1hZ2VzQ29uZmlnJHNjaGVtYSQgOiBkZWZhdWx0QWx0RmllbGQsXG4gICAgICAgIHRpdGxlOiAoX2ltYWdlc0NvbmZpZyRzY2hlbWEkMiA9IChfaW1hZ2VzQ29uZmlnJHNjaGVtYTIgPSBpbWFnZXNDb25maWcuc2NoZW1hKSA9PT0gbnVsbCB8fCBfaW1hZ2VzQ29uZmlnJHNjaGVtYTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9pbWFnZXNDb25maWckc2NoZW1hMi50aXRsZSkgIT09IG51bGwgJiYgX2ltYWdlc0NvbmZpZyRzY2hlbWEkMiAhPT0gdm9pZCAwID8gX2ltYWdlc0NvbmZpZyRzY2hlbWEkMiA6IGVtcHR5VGl0bGVGaWVsZFxuICAgICAgfVxuICAgIH0sXG4gICAgdGFibGVzOiAhIWNvbmZpZy50YWJsZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIGRvY3VtZW50JDEoe1xuICBsYWJlbCxcbiAgY29tcG9uZW50QmxvY2tzID0ge30sXG4gIGRlc2NyaXB0aW9uLFxuICAuLi5kb2N1bWVudEZlYXR1cmVzQ29uZmlnXG59KSB7XG4gIGNvbnN0IGRvY3VtZW50RmVhdHVyZXMgPSBub3JtYWxpc2VEb2N1bWVudEZlYXR1cmVzKGRvY3VtZW50RmVhdHVyZXNDb25maWcpO1xuICBjb25zdCBwYXJzZSA9IG1vZGUgPT4gKF92YWx1ZSwgZGF0YSkgPT4ge1xuICAgIGNvbnN0IG1hcmtkb2MgPSB0ZXh0RGVjb2Rlci5kZWNvZGUoZGF0YS5jb250ZW50KTtcbiAgICBjb25zdCBkb2N1bWVudCA9IGZyb21NYXJrZG9jKE1hcmtkb2MucGFyc2UobWFya2RvYyksIGNvbXBvbmVudEJsb2Nrcyk7XG4gICAgY29uc3QgZWRpdG9yID0gY3JlYXRlRG9jdW1lbnRFZGl0b3JGb3JOb3JtYWxpemF0aW9uKGRvY3VtZW50RmVhdHVyZXMsIGNvbXBvbmVudEJsb2Nrcyk7XG4gICAgZWRpdG9yLmNoaWxkcmVuID0gZG9jdW1lbnQ7XG4gICAgRWRpdG9yLm5vcm1hbGl6ZShlZGl0b3IsIHtcbiAgICAgIGZvcmNlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGRlc2VyaWFsaXplRmlsZXMoZWRpdG9yLmNoaWxkcmVuLCBjb21wb25lbnRCbG9ja3MsIGRhdGEub3RoZXIsIGRhdGEuZXh0ZXJuYWwgfHwgbmV3IE1hcCgpLCBtb2RlLCBkb2N1bWVudEZlYXR1cmVzLCBkYXRhLnNsdWcpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIGtpbmQ6ICdmb3JtJyxcbiAgICBmb3JtS2luZDogJ2NvbnRlbnQnLFxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgdGV4dDogJydcbiAgICAgICAgfV1cbiAgICAgIH1dO1xuICAgIH0sXG4gICAgSW5wdXQocHJvcHMpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovanN4KERvY3VtZW50RmllbGRJbnB1dCwge1xuICAgICAgICBjb21wb25lbnRCbG9ja3M6IGNvbXBvbmVudEJsb2NrcyxcbiAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgIGRvY3VtZW50RmVhdHVyZXM6IGRvY3VtZW50RmVhdHVyZXMsXG4gICAgICAgIC4uLnByb3BzXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHBhcnNlOiBwYXJzZSgnZWRpdCcpLFxuICAgIGNvbnRlbnRFeHRlbnNpb246ICcubWRvYycsXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIGRpcmVjdG9yaWVzOiBbLi4uY29sbGVjdERpcmVjdG9yaWVzVXNlZEluU2NoZW1hKG9iamVjdChPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoY29tcG9uZW50QmxvY2tzKS5tYXAoKFtuYW1lLCBibG9ja10pID0+IFtuYW1lLCBvYmplY3QoYmxvY2suc2NoZW1hKV0pKSkpLCAuLi4odHlwZW9mIGRvY3VtZW50RmVhdHVyZXMuaW1hZ2VzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZG9jdW1lbnRGZWF0dXJlcy5pbWFnZXMuZGlyZWN0b3J5ID09PSAnc3RyaW5nJyA/IFtmaXhQYXRoKGRvY3VtZW50RmVhdHVyZXMuaW1hZ2VzLmRpcmVjdG9yeSldIDogW10pXSxcbiAgICBzZXJpYWxpemUodmFsdWUsIG9wdHMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZXh0cmFGaWxlcyxcbiAgICAgICAgbm9kZVxuICAgICAgfSA9IHRvTWFya2RvY0RvY3VtZW50KHZhbHVlLCB7XG4gICAgICAgIGNvbXBvbmVudEJsb2NrcyxcbiAgICAgICAgZG9jdW1lbnRGZWF0dXJlcyxcbiAgICAgICAgc2x1Zzogb3B0cy5zbHVnXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG90aGVyID0gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgZXh0ZXJuYWwgPSBuZXcgTWFwKCk7XG4gICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZXh0cmFGaWxlcykge1xuICAgICAgICBpZiAoZmlsZS5wYXJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG90aGVyLnNldChmaWxlLnBhdGgsIGZpbGUuY29udGVudHMpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXh0ZXJuYWwuaGFzKGZpbGUucGFyZW50KSkge1xuICAgICAgICAgIGV4dGVybmFsLnNldChmaWxlLnBhcmVudCwgbmV3IE1hcCgpKTtcbiAgICAgICAgfVxuICAgICAgICBleHRlcm5hbC5nZXQoZmlsZS5wYXJlbnQpLnNldChmaWxlLnBhdGgsIGZpbGUuY29udGVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udGVudDogdGV4dEVuY29kZXIuZW5jb2RlKE1hcmtkb2MuZm9ybWF0KE1hcmtkb2MucGFyc2UoTWFya2RvYy5mb3JtYXQobm9kZSkpKSksXG4gICAgICAgIG90aGVyLFxuICAgICAgICBleHRlcm5hbCxcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9LFxuICAgIHJlYWRlcjoge1xuICAgICAgcGFyc2U6IHBhcnNlKCdyZWFkJylcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCB7IGdldFNsdWdHbG9iRm9yQ29sbGVjdGlvbiBhcyBBLCBnZXRDb2xsZWN0aW9uRm9ybWF0IGFzIEIsIGdldENvbGxlY3Rpb25JdGVtUGF0aCBhcyBDLCBnZXREYXRhRmlsZUV4dGVuc2lvbiBhcyBELCBnZXRSZXBvVXJsIGFzIEUsIGtleWVkRW50cmllcyBhcyBGLCBub2RlVHlwZU1hdGNoZXIgYXMgRywgZ2V0U3BsaXRDbG91ZFByb2plY3QgYXMgSCwgZ2V0U2luZ2xldG9uRm9ybWF0IGFzIEksIEZpZWxkRGF0YUVycm9yIGFzIEosIEtFWVNUQVRJQ19DTE9VRF9BUElfVVJMIGFzIEssIGJhc2ljRm9ybUZpZWxkV2l0aFNpbXBsZVJlYWRlclBhcnNlIGFzIEwsIGFzc2VydFJlcXVpcmVkIGFzIE0sIGdldFNyY1ByZWZpeCBhcyBOLCBmaXhQYXRoIGFzIE8sIHZhbGlkYXRlVGV4dCBhcyBQLCB0ZXh0IGFzIFEsIGRvY3VtZW50JDEgYXMgUiwgc2hhMSBhcyBTLCBnZXRWYWx1ZUF0UHJvcFBhdGggYXMgVCwgS0VZU1RBVElDX0NMT1VEX0hFQURFUlMgYXMgYSwgZ2V0RW50cmllc0luQ29sbGVjdGlvbldpdGhUcmVlS2V5IGFzIGIsIGdldFNpbmdsZXRvblBhdGggYXMgYywgZ2V0VHJlZU5vZGVBdFBhdGggYXMgZCwgdHJlZVNoYSBhcyBlLCBpc0Nsb3VkQ29uZmlnIGFzIGYsIGdldFBhdGhQcmVmaXggYXMgZywgZ2V0Q29sbGVjdGlvblBhdGggYXMgaCwgaXNHaXRIdWJDb25maWcgYXMgaSwgaXNMb2NhbENvbmZpZyBhcyBqLCBnZXRLZXlzRm9yQXJyYXlWYWx1ZSBhcyBrLCBnZXRTbHVnRnJvbVN0YXRlIGFzIGwsIGdldEJyYW5jaFByZWZpeCBhcyBtLCBnZXRJbml0aWFsUHJvcHNWYWx1ZSBhcyBuLCBnZXRFbnRyeURhdGFGaWxlcGF0aCBhcyBvLCBwbHVyYWxpemUgYXMgcCwgb2JqZWN0IGFzIHEsIHJlZGlyZWN0VG9DbG91ZEF1dGggYXMgciwgc2V0S2V5c0ZvckFycmF5VmFsdWUgYXMgcywgdHJlZUVudHJpZXNUb1RyZWVOb2RlcyBhcyB0LCB1cGRhdGVWYWx1ZSBhcyB1LCBnZXREaXJlY3Rvcmllc0ZvclRyZWVLZXkgYXMgdiwgZ2V0VHJlZUtleSBhcyB3LCBibG9iU2hhIGFzIHgsIHVwZGF0ZVRyZWVXaXRoQ2hhbmdlcyBhcyB5LCBzZXJpYWxpemVQcm9wcyBhcyB6IH07XG4iXSwibmFtZXMiOlsiTWFya2RvYyIsIkFzdCIsIlRleHQiLCJFbGVtZW50IiwiRWxlbWVudCQxIiwiVHJhbnNmb3JtcyIsIkVkaXRvciIsIk5vZGUiLCJQYXRoIiwiUmFuZ2UiLCJQb2ludCIsImNyZWF0ZUVkaXRvciIsImFzc2VydE5ldmVyIiwiYXNzZXJ0TmV2ZXIkMSIsImFzc2VydCIsImFzc2VydCQxIiwiZnJvbVVpbnQ4QXJyYXkiLCJjcmVhdGVIYXNoIiwiVCIsIlRleHRGaWVsZElucHV0IiwiRCIsIkRvY3VtZW50RmllbGRJbnB1dCIsImpzeCIsIndlYWtNZW1vaXplIiwiZml4UGF0aCIsInBhdGgiLCJyZXBsYWNlIiwiY29sbGVjdGlvblBhdGgiLCJnZXRDb25maWd1cmVkQ29sbGVjdGlvblBhdGgiLCJjb25maWciLCJjb2xsZWN0aW9uIiwiX2NvbGxlY3Rpb25Db25maWckcGF0IiwiY29sbGVjdGlvbkNvbmZpZyIsImNvbGxlY3Rpb25zIiwidGVzdCIsIkVycm9yIiwiZ2V0Q29sbGVjdGlvblBhdGgiLCJjb25maWd1cmVkUGF0aCIsImdldENvbGxlY3Rpb25Gb3JtYXQiLCJfY29sbGVjdGlvbkNvbmZpZyRmb3IiLCJnZXRGb3JtYXRJbmZvIiwiZm9ybWF0Iiwic2NoZW1hIiwiZ2V0U2luZ2xldG9uRm9ybWF0Iiwic2luZ2xldG9uIiwiX3NpbmdsZXRvbkNvbmZpZyRmb3JtIiwiX3NpbmdsZXRvbkNvbmZpZyRwYXRoIiwic2luZ2xldG9uQ29uZmlnIiwic2luZ2xldG9ucyIsImdldENvbGxlY3Rpb25JdGVtUGF0aCIsInNsdWciLCJiYXNlUGF0aCIsInN1ZmZpeCIsImdldENvbGxlY3Rpb25JdGVtU2x1Z1N1ZmZpeCIsImdldEVudHJ5RGF0YUZpbGVwYXRoIiwiZGlyIiwiZm9ybWF0SW5mbyIsImRhdGFMb2NhdGlvbiIsImdldERhdGFGaWxlRXh0ZW5zaW9uIiwiZ2V0U2x1Z0dsb2JGb3JDb2xsZWN0aW9uIiwiaW5jbHVkZXMiLCJnZXRTaW5nbGV0b25QYXRoIiwiX3NpbmdsZXRvbiRwYXRoIiwiX3NpbmdsZXRvbiRwYXRoMiIsImNvbnRlbnRGaWVsZCIsImNvbnRlbnRFeHRlbnNpb24iLCJkYXRhIiwiX2Zvcm1hdCRkYXRhIiwiZW5kc1dpdGgiLCJ1bmRlZmluZWQiLCJmaWVsZCIsImtpbmQiLCJmb3JtS2luZCIsImtleSIsImdldFBhdGhQcmVmaXgiLCJzdG9yYWdlIiwicGF0aFByZWZpeCIsInNoYTEiLCJjb250ZW50IiwidXBkYXRlIiwiZGlnZXN0IiwidGV4dEVuY29kZXIkMiIsIlRleHRFbmNvZGVyIiwiYmxvYlNoYSIsImNvbnRlbnRzIiwiYmxvYlByZWZpeCIsImVuY29kZSIsImxlbmd0aCIsImFycmF5IiwiVWludDhBcnJheSIsImJ5dGVMZW5ndGgiLCJzZXQiLCJnZXRUcmVlTm9kZUF0UGF0aCIsInJvb3QiLCJwYXJ0cyIsInNwbGl0Iiwibm9kZSIsImdldCIsInBhcnQiLCJzbGljZSIsImNoaWxkcmVuIiwiZ2V0Tm9kZUF0UGF0aCIsInRyZWUiLCJoYXMiLCJNYXAiLCJpbm5lck5vZGUiLCJnZXRGaWxlbmFtZSIsImdldERpcm5hbWUiLCJ0b1RyZWVDaGFuZ2VzIiwiY2hhbmdlcyIsImNoYW5nZXNSb290IiwiZGVsZXRpb24iLCJkZWxldGlvbnMiLCJwYXJlbnRUcmVlIiwiYWRkaXRpb24iLCJhZGRpdGlvbnMiLCJTUEFDRV9DSEFSX0NPREUiLCJzcGFjZSIsIm51bGxjaGFyIiwidHJlZVNoYSIsImVudHJpZXMiLCJtYXAiLCJuYW1lIiwic2hhIiwiZW50cnkiLCJtb2RlIiwic29ydCIsImEiLCJiIiwiYU5hbWUiLCJiTmFtZSIsInRyZWVPYmplY3QiLCJmbGF0TWFwIiwiaGV4VG9CeXRlcyIsImNvbmNhdEJ5dGVzIiwicmVkdWNlIiwic3VtIiwidmFsIiwidG9TdHJpbmciLCJieXRlQXJyYXlzIiwidG90YWxMZW5ndGgiLCJhcnIiLCJyZXN1bHQiLCJvZmZzZXQiLCJzdHIiLCJieXRlcyIsImkiLCJzdGFydCIsInBhcnNlSW50IiwiY3JlYXRlVHJlZU5vZGVFbnRyeSIsInR5cGUiLCJjcmVhdGVCbG9iTm9kZUVudHJ5Iiwic2l6ZSIsInVwZGF0ZVRyZWVXaXRoQ2hhbmdlcyIsIl9hd2FpdCR1cGRhdGVUcmVlIiwibmV3VHJlZSIsInVwZGF0ZVRyZWUiLCJ0cmVlVG9FbnRyaWVzIiwidmFsdWVzIiwieCIsImNoYW5nZWRUcmVlIiwidmFsdWUiLCJkZWxldGUiLCJfbmV3VHJlZSRnZXQkY2hpbGRyZW4iLCJfbmV3VHJlZSRnZXQiLCJleGlzdGluZ0NoaWxkcmVuIiwiY29uY2F0Iiwiam9pbiIsInRyZWVFbnRyaWVzVG9UcmVlTm9kZXMiLCJnZXRDaGlsZHJlbkF0UGF0aCIsIl9ub2RlIiwiY29sbGVjdERpcmVjdG9yaWVzVXNlZEluU2NoZW1hSW5uZXIiLCJkaXJlY3RvcmllcyIsInNlZW5TY2hlbWFzIiwiYWRkIiwiZWxlbWVudCIsImRpcmVjdG9yeSIsIk9iamVjdCIsImZpZWxkcyIsImlubmVyU2NoZW1hIiwiY29sbGVjdERpcmVjdG9yaWVzVXNlZEluU2NoZW1hIiwiU2V0IiwiZ2V0RGlyZWN0b3JpZXNGb3JUcmVlS2V5IiwicHVzaCIsInRvQWRkIiwiZ2V0VHJlZUtleSIsImQiLCJfZ2V0VHJlZU5vZGVBdFBhdGgiLCJwa2dKc29uIiwidmVyc2lvbiIsImxpY2Vuc2UiLCJyZXBvc2l0b3J5IiwidXJsIiwiZXhwb3J0cyIsInR5cGVzIiwibW9kdWxlIiwibWFpbiIsImZpbGVzIiwic2NyaXB0cyIsInNldHVwIiwiYnVpbGQiLCJkZXYiLCJkZXBlbmRlbmNpZXMiLCJjb29raWUiLCJlbWVyeSIsImdyYXBocWwiLCJpZ25vcmUiLCJtaW5pbWF0Y2giLCJzbGF0ZSIsInVycWwiLCJ6b2QiLCJkZXZEZXBlbmRlbmNpZXMiLCJlc2xpbnQiLCJvdXRkZW50IiwicHJpc21qcyIsInJlYWN0IiwidHN4IiwidHlwZXNjcmlwdCIsInBlZXJEZXBlbmRlbmNpZXMiLCJwcmVjb25zdHJ1Y3QiLCJlbnRyeXBvaW50cyIsImFkZFR5cGVuYW1lIiwic2NhbGFycyIsIkdpdE9iamVjdElEIiwiaW1wb3J0cyIsIm9iamVjdCIsIm9wdHMiLCJwbHVyYWxpemUiLCJjb3VudCIsIm9wdGlvbnMiLCJzaW5ndWxhciIsInBsdXJhbCIsImluY2x1c2l2ZSIsInZhcmlhbnQiLCJnZXRCcmFuY2hQcmVmaXgiLCJicmFuY2hQcmVmaXgiLCJrZXllZEVudHJpZXMiLCJvYmoiLCJpc0dpdEh1YkNvbmZpZyIsImlzTG9jYWxDb25maWciLCJpc0Nsb3VkQ29uZmlnIiwiX2NvbmZpZyRjbG91ZCIsImNsb3VkIiwicHJvamVjdCIsImdldFNwbGl0Q2xvdWRQcm9qZWN0IiwiX2NvbmZpZyRjbG91ZDIiLCJ0ZWFtIiwiZ2V0UmVwb1BhdGgiLCJtYWluT3duZXIiLCJtYWluUmVwbyIsImdldFJlcG9VcmwiLCJnZXRTbHVnRnJvbVN0YXRlIiwic3RhdGUiLCJzbHVnRmllbGQiLCJzZXJpYWxpemVXaXRoU2x1ZyIsImdldEVudHJpZXNJbkNvbGxlY3Rpb25XaXRoVHJlZUtleSIsInJvb3RUcmVlIiwiX2dldFRyZWVOb2RlQXRQYXRoJGNoIiwiZXh0ZW5zaW9uIiwiZ2xvYiIsImRpcmVjdG9yaWVzVXNlZEluU2NoZW1hIiwicG9zc2libGVFbnRyaWVzIiwiaGFuZGxlRGlyZWN0b3J5IiwicHJlZml4IiwiX2FjdHVhbEVudHJ5JGNoaWxkcmVuIiwiYWN0dWFsRW50cnkiLCJuZXdFbnRyeSIsIktFWVNUQVRJQ19DTE9VRF9BUElfVVJMIiwiS0VZU1RBVElDX0NMT1VEX0hFQURFUlMiLCJ0ZXh0RW5jb2RlciQxIiwicmVkaXJlY3RUb0Nsb3VkQXV0aCIsImZyb20iLCJfY29uZmlnJGNsb3VkMyIsImNvZGVfdmVyaWZpZXIiLCJjcnlwdG8iLCJnZXRSYW5kb21WYWx1ZXMiLCJjb2RlX2NoYWxsZW5nZSIsInN1YnRsZSIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJKU09OIiwic3RyaW5naWZ5IiwiVVJMIiwic2VhcmNoUGFyYW1zIiwid2luZG93IiwibG9jYXRpb24iLCJvcmlnaW4iLCJocmVmIiwiRmllbGREYXRhRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJhc3NlcnRSZXF1aXJlZCIsInZhbGlkYXRpb24iLCJsYWJlbCIsImlzUmVxdWlyZWQiLCJiYXNpY0Zvcm1GaWVsZFdpdGhTaW1wbGVSZWFkZXJQYXJzZSIsIklucHV0IiwiZGVmYXVsdFZhbHVlIiwicGFyc2UiLCJzZXJpYWxpemUiLCJ2YWxpZGF0ZSIsInJlYWRlciIsImFycmF5VmFsdWVzVG9FbGVtZW50S2V5cyIsIldlYWtNYXAiLCJjb3VudGVyIiwiZ2V0S2V5c0ZvckFycmF5VmFsdWUiLCJBcnJheSIsImdldE5ld0FycmF5RWxlbWVudEtleSIsInNldEtleXNGb3JBcnJheVZhbHVlIiwiZWxlbWVudElkcyIsImdldEluaXRpYWxQcm9wc1ZhbHVlIiwiX2dldEluaXRpYWxQcm9wc1ZhbHVlIiwiZGlzY3JpbWluYW50Iiwia2V5cyIsImdldEluaXRpYWxQcm9wc1ZhbHVlRnJvbUluaXRpYWxpemVyIiwiaW5pdGlhbGl6ZXIiLCJ1cGRhdGVWYWx1ZSIsImN1cnJlbnRWYWx1ZSIsInVwZGF0ZXIiLCJjdXJyZW50QXJyVmFsIiwibmV3VmFsIiwidW5pcXVlS2V5cyIsImVsZW1lbnRLZXkiLCJwcmV2S2V5cyIsInByZXZWYWx1ZXNCeUtleSIsImlkIiwiZ2V0VmFsdWVBdFByb3BQYXRoIiwiaW5wdXRQYXRoIiwic2hpZnQiLCJ0cmF2ZXJzZVByb3BzIiwidmlzaXRvciIsImNoaWxkUHJvcCIsImlkeCIsInRyYW5zZm9ybVByb3BzIiwidmlzaXRvcnMiLCJmcm9tRW50cmllcyIsImNvbmRpdGlvbmFsVmFsIiwiY29uZGl0aW9uYWwiLCJyZXBsYWNlVmFsdWVBdFByb3BQYXRoIiwibmV3VmFsdWUiLCJuZXdQYXRoIiwiY29uZGl0aW9uYWxWYWx1ZSIsInByZXZWYWwiLCJjdXJyZW50bHlBY3RpdmVNYXJrcyIsImN1cnJlbnRseURpc2FibGVkTWFya3MiLCJjdXJyZW50TGluayIsImFkZE1hcmtUb0NoaWxkcmVuIiwibWFyayIsImNiIiwid2FzUHJldmlvdXNseUFjdGl2ZSIsInNldExpbmtGb3JDaGlsZHJlbiIsImdldElubGluZU5vZGVzIiwidGV4dCIsIlZhcmlhYmxlQ2hpbGRGaWVsZHMiLCJmaW5kU2luZ2xlQ2hpbGRGaWVsZCIsIl9maW5kQ29uc3RhbnRDaGlsZEZpZWxkcyIsImVyciIsInJlbGF0aXZlUGF0aCIsImNvdWxkQ29udGFpbkNoaWxkRmllbGQiLCJhc0NoaWxkVGFnIiwiY2hpbGQiLCJwYXRocyIsInNlZW4iLCJzb21lIiwiaW5saW5lTm9kZUZyb21NYXJrZG9jIiwiaW5saW5lQ2hpbGRyZW5Gcm9tTWFya2RvYyIsImF0dHJpYnV0ZXMiLCJjb2RlIiwidGFnIiwiaXNBcnJheSIsInByb3BQYXRoIiwiZXZlcnkiLCJpbmxpbmVGcm9tTWFya2RvYyIsIm5vZGVzIiwidHJhbnNmb3JtZWROb2RlcyIsIm5leHROb2RlcyIsImxhc3ROb2RlIiwiX2xhc3ROb2RlIiwiZnJvbU1hcmtkb2MiLCJjb21wb25lbnRCbG9ja3MiLCJmcm9tTWFya2RvY05vZGUiLCJsYW5ndWFnZSIsInJlc3QiLCJsZXZlbCIsIm9yZGVyZWQiLCJfbm9kZSRjaGlsZHJlbiQiLCJsaXN0IiwiX2ltYWdlJGF0dHJpYnV0ZXMkdGl0IiwiaW1hZ2UiLCJzcmMiLCJkZWNvZGVVUkkiLCJhbHQiLCJ0aXRsZSIsInRleHRBbGlnbiIsImhlYWRlciIsImxheW91dCIsImNvbXBvbmVudCIsInByb3BzIiwiY29tcG9uZW50QmxvY2siLCJzaW5nbGVDaGlsZEZpZWxkIiwibmV3QXR0cmlidXRlcyIsInRvQ2hpbGRyZW5BbmRQcm9wcyQxIiwicmVzdWx0aW5nQ2hpbGRyZW4iLCJwYXJlbnRQcm9wUGF0aCIsInBhcmVudCIsImFyZUFycmF5c0VxdWFsIiwibm9ybWFsaXplVGV4dEJhc2VkT25JbmxpbmVNYXJrc0FuZFNvZnRCcmVha3MiLCJlZGl0b3IiLCJpbmxpbmVNYXJrcyIsInNvZnRCcmVha3MiLCJtYXJrc1RvUmVtb3ZlIiwiZmlsdGVyIiwidW5zZXROb2RlcyIsImF0IiwiaGFzU29mdEJyZWFrcyIsInBhcmVudE5vZGUiLCJwb3NpdGlvbiIsInBvc2l0aW9ucyIsImNoYXJhY3RlciIsIm5vcm1hbGl6ZUlubGluZUJhc2VkT25MaW5rcyIsImxpbmtzIiwiaW5zZXJ0VGV4dCIsImVuZCIsInVud3JhcE5vZGVzIiwibm9ybWFsaXplRWxlbWVudEJhc2VkT25Eb2N1bWVudEZlYXR1cmVzIiwiZm9ybWF0dGluZyIsImRpdmlkZXJzIiwibGF5b3V0cyIsImltYWdlcyIsInRhYmxlcyIsImhlYWRpbmdzIiwibGV2ZWxzIiwibGlzdFR5cGVzIiwidW5vcmRlcmVkIiwiYmxvY2tUeXBlcyIsImJsb2NrcXVvdGUiLCJhbGlnbm1lbnQiLCJjZW50ZXIiLCJyZW1vdmVOb2RlcyIsIndpdGhEb2N1bWVudEZlYXR1cmVzTm9ybWFsaXphdGlvbiIsImRvY3VtZW50RmVhdHVyZXMiLCJub3JtYWxpemVOb2RlIiwiaXNUZXh0IiwiaXNFbGVtZW50IiwiZ2V0U3JjUHJlZml4IiwicHVibGljUGF0aCIsImRlc2VyaWFsaXplRmlsZXMiLCJvdGhlckZpbGVzIiwiZGVzZXJpYWxpemVQcm9wcyIsIl9yZWYiLCJnZXRTcmNQcmVmaXhGb3JJbWFnZUJsb2NrIiwiZmlsZW5hbWUiLCJmb3JtIiwiX290aGVyRmlsZXMkZ2V0Iiwic3VnZ2VzdGVkRmlsZW5hbWVQcmVmaXgiLCJhc3NldCIsInNlcmlhbGl6ZVByb3BzIiwicm9vdFZhbHVlIiwicm9vdFNjaGVtYSIsInNob3VsZFN1Z2dlc3RGaWxlbmFtZVByZWZpeCIsImV4dHJhRmlsZXMiLCJmb3JZYW1sIiwiZ2V0UHJvcFBhdGhQb3J0aW9uIiwib3RoZXIiLCJleHRlcm5hbCIsImFsbG93ZWREaXJlY3RvcmllcyIsImZpbGVDb250ZW50cyIsIl9zY2hlbWEiLCJfIiwicG9ydGlvbiIsInRvSW5saW5lIiwidG9NYXJrZG9jSW5saW5lIiwibWFya1RvTWFya2RvYyIsImJvbGQiLCJpdGFsaWMiLCJ1bmRlcmxpbmUiLCJrZXlib2FyZCIsInN0cmlrZXRocm91Z2giLCJzdWJzY3JpcHQiLCJzdXBlcnNjcmlwdCIsIm1hcmtzIiwibWFya2RvY05vZGUiLCJ0b01hcmtkb2NEb2N1bWVudCIsIl9jb25maWciLCJ0b01hcmtkb2MiLCJ0b0NoaWxkcmVuQW5kUHJvcHMiLCJjaGlsZHJlbkFzTWFya2RvYyIsImZpbmQiLCJ2YWx1ZUF0UHJvcFBhdGgiLCJjaGlsZE5vZGVzIiwiaW5uZXJQcm9wUGF0aCIsIm51bSIsIl9jaGlsZE5vZGVzJGdldCIsIm5ld0NoaWxkcmVuQXNNYXJrZG9jIiwiYW5ub3RhdGlvbnMiLCJlbmNvZGVVUkkiLCJleHRyYUF0dHJpYnV0ZXMiLCJzZXJpYWxpemVkIiwiYXNzaWduIiwiX3RvTWFya2RvYyIsImhlYWQiLCJpc1ZvaWQiLCJsaXN0SXRlbUNvbnRlbnQiLCJpbmxpbmUiLCJuZXN0ZWRMaXN0IiwidmFsaWRhdGVUZXh0IiwibWluIiwibWF4IiwiZmllbGRMYWJlbCIsInNsdWdJbmZvIiwicyIsInNsdWdzIiwicGFyc2VBc05vcm1hbEZpZWxkIiwiZW1wdHlTZXQiLCJJbmZpbml0eSIsImRlc2NyaXB0aW9uIiwibXVsdGlsaW5lIiwiYXJncyIsInBhcnNlZCIsInBhcnNlV2l0aFNsdWciLCJfdmFsdWUiLCJ0YWJsZUNlbGxDaGlsZHJlbiIsImJsb2NrcXVvdGVDaGlsZHJlbiIsInBhcmFncmFwaExpa2UiLCJpbnNpZGVPZkxheW91dHMiLCJibG9ja0NvbnRhaW5lciIsImFsbG93ZWRDaGlsZHJlbiIsImJsb2NrVG9XcmFwSW5saW5lc0luIiwiaW52YWxpZFBvc2l0aW9uSGFuZGxlTW9kZSIsImlubGluZUNvbnRhaW5lciIsInNhdGlzZmllcyIsImVkaXRvclNjaGVtYSIsInBhcmFncmFwaCIsImRpdmlkZXIiLCJoZWFkaW5nIiwidGFibGUiLCJpbmxpbmVDb250YWluZXJUeXBlcyIsImlzSW5saW5lQ29udGFpbmVyIiwiaXNCbG9jayIsImdldERvY3VtZW50RmVhdHVyZXNGb3JDaGlsZEZpZWxkIiwiZWRpdG9yRG9jdW1lbnRGZWF0dXJlcyIsIl9vcHRpb25zJGZvcm1hdHRpbmciLCJfb3B0aW9ucyRmb3JtYXR0aW5nMyIsIl9vcHRpb25zJGZvcm1hdHRpbmc0IiwiX29wdGlvbnMkZm9ybWF0dGluZzUiLCJfb3B0aW9ucyRmb3JtYXR0aW5nNiIsIl9vcHRpb25zJGZvcm1hdHRpbmc3IiwiaW5saW5lTWFya3NGcm9tT3B0aW9ucyIsIl9vcHRpb25zJGZvcm1hdHRpbmcyIiwiaGVhZGluZ0xldmVscyIsImdldFNjaGVtYUF0UHJvcFBhdGhJbm5lciIsInByb3BWYWwiLCJpbmRleCIsImdldFNjaGVtYUF0UHJvcFBhdGgiLCJnZXRBbmNlc3RvclNjaGVtYXMiLCJhbmNlc3RvcnMiLCJjdXJyZW50UGF0aCIsImN1cnJlbnRQcm9wIiwibW92ZUNoaWxkcmVuIiwidG8iLCJzaG91bGRNb3ZlTm9kZSIsInBhcmVudFBhdGgiLCJpc1BhdGgiLCJjaGlsZFBhdGgiLCJtb3ZlTm9kZXMiLCJFZGl0b3JBZnRlckJ1dElnbm9yaW5naW5nUG9pbnRzV2l0aE5vQ29udGVudCIsImRpc3RhbmNlIiwiYW5jaG9yIiwicG9pbnQiLCJlZGdlIiwiZm9jdXMiLCJyYW5nZSIsInRhcmdldCIsInAiLCJub2RlVHlwZU1hdGNoZXIiLCJnZXRBbmNlc3RvckNvbXBvbmVudENoaWxkRmllbGREb2N1bWVudEZlYXR1cmVzIiwiYW5jZXN0b3JDb21wb25lbnRQcm9wIiwiYWJvdmUiLCJtYXRjaCIsImFuY2VzdG9yQ29tcG9uZW50IiwiY2hpbGRGaWVsZCIsImdsb2JhbFRoaXMiLCJQcmlzbSIsIm1hbnVhbCIsIl9zZWxmIiwibGFuZyIsInVuaXF1ZUlkIiwicGxhaW5UZXh0R3JhbW1hciIsImRpc2FibGVXb3JrZXJNZXNzYWdlSGFuZGxlciIsInV0aWwiLCJ0b2tlbnMiLCJUb2tlbiIsImFsaWFzIiwibyIsInByb3RvdHlwZSIsImNhbGwiLCJvYmpJZCIsImRlZmluZVByb3BlcnR5IiwiY2xvbmUiLCJkZWVwQ2xvbmUiLCJ2aXNpdGVkIiwiaGFzT3duUHJvcGVydHkiLCJmb3JFYWNoIiwidiIsImdldExhbmd1YWdlIiwibSIsImV4ZWMiLCJjbGFzc05hbWUiLCJ0b0xvd2VyQ2FzZSIsInBhcmVudEVsZW1lbnQiLCJzZXRMYW5ndWFnZSIsIlJlZ0V4cCIsImNsYXNzTGlzdCIsImN1cnJlbnRTY3JpcHQiLCJkb2N1bWVudCIsInN0YWNrIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpc0FjdGl2ZSIsImRlZmF1bHRBY3RpdmF0aW9uIiwibm8iLCJjb250YWlucyIsImxhbmd1YWdlcyIsInBsYWluIiwicGxhaW50ZXh0IiwidHh0IiwiZXh0ZW5kIiwicmVkZWYiLCJpbnNlcnRCZWZvcmUiLCJpbnNpZGUiLCJiZWZvcmUiLCJpbnNlcnQiLCJncmFtbWFyIiwicmV0IiwidG9rZW4iLCJuZXdUb2tlbiIsIm9sZCIsIkRGUyIsImNhbGxiYWNrIiwicHJvcGVydHkiLCJwcm9wZXJ0eVR5cGUiLCJwbHVnaW5zIiwiaGlnaGxpZ2h0QWxsIiwiYXN5bmMiLCJoaWdobGlnaHRBbGxVbmRlciIsImNvbnRhaW5lciIsImVudiIsInNlbGVjdG9yIiwiaG9va3MiLCJydW4iLCJlbGVtZW50cyIsImFwcGx5IiwicXVlcnlTZWxlY3RvckFsbCIsImhpZ2hsaWdodEVsZW1lbnQiLCJub2RlTmFtZSIsInRleHRDb250ZW50IiwiaW5zZXJ0SGlnaGxpZ2h0ZWRDb2RlIiwiaGlnaGxpZ2h0ZWRDb2RlIiwiaW5uZXJIVE1MIiwiaGFzQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiV29ya2VyIiwid29ya2VyIiwib25tZXNzYWdlIiwiZXZ0IiwicG9zdE1lc3NhZ2UiLCJpbW1lZGlhdGVDbG9zZSIsImhpZ2hsaWdodCIsInRva2VuaXplIiwidG9rZW5MaXN0IiwiTGlua2VkTGlzdCIsImFkZEFmdGVyIiwibWF0Y2hHcmFtbWFyIiwidG9BcnJheSIsImFsbCIsImNhbGxiYWNrcyIsIm1hdGNoZWRTdHIiLCJlIiwiY2xhc3NlcyIsImFsaWFzZXMiLCJtYXRjaFBhdHRlcm4iLCJwYXR0ZXJuIiwicG9zIiwibG9va2JlaGluZCIsImxhc3RJbmRleCIsImxvb2tiZWhpbmRMZW5ndGgiLCJzdGFydE5vZGUiLCJzdGFydFBvcyIsInJlbWF0Y2giLCJwYXR0ZXJucyIsImoiLCJjYXVzZSIsInBhdHRlcm5PYmoiLCJncmVlZHkiLCJnbG9iYWwiLCJmbGFncyIsInNvdXJjZSIsImN1cnJlbnROb2RlIiwibmV4dCIsInRhaWwiLCJyZWFjaCIsInJlbW92ZUNvdW50IiwiayIsIm1hdGNoU3RyIiwiYWZ0ZXIiLCJyZW1vdmVGcm9tIiwicHJldiIsInJlbW92ZVJhbmdlIiwid3JhcHBlZCIsIm5lc3RlZFJlbWF0Y2giLCJuZXdOb2RlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImNsb3NlIiwic2NyaXB0IiwiaGlnaGxpZ2h0QXV0b21hdGljYWxseUNhbGxiYWNrIiwicmVhZHlTdGF0ZSIsImRlZmVyIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2V0VGltZW91dCIsIm1hcmt1cCIsImFkZElubGluZWQiLCJ0YWdOYW1lIiwiaW5jbHVkZWRDZGF0YUluc2lkZSIsImRlZiIsImF0dHJOYW1lIiwiaHRtbCIsIm1hdGhtbCIsInN2ZyIsInhtbCIsInNzbWwiLCJhdG9tIiwicnNzIiwic3RyaW5nIiwiY3NzIiwiYWRkQXR0cmlidXRlIiwiY2xpa2UiLCJqYXZhc2NyaXB0IiwicmVnZXgiLCJqcyIsIm1hdGNoZXMiLCJtc01hdGNoZXNTZWxlY3RvciIsIndlYmtpdE1hdGNoZXNTZWxlY3RvciIsIkxPQURJTkdfTUVTU0FHRSIsIkZBSUxVUkVfTUVTU0FHRSIsInN0YXR1cyIsIkZBSUxVUkVfRU1QVFlfTUVTU0FHRSIsIkVYVEVOU0lPTlMiLCJTVEFUVVNfQVRUUiIsIlNUQVRVU19MT0FESU5HIiwiU1RBVFVTX0xPQURFRCIsIlNUQVRVU19GQUlMRUQiLCJTRUxFQ1RPUiIsImxvYWRGaWxlIiwic3VjY2VzcyIsImVycm9yIiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVzcG9uc2VUZXh0Iiwic3RhdHVzVGV4dCIsInNlbmQiLCJwYXJzZVJhbmdlIiwiTnVtYmVyIiwiY29tbWEiLCJwcmUiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZUVsZW1lbnQiLCJnZXRBdHRyaWJ1dGUiLCJhdXRvbG9hZGVyIiwibG9hZExhbmd1YWdlcyIsImxpbmVzIiwiTWF0aCIsIlN0cmluZyIsImZpbGVIaWdobGlnaHQiLCJsb2dnZWQiLCJjb25zb2xlIiwid2FybiIsImFyZ3VtZW50cyIsImMiLCJrZXl3b3JkIiwibW9kTmFtZSIsImNwcCIsImFyZHVpbm8iLCJpbm8iLCJlbnZWYXJzIiwiY29tbWFuZEFmdGVySGVyZWRvYyIsImluc2lkZVN0cmluZyIsImJhc2giLCJlbnRpdHkiLCJ2YXJpYWJsZSIsInRvQmVDb3BpZWQiLCJzaCIsInNoZWxsIiwicmVwbGFjZW1lbnRzIiwicmUiLCJuZXN0ZWQiLCJkZXB0aExvZzIiLCJrZXl3b3JkS2luZHMiLCJ0eXBlRGVjbGFyYXRpb24iLCJjb250ZXh0dWFsIiwia2V5d29yZHNUb1BhdHRlcm4iLCJ3b3JkcyIsInRyaW0iLCJ0eXBlRGVjbGFyYXRpb25LZXl3b3JkcyIsImtleXdvcmRzIiwibm9uVHlwZUtleXdvcmRzIiwibm9uQ29udGV4dHVhbEtleXdvcmRzIiwiZ2VuZXJpYyIsIm5lc3RlZFJvdW5kIiwiZ2VuZXJpY05hbWUiLCJpZGVudGlmaWVyIiwidHlwZUV4cHJlc3Npb25XaXRob3V0VHVwbGUiLCJ0dXBsZUVsZW1lbnQiLCJ0dXBsZSIsInR5cGVFeHByZXNzaW9uIiwidHlwZUluc2lkZSIsInJlZ3VsYXJTdHJpbmciLCJ2ZXJiYXRpbVN0cmluZyIsImNzaGFycCIsInJlZ3VsYXJTdHJpbmdPckNoYXJhY3RlciIsInJlZ3VsYXJTdHJpbmdDaGFyYWN0ZXJPckNvbW1lbnQiLCJyb3VuZEV4cHJlc3Npb24iLCJhdHRyVGFyZ2V0IiwiYXR0ciIsImZvcm1hdFN0cmluZyIsIm1JbnRlcnBvbGF0aW9uUm91bmQiLCJtSW50ZXJwb2xhdGlvbiIsInNJbnRlcnBvbGF0aW9uUm91bmQiLCJzSW50ZXJwb2xhdGlvbiIsImNyZWF0ZUludGVycG9sYXRpb25JbnNpZGUiLCJpbnRlcnBvbGF0aW9uIiwiaW50ZXJwb2xhdGlvblJvdW5kIiwiZG90bmV0IiwiY3MiLCJkaWZmIiwiUFJFRklYRVMiLCJnbyIsImluaSIsImNsYXNzTmFtZVByZWZpeCIsImphdmEiLCJmdW5jdGlvbiIsIm5hbWVzcGFjZSIsInNwZWNpYWxFc2NhcGUiLCJlc2NhcGUiLCJjaGFyU2V0IiwiY2hhclNldFdpdGhvdXREb3QiLCJyYW5nZUNoYXIiLCJncm91cE5hbWUiLCJicmFjZXMiLCJzcHJlYWQiLCJzdHJpbmdpZnlUb2tlbiIsIndhbGtUb2tlbnMiLCJvcGVuZWRUYWdzIiwibm90VGFnTm9yQnJhY2UiLCJwb3AiLCJvcGVuZWRCcmFjZXMiLCJwbGFpblRleHQiLCJzcGxpY2UiLCJqc29uIiwid2VibWFuaWZlc3QiLCJrb3RsaW4iLCJpbnRlcnBvbGF0aW9uSW5zaWRlIiwia3QiLCJrdHMiLCJsZXNzIiwibHVhIiwibWFrZWZpbGUiLCJhbmNob3JPckFsaWFzIiwicHJvcGVydGllcyIsInBsYWluS2V5IiwiY3JlYXRlVmFsdWVQYXR0ZXJuIiwieWFtbCIsInltbCIsImlubmVyIiwiY3JlYXRlSW5saW5lIiwidGFibGVDZWxsIiwidGFibGVSb3ciLCJ0YWJsZUxpbmUiLCJtYXJrZG93biIsInB1bmN0dWF0aW9uIiwibCIsImNvZGVMYW5nIiwiY29kZUJsb2NrIiwiY2xzIiwiRGF0ZSIsInZhbHVlT2YiLCJmbG9vciIsInJhbmRvbSIsImVsZSIsImdldEVsZW1lbnRCeUlkIiwidGFnUGF0dGVybiIsIktOT1dOX0VOVElUWV9OQU1FUyIsImZyb21Db2RlUG9pbnQiLCJmcm9tQ2hhckNvZGUiLCJrbm93biIsIm1kIiwib2JqZWN0aXZlYyIsIm9iamMiLCJicmFja2V0cyIsInBlcmwiLCJnZXRQbGFjZWhvbGRlciIsInRvVXBwZXJDYXNlIiwiZGVmaW5lUHJvcGVydGllcyIsImJ1aWxkUGxhY2Vob2xkZXJzIiwicGxhY2Vob2xkZXJQYXR0ZXJuIiwicmVwbGFjZUZpbHRlciIsInRva2VuU3RhY2siLCJwbGFjZWhvbGRlciIsImluZGV4T2YiLCJ0b2tlbml6ZVBsYWNlaG9sZGVycyIsInQiLCJzdWJzdHJpbmciLCJtaWRkbGUiLCJyZXBsYWNlbWVudCIsImNvbW1lbnQiLCJjb25zdGFudCIsIm51bWJlciIsIm9wZXJhdG9yIiwicGhwIiwic3RyaW5nX2ludGVycG9sYXRpb24iLCJwaHBQYXR0ZXJuIiwicHl0aG9uIiwicHkiLCJyIiwicnVieSIsInBlcmNlbnRFeHByZXNzaW9uIiwic3ltYm9sTmFtZSIsInJiIiwibXVsdGlsaW5lQ29tbWVudCIsInJ1c3QiLCJzYXNzIiwiYXRydWxlIiwiaW1wb3J0YW50Iiwic2NzcyIsInNxbCIsInN3aWZ0IiwicnVsZSIsInRzIiwiYmFzaWMiLCJ2Ym5ldCIsImNhbm9uaWNhbE5hbWVUb0xhYmVsIiwibGFuZ3VhZ2VUb0Nhbm9uaWNhbE5hbWUiLCJhbGlhc2VzVG9DYW5vbmljYWxOYW1lIiwiY2Fub25pY2FsTmFtZSIsImxhbmd1YWdlc1RvQWxpYXNlcyIsImNvZGVCbG9ja1Nob3J0Y3V0UGF0dGVybiIsIndpdGhDb2RlQmxvY2siLCJpbnNlcnRCcmVhayIsImNvZGVCbG9ja1Nob3J0Y3V0IiwiYmxvY2siLCJfYWxpYXNlc1RvQ2Fub25pY2FsTmEiLCJsb2NhdGlvbkRvY3VtZW50RmVhdHVyZXMiLCJoaXN0b3J5IiwidW5kb3MiLCJvcGVyYXRpb25zIiwic2VsZWN0aW9uQmVmb3JlIiwic2VsZWN0aW9uIiwic2VsZWN0Iiwid3JhcE5vZGVzIiwiaXNDb2xsYXBzZWQiLCJlcXVhbHMiLCJzZXROb2RlcyIsImNoaWxkTm9kZSIsImZpbmRDaGlsZFByb3BQYXRoc0ZvclByb3AiLCJmaW5kQ2hpbGRQcm9wUGF0aHMiLCJwcm9wUGF0aHMiLCJnZXRBbmNlc3RvckNvbXBvbmVudEJsb2NrIiwiYW5jZXN0b3JFbnRyeSIsImlzSW5zaWRlIiwicHJvcCIsImFscmVhZHlOb3JtYWxpemVkVGhpbmdzIiwibm9ybWFsaXplTm9kZVdpdGhpbkNvbXBvbmVudFByb3AiLCJmaWVsZE9wdGlvbnMiLCJhbHJlYWR5Tm9ybWFsaXplZE5vZGVzIiwiV2Vha1NldCIsImRpZE5vcm1hbGl6YXRpb24iLCJjaGlsZHJlbkhhc0NoYW5nZWQiLCJjYW5TY2hlbWFDb250YWluQ2hpbGRGaWVsZCIsInF1ZXVlIiwiaW5uZXJQcm9wIiwiZG9lc1NjaGVtYU9ubHlFdmVyQ29udGFpbkFTaW5nbGVDaGlsZEZpZWxkIiwiaGFzRm91bmRDaGlsZEZpZWxkIiwiZmluZEFycmF5RmllbGRzV2l0aFNpbmdsZUNoaWxkRmllbGQiLCJpc0VtcHR5Q2hpbGRGaWVsZE5vZGUiLCJmaXJzdENoaWxkIiwid2l0aENvbXBvbmVudEJsb2NrcyIsImJsb2NrQ29tcG9uZW50cyIsIm1lbW9pemVkR2V0RG9jdW1lbnRGZWF0dXJlc0ZvckNoaWxkRmllbGQiLCJkZWxldGVCYWNrd2FyZCIsInVuaXQiLCJhbmNlc3RvckNvbXBvbmVudEJsb2NrIiwiaXNTdGFydCIsImNvbXBvbmVudFByb3BOb2RlIiwiY29tcG9uZW50UHJvcFBhdGgiLCJjb21wb25lbnRCbG9ja05vZGUiLCJjb21wb25lbnRCbG9ja1BhdGgiLCJpc0xhc3RQcm9wIiwicGFyYWdyYXBoTm9kZSIsInBhcmFncmFwaFBhdGgiLCJpc0xhc3RQYXJhZ3JhcGgiLCJtb3ZlIiwid2l0aG91dE5vcm1hbGl6aW5nIiwiYW5jZXN0b3JGaWVsZHMiLCJyZXZlcnNlIiwiZmluZEluZGV4IiwiaXRlbSIsImFycmF5RmllbGRJZHgiLCJhcnJheUZpZWxkIiwiaW5zZXJ0Tm9kZXMiLCJzcGxpdE5vZGVzIiwiYWx3YXlzIiwic3BsaXROb2RlUGF0aCIsInVwZGF0ZWRQcm9wcyIsImFkZE1pc3NpbmdGaWVsZHMiLCJub2Rlc1dpdGhpbiIsInN1YlBhdGgiLCJhcnJWYWwiLCJwcmV2S2V5c1NldCIsImFscmVhZHlVc2VkSW5kaWNpZXMiLCJuZXdLZXlzIiwiZ2V0TmV3S2V5IiwiaWR4RnJvbVZhbHVlIiwidHJhbnNmb3JtZWRQcm9wcyIsImlkeEluQ2hpbGRyZW5PZkJsb2NrIiwibm9kZVdpdGhpbiIsIm5ld1Byb3BQYXRoIiwibWlzc2luZ0tleXMiLCJmb3VuZFByb3BzIiwic3RyaW5naWZpZWRJbmxpbmVQcm9wUGF0aHMiLCJzdHJpbmdpZmllZFByb3BQYXRoIiwicHJvcEluZm8iLCJleHBlY3RlZEluZGV4IiwiZXhwZWN0ZWRDaGlsZE5vZGVUeXBlIiwidXBkYXRlZElubmVyVmFsdWUiLCJhcnJWYWx1ZSIsIm5ld0FyclZhbHVlIiwib2JqZWN0VmFsdWUiLCJoYXNDaGFuZ2VkIiwibmV3T2JqZWN0VmFsdWUiLCJpbm5lclZhbHVlIiwibmV3SW5uZXJWYWx1ZSIsInBhcmFncmFwaEVsZW1lbnQiLCJ3aXRoUGFyYWdyYXBocyIsImlzRWRpdG9yIiwid2l0aExheW91dHMiLCJhYm92ZU5vZGUiLCJhYm92ZVBhdGgiLCJsYXlvdXRBcmVhVG9SZW1vdmVQYXRoIiwibWFya2Rvd25MaW5rUGF0dGVybiIsIndpdGhMaW5rIiwiaXNJbmxpbmUiLCJzdGFydE9mQmxvY2siLCJzdGFydE9mQmxvY2tUb0VuZE9mU2hvcnRjdXRTdHJpbmciLCJhbmNlc3RvckNvbXBvbmVudENoaWxkRmllbGREb2N1bWVudEZlYXR1cmVzIiwibWF5YmVXaGl0ZXNwYWNlIiwibGlua1RleHQiLCJzdGFydE9mU2hvcnRjdXQiLCJzdGFydE9mTGlua1RleHQiLCJlbmRPZkxpbmtUZXh0IiwibmV4dE5vZGUiLCJsYXN0TWVyZ2FibGVMaW5rIiwiX2xhc3RNZXJnYWJsZUxpbmsiLCJmaXJzdExpbmtQYXRoIiwic2Vjb25kTGlua1BhdGgiLCJpc0xpc3RUeXBlIiwiaXNMaXN0Tm9kZSIsImdldEFuY2VzdG9yTGlzdCIsImxpc3RJdGVtIiwid2l0aExpc3QiLCJhbmNlc3Rvckxpc3QiLCJpc0VsZW1lbnRCZWluZ05vcm1hbGl6ZWRBTGlzdCIsIl9ub2RlJGNoaWxkcmVuIiwic2libGluZ05vZGVQYXRoIiwicHJldmlvdXNDaGlsZCIsInByZXZpb3VzIiwib3JkZXIiLCJnZXRSZWxhdGl2ZVJvd1BhdGgiLCJoYXNIZWFkIiwicm93SW5kZXgiLCJnZXRTZWxlY3RlZFRhYmxlQXJlYSIsIl9FZGl0b3IkYWJvdmUiLCJfZWRpdG9yJHNlbGVjdGlvbiIsIl9FZGl0b3IkYWJvdmUyIiwiX2VkaXRvciRzZWxlY3Rpb24yIiwiZWRnZXMiLCJ0YWJsZVBhdGgiLCJzaW5nbGVDZWxsIiwicm93IiwiY29sdW1uIiwiY2VsbCIsImNsb25lRGVzY2VuZGFudCIsIndpdGhUYWJsZSIsImRlbGV0ZUZyYWdtZW50IiwiZ2V0RnJhZ21lbnQiLCJpbnNlcnRGcmFnbWVudCIsImZyYWdtZW50Iiwic2VsZWN0ZWRUYWJsZUFyZWEiLCJuZXdSb3dzIiwiZXhpc3RpbmdCb2R5IiwibmV3Um93IiwiY2VsbEluZGV4IiwicmVsYXRpdmVDZWxsUGF0aCIsIm5ld0NlbGwiLCJjZWxsUGF0aCIsImNoaWxkSWR4Iiwic2V0U2VsZWN0aW9uIiwiX3RhYmxlJGNoaWxkcmVuJCIsImZpcnN0Iiwic2Vjb25kIiwiYm9keSIsImlzU2VsZWN0aW9uSW5IZWFkIiwiY29sdW1uTGVuZ3RoIiwiY29sdW1uSW5kZXgiLCJkaXJlY3Rpb24iLCJoZWFkT3JCb2R5IiwibWF4Um93SWR4IiwiaGFzV2hvbGVDb2x1bW5TZWxlY3RlZCIsImhhc1dob2xlUm93U2VsZWN0ZWQiLCJyb3dJZHgiLCJzZWxlY3Rpb25QYXRoIiwic2VsZWN0aW9uU3RhcnQiLCJkaWRVcGRhdGVUaGluZ3MiLCJjZWxsSWR4IiwibWF4Um93Q291bnQiLCJkaWRJbnNlcnQiLCJjcmVhdGVEb2N1bWVudEVkaXRvckZvck5vcm1hbGl6YXRpb24iLCJfY3JlYXRlRG9jdW1lbnRFZGl0b3IiLCJiYXNlRWRpdG9yIiwid2l0aEJsb2Nrc1NjaGVtYSIsIndpdGhWb2lkRWxlbWVudHMiLCJub2RlVHlwZSIsImluZm8iLCJkaWRVcGRhdGUiLCJoYW5kbGVOb2RlSW5JbnZhbGlkUG9zaXRpb24iLCJhbmNlc3RvclBhdGgiLCJjaGlsZE5vZGVJbmZvIiwiYW5jZXN0b3JOb2RlIiwicGFyZW50Tm9kZVR5cGUiLCJwYXJlbnROb2RlSW5mbyIsInRleHRFbmNvZGVyIiwidGV4dERlY29kZXIiLCJUZXh0RGVjb2RlciIsImRlZmF1bHRBbHRGaWVsZCIsImVtcHR5VGl0bGVGaWVsZCIsIm5vcm1hbGlzZURvY3VtZW50RmVhdHVyZXMiLCJfY29uZmlnJGZvcm1hdHRpbmciLCJfZm9ybWF0dGluZyRhbGlnbm1lbnQiLCJfZm9ybWF0dGluZyRhbGlnbm1lbnQyIiwiX2Zvcm1hdHRpbmckYmxvY2tUeXBlIiwiX2Zvcm1hdHRpbmckaW5saW5lTWFyIiwiX2Zvcm1hdHRpbmckaW5saW5lTWFyMiIsIl9mb3JtYXR0aW5nJGlubGluZU1hcjMiLCJfZm9ybWF0dGluZyRpbmxpbmVNYXI0IiwiX2Zvcm1hdHRpbmckaW5saW5lTWFyNSIsIl9mb3JtYXR0aW5nJGlubGluZU1hcjYiLCJfZm9ybWF0dGluZyRpbmxpbmVNYXI3IiwiX2Zvcm1hdHRpbmckaW5saW5lTWFyOCIsIl9mb3JtYXR0aW5nJGxpc3RUeXBlcyIsIl9mb3JtYXR0aW5nJGxpc3RUeXBlczIiLCJfaW1hZ2VzQ29uZmlnJHNjaGVtYSQiLCJfaW1hZ2VzQ29uZmlnJHNjaGVtYSIsIl9pbWFnZXNDb25maWckc2NoZW1hJDIiLCJfaW1hZ2VzQ29uZmlnJHNjaGVtYTIiLCJpbWFnZXNDb25maWciLCJfZm9ybWF0dGluZyRibG9ja1R5cGUyIiwiX29iaiRzY2hlbWEiLCJvcHQiLCJkb2N1bWVudCQxIiwiZG9jdW1lbnRGZWF0dXJlc0NvbmZpZyIsIm1hcmtkb2MiLCJkZWNvZGUiLCJub3JtYWxpemUiLCJmb3JjZSIsImZpbGUiLCJBIiwiQiIsIkMiLCJFIiwiRiIsIkciLCJIIiwiSSIsIkoiLCJLIiwiTCIsIk0iLCJOIiwiTyIsIlAiLCJRIiwiUiIsIlMiLCJmIiwiZyIsImgiLCJuIiwicSIsInUiLCJ3IiwieSIsInoiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/index-b0eee923.node.react-server.esm.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/keystatic-core.node.react-server.esm.js":
/*!**************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/keystatic-core.node.react-server.esm.js ***!
  \**************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlockWrapper: () => (/* binding */ BlockWrapper),\n/* harmony export */   NotEditable: () => (/* binding */ NotEditable),\n/* harmony export */   ToolbarSeparator: () => (/* binding */ ToolbarSeparator),\n/* harmony export */   collection: () => (/* binding */ collection),\n/* harmony export */   component: () => (/* reexport safe */ _api_719c8c15_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   fields: () => (/* binding */ index),\n/* harmony export */   singleton: () => (/* binding */ singleton)\n/* harmony export */ });\n/* harmony import */ var _api_719c8c15_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api-719c8c15.node.react-server.esm.js */ \"(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/api-719c8c15.node.react-server.esm.js\");\n/* harmony import */ var _empty_field_ui_5b08ee07_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./empty-field-ui-5b08ee07.node.react-server.esm.js */ \"(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/empty-field-ui-5b08ee07.node.react-server.esm.js\");\n/* harmony import */ var _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-b0eee923.node.react-server.esm.js */ \"(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/index-b0eee923.node.react-server.esm.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ \"(rsc)/../../node_modules/.pnpm/next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _sindresorhus_slugify__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sindresorhus/slugify */ \"(rsc)/../../node_modules/.pnpm/@sindresorhus+slugify@1.1.2/node_modules/@sindresorhus/slugify/index.js\");\n/* harmony import */ var _sindresorhus_slugify__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_sindresorhus_slugify__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _braintree_sanitize_url__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @braintree/sanitize-url */ \"(rsc)/../../node_modules/.pnpm/@braintree+sanitize-url@6.0.4/node_modules/@braintree/sanitize-url/dist/index.js\");\n/* harmony import */ var emery__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! emery */ \"(rsc)/../../node_modules/.pnpm/emery@1.4.2/node_modules/emery/dist/emery.cjs.js\");\n/* harmony import */ var emery_assertions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! emery/assertions */ \"(rsc)/../../node_modules/.pnpm/emery@1.4.2/node_modules/emery/assertions/dist/emery-assertions.cjs.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _emotion_weak_memoize__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @emotion/weak-memoize */ \"(rsc)/../../node_modules/.pnpm/@emotion+weak-memoize@0.3.1/node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction array(element, opts) {\n    var _opts$label;\n    return {\n        kind: \"array\",\n        element,\n        label: (_opts$label = opts === null || opts === void 0 ? void 0 : opts.label) !== null && _opts$label !== void 0 ? _opts$label : \"Items\",\n        description: opts === null || opts === void 0 ? void 0 : opts.description,\n        itemLabel: opts === null || opts === void 0 ? void 0 : opts.itemLabel,\n        asChildTag: opts === null || opts === void 0 ? void 0 : opts.asChildTag,\n        slugField: opts === null || opts === void 0 ? void 0 : opts.slugField,\n        validation: opts === null || opts === void 0 ? void 0 : opts.validation\n    };\n}\nfunction checkbox({ label, defaultValue = false, description }) {\n    return (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.L)({\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_empty_field_ui_5b08ee07_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.C, {\n                ...props,\n                label: label,\n                description: description\n            });\n        },\n        defaultValue () {\n            return defaultValue;\n        },\n        parse (value) {\n            if (value === undefined) return defaultValue;\n            if (typeof value !== \"boolean\") {\n                throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.J(\"Must be a boolean\");\n            }\n            return value;\n        },\n        validate (value) {\n            return value;\n        },\n        serialize (value) {\n            return {\n                value\n            };\n        }\n    });\n}\nfunction child(options) {\n    return {\n        kind: \"child\",\n        options: options.kind === \"block\" ? {\n            kind: \"block\",\n            placeholder: options.placeholder,\n            dividers: options.dividers,\n            formatting: options.formatting === \"inherit\" ? {\n                blockTypes: \"inherit\",\n                headingLevels: \"inherit\",\n                inlineMarks: \"inherit\",\n                listTypes: \"inherit\",\n                alignment: \"inherit\",\n                softBreaks: \"inherit\"\n            } : options.formatting,\n            links: options.links,\n            images: options.images,\n            tables: options.tables,\n            componentBlocks: options.componentBlocks\n        } : {\n            kind: \"inline\",\n            placeholder: options.placeholder,\n            formatting: options.formatting === \"inherit\" ? {\n                inlineMarks: \"inherit\",\n                softBreaks: \"inherit\"\n            } : options.formatting,\n            links: options.links\n        }\n    };\n}\nfunction conditional(discriminant, values) {\n    return {\n        kind: \"conditional\",\n        discriminant,\n        values: values\n    };\n}\nfunction validateDate(validation, value, label) {\n    if (value !== null && !/^\\d{4}-\\d{2}-\\d{2}$/.test(value)) {\n        return `${label} is not a valid date`;\n    }\n    if (validation !== null && validation !== void 0 && validation.isRequired && value === null) {\n        return `${label} is required`;\n    }\n    if ((validation !== null && validation !== void 0 && validation.min || validation !== null && validation !== void 0 && validation.max) && value !== null) {\n        const date = new Date(value);\n        if ((validation === null || validation === void 0 ? void 0 : validation.min) !== undefined) {\n            const min = new Date(validation.min);\n            if (date < min) {\n                return `${label} must be after ${min.toLocaleDateString()}`;\n            }\n        }\n        if ((validation === null || validation === void 0 ? void 0 : validation.max) !== undefined) {\n            const max = new Date(validation.max);\n            if (date > max) {\n                return `${label} must be no later than ${max.toLocaleDateString()}`;\n            }\n        }\n    }\n}\nfunction date({ label, defaultValue, validation, description }) {\n    return (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.L)({\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_empty_field_ui_5b08ee07_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.a, {\n                validation: validation,\n                label: label,\n                description: description,\n                ...props\n            });\n        },\n        defaultValue () {\n            if (defaultValue === undefined) {\n                return null;\n            }\n            if (typeof defaultValue === \"string\") {\n                return defaultValue;\n            }\n            const today = new Date();\n            const year = today.getFullYear();\n            const month = String(today.getMonth() + 1).padStart(2, \"0\");\n            const day = String(today.getDate()).padStart(2, \"0\");\n            return `${year}-${month}-${day}`;\n        },\n        parse (value) {\n            if (value === undefined) {\n                return null;\n            }\n            if (typeof value !== \"string\") {\n                throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.J(\"Must be a string\");\n            }\n            return value;\n        },\n        serialize (value) {\n            return {\n                value: value === null ? undefined : value\n            };\n        },\n        validate (value) {\n            const message = validateDate(validation, value, label);\n            if (message !== undefined) {\n                throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.J(message);\n            }\n            (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.M)(value, validation, label);\n            return value;\n        }\n    });\n}\nfunction validateDatetime(validation, value, label) {\n    if (value !== null && !/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}$/.test(value)) {\n        return `${label} is not a valid datetime`;\n    }\n    if (validation !== null && validation !== void 0 && validation.isRequired && value === null) {\n        return `${label} is required`;\n    }\n    if ((validation !== null && validation !== void 0 && validation.min || validation !== null && validation !== void 0 && validation.max) && value !== null) {\n        const datetime = new Date(value);\n        if ((validation === null || validation === void 0 ? void 0 : validation.min) !== undefined) {\n            const min = new Date(validation.min);\n            if (datetime < min) {\n                return `${label} must be after ${min.toISOString()}`;\n            }\n        }\n        if ((validation === null || validation === void 0 ? void 0 : validation.max) !== undefined) {\n            const max = new Date(validation.max);\n            if (datetime > max) {\n                return `${label} must be no later than ${max.toISOString()}`;\n            }\n        }\n    }\n}\nfunction datetime({ label, defaultValue, validation, description }) {\n    return (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.L)({\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_empty_field_ui_5b08ee07_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.b, {\n                validation: validation,\n                label: label,\n                description: description,\n                ...props\n            });\n        },\n        defaultValue () {\n            if (defaultValue === undefined) {\n                return null;\n            }\n            if (typeof defaultValue === \"string\") {\n                return defaultValue;\n            }\n            if (defaultValue.kind === \"now\") {\n                const now = new Date();\n                return now.toISOString();\n            }\n            return null;\n        },\n        parse (value) {\n            if (value === undefined) {\n                return null;\n            }\n            if (typeof value !== \"string\") {\n                throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.J(\"Must be a string\");\n            }\n            return value;\n        },\n        serialize (value) {\n            return {\n                value: value === null ? undefined : value\n            };\n        },\n        validate (value) {\n            const message = validateDatetime(validation, value, label);\n            if (message !== undefined) {\n                throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.J(message);\n            }\n            (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.M)(value, validation, label);\n            return value;\n        }\n    });\n}\nfunction emptyDocument() {\n    return {\n        kind: \"form\",\n        formKind: \"content\",\n        Input () {\n            return null;\n        },\n        defaultValue () {\n            return null;\n        },\n        parse () {\n            return null;\n        },\n        contentExtension: \".mdoc\",\n        serialize () {\n            return {\n                value: undefined,\n                content: new Uint8Array(),\n                external: new Map(),\n                other: new Map()\n            };\n        },\n        validate (value) {\n            return value;\n        },\n        reader: {\n            parse () {\n                return null;\n            }\n        }\n    };\n}\nfunction empty() {\n    return (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.L)({\n        Input () {\n            return null;\n        },\n        defaultValue () {\n            return null;\n        },\n        parse () {\n            return null;\n        },\n        serialize () {\n            return {\n                value: undefined\n            };\n        },\n        validate (value) {\n            return value;\n        }\n    });\n}\nfunction image({ label, directory, validation, description, publicPath }) {\n    return {\n        kind: \"form\",\n        formKind: \"asset\",\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_empty_field_ui_5b08ee07_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.I, {\n                label: label,\n                description: description,\n                validation: validation,\n                ...props\n            });\n        },\n        defaultValue () {\n            return null;\n        },\n        filename (value, args) {\n            if (typeof value === \"string\") {\n                return value.slice((0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.N)(publicPath, args.slug).length);\n            }\n            return undefined;\n        },\n        parse (value, args) {\n            var _value$match$, _value$match;\n            if (value === undefined) {\n                return null;\n            }\n            if (typeof value !== \"string\") {\n                throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.J(\"Must be a string\");\n            }\n            if (args.asset === undefined) {\n                return null;\n            }\n            return {\n                data: args.asset,\n                filename: value.slice((0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.N)(publicPath, args.slug).length),\n                extension: (_value$match$ = (_value$match = value.match(/\\.([^.]+$)/)) === null || _value$match === void 0 ? void 0 : _value$match[1]) !== null && _value$match$ !== void 0 ? _value$match$ : \"\"\n            };\n        },\n        validate (value) {\n            (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.M)(value, validation, label);\n            return value;\n        },\n        serialize (value, args) {\n            if (value === null) {\n                return {\n                    value: undefined,\n                    asset: undefined\n                };\n            }\n            const filename = args.suggestedFilenamePrefix ? args.suggestedFilenamePrefix + \".\" + value.extension : value.filename;\n            return {\n                value: `${(0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.N)(publicPath, args.slug)}${filename}`,\n                asset: {\n                    filename,\n                    content: value.data\n                }\n            };\n        },\n        directory: directory ? (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.O)(directory) : undefined,\n        reader: {\n            parse (value) {\n                if (typeof value !== \"string\" && value !== undefined) {\n                    throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.J(\"Must be a string\");\n                }\n                const val = value === undefined ? null : value;\n                (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.M)(val, validation, label);\n                return val;\n            }\n        }\n    };\n}\nfunction file({ label, directory, validation, description, publicPath }) {\n    return {\n        kind: \"form\",\n        formKind: \"asset\",\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_empty_field_ui_5b08ee07_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.F, {\n                label: label,\n                description: description,\n                validation: validation,\n                ...props\n            });\n        },\n        defaultValue () {\n            return null;\n        },\n        filename (value, args) {\n            if (typeof value === \"string\") {\n                return value.slice((0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.N)(publicPath, args.slug).length);\n            }\n            return undefined;\n        },\n        parse (value, args) {\n            var _value$match$, _value$match;\n            if (value === undefined) {\n                return null;\n            }\n            if (typeof value !== \"string\") {\n                throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.J(\"Must be a string\");\n            }\n            if (args.asset === undefined) {\n                return null;\n            }\n            return {\n                data: args.asset,\n                filename: value.slice((0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.N)(publicPath, args.slug).length),\n                extension: (_value$match$ = (_value$match = value.match(/\\.([^.]+$)/)) === null || _value$match === void 0 ? void 0 : _value$match[1]) !== null && _value$match$ !== void 0 ? _value$match$ : \"\"\n            };\n        },\n        validate (value) {\n            (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.M)(value, validation, label);\n            return value;\n        },\n        serialize (value, args) {\n            if (value === null) {\n                return {\n                    value: undefined,\n                    asset: undefined\n                };\n            }\n            const filename = args.suggestedFilenamePrefix ? args.suggestedFilenamePrefix + \".\" + value.extension : value.filename;\n            return {\n                value: `${(0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.N)(publicPath, args.slug)}${filename}`,\n                asset: {\n                    filename,\n                    content: value.data\n                }\n            };\n        },\n        directory: directory ? (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.O)(directory) : undefined,\n        reader: {\n            parse (value) {\n                if (typeof value !== \"string\" && value !== undefined) {\n                    throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.J(\"Must be a string\");\n                }\n                const val = value === undefined ? null : value;\n                (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.M)(val, validation, label);\n                return val;\n            }\n        }\n    };\n}\nfunction multiselect({ label, options, defaultValue = [], description }) {\n    const valuesToOption = new Map(options.map((x)=>[\n            x.value,\n            x\n        ]));\n    const field = (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.L)({\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_empty_field_ui_5b08ee07_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.M, {\n                label: label,\n                description: description,\n                options: options,\n                ...props\n            });\n        },\n        defaultValue () {\n            return defaultValue;\n        },\n        parse (value) {\n            if (value === undefined) {\n                return [];\n            }\n            if (!Array.isArray(value)) {\n                throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.J(\"Must be an array of options\");\n            }\n            if (!value.every((x)=>typeof x === \"string\" && valuesToOption.has(x))) {\n                throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.J(`Must be an array with one of ${options.map((x)=>x.value).join(\", \")}`);\n            }\n            return value;\n        },\n        validate (value) {\n            return value;\n        },\n        serialize (value) {\n            return {\n                value\n            };\n        }\n    });\n    return {\n        ...field,\n        options\n    };\n}\nfunction pathReference({ label, pattern, validation, description }) {\n    return (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.L)({\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_empty_field_ui_5b08ee07_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.P, {\n                label: label,\n                pattern: pattern,\n                description: description,\n                validation: validation,\n                ...props\n            });\n        },\n        defaultValue () {\n            return null;\n        },\n        parse (value) {\n            if (value === undefined) {\n                return null;\n            }\n            if (typeof value !== \"string\") {\n                throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.J(\"Must be a string\");\n            }\n            return value;\n        },\n        validate (value) {\n            (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.M)(value, validation, label);\n            return value;\n        },\n        serialize (value) {\n            return {\n                value: value === null ? undefined : value\n            };\n        }\n    });\n}\nfunction relationship({ label, collection, validation, description }) {\n    return (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.L)({\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_empty_field_ui_5b08ee07_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.R, {\n                label: label,\n                collection: collection,\n                description: description,\n                validation: validation,\n                ...props\n            });\n        },\n        defaultValue () {\n            return null;\n        },\n        parse (value) {\n            if (value === undefined) {\n                return null;\n            }\n            if (typeof value !== \"string\") {\n                throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.J(\"Must be a string\");\n            }\n            return value;\n        },\n        validate (value) {\n            (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.M)(value, validation, label);\n            return value;\n        },\n        serialize (value) {\n            return {\n                value: value === null ? undefined : value\n            };\n        }\n    });\n}\nfunction select({ label, options, defaultValue, description }) {\n    const optionValuesSet = new Set(options.map((x)=>x.value));\n    if (!optionValuesSet.has(defaultValue)) {\n        throw new Error(`A defaultValue of ${defaultValue} was provided to a select field but it does not match the value of one of the options provided`);\n    }\n    const field = (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.L)({\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_empty_field_ui_5b08ee07_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.S, {\n                label: label,\n                options: options,\n                description: description,\n                ...props\n            });\n        },\n        defaultValue () {\n            return defaultValue;\n        },\n        parse (value) {\n            if (value === undefined) {\n                return defaultValue;\n            }\n            if (typeof value !== \"string\") {\n                throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.J(\"Must be a string\");\n            }\n            if (!optionValuesSet.has(value)) {\n                throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.J(\"Must be a valid option\");\n            }\n            return value;\n        },\n        validate (value) {\n            return value;\n        },\n        serialize (value) {\n            return {\n                value\n            };\n        }\n    });\n    return {\n        ...field,\n        options\n    };\n}\nfunction parseSlugFieldAsNormalField(value) {\n    if (value === undefined) {\n        return {\n            name: \"\",\n            slug: \"\"\n        };\n    }\n    if (typeof value !== \"object\") {\n        throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.J(\"Must be an object\");\n    }\n    if (Object.keys(value).length !== 2) {\n        throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.J(\"Unexpected keys\");\n    }\n    if (!(\"name\" in value) || !(\"slug\" in value)) {\n        throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.J(\"Missing name or slug\");\n    }\n    if (typeof value.name !== \"string\") {\n        throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.J(\"name must be a string\");\n    }\n    if (typeof value.slug !== \"string\") {\n        throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.J(\"slug must be a string\");\n    }\n    return {\n        name: value.name,\n        slug: value.slug\n    };\n}\nfunction parseAsSlugField(value, slug) {\n    if (value === undefined) {\n        return {\n            name: \"\",\n            slug\n        };\n    }\n    if (typeof value !== \"string\") {\n        throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.J(\"Must be a string\");\n    }\n    return {\n        name: value,\n        slug\n    };\n}\nfunction slug(args) {\n    var _args$slug, _args$name$defaultVal, _args$name$defaultVal2;\n    const naiveGenerateSlug = ((_args$slug = args.slug) === null || _args$slug === void 0 ? void 0 : _args$slug.generate) || (_sindresorhus_slugify__WEBPACK_IMPORTED_MODULE_4___default());\n    const defaultValue = {\n        name: (_args$name$defaultVal = args.name.defaultValue) !== null && _args$name$defaultVal !== void 0 ? _args$name$defaultVal : \"\",\n        slug: naiveGenerateSlug((_args$name$defaultVal2 = args.name.defaultValue) !== null && _args$name$defaultVal2 !== void 0 ? _args$name$defaultVal2 : \"\")\n    };\n    function validate(value, { slugField } = {\n        slugField: undefined\n    }) {\n        var _args$name$validation, _args$name$validation2, _args$name$validation3, _args$name$validation4, _args$slug$validation, _args$slug2, _args$slug$validation2, _args$slug3, _args$slug$label, _args$slug4;\n        const nameMessage = (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.P)(value.name, (_args$name$validation = (_args$name$validation2 = args.name.validation) === null || _args$name$validation2 === void 0 || (_args$name$validation2 = _args$name$validation2.length) === null || _args$name$validation2 === void 0 ? void 0 : _args$name$validation2.min) !== null && _args$name$validation !== void 0 ? _args$name$validation : 0, (_args$name$validation3 = (_args$name$validation4 = args.name.validation) === null || _args$name$validation4 === void 0 || (_args$name$validation4 = _args$name$validation4.length) === null || _args$name$validation4 === void 0 ? void 0 : _args$name$validation4.max) !== null && _args$name$validation3 !== void 0 ? _args$name$validation3 : Infinity, args.name.label, undefined);\n        if (nameMessage !== undefined) {\n            throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.J(nameMessage);\n        }\n        const slugMessage = (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.P)(value.slug, (_args$slug$validation = (_args$slug2 = args.slug) === null || _args$slug2 === void 0 || (_args$slug2 = _args$slug2.validation) === null || _args$slug2 === void 0 || (_args$slug2 = _args$slug2.length) === null || _args$slug2 === void 0 ? void 0 : _args$slug2.min) !== null && _args$slug$validation !== void 0 ? _args$slug$validation : 1, (_args$slug$validation2 = (_args$slug3 = args.slug) === null || _args$slug3 === void 0 || (_args$slug3 = _args$slug3.validation) === null || _args$slug3 === void 0 || (_args$slug3 = _args$slug3.length) === null || _args$slug3 === void 0 ? void 0 : _args$slug3.max) !== null && _args$slug$validation2 !== void 0 ? _args$slug$validation2 : Infinity, (_args$slug$label = (_args$slug4 = args.slug) === null || _args$slug4 === void 0 ? void 0 : _args$slug4.label) !== null && _args$slug$label !== void 0 ? _args$slug$label : \"Slug\", slugField ? slugField : {\n            slugs: emptySet,\n            glob: \"*\"\n        });\n        if (slugMessage !== undefined) {\n            throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.J(slugMessage);\n        }\n        return value;\n    }\n    const emptySet = new Set();\n    return {\n        kind: \"form\",\n        formKind: \"slug\",\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_empty_field_ui_5b08ee07_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.c, {\n                args: args,\n                naiveGenerateSlug: naiveGenerateSlug,\n                defaultValue: defaultValue,\n                ...props\n            });\n        },\n        defaultValue () {\n            return defaultValue;\n        },\n        parse (value, args) {\n            if ((args === null || args === void 0 ? void 0 : args.slug) !== undefined) {\n                return parseAsSlugField(value, args.slug);\n            }\n            return parseSlugFieldAsNormalField(value);\n        },\n        validate,\n        serialize (value) {\n            return {\n                value\n            };\n        },\n        serializeWithSlug (value) {\n            return {\n                value: value.name,\n                slug: value.slug\n            };\n        },\n        reader: {\n            parse (value) {\n                const parsed = parseSlugFieldAsNormalField(value);\n                return validate(parsed);\n            },\n            parseWithSlug (value, args) {\n                return validate(parseAsSlugField(value, args.slug), {\n                    slugField: {\n                        glob: args.glob,\n                        slugs: emptySet\n                    }\n                }).name;\n            }\n        }\n    };\n}\nfunction isValidURL(url) {\n    return url === (0,_braintree_sanitize_url__WEBPACK_IMPORTED_MODULE_5__.sanitizeUrl)(url);\n}\nfunction validateUrl(validation, value, label) {\n    if (value !== null && (typeof value !== \"string\" || !isValidURL(value))) {\n        return `${label} is not a valid URL`;\n    }\n    if (validation !== null && validation !== void 0 && validation.isRequired && value === null) {\n        return `${label} is required`;\n    }\n}\nfunction url({ label, defaultValue, validation, description }) {\n    return (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.L)({\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_empty_field_ui_5b08ee07_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.U, {\n                label: label,\n                description: description,\n                validation: validation,\n                ...props\n            });\n        },\n        defaultValue () {\n            return defaultValue || null;\n        },\n        parse (value) {\n            if (value === undefined) {\n                return null;\n            }\n            if (typeof value !== \"string\") {\n                throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.J(\"Must be a string\");\n            }\n            return value === \"\" ? null : value;\n        },\n        validate (value) {\n            const message = validateUrl(validation, value, label);\n            if (message !== undefined) {\n                throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.J(message);\n            }\n            (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.M)(value, validation, label);\n            return value;\n        },\n        serialize (value) {\n            return {\n                value: value === null ? undefined : value\n            };\n        }\n    });\n}\nfunction blocks(blocks, opts) {\n    const entries = Object.entries(blocks);\n    if (!entries.length) {\n        throw new Error(\"fields.blocks must have at least one entry\");\n    }\n    const select$1 = select({\n        label: \"Kind\",\n        defaultValue: entries[0][0],\n        options: Object.entries(blocks).map(([key, { label }])=>({\n                label,\n                value: key\n            }))\n    });\n    const element = conditional(select$1, Object.fromEntries(entries.map(([key, { schema }])=>[\n            key,\n            schema\n        ])));\n    return {\n        ...array(element, {\n            label: opts.label,\n            description: opts.description,\n            validation: opts.validation,\n            itemLabel (props) {\n                const kind = props.discriminant;\n                const block = blocks[kind];\n                if (!block.itemLabel) return block.label;\n                return block.itemLabel(props.value);\n            }\n        }),\n        Input: _empty_field_ui_5b08ee07_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.B\n    };\n}\nfunction cloudImage({ label, description, validation }) {\n    return {\n        ...(0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.q)({\n            src: (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.Q)({\n                label: \"URL\",\n                validation: {\n                    length: {\n                        min: validation !== null && validation !== void 0 && validation.isRequired ? 1 : 0\n                    }\n                }\n            }),\n            alt: (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.Q)({\n                label: \"Alt text\"\n            }),\n            height: (0,_api_719c8c15_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)({\n                label: \"Height\"\n            }),\n            width: (0,_api_719c8c15_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)({\n                label: \"Width\"\n            })\n        }, {\n            label,\n            description\n        }),\n        Input (props) {\n            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_empty_field_ui_5b08ee07_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_1__.d, {\n                ...props,\n                isRequired: validation === null || validation === void 0 ? void 0 : validation.isRequired\n            });\n        }\n    };\n}\nvar index = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    array: array,\n    checkbox: checkbox,\n    child: child,\n    conditional: conditional,\n    date: date,\n    datetime: datetime,\n    document: _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.R,\n    emptyDocument: emptyDocument,\n    empty: empty,\n    image: image,\n    file: file,\n    integer: _api_719c8c15_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__.i,\n    multiselect: multiselect,\n    object: _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.q,\n    pathReference: pathReference,\n    relationship: relationship,\n    select: select,\n    slug: slug,\n    text: _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.Q,\n    url: url,\n    blocks: blocks,\n    cloudImage: cloudImage\n});\nfunction config(config) {\n    return config;\n}\nfunction collection(collection) {\n    return collection;\n}\nfunction singleton(collection) {\n    return collection;\n}\nfunction BlockWrapper() {}\nfunction NotEditable() {}\nfunction ToolbarSeparator() {}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BrZXlzdGF0aWMrY29yZUAwLjEuN19uZXh0QDEzLjUuNl9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQGtleXN0YXRpYy9jb3JlL2Rpc3Qva2V5c3RhdGljLWNvcmUubm9kZS5yZWFjdC1zZXJ2ZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF1RTtBQUNFO0FBQzRTO0FBQzNJO0FBQ2xNO0FBQ0k7QUFDVTtBQUN2QztBQUNXO0FBQ1g7QUFDVztBQUNQO0FBQ0g7QUFDZTtBQUUvQixTQUFTK0MsTUFBTUMsT0FBTyxFQUFFQyxJQUFJO0lBQzFCLElBQUlDO0lBQ0osT0FBTztRQUNMQyxNQUFNO1FBQ05IO1FBQ0FJLE9BQU8sQ0FBQ0YsY0FBY0QsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUtHLEtBQUssTUFBTSxRQUFRRixnQkFBZ0IsS0FBSyxJQUFJQSxjQUFjO1FBQ2pJRyxhQUFhSixTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBS0ksV0FBVztRQUN6RUMsV0FBV0wsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUtLLFNBQVM7UUFDckVDLFlBQVlOLFNBQVMsUUFBUUEsU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJQSxLQUFLTSxVQUFVO1FBQ3ZFQyxXQUFXUCxTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBS08sU0FBUztRQUNyRUMsWUFBWVIsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUtRLFVBQVU7SUFDekU7QUFDRjtBQUVBLFNBQVNDLFNBQVMsRUFDaEJOLEtBQUssRUFDTE8sZUFBZSxLQUFLLEVBQ3BCTixXQUFXLEVBQ1o7SUFDQyxPQUFPdkIsMkVBQW1DQSxDQUFDO1FBQ3pDOEIsT0FBTUMsS0FB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b0JBQW9CO0FBRTBFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va2V5c3RhdGljLXN0YXJ0ZXIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BrZXlzdGF0aWMrY29yZUAwLjEuN19uZXh0QDEzLjUuNl9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQGtleXN0YXRpYy9jb3JlL2Rpc3Qva2V5c3RhdGljLWNvcmUubm9kZS5yZWFjdC1zZXJ2ZXIuZXNtLmpzP2NlMTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaSBhcyBpbnRlZ2VyIH0gZnJvbSAnLi9hcGktNzE5YzhjMTUubm9kZS5yZWFjdC1zZXJ2ZXIuZXNtLmpzJztcbmV4cG9ydCB7IGMgYXMgY29tcG9uZW50IH0gZnJvbSAnLi9hcGktNzE5YzhjMTUubm9kZS5yZWFjdC1zZXJ2ZXIuZXNtLmpzJztcbmltcG9ydCB7IEMgYXMgQ2hlY2tib3hGaWVsZElucHV0LCBhIGFzIERhdGVGaWVsZElucHV0LCBiIGFzIERhdGV0aW1lRmllbGRJbnB1dCwgSSBhcyBJbWFnZUZpZWxkSW5wdXQsIEYgYXMgRmlsZUZpZWxkSW5wdXQsIE0gYXMgTXVsdGlzZWxlY3RGaWVsZElucHV0LCBQIGFzIFBhdGhSZWZlcmVuY2VJbnB1dCwgUiBhcyBSZWxhdGlvbnNoaXBJbnB1dCwgUyBhcyBTZWxlY3RGaWVsZElucHV0LCBjIGFzIFNsdWdGaWVsZElucHV0LCBVIGFzIFVybEZpZWxkSW5wdXQsIEIgYXMgQmxvY2tzRmllbGRJbnB1dCwgZCBhcyBDbG91ZEltYWdlRmllbGRJbnB1dCB9IGZyb20gJy4vZW1wdHktZmllbGQtdWktNWIwOGVlMDcubm9kZS5yZWFjdC1zZXJ2ZXIuZXNtLmpzJztcbmltcG9ydCB7IEwgYXMgYmFzaWNGb3JtRmllbGRXaXRoU2ltcGxlUmVhZGVyUGFyc2UsIEogYXMgRmllbGREYXRhRXJyb3IsIE0gYXMgYXNzZXJ0UmVxdWlyZWQsIE4gYXMgZ2V0U3JjUHJlZml4LCBPIGFzIGZpeFBhdGgsIFAgYXMgdmFsaWRhdGVUZXh0LCBxIGFzIG9iamVjdCwgUSBhcyB0ZXh0LCBSIGFzIGRvY3VtZW50IH0gZnJvbSAnLi9pbmRleC1iMGVlZTkyMy5ub2RlLnJlYWN0LXNlcnZlci5lc20uanMnO1xuaW1wb3J0IHsganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHNsdWdpZnkgZnJvbSAnQHNpbmRyZXNvcmh1cy9zbHVnaWZ5JztcbmltcG9ydCB7IHNhbml0aXplVXJsIH0gZnJvbSAnQGJyYWludHJlZS9zYW5pdGl6ZS11cmwnO1xuaW1wb3J0ICdlbWVyeSc7XG5pbXBvcnQgJ0BtYXJrZG9jL21hcmtkb2MnO1xuaW1wb3J0ICdzbGF0ZSc7XG5pbXBvcnQgJ2VtZXJ5L2Fzc2VydGlvbnMnO1xuaW1wb3J0ICdqcy1iYXNlNjQnO1xuaW1wb3J0ICdjcnlwdG8nO1xuaW1wb3J0ICdAZW1vdGlvbi93ZWFrLW1lbW9pemUnO1xuXG5mdW5jdGlvbiBhcnJheShlbGVtZW50LCBvcHRzKSB7XG4gIHZhciBfb3B0cyRsYWJlbDtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiAnYXJyYXknLFxuICAgIGVsZW1lbnQsXG4gICAgbGFiZWw6IChfb3B0cyRsYWJlbCA9IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5sYWJlbCkgIT09IG51bGwgJiYgX29wdHMkbGFiZWwgIT09IHZvaWQgMCA/IF9vcHRzJGxhYmVsIDogJ0l0ZW1zJyxcbiAgICBkZXNjcmlwdGlvbjogb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmRlc2NyaXB0aW9uLFxuICAgIGl0ZW1MYWJlbDogb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLml0ZW1MYWJlbCxcbiAgICBhc0NoaWxkVGFnOiBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuYXNDaGlsZFRhZyxcbiAgICBzbHVnRmllbGQ6IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5zbHVnRmllbGQsXG4gICAgdmFsaWRhdGlvbjogb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnZhbGlkYXRpb25cbiAgfTtcbn1cblxuZnVuY3Rpb24gY2hlY2tib3goe1xuICBsYWJlbCxcbiAgZGVmYXVsdFZhbHVlID0gZmFsc2UsXG4gIGRlc2NyaXB0aW9uXG59KSB7XG4gIHJldHVybiBiYXNpY0Zvcm1GaWVsZFdpdGhTaW1wbGVSZWFkZXJQYXJzZSh7XG4gICAgSW5wdXQocHJvcHMpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovanN4KENoZWNrYm94RmllbGRJbnB1dCwge1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb25cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9LFxuICAgIHBhcnNlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IoJ011c3QgYmUgYSBib29sZWFuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjaGlsZChvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogJ2NoaWxkJyxcbiAgICBvcHRpb25zOiBvcHRpb25zLmtpbmQgPT09ICdibG9jaycgPyB7XG4gICAgICBraW5kOiAnYmxvY2snLFxuICAgICAgcGxhY2Vob2xkZXI6IG9wdGlvbnMucGxhY2Vob2xkZXIsXG4gICAgICBkaXZpZGVyczogb3B0aW9ucy5kaXZpZGVycyxcbiAgICAgIGZvcm1hdHRpbmc6IG9wdGlvbnMuZm9ybWF0dGluZyA9PT0gJ2luaGVyaXQnID8ge1xuICAgICAgICBibG9ja1R5cGVzOiAnaW5oZXJpdCcsXG4gICAgICAgIGhlYWRpbmdMZXZlbHM6ICdpbmhlcml0JyxcbiAgICAgICAgaW5saW5lTWFya3M6ICdpbmhlcml0JyxcbiAgICAgICAgbGlzdFR5cGVzOiAnaW5oZXJpdCcsXG4gICAgICAgIGFsaWdubWVudDogJ2luaGVyaXQnLFxuICAgICAgICBzb2Z0QnJlYWtzOiAnaW5oZXJpdCdcbiAgICAgIH0gOiBvcHRpb25zLmZvcm1hdHRpbmcsXG4gICAgICBsaW5rczogb3B0aW9ucy5saW5rcyxcbiAgICAgIGltYWdlczogb3B0aW9ucy5pbWFnZXMsXG4gICAgICB0YWJsZXM6IG9wdGlvbnMudGFibGVzLFxuICAgICAgY29tcG9uZW50QmxvY2tzOiBvcHRpb25zLmNvbXBvbmVudEJsb2Nrc1xuICAgIH0gOiB7XG4gICAgICBraW5kOiAnaW5saW5lJyxcbiAgICAgIHBsYWNlaG9sZGVyOiBvcHRpb25zLnBsYWNlaG9sZGVyLFxuICAgICAgZm9ybWF0dGluZzogb3B0aW9ucy5mb3JtYXR0aW5nID09PSAnaW5oZXJpdCcgPyB7XG4gICAgICAgIGlubGluZU1hcmtzOiAnaW5oZXJpdCcsXG4gICAgICAgIHNvZnRCcmVha3M6ICdpbmhlcml0J1xuICAgICAgfSA6IG9wdGlvbnMuZm9ybWF0dGluZyxcbiAgICAgIGxpbmtzOiBvcHRpb25zLmxpbmtzXG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb25kaXRpb25hbChkaXNjcmltaW5hbnQsIHZhbHVlcykge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6ICdjb25kaXRpb25hbCcsXG4gICAgZGlzY3JpbWluYW50LFxuICAgIHZhbHVlczogdmFsdWVzXG4gIH07XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGF0ZSh2YWxpZGF0aW9uLCB2YWx1ZSwgbGFiZWwpIHtcbiAgaWYgKHZhbHVlICE9PSBudWxsICYmICEvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9JC8udGVzdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gYCR7bGFiZWx9IGlzIG5vdCBhIHZhbGlkIGRhdGVgO1xuICB9XG4gIGlmICh2YWxpZGF0aW9uICE9PSBudWxsICYmIHZhbGlkYXRpb24gIT09IHZvaWQgMCAmJiB2YWxpZGF0aW9uLmlzUmVxdWlyZWQgJiYgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gYCR7bGFiZWx9IGlzIHJlcXVpcmVkYDtcbiAgfVxuICBpZiAoKHZhbGlkYXRpb24gIT09IG51bGwgJiYgdmFsaWRhdGlvbiAhPT0gdm9pZCAwICYmIHZhbGlkYXRpb24ubWluIHx8IHZhbGlkYXRpb24gIT09IG51bGwgJiYgdmFsaWRhdGlvbiAhPT0gdm9pZCAwICYmIHZhbGlkYXRpb24ubWF4KSAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgaWYgKCh2YWxpZGF0aW9uID09PSBudWxsIHx8IHZhbGlkYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbGlkYXRpb24ubWluKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBtaW4gPSBuZXcgRGF0ZSh2YWxpZGF0aW9uLm1pbik7XG4gICAgICBpZiAoZGF0ZSA8IG1pbikge1xuICAgICAgICByZXR1cm4gYCR7bGFiZWx9IG11c3QgYmUgYWZ0ZXIgJHttaW4udG9Mb2NhbGVEYXRlU3RyaW5nKCl9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCh2YWxpZGF0aW9uID09PSBudWxsIHx8IHZhbGlkYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbGlkYXRpb24ubWF4KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBtYXggPSBuZXcgRGF0ZSh2YWxpZGF0aW9uLm1heCk7XG4gICAgICBpZiAoZGF0ZSA+IG1heCkge1xuICAgICAgICByZXR1cm4gYCR7bGFiZWx9IG11c3QgYmUgbm8gbGF0ZXIgdGhhbiAke21heC50b0xvY2FsZURhdGVTdHJpbmcoKX1gO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkYXRlKHtcbiAgbGFiZWwsXG4gIGRlZmF1bHRWYWx1ZSxcbiAgdmFsaWRhdGlvbixcbiAgZGVzY3JpcHRpb25cbn0pIHtcbiAgcmV0dXJuIGJhc2ljRm9ybUZpZWxkV2l0aFNpbXBsZVJlYWRlclBhcnNlKHtcbiAgICBJbnB1dChwcm9wcykge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goRGF0ZUZpZWxkSW5wdXQsIHtcbiAgICAgICAgdmFsaWRhdGlvbjogdmFsaWRhdGlvbixcbiAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICAgIC4uLnByb3BzXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgIGlmIChkZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgeWVhciA9IHRvZGF5LmdldEZ1bGxZZWFyKCk7XG4gICAgICBjb25zdCBtb250aCA9IFN0cmluZyh0b2RheS5nZXRNb250aCgpICsgMSkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICAgIGNvbnN0IGRheSA9IFN0cmluZyh0b2RheS5nZXREYXRlKCkpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgICByZXR1cm4gYCR7eWVhcn0tJHttb250aH0tJHtkYXl9YDtcbiAgICB9LFxuICAgIHBhcnNlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBGaWVsZERhdGFFcnJvcignTXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUgPT09IG51bGwgPyB1bmRlZmluZWQgOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9LFxuICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gdmFsaWRhdGVEYXRlKHZhbGlkYXRpb24sIHZhbHVlLCBsYWJlbCk7XG4gICAgICBpZiAobWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBGaWVsZERhdGFFcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydFJlcXVpcmVkKHZhbHVlLCB2YWxpZGF0aW9uLCBsYWJlbCk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVEYXRldGltZSh2YWxpZGF0aW9uLCB2YWx1ZSwgbGFiZWwpIHtcbiAgaWYgKHZhbHVlICE9PSBudWxsICYmICEvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9VFxcZHsyfTpcXGR7Mn0kLy50ZXN0KHZhbHVlKSkge1xuICAgIHJldHVybiBgJHtsYWJlbH0gaXMgbm90IGEgdmFsaWQgZGF0ZXRpbWVgO1xuICB9XG4gIGlmICh2YWxpZGF0aW9uICE9PSBudWxsICYmIHZhbGlkYXRpb24gIT09IHZvaWQgMCAmJiB2YWxpZGF0aW9uLmlzUmVxdWlyZWQgJiYgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gYCR7bGFiZWx9IGlzIHJlcXVpcmVkYDtcbiAgfVxuICBpZiAoKHZhbGlkYXRpb24gIT09IG51bGwgJiYgdmFsaWRhdGlvbiAhPT0gdm9pZCAwICYmIHZhbGlkYXRpb24ubWluIHx8IHZhbGlkYXRpb24gIT09IG51bGwgJiYgdmFsaWRhdGlvbiAhPT0gdm9pZCAwICYmIHZhbGlkYXRpb24ubWF4KSAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGRhdGV0aW1lID0gbmV3IERhdGUodmFsdWUpO1xuICAgIGlmICgodmFsaWRhdGlvbiA9PT0gbnVsbCB8fCB2YWxpZGF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWxpZGF0aW9uLm1pbikgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbWluID0gbmV3IERhdGUodmFsaWRhdGlvbi5taW4pO1xuICAgICAgaWYgKGRhdGV0aW1lIDwgbWluKSB7XG4gICAgICAgIHJldHVybiBgJHtsYWJlbH0gbXVzdCBiZSBhZnRlciAke21pbi50b0lTT1N0cmluZygpfWA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgodmFsaWRhdGlvbiA9PT0gbnVsbCB8fCB2YWxpZGF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWxpZGF0aW9uLm1heCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbWF4ID0gbmV3IERhdGUodmFsaWRhdGlvbi5tYXgpO1xuICAgICAgaWYgKGRhdGV0aW1lID4gbWF4KSB7XG4gICAgICAgIHJldHVybiBgJHtsYWJlbH0gbXVzdCBiZSBubyBsYXRlciB0aGFuICR7bWF4LnRvSVNPU3RyaW5nKCl9YDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGF0ZXRpbWUoe1xuICBsYWJlbCxcbiAgZGVmYXVsdFZhbHVlLFxuICB2YWxpZGF0aW9uLFxuICBkZXNjcmlwdGlvblxufSkge1xuICByZXR1cm4gYmFzaWNGb3JtRmllbGRXaXRoU2ltcGxlUmVhZGVyUGFyc2Uoe1xuICAgIElucHV0KHByb3BzKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2pzeChEYXRldGltZUZpZWxkSW5wdXQsIHtcbiAgICAgICAgdmFsaWRhdGlvbjogdmFsaWRhdGlvbixcbiAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICAgIC4uLnByb3BzXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgIGlmIChkZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmF1bHRWYWx1ZS5raW5kID09PSAnbm93Jykge1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICByZXR1cm4gbm93LnRvSVNPU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHBhcnNlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBGaWVsZERhdGFFcnJvcignTXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUgPT09IG51bGwgPyB1bmRlZmluZWQgOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9LFxuICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gdmFsaWRhdGVEYXRldGltZSh2YWxpZGF0aW9uLCB2YWx1ZSwgbGFiZWwpO1xuICAgICAgaWYgKG1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBhc3NlcnRSZXF1aXJlZCh2YWx1ZSwgdmFsaWRhdGlvbiwgbGFiZWwpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVtcHR5RG9jdW1lbnQoKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogJ2Zvcm0nLFxuICAgIGZvcm1LaW5kOiAnY29udGVudCcsXG4gICAgSW5wdXQoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgcGFyc2UoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGNvbnRlbnRFeHRlbnNpb246ICcubWRvYycsXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgY29udGVudDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgZXh0ZXJuYWw6IG5ldyBNYXAoKSxcbiAgICAgICAgb3RoZXI6IG5ldyBNYXAoKVxuICAgICAgfTtcbiAgICB9LFxuICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICByZWFkZXI6IHtcbiAgICAgIHBhcnNlKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVtcHR5KCkge1xuICByZXR1cm4gYmFzaWNGb3JtRmllbGRXaXRoU2ltcGxlUmVhZGVyUGFyc2Uoe1xuICAgIElucHV0KCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHBhcnNlKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgIH0sXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbWFnZSh7XG4gIGxhYmVsLFxuICBkaXJlY3RvcnksXG4gIHZhbGlkYXRpb24sXG4gIGRlc2NyaXB0aW9uLFxuICBwdWJsaWNQYXRoXG59KSB7XG4gIHJldHVybiB7XG4gICAga2luZDogJ2Zvcm0nLFxuICAgIGZvcm1LaW5kOiAnYXNzZXQnLFxuICAgIElucHV0KHByb3BzKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2pzeChJbWFnZUZpZWxkSW5wdXQsIHtcbiAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICAgIHZhbGlkYXRpb246IHZhbGlkYXRpb24sXG4gICAgICAgIC4uLnByb3BzXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZmlsZW5hbWUodmFsdWUsIGFyZ3MpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5zbGljZShnZXRTcmNQcmVmaXgocHVibGljUGF0aCwgYXJncy5zbHVnKS5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIHBhcnNlKHZhbHVlLCBhcmdzKSB7XG4gICAgICB2YXIgX3ZhbHVlJG1hdGNoJCwgX3ZhbHVlJG1hdGNoO1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IoJ011c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmdzLmFzc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBhcmdzLmFzc2V0LFxuICAgICAgICBmaWxlbmFtZTogdmFsdWUuc2xpY2UoZ2V0U3JjUHJlZml4KHB1YmxpY1BhdGgsIGFyZ3Muc2x1ZykubGVuZ3RoKSxcbiAgICAgICAgZXh0ZW5zaW9uOiAoX3ZhbHVlJG1hdGNoJCA9IChfdmFsdWUkbWF0Y2ggPSB2YWx1ZS5tYXRjaCgvXFwuKFteLl0rJCkvKSkgPT09IG51bGwgfHwgX3ZhbHVlJG1hdGNoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdmFsdWUkbWF0Y2hbMV0pICE9PSBudWxsICYmIF92YWx1ZSRtYXRjaCQgIT09IHZvaWQgMCA/IF92YWx1ZSRtYXRjaCQgOiAnJ1xuICAgICAgfTtcbiAgICB9LFxuICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICBhc3NlcnRSZXF1aXJlZCh2YWx1ZSwgdmFsaWRhdGlvbiwgbGFiZWwpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgc2VyaWFsaXplKHZhbHVlLCBhcmdzKSB7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGFzc2V0OiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpbGVuYW1lID0gYXJncy5zdWdnZXN0ZWRGaWxlbmFtZVByZWZpeCA/IGFyZ3Muc3VnZ2VzdGVkRmlsZW5hbWVQcmVmaXggKyAnLicgKyB2YWx1ZS5leHRlbnNpb24gOiB2YWx1ZS5maWxlbmFtZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBgJHtnZXRTcmNQcmVmaXgocHVibGljUGF0aCwgYXJncy5zbHVnKX0ke2ZpbGVuYW1lfWAsXG4gICAgICAgIGFzc2V0OiB7XG4gICAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgICAgY29udGVudDogdmFsdWUuZGF0YVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgZGlyZWN0b3J5OiBkaXJlY3RvcnkgPyBmaXhQYXRoKGRpcmVjdG9yeSkgOiB1bmRlZmluZWQsXG4gICAgcmVhZGVyOiB7XG4gICAgICBwYXJzZSh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZpZWxkRGF0YUVycm9yKCdNdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB2YWx1ZTtcbiAgICAgICAgYXNzZXJ0UmVxdWlyZWQodmFsLCB2YWxpZGF0aW9uLCBsYWJlbCk7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBmaWxlKHtcbiAgbGFiZWwsXG4gIGRpcmVjdG9yeSxcbiAgdmFsaWRhdGlvbixcbiAgZGVzY3JpcHRpb24sXG4gIHB1YmxpY1BhdGhcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiAnZm9ybScsXG4gICAgZm9ybUtpbmQ6ICdhc3NldCcsXG4gICAgSW5wdXQocHJvcHMpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovanN4KEZpbGVGaWVsZElucHV0LCB7XG4gICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgICAgICB2YWxpZGF0aW9uOiB2YWxpZGF0aW9uLFxuICAgICAgICAuLi5wcm9wc1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGZpbGVuYW1lKHZhbHVlLCBhcmdzKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoZ2V0U3JjUHJlZml4KHB1YmxpY1BhdGgsIGFyZ3Muc2x1ZykubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBwYXJzZSh2YWx1ZSwgYXJncykge1xuICAgICAgdmFyIF92YWx1ZSRtYXRjaCQsIF92YWx1ZSRtYXRjaDtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpZWxkRGF0YUVycm9yKCdNdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBpZiAoYXJncy5hc3NldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogYXJncy5hc3NldCxcbiAgICAgICAgZmlsZW5hbWU6IHZhbHVlLnNsaWNlKGdldFNyY1ByZWZpeChwdWJsaWNQYXRoLCBhcmdzLnNsdWcpLmxlbmd0aCksXG4gICAgICAgIGV4dGVuc2lvbjogKF92YWx1ZSRtYXRjaCQgPSAoX3ZhbHVlJG1hdGNoID0gdmFsdWUubWF0Y2goL1xcLihbXi5dKyQpLykpID09PSBudWxsIHx8IF92YWx1ZSRtYXRjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ZhbHVlJG1hdGNoWzFdKSAhPT0gbnVsbCAmJiBfdmFsdWUkbWF0Y2gkICE9PSB2b2lkIDAgPyBfdmFsdWUkbWF0Y2gkIDogJydcbiAgICAgIH07XG4gICAgfSxcbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgYXNzZXJ0UmVxdWlyZWQodmFsdWUsIHZhbGlkYXRpb24sIGxhYmVsKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHNlcmlhbGl6ZSh2YWx1ZSwgYXJncykge1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBhc3NldDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBmaWxlbmFtZSA9IGFyZ3Muc3VnZ2VzdGVkRmlsZW5hbWVQcmVmaXggPyBhcmdzLnN1Z2dlc3RlZEZpbGVuYW1lUHJlZml4ICsgJy4nICsgdmFsdWUuZXh0ZW5zaW9uIDogdmFsdWUuZmlsZW5hbWU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogYCR7Z2V0U3JjUHJlZml4KHB1YmxpY1BhdGgsIGFyZ3Muc2x1Zyl9JHtmaWxlbmFtZX1gLFxuICAgICAgICBhc3NldDoge1xuICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgIGNvbnRlbnQ6IHZhbHVlLmRhdGFcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIGRpcmVjdG9yeTogZGlyZWN0b3J5ID8gZml4UGF0aChkaXJlY3RvcnkpIDogdW5kZWZpbmVkLFxuICAgIHJlYWRlcjoge1xuICAgICAgcGFyc2UodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBGaWVsZERhdGFFcnJvcignTXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbCA9IHZhbHVlID09PSB1bmRlZmluZWQgPyBudWxsIDogdmFsdWU7XG4gICAgICAgIGFzc2VydFJlcXVpcmVkKHZhbCwgdmFsaWRhdGlvbiwgbGFiZWwpO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbXVsdGlzZWxlY3Qoe1xuICBsYWJlbCxcbiAgb3B0aW9ucyxcbiAgZGVmYXVsdFZhbHVlID0gW10sXG4gIGRlc2NyaXB0aW9uXG59KSB7XG4gIGNvbnN0IHZhbHVlc1RvT3B0aW9uID0gbmV3IE1hcChvcHRpb25zLm1hcCh4ID0+IFt4LnZhbHVlLCB4XSkpO1xuICBjb25zdCBmaWVsZCA9IGJhc2ljRm9ybUZpZWxkV2l0aFNpbXBsZVJlYWRlclBhcnNlKHtcbiAgICBJbnB1dChwcm9wcykge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goTXVsdGlzZWxlY3RGaWVsZElucHV0LCB7XG4gICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAuLi5wcm9wc1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH0sXG4gICAgcGFyc2UodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpZWxkRGF0YUVycm9yKCdNdXN0IGJlIGFuIGFycmF5IG9mIG9wdGlvbnMnKTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsdWUuZXZlcnkoeCA9PiB0eXBlb2YgeCA9PT0gJ3N0cmluZycgJiYgdmFsdWVzVG9PcHRpb24uaGFzKHgpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IoYE11c3QgYmUgYW4gYXJyYXkgd2l0aCBvbmUgb2YgJHtvcHRpb25zLm1hcCh4ID0+IHgudmFsdWUpLmpvaW4oJywgJyl9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIC4uLmZpZWxkLFxuICAgIG9wdGlvbnNcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGF0aFJlZmVyZW5jZSh7XG4gIGxhYmVsLFxuICBwYXR0ZXJuLFxuICB2YWxpZGF0aW9uLFxuICBkZXNjcmlwdGlvblxufSkge1xuICByZXR1cm4gYmFzaWNGb3JtRmllbGRXaXRoU2ltcGxlUmVhZGVyUGFyc2Uoe1xuICAgIElucHV0KHByb3BzKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2pzeChQYXRoUmVmZXJlbmNlSW5wdXQsIHtcbiAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICBwYXR0ZXJuOiBwYXR0ZXJuLFxuICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICAgIHZhbGlkYXRpb246IHZhbGlkYXRpb24sXG4gICAgICAgIC4uLnByb3BzXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgcGFyc2UodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpZWxkRGF0YUVycm9yKCdNdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgYXNzZXJ0UmVxdWlyZWQodmFsdWUsIHZhbGlkYXRpb24sIGxhYmVsKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlID09PSBudWxsID8gdW5kZWZpbmVkIDogdmFsdWVcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVsYXRpb25zaGlwKHtcbiAgbGFiZWwsXG4gIGNvbGxlY3Rpb24sXG4gIHZhbGlkYXRpb24sXG4gIGRlc2NyaXB0aW9uXG59KSB7XG4gIHJldHVybiBiYXNpY0Zvcm1GaWVsZFdpdGhTaW1wbGVSZWFkZXJQYXJzZSh7XG4gICAgSW5wdXQocHJvcHMpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFJlbGF0aW9uc2hpcElucHV0LCB7XG4gICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbixcbiAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgICAgICB2YWxpZGF0aW9uOiB2YWxpZGF0aW9uLFxuICAgICAgICAuLi5wcm9wc1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHBhcnNlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBGaWVsZERhdGFFcnJvcignTXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgIGFzc2VydFJlcXVpcmVkKHZhbHVlLCB2YWxpZGF0aW9uLCBsYWJlbCk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBzZXJpYWxpemUodmFsdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdCh7XG4gIGxhYmVsLFxuICBvcHRpb25zLFxuICBkZWZhdWx0VmFsdWUsXG4gIGRlc2NyaXB0aW9uXG59KSB7XG4gIGNvbnN0IG9wdGlvblZhbHVlc1NldCA9IG5ldyBTZXQob3B0aW9ucy5tYXAoeCA9PiB4LnZhbHVlKSk7XG4gIGlmICghb3B0aW9uVmFsdWVzU2V0LmhhcyhkZWZhdWx0VmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBIGRlZmF1bHRWYWx1ZSBvZiAke2RlZmF1bHRWYWx1ZX0gd2FzIHByb3ZpZGVkIHRvIGEgc2VsZWN0IGZpZWxkIGJ1dCBpdCBkb2VzIG5vdCBtYXRjaCB0aGUgdmFsdWUgb2Ygb25lIG9mIHRoZSBvcHRpb25zIHByb3ZpZGVkYCk7XG4gIH1cbiAgY29uc3QgZmllbGQgPSBiYXNpY0Zvcm1GaWVsZFdpdGhTaW1wbGVSZWFkZXJQYXJzZSh7XG4gICAgSW5wdXQocHJvcHMpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFNlbGVjdEZpZWxkSW5wdXQsIHtcbiAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICAgIC4uLnByb3BzXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfSxcbiAgICBwYXJzZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBGaWVsZERhdGFFcnJvcignTXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgaWYgKCFvcHRpb25WYWx1ZXNTZXQuaGFzKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IoJ011c3QgYmUgYSB2YWxpZCBvcHRpb24nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBzZXJpYWxpemUodmFsdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgLi4uZmllbGQsXG4gICAgb3B0aW9uc1xuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVNsdWdGaWVsZEFzTm9ybWFsRmllbGQodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogJycsXG4gICAgICBzbHVnOiAnJ1xuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IoJ011c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cbiAgaWYgKE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IoJ1VuZXhwZWN0ZWQga2V5cycpO1xuICB9XG4gIGlmICghKCduYW1lJyBpbiB2YWx1ZSkgfHwgISgnc2x1ZycgaW4gdmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEZpZWxkRGF0YUVycm9yKCdNaXNzaW5nIG5hbWUgb3Igc2x1ZycpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IoJ25hbWUgbXVzdCBiZSBhIHN0cmluZycpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUuc2x1ZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IoJ3NsdWcgbXVzdCBiZSBhIHN0cmluZycpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogdmFsdWUubmFtZSxcbiAgICBzbHVnOiB2YWx1ZS5zbHVnXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZUFzU2x1Z0ZpZWxkKHZhbHVlLCBzbHVnKSB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6ICcnLFxuICAgICAgc2x1Z1xuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRmllbGREYXRhRXJyb3IoJ011c3QgYmUgYSBzdHJpbmcnKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6IHZhbHVlLFxuICAgIHNsdWdcbiAgfTtcbn1cbmZ1bmN0aW9uIHNsdWcoYXJncykge1xuICB2YXIgX2FyZ3Mkc2x1ZywgX2FyZ3MkbmFtZSRkZWZhdWx0VmFsLCBfYXJncyRuYW1lJGRlZmF1bHRWYWwyO1xuICBjb25zdCBuYWl2ZUdlbmVyYXRlU2x1ZyA9ICgoX2FyZ3Mkc2x1ZyA9IGFyZ3Muc2x1ZykgPT09IG51bGwgfHwgX2FyZ3Mkc2x1ZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FyZ3Mkc2x1Zy5nZW5lcmF0ZSkgfHwgc2x1Z2lmeTtcbiAgY29uc3QgZGVmYXVsdFZhbHVlID0ge1xuICAgIG5hbWU6IChfYXJncyRuYW1lJGRlZmF1bHRWYWwgPSBhcmdzLm5hbWUuZGVmYXVsdFZhbHVlKSAhPT0gbnVsbCAmJiBfYXJncyRuYW1lJGRlZmF1bHRWYWwgIT09IHZvaWQgMCA/IF9hcmdzJG5hbWUkZGVmYXVsdFZhbCA6ICcnLFxuICAgIHNsdWc6IG5haXZlR2VuZXJhdGVTbHVnKChfYXJncyRuYW1lJGRlZmF1bHRWYWwyID0gYXJncy5uYW1lLmRlZmF1bHRWYWx1ZSkgIT09IG51bGwgJiYgX2FyZ3MkbmFtZSRkZWZhdWx0VmFsMiAhPT0gdm9pZCAwID8gX2FyZ3MkbmFtZSRkZWZhdWx0VmFsMiA6ICcnKVxuICB9O1xuICBmdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSwge1xuICAgIHNsdWdGaWVsZFxuICB9ID0ge1xuICAgIHNsdWdGaWVsZDogdW5kZWZpbmVkXG4gIH0pIHtcbiAgICB2YXIgX2FyZ3MkbmFtZSR2YWxpZGF0aW9uLCBfYXJncyRuYW1lJHZhbGlkYXRpb24yLCBfYXJncyRuYW1lJHZhbGlkYXRpb24zLCBfYXJncyRuYW1lJHZhbGlkYXRpb240LCBfYXJncyRzbHVnJHZhbGlkYXRpb24sIF9hcmdzJHNsdWcyLCBfYXJncyRzbHVnJHZhbGlkYXRpb24yLCBfYXJncyRzbHVnMywgX2FyZ3Mkc2x1ZyRsYWJlbCwgX2FyZ3Mkc2x1ZzQ7XG4gICAgY29uc3QgbmFtZU1lc3NhZ2UgPSB2YWxpZGF0ZVRleHQodmFsdWUubmFtZSwgKF9hcmdzJG5hbWUkdmFsaWRhdGlvbiA9IChfYXJncyRuYW1lJHZhbGlkYXRpb24yID0gYXJncy5uYW1lLnZhbGlkYXRpb24pID09PSBudWxsIHx8IF9hcmdzJG5hbWUkdmFsaWRhdGlvbjIgPT09IHZvaWQgMCB8fCAoX2FyZ3MkbmFtZSR2YWxpZGF0aW9uMiA9IF9hcmdzJG5hbWUkdmFsaWRhdGlvbjIubGVuZ3RoKSA9PT0gbnVsbCB8fCBfYXJncyRuYW1lJHZhbGlkYXRpb24yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYXJncyRuYW1lJHZhbGlkYXRpb24yLm1pbikgIT09IG51bGwgJiYgX2FyZ3MkbmFtZSR2YWxpZGF0aW9uICE9PSB2b2lkIDAgPyBfYXJncyRuYW1lJHZhbGlkYXRpb24gOiAwLCAoX2FyZ3MkbmFtZSR2YWxpZGF0aW9uMyA9IChfYXJncyRuYW1lJHZhbGlkYXRpb240ID0gYXJncy5uYW1lLnZhbGlkYXRpb24pID09PSBudWxsIHx8IF9hcmdzJG5hbWUkdmFsaWRhdGlvbjQgPT09IHZvaWQgMCB8fCAoX2FyZ3MkbmFtZSR2YWxpZGF0aW9uNCA9IF9hcmdzJG5hbWUkdmFsaWRhdGlvbjQubGVuZ3RoKSA9PT0gbnVsbCB8fCBfYXJncyRuYW1lJHZhbGlkYXRpb240ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYXJncyRuYW1lJHZhbGlkYXRpb240Lm1heCkgIT09IG51bGwgJiYgX2FyZ3MkbmFtZSR2YWxpZGF0aW9uMyAhPT0gdm9pZCAwID8gX2FyZ3MkbmFtZSR2YWxpZGF0aW9uMyA6IEluZmluaXR5LCBhcmdzLm5hbWUubGFiZWwsIHVuZGVmaW5lZCk7XG4gICAgaWYgKG5hbWVNZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBGaWVsZERhdGFFcnJvcihuYW1lTWVzc2FnZSk7XG4gICAgfVxuICAgIGNvbnN0IHNsdWdNZXNzYWdlID0gdmFsaWRhdGVUZXh0KHZhbHVlLnNsdWcsIChfYXJncyRzbHVnJHZhbGlkYXRpb24gPSAoX2FyZ3Mkc2x1ZzIgPSBhcmdzLnNsdWcpID09PSBudWxsIHx8IF9hcmdzJHNsdWcyID09PSB2b2lkIDAgfHwgKF9hcmdzJHNsdWcyID0gX2FyZ3Mkc2x1ZzIudmFsaWRhdGlvbikgPT09IG51bGwgfHwgX2FyZ3Mkc2x1ZzIgPT09IHZvaWQgMCB8fCAoX2FyZ3Mkc2x1ZzIgPSBfYXJncyRzbHVnMi5sZW5ndGgpID09PSBudWxsIHx8IF9hcmdzJHNsdWcyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYXJncyRzbHVnMi5taW4pICE9PSBudWxsICYmIF9hcmdzJHNsdWckdmFsaWRhdGlvbiAhPT0gdm9pZCAwID8gX2FyZ3Mkc2x1ZyR2YWxpZGF0aW9uIDogMSwgKF9hcmdzJHNsdWckdmFsaWRhdGlvbjIgPSAoX2FyZ3Mkc2x1ZzMgPSBhcmdzLnNsdWcpID09PSBudWxsIHx8IF9hcmdzJHNsdWczID09PSB2b2lkIDAgfHwgKF9hcmdzJHNsdWczID0gX2FyZ3Mkc2x1ZzMudmFsaWRhdGlvbikgPT09IG51bGwgfHwgX2FyZ3Mkc2x1ZzMgPT09IHZvaWQgMCB8fCAoX2FyZ3Mkc2x1ZzMgPSBfYXJncyRzbHVnMy5sZW5ndGgpID09PSBudWxsIHx8IF9hcmdzJHNsdWczID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYXJncyRzbHVnMy5tYXgpICE9PSBudWxsICYmIF9hcmdzJHNsdWckdmFsaWRhdGlvbjIgIT09IHZvaWQgMCA/IF9hcmdzJHNsdWckdmFsaWRhdGlvbjIgOiBJbmZpbml0eSwgKF9hcmdzJHNsdWckbGFiZWwgPSAoX2FyZ3Mkc2x1ZzQgPSBhcmdzLnNsdWcpID09PSBudWxsIHx8IF9hcmdzJHNsdWc0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYXJncyRzbHVnNC5sYWJlbCkgIT09IG51bGwgJiYgX2FyZ3Mkc2x1ZyRsYWJlbCAhPT0gdm9pZCAwID8gX2FyZ3Mkc2x1ZyRsYWJlbCA6ICdTbHVnJywgc2x1Z0ZpZWxkID8gc2x1Z0ZpZWxkIDoge1xuICAgICAgc2x1Z3M6IGVtcHR5U2V0LFxuICAgICAgZ2xvYjogJyonXG4gICAgfSk7XG4gICAgaWYgKHNsdWdNZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBGaWVsZERhdGFFcnJvcihzbHVnTWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBjb25zdCBlbXB0eVNldCA9IG5ldyBTZXQoKTtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiAnZm9ybScsXG4gICAgZm9ybUtpbmQ6ICdzbHVnJyxcbiAgICBJbnB1dChwcm9wcykge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goU2x1Z0ZpZWxkSW5wdXQsIHtcbiAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgbmFpdmVHZW5lcmF0ZVNsdWc6IG5haXZlR2VuZXJhdGVTbHVnLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgLi4ucHJvcHNcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9LFxuICAgIHBhcnNlKHZhbHVlLCBhcmdzKSB7XG4gICAgICBpZiAoKGFyZ3MgPT09IG51bGwgfHwgYXJncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXJncy5zbHVnKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUFzU2x1Z0ZpZWxkKHZhbHVlLCBhcmdzLnNsdWcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlU2x1Z0ZpZWxkQXNOb3JtYWxGaWVsZCh2YWx1ZSk7XG4gICAgfSxcbiAgICB2YWxpZGF0ZSxcbiAgICBzZXJpYWxpemUodmFsdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlXG4gICAgICB9O1xuICAgIH0sXG4gICAgc2VyaWFsaXplV2l0aFNsdWcodmFsdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZS5uYW1lLFxuICAgICAgICBzbHVnOiB2YWx1ZS5zbHVnXG4gICAgICB9O1xuICAgIH0sXG4gICAgcmVhZGVyOiB7XG4gICAgICBwYXJzZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZVNsdWdGaWVsZEFzTm9ybWFsRmllbGQodmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocGFyc2VkKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZVdpdGhTbHVnKHZhbHVlLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwYXJzZUFzU2x1Z0ZpZWxkKHZhbHVlLCBhcmdzLnNsdWcpLCB7XG4gICAgICAgICAgc2x1Z0ZpZWxkOiB7XG4gICAgICAgICAgICBnbG9iOiBhcmdzLmdsb2IsXG4gICAgICAgICAgICBzbHVnczogZW1wdHlTZXRcbiAgICAgICAgICB9XG4gICAgICAgIH0pLm5hbWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkVVJMKHVybCkge1xuICByZXR1cm4gdXJsID09PSBzYW5pdGl6ZVVybCh1cmwpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVVybCh2YWxpZGF0aW9uLCB2YWx1ZSwgbGFiZWwpIHtcbiAgaWYgKHZhbHVlICE9PSBudWxsICYmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8ICFpc1ZhbGlkVVJMKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gYCR7bGFiZWx9IGlzIG5vdCBhIHZhbGlkIFVSTGA7XG4gIH1cbiAgaWYgKHZhbGlkYXRpb24gIT09IG51bGwgJiYgdmFsaWRhdGlvbiAhPT0gdm9pZCAwICYmIHZhbGlkYXRpb24uaXNSZXF1aXJlZCAmJiB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBgJHtsYWJlbH0gaXMgcmVxdWlyZWRgO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVybCh7XG4gIGxhYmVsLFxuICBkZWZhdWx0VmFsdWUsXG4gIHZhbGlkYXRpb24sXG4gIGRlc2NyaXB0aW9uXG59KSB7XG4gIHJldHVybiBiYXNpY0Zvcm1GaWVsZFdpdGhTaW1wbGVSZWFkZXJQYXJzZSh7XG4gICAgSW5wdXQocHJvcHMpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFVybEZpZWxkSW5wdXQsIHtcbiAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICAgIHZhbGlkYXRpb246IHZhbGlkYXRpb24sXG4gICAgICAgIC4uLnByb3BzXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcbiAgICB9LFxuICAgIHBhcnNlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBGaWVsZERhdGFFcnJvcignTXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID09PSAnJyA/IG51bGwgOiB2YWx1ZTtcbiAgICB9LFxuICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gdmFsaWRhdGVVcmwodmFsaWRhdGlvbiwgdmFsdWUsIGxhYmVsKTtcbiAgICAgIGlmIChtZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpZWxkRGF0YUVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0UmVxdWlyZWQodmFsdWUsIHZhbGlkYXRpb24sIGxhYmVsKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlID09PSBudWxsID8gdW5kZWZpbmVkIDogdmFsdWVcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYmxvY2tzKGJsb2Nrcywgb3B0cykge1xuICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoYmxvY2tzKTtcbiAgaWYgKCFlbnRyaWVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZmllbGRzLmJsb2NrcyBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGVudHJ5Jyk7XG4gIH1cbiAgY29uc3Qgc2VsZWN0JDEgPSBzZWxlY3Qoe1xuICAgIGxhYmVsOiAnS2luZCcsXG4gICAgZGVmYXVsdFZhbHVlOiBlbnRyaWVzWzBdWzBdLFxuICAgIG9wdGlvbnM6IE9iamVjdC5lbnRyaWVzKGJsb2NrcykubWFwKChba2V5LCB7XG4gICAgICBsYWJlbFxuICAgIH1dKSA9PiAoe1xuICAgICAgbGFiZWwsXG4gICAgICB2YWx1ZToga2V5XG4gICAgfSkpXG4gIH0pO1xuICBjb25zdCBlbGVtZW50ID0gY29uZGl0aW9uYWwoc2VsZWN0JDEsIE9iamVjdC5mcm9tRW50cmllcyhlbnRyaWVzLm1hcCgoW2tleSwge1xuICAgIHNjaGVtYVxuICB9XSkgPT4gW2tleSwgc2NoZW1hXSkpKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5hcnJheShlbGVtZW50LCB7XG4gICAgICBsYWJlbDogb3B0cy5sYWJlbCxcbiAgICAgIGRlc2NyaXB0aW9uOiBvcHRzLmRlc2NyaXB0aW9uLFxuICAgICAgdmFsaWRhdGlvbjogb3B0cy52YWxpZGF0aW9uLFxuICAgICAgaXRlbUxhYmVsKHByb3BzKSB7XG4gICAgICAgIGNvbnN0IGtpbmQgPSBwcm9wcy5kaXNjcmltaW5hbnQ7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gYmxvY2tzW2tpbmRdO1xuICAgICAgICBpZiAoIWJsb2NrLml0ZW1MYWJlbCkgcmV0dXJuIGJsb2NrLmxhYmVsO1xuICAgICAgICByZXR1cm4gYmxvY2suaXRlbUxhYmVsKHByb3BzLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICBJbnB1dDogQmxvY2tzRmllbGRJbnB1dFxuICB9O1xufVxuXG5mdW5jdGlvbiBjbG91ZEltYWdlKHtcbiAgbGFiZWwsXG4gIGRlc2NyaXB0aW9uLFxuICB2YWxpZGF0aW9uXG59KSB7XG4gIHJldHVybiB7XG4gICAgLi4ub2JqZWN0KHtcbiAgICAgIHNyYzogdGV4dCh7XG4gICAgICAgIGxhYmVsOiAnVVJMJyxcbiAgICAgICAgdmFsaWRhdGlvbjoge1xuICAgICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgbWluOiB2YWxpZGF0aW9uICE9PSBudWxsICYmIHZhbGlkYXRpb24gIT09IHZvaWQgMCAmJiB2YWxpZGF0aW9uLmlzUmVxdWlyZWQgPyAxIDogMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBhbHQ6IHRleHQoe1xuICAgICAgICBsYWJlbDogJ0FsdCB0ZXh0J1xuICAgICAgfSksXG4gICAgICBoZWlnaHQ6IGludGVnZXIoe1xuICAgICAgICBsYWJlbDogJ0hlaWdodCdcbiAgICAgIH0pLFxuICAgICAgd2lkdGg6IGludGVnZXIoe1xuICAgICAgICBsYWJlbDogJ1dpZHRoJ1xuICAgICAgfSlcbiAgICB9LCB7XG4gICAgICBsYWJlbCxcbiAgICAgIGRlc2NyaXB0aW9uXG4gICAgfSksXG4gICAgSW5wdXQocHJvcHMpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovanN4KENsb3VkSW1hZ2VGaWVsZElucHV0LCB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBpc1JlcXVpcmVkOiB2YWxpZGF0aW9uID09PSBudWxsIHx8IHZhbGlkYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbGlkYXRpb24uaXNSZXF1aXJlZFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgaW5kZXggPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYXJyYXk6IGFycmF5LFxuICBjaGVja2JveDogY2hlY2tib3gsXG4gIGNoaWxkOiBjaGlsZCxcbiAgY29uZGl0aW9uYWw6IGNvbmRpdGlvbmFsLFxuICBkYXRlOiBkYXRlLFxuICBkYXRldGltZTogZGF0ZXRpbWUsXG4gIGRvY3VtZW50OiBkb2N1bWVudCxcbiAgZW1wdHlEb2N1bWVudDogZW1wdHlEb2N1bWVudCxcbiAgZW1wdHk6IGVtcHR5LFxuICBpbWFnZTogaW1hZ2UsXG4gIGZpbGU6IGZpbGUsXG4gIGludGVnZXI6IGludGVnZXIsXG4gIG11bHRpc2VsZWN0OiBtdWx0aXNlbGVjdCxcbiAgb2JqZWN0OiBvYmplY3QsXG4gIHBhdGhSZWZlcmVuY2U6IHBhdGhSZWZlcmVuY2UsXG4gIHJlbGF0aW9uc2hpcDogcmVsYXRpb25zaGlwLFxuICBzZWxlY3Q6IHNlbGVjdCxcbiAgc2x1Zzogc2x1ZyxcbiAgdGV4dDogdGV4dCxcbiAgdXJsOiB1cmwsXG4gIGJsb2NrczogYmxvY2tzLFxuICBjbG91ZEltYWdlOiBjbG91ZEltYWdlXG59KTtcblxuZnVuY3Rpb24gY29uZmlnKGNvbmZpZykge1xuICByZXR1cm4gY29uZmlnO1xufVxuZnVuY3Rpb24gY29sbGVjdGlvbihjb2xsZWN0aW9uKSB7XG4gIHJldHVybiBjb2xsZWN0aW9uO1xufVxuZnVuY3Rpb24gc2luZ2xldG9uKGNvbGxlY3Rpb24pIHtcbiAgcmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIEJsb2NrV3JhcHBlcigpIHt9XG5mdW5jdGlvbiBOb3RFZGl0YWJsZSgpIHt9XG5mdW5jdGlvbiBUb29sYmFyU2VwYXJhdG9yKCkge31cblxuZXhwb3J0IHsgQmxvY2tXcmFwcGVyLCBOb3RFZGl0YWJsZSwgVG9vbGJhclNlcGFyYXRvciwgY29sbGVjdGlvbiwgY29uZmlnLCBpbmRleCBhcyBmaWVsZHMsIHNpbmdsZXRvbiB9O1xuIl0sIm5hbWVzIjpbImkiLCJpbnRlZ2VyIiwiYyIsImNvbXBvbmVudCIsIkMiLCJDaGVja2JveEZpZWxkSW5wdXQiLCJhIiwiRGF0ZUZpZWxkSW5wdXQiLCJiIiwiRGF0ZXRpbWVGaWVsZElucHV0IiwiSSIsIkltYWdlRmllbGRJbnB1dCIsIkYiLCJGaWxlRmllbGRJbnB1dCIsIk0iLCJNdWx0aXNlbGVjdEZpZWxkSW5wdXQiLCJQIiwiUGF0aFJlZmVyZW5jZUlucHV0IiwiUiIsIlJlbGF0aW9uc2hpcElucHV0IiwiUyIsIlNlbGVjdEZpZWxkSW5wdXQiLCJTbHVnRmllbGRJbnB1dCIsIlUiLCJVcmxGaWVsZElucHV0IiwiQiIsIkJsb2Nrc0ZpZWxkSW5wdXQiLCJkIiwiQ2xvdWRJbWFnZUZpZWxkSW5wdXQiLCJMIiwiYmFzaWNGb3JtRmllbGRXaXRoU2ltcGxlUmVhZGVyUGFyc2UiLCJKIiwiRmllbGREYXRhRXJyb3IiLCJhc3NlcnRSZXF1aXJlZCIsIk4iLCJnZXRTcmNQcmVmaXgiLCJPIiwiZml4UGF0aCIsInZhbGlkYXRlVGV4dCIsInEiLCJvYmplY3QiLCJRIiwidGV4dCIsImRvY3VtZW50IiwianN4Iiwic2x1Z2lmeSIsInNhbml0aXplVXJsIiwiYXJyYXkiLCJlbGVtZW50Iiwib3B0cyIsIl9vcHRzJGxhYmVsIiwia2luZCIsImxhYmVsIiwiZGVzY3JpcHRpb24iLCJpdGVtTGFiZWwiLCJhc0NoaWxkVGFnIiwic2x1Z0ZpZWxkIiwidmFsaWRhdGlvbiIsImNoZWNrYm94IiwiZGVmYXVsdFZhbHVlIiwiSW5wdXQiLCJwcm9wcyIsInBhcnNlIiwidmFsdWUiLCJ1bmRlZmluZWQiLCJ2YWxpZGF0ZSIsInNlcmlhbGl6ZSIsImNoaWxkIiwib3B0aW9ucyIsInBsYWNlaG9sZGVyIiwiZGl2aWRlcnMiLCJmb3JtYXR0aW5nIiwiYmxvY2tUeXBlcyIsImhlYWRpbmdMZXZlbHMiLCJpbmxpbmVNYXJrcyIsImxpc3RUeXBlcyIsImFsaWdubWVudCIsInNvZnRCcmVha3MiLCJsaW5rcyIsImltYWdlcyIsInRhYmxlcyIsImNvbXBvbmVudEJsb2NrcyIsImNvbmRpdGlvbmFsIiwiZGlzY3JpbWluYW50IiwidmFsdWVzIiwidmFsaWRhdGVEYXRlIiwidGVzdCIsImlzUmVxdWlyZWQiLCJtaW4iLCJtYXgiLCJkYXRlIiwiRGF0ZSIsInRvTG9jYWxlRGF0ZVN0cmluZyIsInRvZGF5IiwieWVhciIsImdldEZ1bGxZZWFyIiwibW9udGgiLCJTdHJpbmciLCJnZXRNb250aCIsInBhZFN0YXJ0IiwiZGF5IiwiZ2V0RGF0ZSIsIm1lc3NhZ2UiLCJ2YWxpZGF0ZURhdGV0aW1lIiwiZGF0ZXRpbWUiLCJ0b0lTT1N0cmluZyIsIm5vdyIsImVtcHR5RG9jdW1lbnQiLCJmb3JtS2luZCIsImNvbnRlbnRFeHRlbnNpb24iLCJjb250ZW50IiwiVWludDhBcnJheSIsImV4dGVybmFsIiwiTWFwIiwib3RoZXIiLCJyZWFkZXIiLCJlbXB0eSIsImltYWdlIiwiZGlyZWN0b3J5IiwicHVibGljUGF0aCIsImZpbGVuYW1lIiwiYXJncyIsInNsaWNlIiwic2x1ZyIsImxlbmd0aCIsIl92YWx1ZSRtYXRjaCQiLCJfdmFsdWUkbWF0Y2giLCJhc3NldCIsImRhdGEiLCJleHRlbnNpb24iLCJtYXRjaCIsInN1Z2dlc3RlZEZpbGVuYW1lUHJlZml4IiwidmFsIiwiZmlsZSIsIm11bHRpc2VsZWN0IiwidmFsdWVzVG9PcHRpb24iLCJtYXAiLCJ4IiwiZmllbGQiLCJBcnJheSIsImlzQXJyYXkiLCJldmVyeSIsImhhcyIsImpvaW4iLCJwYXRoUmVmZXJlbmNlIiwicGF0dGVybiIsInJlbGF0aW9uc2hpcCIsImNvbGxlY3Rpb24iLCJzZWxlY3QiLCJvcHRpb25WYWx1ZXNTZXQiLCJTZXQiLCJFcnJvciIsInBhcnNlU2x1Z0ZpZWxkQXNOb3JtYWxGaWVsZCIsIm5hbWUiLCJPYmplY3QiLCJrZXlzIiwicGFyc2VBc1NsdWdGaWVsZCIsIl9hcmdzJHNsdWciLCJfYXJncyRuYW1lJGRlZmF1bHRWYWwiLCJfYXJncyRuYW1lJGRlZmF1bHRWYWwyIiwibmFpdmVHZW5lcmF0ZVNsdWciLCJnZW5lcmF0ZSIsIl9hcmdzJG5hbWUkdmFsaWRhdGlvbiIsIl9hcmdzJG5hbWUkdmFsaWRhdGlvbjIiLCJfYXJncyRuYW1lJHZhbGlkYXRpb24zIiwiX2FyZ3MkbmFtZSR2YWxpZGF0aW9uNCIsIl9hcmdzJHNsdWckdmFsaWRhdGlvbiIsIl9hcmdzJHNsdWcyIiwiX2FyZ3Mkc2x1ZyR2YWxpZGF0aW9uMiIsIl9hcmdzJHNsdWczIiwiX2FyZ3Mkc2x1ZyRsYWJlbCIsIl9hcmdzJHNsdWc0IiwibmFtZU1lc3NhZ2UiLCJJbmZpbml0eSIsInNsdWdNZXNzYWdlIiwic2x1Z3MiLCJlbXB0eVNldCIsImdsb2IiLCJzZXJpYWxpemVXaXRoU2x1ZyIsInBhcnNlZCIsInBhcnNlV2l0aFNsdWciLCJpc1ZhbGlkVVJMIiwidXJsIiwidmFsaWRhdGVVcmwiLCJibG9ja3MiLCJlbnRyaWVzIiwic2VsZWN0JDEiLCJrZXkiLCJmcm9tRW50cmllcyIsInNjaGVtYSIsImJsb2NrIiwiY2xvdWRJbWFnZSIsInNyYyIsImFsdCIsImhlaWdodCIsIndpZHRoIiwiaW5kZXgiLCJmcmVlemUiLCJfX3Byb3RvX18iLCJjb25maWciLCJzaW5nbGV0b24iLCJCbG9ja1dyYXBwZXIiLCJOb3RFZGl0YWJsZSIsIlRvb2xiYXJTZXBhcmF0b3IiLCJmaWVsZHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/keystatic-core.node.react-server.esm.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/required-files-58b1ab35.node.react-server.esm.js":
/*!***********************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/required-files-58b1ab35.node.react-server.esm.js ***!
  \***********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   P: () => (/* binding */ PropValidationError),\n/* harmony export */   f: () => (/* binding */ formatFormDataError),\n/* harmony export */   l: () => (/* binding */ loadDataFile),\n/* harmony export */   p: () => (/* binding */ parseProps),\n/* harmony export */   t: () => (/* binding */ toFormattedFormDataError),\n/* harmony export */   v: () => (/* binding */ validateArrayLength)\n/* harmony export */ });\n/* harmony import */ var _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-b0eee923.node.react-server.esm.js */ \"(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/index-b0eee923.node.react-server.esm.js\");\n/* harmony import */ var emery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! emery */ \"(rsc)/../../node_modules/.pnpm/emery@1.4.2/node_modules/emery/dist/emery.cjs.js\");\n/* harmony import */ var js_yaml__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! js-yaml */ \"(rsc)/../../node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/dist/js-yaml.mjs\");\n\n\n\nfunction validateArrayLength(schema, val, path) {\n    var _schema$validation, _schema$validation2;\n    if (((_schema$validation = schema.validation) === null || _schema$validation === void 0 || (_schema$validation = _schema$validation.length) === null || _schema$validation === void 0 ? void 0 : _schema$validation.min) !== undefined && val.length < schema.validation.length.min) {\n        return new PropValidationError(new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__.J(`Must have at least ${schema.validation.length.min} element${schema.validation.length.min === 1 ? \"\" : \"s\"}`), path, schema);\n    }\n    if (((_schema$validation2 = schema.validation) === null || _schema$validation2 === void 0 || (_schema$validation2 = _schema$validation2.length) === null || _schema$validation2 === void 0 ? void 0 : _schema$validation2.max) !== undefined && val.length > schema.validation.length.max) {\n        return new PropValidationError(new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__.J(`Must have at most ${schema.validation.length.max} element${schema.validation.length.max === 1 ? \"\" : \"s\"}}`), path, schema);\n    }\n}\nclass PropValidationError extends Error {\n    constructor(cause, path, schema){\n        super(`field error at ${path.join(\".\")}`, {\n            cause\n        });\n        this.path = path;\n        this.schema = schema;\n        this.cause = cause;\n    }\n}\nfunction toFormFieldStoredValue(val) {\n    if (val === null) {\n        return undefined;\n    }\n    return val;\n}\nconst isArray = Array.isArray;\nfunction parseProps(schema, _value, path, pathWithArrayFieldSlugs, parseFormField, /** This should be true for the reader and false elsewhere */ validateArrayFieldLength) {\n    let value = toFormFieldStoredValue(_value);\n    if (schema.kind === \"form\") {\n        try {\n            return parseFormField(schema, value, path, pathWithArrayFieldSlugs);\n        } catch (err) {\n            throw new PropValidationError(err, path, schema);\n        }\n    }\n    if (schema.kind === \"child\") {\n        return null;\n    }\n    if (schema.kind === \"conditional\") {\n        if (value === undefined) {\n            return (0,_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__.n)(schema);\n        }\n        try {\n            if (typeof value !== \"object\" || value === null || isArray(value)) {\n                throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__.J(\"Must be an object\");\n            }\n            for (const key of Object.keys(value)){\n                if (key !== \"discriminant\" && key !== \"value\") {\n                    throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__.J(`Must only contain keys \"discriminant\" and \"value\", not \"${key}\"`);\n                }\n            }\n        } catch (err) {\n            throw new PropValidationError(err, path, schema);\n        }\n        const parsedDiscriminant = parseProps(schema.discriminant, value.discriminant, path.concat(\"discriminant\"), pathWithArrayFieldSlugs.concat(\"discriminant\"), parseFormField, validateArrayFieldLength);\n        return {\n            discriminant: parsedDiscriminant,\n            value: parseProps(schema.values[parsedDiscriminant], value.value, path.concat(\"value\"), pathWithArrayFieldSlugs.concat(\"value\"), parseFormField, validateArrayFieldLength)\n        };\n    }\n    if (schema.kind === \"object\") {\n        if (value === undefined) {\n            value = {};\n        }\n        try {\n            if (typeof value !== \"object\" || value === null || isArray(value)) {\n                throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__.J(\"Must be an object\");\n            }\n            const allowedKeysSet = new Set(Object.keys(schema.fields));\n            for (const key of Object.keys(value)){\n                if (!allowedKeysSet.has(key)) {\n                    throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__.J(`Key on object value \"${key}\" is not allowed`);\n                }\n            }\n        } catch (err) {\n            throw new PropValidationError(err, path, schema);\n        }\n        const val = {};\n        const errors = [];\n        for (const key of Object.keys(schema.fields)){\n            let individualVal = value[key];\n            try {\n                const propVal = parseProps(schema.fields[key], individualVal, path.concat(key), pathWithArrayFieldSlugs.concat(key), parseFormField, validateArrayFieldLength);\n                val[key] = propVal;\n            } catch (err) {\n                errors.push(err);\n            }\n        }\n        if (errors.length) {\n            throw new AggregateError(errors);\n        }\n        return val;\n    }\n    if (schema.kind === \"array\") {\n        if (value === undefined) {\n            return [];\n        }\n        try {\n            if (!isArray(value)) {\n                throw new _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__.J(\"Must be an array\");\n            }\n        } catch (err) {\n            throw new PropValidationError(err, path, schema);\n        }\n        const errors = [];\n        try {\n            if (validateArrayFieldLength) {\n                const error = validateArrayLength(schema, value, path);\n                if (error !== undefined) {\n                    errors.push(error);\n                }\n            }\n            return value.map((innerVal, i)=>{\n                try {\n                    let slug = i.toString();\n                    if (schema.slugField && typeof innerVal === \"object\" && innerVal !== null && !isArray(innerVal)) {\n                        if (schema.element.kind !== \"object\") {\n                            throw new Error(\"slugField on array fields requires the an object field element\");\n                        }\n                        const slugField = schema.element.fields[schema.slugField];\n                        if (!slugField) {\n                            throw new Error(`slugField \"${schema.slugField}\" does not exist on object field`);\n                        }\n                        if (slugField.kind !== \"form\") {\n                            throw new Error(`slugField \"${schema.slugField}\" is not a form field`);\n                        }\n                        if (slugField.formKind !== \"slug\") {\n                            throw new Error(`slugField \"${schema.slugField}\" is not a slug field`);\n                        }\n                        let parsedSlugFieldValue;\n                        try {\n                            parsedSlugFieldValue = slugField.parse(toFormFieldStoredValue(innerVal[schema.slugField]), undefined);\n                        } catch (err) {\n                            throw new AggregateError([\n                                err\n                            ]);\n                        }\n                        slug = slugField.serializeWithSlug(parsedSlugFieldValue).slug;\n                    }\n                    return parseProps(schema.element, innerVal, path.concat(i), pathWithArrayFieldSlugs.concat(slug), parseFormField, validateArrayFieldLength);\n                } catch (err) {\n                    errors.push(err);\n                }\n            });\n        } finally{\n            if (errors.length) {\n                throw new AggregateError(errors);\n            }\n        }\n    }\n    (0,emery__WEBPACK_IMPORTED_MODULE_1__.assertNever)(schema);\n}\nfunction flattenErrors(error) {\n    if (error instanceof AggregateError) {\n        return error.errors.flatMap(flattenErrors);\n    }\n    return [\n        error\n    ];\n}\nfunction formatFormDataError(error) {\n    const flatErrors = flattenErrors(error);\n    return flatErrors.map((error)=>{\n        if (error instanceof PropValidationError) {\n            const path = error.path.join(\".\");\n            return `${path}: ${error.cause instanceof _index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__.J ? error.cause.message : `Unexpected error: ${error.cause}`}`;\n        }\n        return `Unexpected error: ${error}`;\n    }).join(\"\\n\");\n}\nfunction toFormattedFormDataError(error) {\n    const formatted = formatFormDataError(error);\n    return new Error(`Field validation failed:\\n` + formatted);\n}\nconst textDecoder = new TextDecoder();\nconst textEncoder = new TextEncoder();\nfunction splitFrontmatter(data) {\n    const str = textDecoder.decode(data);\n    const match = str.match(/^---(?:\\r?\\n([^]*?))?\\r?\\n---\\r?\\n?/);\n    if (match) {\n        var _match$;\n        const encoded = textEncoder.encode(match[0]);\n        return {\n            frontmatter: (_match$ = match[1]) !== null && _match$ !== void 0 ? _match$ : \"\",\n            content: data.slice(encoded.byteLength)\n        };\n    }\n    return null;\n}\nfunction loadDataFile(data, formatInfo) {\n    const parse = formatInfo.data === \"json\" ? JSON.parse : js_yaml__WEBPACK_IMPORTED_MODULE_2__.load;\n    if (!formatInfo.contentField) {\n        const dataFile = textDecoder.decode(data);\n        return {\n            loaded: parse(dataFile)\n        };\n    }\n    const res = splitFrontmatter(data);\n    (0,emery__WEBPACK_IMPORTED_MODULE_1__.assert)(res !== null, \"frontmatter not found\");\n    return {\n        loaded: parse(res.frontmatter),\n        extraFakeFile: {\n            path: `${formatInfo.contentField.key}${formatInfo.contentField.config.contentExtension}`,\n            contents: res.content\n        }\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BrZXlzdGF0aWMrY29yZUAwLjEuN19uZXh0QDEzLjUuNl9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQGtleXN0YXRpYy9jb3JlL2Rpc3QvcmVxdWlyZWQtZmlsZXMtNThiMWFiMzUubm9kZS5yZWFjdC1zZXJ2ZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUEyRztBQUMvRDtBQUNiO0FBRS9CLFNBQVNPLG9CQUFvQkMsTUFBTSxFQUFFQyxHQUFHLEVBQUVDLElBQUk7SUFDNUMsSUFBSUMsb0JBQW9CQztJQUN4QixJQUFJLENBQUMsQ0FBQ0QscUJBQXFCSCxPQUFPSyxVQUFVLE1BQU0sUUFBUUYsdUJBQXVCLEtBQUssS0FBSyxDQUFDQSxxQkFBcUJBLG1CQUFtQkcsTUFBTSxNQUFNLFFBQVFILHVCQUF1QixLQUFLLElBQUksS0FBSyxJQUFJQSxtQkFBbUJJLEdBQUcsTUFBTUMsYUFBYVAsSUFBSUssTUFBTSxHQUFHTixPQUFPSyxVQUFVLENBQUNDLE1BQU0sQ0FBQ0MsR0FBRyxFQUFFO1FBQ25SLE9BQU8sSUFBSUUsb0JBQW9CLElBQUloQix1RUFBY0EsQ0FBQyxDQUFDLG1CQUFtQixFQUFFTyxPQUFPSyxVQUFVLENBQUNDLE1BQU0sQ0FBQ0MsR0FBRyxDQUFDLFFBQVEsRUFBRVAsT0FBT0ssVUFBVSxDQUFDQyxNQUFNLENBQUNDLEdBQUcsS0FBSyxJQUFJLEtBQUssSUFBSSxDQUFDLEdBQUdMLE1BQU1GO0lBQ3pLO0lBQ0EsSUFBSSxDQUFDLENBQUNJLHNCQUFzQkosT0FBT0ssVUFBVSxNQUFNLFFBQVFELHdCQUF3QixLQUFLLEtBQUssQ0FBQ0Esc0JBQXNCQSxvQkFBb0JFLE1BQU0sTUFBTSxRQUFRRix3QkFBd0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsb0JBQW9CTSxHQUFHLE1BQU1GLGFBQWFQLElBQUlLLE1BQU0sR0FBR04sT0FBT0ssVUFBVSxDQUFD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O0FBRTJKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va2V5c3RhdGljLXN0YXJ0ZXIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BrZXlzdGF0aWMrY29yZUAwLjEuN19uZXh0QDEzLjUuNl9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQGtleXN0YXRpYy9jb3JlL2Rpc3QvcmVxdWlyZWQtZmlsZXMtNThiMWFiMzUubm9kZS5yZWFjdC1zZXJ2ZXIuZXNtLmpzPzYwMTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSiBhcyBGaWVsZERhdGFFcnJvciwgbiBhcyBnZXRJbml0aWFsUHJvcHNWYWx1ZSB9IGZyb20gJy4vaW5kZXgtYjBlZWU5MjMubm9kZS5yZWFjdC1zZXJ2ZXIuZXNtLmpzJztcbmltcG9ydCB7IGFzc2VydE5ldmVyLCBhc3NlcnQgfSBmcm9tICdlbWVyeSc7XG5pbXBvcnQgeyBsb2FkIH0gZnJvbSAnanMteWFtbCc7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQXJyYXlMZW5ndGgoc2NoZW1hLCB2YWwsIHBhdGgpIHtcbiAgdmFyIF9zY2hlbWEkdmFsaWRhdGlvbiwgX3NjaGVtYSR2YWxpZGF0aW9uMjtcbiAgaWYgKCgoX3NjaGVtYSR2YWxpZGF0aW9uID0gc2NoZW1hLnZhbGlkYXRpb24pID09PSBudWxsIHx8IF9zY2hlbWEkdmFsaWRhdGlvbiA9PT0gdm9pZCAwIHx8IChfc2NoZW1hJHZhbGlkYXRpb24gPSBfc2NoZW1hJHZhbGlkYXRpb24ubGVuZ3RoKSA9PT0gbnVsbCB8fCBfc2NoZW1hJHZhbGlkYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zY2hlbWEkdmFsaWRhdGlvbi5taW4pICE9PSB1bmRlZmluZWQgJiYgdmFsLmxlbmd0aCA8IHNjaGVtYS52YWxpZGF0aW9uLmxlbmd0aC5taW4pIHtcbiAgICByZXR1cm4gbmV3IFByb3BWYWxpZGF0aW9uRXJyb3IobmV3IEZpZWxkRGF0YUVycm9yKGBNdXN0IGhhdmUgYXQgbGVhc3QgJHtzY2hlbWEudmFsaWRhdGlvbi5sZW5ndGgubWlufSBlbGVtZW50JHtzY2hlbWEudmFsaWRhdGlvbi5sZW5ndGgubWluID09PSAxID8gJycgOiAncyd9YCksIHBhdGgsIHNjaGVtYSk7XG4gIH1cbiAgaWYgKCgoX3NjaGVtYSR2YWxpZGF0aW9uMiA9IHNjaGVtYS52YWxpZGF0aW9uKSA9PT0gbnVsbCB8fCBfc2NoZW1hJHZhbGlkYXRpb24yID09PSB2b2lkIDAgfHwgKF9zY2hlbWEkdmFsaWRhdGlvbjIgPSBfc2NoZW1hJHZhbGlkYXRpb24yLmxlbmd0aCkgPT09IG51bGwgfHwgX3NjaGVtYSR2YWxpZGF0aW9uMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NjaGVtYSR2YWxpZGF0aW9uMi5tYXgpICE9PSB1bmRlZmluZWQgJiYgdmFsLmxlbmd0aCA+IHNjaGVtYS52YWxpZGF0aW9uLmxlbmd0aC5tYXgpIHtcbiAgICByZXR1cm4gbmV3IFByb3BWYWxpZGF0aW9uRXJyb3IobmV3IEZpZWxkRGF0YUVycm9yKGBNdXN0IGhhdmUgYXQgbW9zdCAke3NjaGVtYS52YWxpZGF0aW9uLmxlbmd0aC5tYXh9IGVsZW1lbnQke3NjaGVtYS52YWxpZGF0aW9uLmxlbmd0aC5tYXggPT09IDEgPyAnJyA6ICdzJ319YCksIHBhdGgsIHNjaGVtYSk7XG4gIH1cbn1cblxuY2xhc3MgUHJvcFZhbGlkYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2F1c2UsIHBhdGgsIHNjaGVtYSkge1xuICAgIHN1cGVyKGBmaWVsZCBlcnJvciBhdCAke3BhdGguam9pbignLicpfWAsIHtcbiAgICAgIGNhdXNlXG4gICAgfSk7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvRm9ybUZpZWxkU3RvcmVkVmFsdWUodmFsKSB7XG4gIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB2YWw7XG59XG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmZ1bmN0aW9uIHBhcnNlUHJvcHMoc2NoZW1hLCBfdmFsdWUsIHBhdGgsIHBhdGhXaXRoQXJyYXlGaWVsZFNsdWdzLCBwYXJzZUZvcm1GaWVsZCwgLyoqIFRoaXMgc2hvdWxkIGJlIHRydWUgZm9yIHRoZSByZWFkZXIgYW5kIGZhbHNlIGVsc2V3aGVyZSAqL1xudmFsaWRhdGVBcnJheUZpZWxkTGVuZ3RoKSB7XG4gIGxldCB2YWx1ZSA9IHRvRm9ybUZpZWxkU3RvcmVkVmFsdWUoX3ZhbHVlKTtcbiAgaWYgKHNjaGVtYS5raW5kID09PSAnZm9ybScpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHBhcnNlRm9ybUZpZWxkKHNjaGVtYSwgdmFsdWUsIHBhdGgsIHBhdGhXaXRoQXJyYXlGaWVsZFNsdWdzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBQcm9wVmFsaWRhdGlvbkVycm9yKGVyciwgcGF0aCwgc2NoZW1hKTtcbiAgICB9XG4gIH1cbiAgaWYgKHNjaGVtYS5raW5kID09PSAnY2hpbGQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHNjaGVtYS5raW5kID09PSAnY29uZGl0aW9uYWwnKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBnZXRJbml0aWFsUHJvcHNWYWx1ZShzY2hlbWEpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwgfHwgaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpZWxkRGF0YUVycm9yKCdNdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModmFsdWUpKSB7XG4gICAgICAgIGlmIChrZXkgIT09ICdkaXNjcmltaW5hbnQnICYmIGtleSAhPT0gJ3ZhbHVlJykge1xuICAgICAgICAgIHRocm93IG5ldyBGaWVsZERhdGFFcnJvcihgTXVzdCBvbmx5IGNvbnRhaW4ga2V5cyBcImRpc2NyaW1pbmFudFwiIGFuZCBcInZhbHVlXCIsIG5vdCBcIiR7a2V5fVwiYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBQcm9wVmFsaWRhdGlvbkVycm9yKGVyciwgcGF0aCwgc2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkRGlzY3JpbWluYW50ID0gcGFyc2VQcm9wcyhzY2hlbWEuZGlzY3JpbWluYW50LCB2YWx1ZS5kaXNjcmltaW5hbnQsIHBhdGguY29uY2F0KCdkaXNjcmltaW5hbnQnKSwgcGF0aFdpdGhBcnJheUZpZWxkU2x1Z3MuY29uY2F0KCdkaXNjcmltaW5hbnQnKSwgcGFyc2VGb3JtRmllbGQsIHZhbGlkYXRlQXJyYXlGaWVsZExlbmd0aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpc2NyaW1pbmFudDogcGFyc2VkRGlzY3JpbWluYW50LFxuICAgICAgdmFsdWU6IHBhcnNlUHJvcHMoc2NoZW1hLnZhbHVlc1twYXJzZWREaXNjcmltaW5hbnRdLCB2YWx1ZS52YWx1ZSwgcGF0aC5jb25jYXQoJ3ZhbHVlJyksIHBhdGhXaXRoQXJyYXlGaWVsZFNsdWdzLmNvbmNhdCgndmFsdWUnKSwgcGFyc2VGb3JtRmllbGQsIHZhbGlkYXRlQXJyYXlGaWVsZExlbmd0aClcbiAgICB9O1xuICB9XG4gIGlmIChzY2hlbWEua2luZCA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsdWUgPSB7fTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsIHx8IGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBGaWVsZERhdGFFcnJvcignTXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFsbG93ZWRLZXlzU2V0ID0gbmV3IFNldChPYmplY3Qua2V5cyhzY2hlbWEuZmllbGRzKSk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCFhbGxvd2VkS2V5c1NldC5oYXMoa2V5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBGaWVsZERhdGFFcnJvcihgS2V5IG9uIG9iamVjdCB2YWx1ZSBcIiR7a2V5fVwiIGlzIG5vdCBhbGxvd2VkYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBQcm9wVmFsaWRhdGlvbkVycm9yKGVyciwgcGF0aCwgc2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgdmFsID0ge307XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hLmZpZWxkcykpIHtcbiAgICAgIGxldCBpbmRpdmlkdWFsVmFsID0gdmFsdWVba2V5XTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHByb3BWYWwgPSBwYXJzZVByb3BzKHNjaGVtYS5maWVsZHNba2V5XSwgaW5kaXZpZHVhbFZhbCwgcGF0aC5jb25jYXQoa2V5KSwgcGF0aFdpdGhBcnJheUZpZWxkU2x1Z3MuY29uY2F0KGtleSksIHBhcnNlRm9ybUZpZWxkLCB2YWxpZGF0ZUFycmF5RmllbGRMZW5ndGgpO1xuICAgICAgICB2YWxba2V5XSA9IHByb3BWYWw7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBBZ2dyZWdhdGVFcnJvcihlcnJvcnMpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGlmIChzY2hlbWEua2luZCA9PT0gJ2FycmF5Jykge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpZiAoIWlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBGaWVsZERhdGFFcnJvcignTXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IFByb3BWYWxpZGF0aW9uRXJyb3IoZXJyLCBwYXRoLCBzY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgaWYgKHZhbGlkYXRlQXJyYXlGaWVsZExlbmd0aCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHZhbGlkYXRlQXJyYXlMZW5ndGgoc2NoZW1hLCB2YWx1ZSwgcGF0aCk7XG4gICAgICAgIGlmIChlcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUubWFwKChpbm5lclZhbCwgaSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCBzbHVnID0gaS50b1N0cmluZygpO1xuICAgICAgICAgIGlmIChzY2hlbWEuc2x1Z0ZpZWxkICYmIHR5cGVvZiBpbm5lclZhbCA9PT0gJ29iamVjdCcgJiYgaW5uZXJWYWwgIT09IG51bGwgJiYgIWlzQXJyYXkoaW5uZXJWYWwpKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLmVsZW1lbnQua2luZCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzbHVnRmllbGQgb24gYXJyYXkgZmllbGRzIHJlcXVpcmVzIHRoZSBhbiBvYmplY3QgZmllbGQgZWxlbWVudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2x1Z0ZpZWxkID0gc2NoZW1hLmVsZW1lbnQuZmllbGRzW3NjaGVtYS5zbHVnRmllbGRdO1xuICAgICAgICAgICAgaWYgKCFzbHVnRmllbGQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzbHVnRmllbGQgXCIke3NjaGVtYS5zbHVnRmllbGR9XCIgZG9lcyBub3QgZXhpc3Qgb24gb2JqZWN0IGZpZWxkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2x1Z0ZpZWxkLmtpbmQgIT09ICdmb3JtJykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNsdWdGaWVsZCBcIiR7c2NoZW1hLnNsdWdGaWVsZH1cIiBpcyBub3QgYSBmb3JtIGZpZWxkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2x1Z0ZpZWxkLmZvcm1LaW5kICE9PSAnc2x1ZycpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzbHVnRmllbGQgXCIke3NjaGVtYS5zbHVnRmllbGR9XCIgaXMgbm90IGEgc2x1ZyBmaWVsZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHBhcnNlZFNsdWdGaWVsZFZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcGFyc2VkU2x1Z0ZpZWxkVmFsdWUgPSBzbHVnRmllbGQucGFyc2UodG9Gb3JtRmllbGRTdG9yZWRWYWx1ZShpbm5lclZhbFtzY2hlbWEuc2x1Z0ZpZWxkXSksIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEFnZ3JlZ2F0ZUVycm9yKFtlcnJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNsdWcgPSBzbHVnRmllbGQuc2VyaWFsaXplV2l0aFNsdWcocGFyc2VkU2x1Z0ZpZWxkVmFsdWUpLnNsdWc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwYXJzZVByb3BzKHNjaGVtYS5lbGVtZW50LCBpbm5lclZhbCwgcGF0aC5jb25jYXQoaSksIHBhdGhXaXRoQXJyYXlGaWVsZFNsdWdzLmNvbmNhdChzbHVnKSwgcGFyc2VGb3JtRmllbGQsIHZhbGlkYXRlQXJyYXlGaWVsZExlbmd0aCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgQWdncmVnYXRlRXJyb3IoZXJyb3JzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXNzZXJ0TmV2ZXIoc2NoZW1hKTtcbn1cblxuZnVuY3Rpb24gZmxhdHRlbkVycm9ycyhlcnJvcikge1xuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBZ2dyZWdhdGVFcnJvcikge1xuICAgIHJldHVybiBlcnJvci5lcnJvcnMuZmxhdE1hcChmbGF0dGVuRXJyb3JzKTtcbiAgfVxuICByZXR1cm4gW2Vycm9yXTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEZvcm1EYXRhRXJyb3IoZXJyb3IpIHtcbiAgY29uc3QgZmxhdEVycm9ycyA9IGZsYXR0ZW5FcnJvcnMoZXJyb3IpO1xuICByZXR1cm4gZmxhdEVycm9ycy5tYXAoZXJyb3IgPT4ge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFByb3BWYWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgIGNvbnN0IHBhdGggPSBlcnJvci5wYXRoLmpvaW4oJy4nKTtcbiAgICAgIHJldHVybiBgJHtwYXRofTogJHtlcnJvci5jYXVzZSBpbnN0YW5jZW9mIEZpZWxkRGF0YUVycm9yID8gZXJyb3IuY2F1c2UubWVzc2FnZSA6IGBVbmV4cGVjdGVkIGVycm9yOiAke2Vycm9yLmNhdXNlfWB9YDtcbiAgICB9XG4gICAgcmV0dXJuIGBVbmV4cGVjdGVkIGVycm9yOiAke2Vycm9yfWA7XG4gIH0pLmpvaW4oJ1xcbicpO1xufVxuZnVuY3Rpb24gdG9Gb3JtYXR0ZWRGb3JtRGF0YUVycm9yKGVycm9yKSB7XG4gIGNvbnN0IGZvcm1hdHRlZCA9IGZvcm1hdEZvcm1EYXRhRXJyb3IoZXJyb3IpO1xuICByZXR1cm4gbmV3IEVycm9yKGBGaWVsZCB2YWxpZGF0aW9uIGZhaWxlZDpcXG5gICsgZm9ybWF0dGVkKTtcbn1cblxuY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbmNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5mdW5jdGlvbiBzcGxpdEZyb250bWF0dGVyKGRhdGEpIHtcbiAgY29uc3Qgc3RyID0gdGV4dERlY29kZXIuZGVjb2RlKGRhdGEpO1xuICBjb25zdCBtYXRjaCA9IHN0ci5tYXRjaCgvXi0tLSg/Olxccj9cXG4oW15dKj8pKT9cXHI/XFxuLS0tXFxyP1xcbj8vKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIF9tYXRjaCQ7XG4gICAgY29uc3QgZW5jb2RlZCA9IHRleHRFbmNvZGVyLmVuY29kZShtYXRjaFswXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb250bWF0dGVyOiAoX21hdGNoJCA9IG1hdGNoWzFdKSAhPT0gbnVsbCAmJiBfbWF0Y2gkICE9PSB2b2lkIDAgPyBfbWF0Y2gkIDogJycsXG4gICAgICBjb250ZW50OiBkYXRhLnNsaWNlKGVuY29kZWQuYnl0ZUxlbmd0aClcbiAgICB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbG9hZERhdGFGaWxlKGRhdGEsIGZvcm1hdEluZm8pIHtcbiAgY29uc3QgcGFyc2UgPSBmb3JtYXRJbmZvLmRhdGEgPT09ICdqc29uJyA/IEpTT04ucGFyc2UgOiBsb2FkO1xuICBpZiAoIWZvcm1hdEluZm8uY29udGVudEZpZWxkKSB7XG4gICAgY29uc3QgZGF0YUZpbGUgPSB0ZXh0RGVjb2Rlci5kZWNvZGUoZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvYWRlZDogcGFyc2UoZGF0YUZpbGUpXG4gICAgfTtcbiAgfVxuICBjb25zdCByZXMgPSBzcGxpdEZyb250bWF0dGVyKGRhdGEpO1xuICBhc3NlcnQocmVzICE9PSBudWxsLCAnZnJvbnRtYXR0ZXIgbm90IGZvdW5kJyk7XG4gIHJldHVybiB7XG4gICAgbG9hZGVkOiBwYXJzZShyZXMuZnJvbnRtYXR0ZXIpLFxuICAgIGV4dHJhRmFrZUZpbGU6IHtcbiAgICAgIHBhdGg6IGAke2Zvcm1hdEluZm8uY29udGVudEZpZWxkLmtleX0ke2Zvcm1hdEluZm8uY29udGVudEZpZWxkLmNvbmZpZy5jb250ZW50RXh0ZW5zaW9ufWAsXG4gICAgICBjb250ZW50czogcmVzLmNvbnRlbnRcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCB7IFByb3BWYWxpZGF0aW9uRXJyb3IgYXMgUCwgZm9ybWF0Rm9ybURhdGFFcnJvciBhcyBmLCBsb2FkRGF0YUZpbGUgYXMgbCwgcGFyc2VQcm9wcyBhcyBwLCB0b0Zvcm1hdHRlZEZvcm1EYXRhRXJyb3IgYXMgdCwgdmFsaWRhdGVBcnJheUxlbmd0aCBhcyB2IH07XG4iXSwibmFtZXMiOlsiSiIsIkZpZWxkRGF0YUVycm9yIiwibiIsImdldEluaXRpYWxQcm9wc1ZhbHVlIiwiYXNzZXJ0TmV2ZXIiLCJhc3NlcnQiLCJsb2FkIiwidmFsaWRhdGVBcnJheUxlbmd0aCIsInNjaGVtYSIsInZhbCIsInBhdGgiLCJfc2NoZW1hJHZhbGlkYXRpb24iLCJfc2NoZW1hJHZhbGlkYXRpb24yIiwidmFsaWRhdGlvbiIsImxlbmd0aCIsIm1pbiIsInVuZGVmaW5lZCIsIlByb3BWYWxpZGF0aW9uRXJyb3IiLCJtYXgiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiY2F1c2UiLCJqb2luIiwidG9Gb3JtRmllbGRTdG9yZWRWYWx1ZSIsImlzQXJyYXkiLCJBcnJheSIsInBhcnNlUHJvcHMiLCJfdmFsdWUiLCJwYXRoV2l0aEFycmF5RmllbGRTbHVncyIsInBhcnNlRm9ybUZpZWxkIiwidmFsaWRhdGVBcnJheUZpZWxkTGVuZ3RoIiwidmFsdWUiLCJraW5kIiwiZXJyIiwia2V5IiwiT2JqZWN0Iiwia2V5cyIsInBhcnNlZERpc2NyaW1pbmFudCIsImRpc2NyaW1pbmFudCIsImNvbmNhdCIsInZhbHVlcyIsImFsbG93ZWRLZXlzU2V0IiwiU2V0IiwiZmllbGRzIiwiaGFzIiwiZXJyb3JzIiwiaW5kaXZpZHVhbFZhbCIsInByb3BWYWwiLCJwdXNoIiwiQWdncmVnYXRlRXJyb3IiLCJlcnJvciIsIm1hcCIsImlubmVyVmFsIiwiaSIsInNsdWciLCJ0b1N0cmluZyIsInNsdWdGaWVsZCIsImVsZW1lbnQiLCJmb3JtS2luZCIsInBhcnNlZFNsdWdGaWVsZFZhbHVlIiwicGFyc2UiLCJzZXJpYWxpemVXaXRoU2x1ZyIsImZsYXR0ZW5FcnJvcnMiLCJmbGF0TWFwIiwiZm9ybWF0Rm9ybURhdGFFcnJvciIsImZsYXRFcnJvcnMiLCJtZXNzYWdlIiwidG9Gb3JtYXR0ZWRGb3JtRGF0YUVycm9yIiwiZm9ybWF0dGVkIiwidGV4dERlY29kZXIiLCJUZXh0RGVjb2RlciIsInRleHRFbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJzcGxpdEZyb250bWF0dGVyIiwiZGF0YSIsInN0ciIsImRlY29kZSIsIm1hdGNoIiwiX21hdGNoJCIsImVuY29kZWQiLCJlbmNvZGUiLCJmcm9udG1hdHRlciIsImNvbnRlbnQiLCJzbGljZSIsImJ5dGVMZW5ndGgiLCJsb2FkRGF0YUZpbGUiLCJmb3JtYXRJbmZvIiwiSlNPTiIsImNvbnRlbnRGaWVsZCIsImRhdGFGaWxlIiwibG9hZGVkIiwicmVzIiwiZXh0cmFGYWtlRmlsZSIsImNvbmZpZyIsImNvbnRlbnRFeHRlbnNpb24iLCJjb250ZW50cyIsIlAiLCJmIiwibCIsInAiLCJ0IiwidiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/required-files-58b1ab35.node.react-server.esm.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/reader/dist/keystatic-core-reader.node.react-server.esm.js":
/*!****************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/reader/dist/keystatic-core-reader.node.react-server.esm.js ***!
  \****************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createReader: () => (/* binding */ createReader)\n/* harmony export */ });\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_path__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var node_fs_promises__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:fs/promises */ \"node:fs/promises\");\n/* harmony import */ var node_fs_promises__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(node_fs_promises__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _dist_generic_ddb9bd13_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dist/generic-ddb9bd13.node.react-server.esm.js */ \"(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/generic-ddb9bd13.node.react-server.esm.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ \"(rsc)/../../node_modules/.pnpm/next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _dist_index_b0eee923_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../dist/index-b0eee923.node.react-server.esm.js */ \"(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/index-b0eee923.node.react-server.esm.js\");\n/* harmony import */ var emery_assertions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! emery/assertions */ \"(rsc)/../../node_modules/.pnpm/emery@1.4.2/node_modules/emery/assertions/dist/emery-assertions.cjs.js\");\n/* harmony import */ var emery__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! emery */ \"(rsc)/../../node_modules/.pnpm/emery@1.4.2/node_modules/emery/dist/emery.cjs.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _dist_empty_field_ui_5b08ee07_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../dist/empty-field-ui-5b08ee07.node.react-server.esm.js */ \"(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/empty-field-ui-5b08ee07.node.react-server.esm.js\");\n/* harmony import */ var _emotion_weak_memoize__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @emotion/weak-memoize */ \"(rsc)/../../node_modules/.pnpm/@emotion+weak-memoize@0.3.1/node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js\");\n/* harmony import */ var _sindresorhus_slugify__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @sindresorhus/slugify */ \"(rsc)/../../node_modules/.pnpm/@sindresorhus+slugify@1.1.2/node_modules/@sindresorhus/slugify/index.js\");\n/* harmony import */ var _sindresorhus_slugify__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_sindresorhus_slugify__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var _braintree_sanitize_url__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @braintree/sanitize-url */ \"(rsc)/../../node_modules/.pnpm/@braintree+sanitize-url@6.0.4/node_modules/@braintree/sanitize-url/dist/index.js\");\n/* harmony import */ var _dist_required_files_58b1ab35_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../dist/required-files-58b1ab35.node.react-server.esm.js */ \"(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/dist/required-files-58b1ab35.node.react-server.esm.js\");\n/* harmony import */ var js_yaml__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! js-yaml */ \"(rsc)/../../node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/dist/js-yaml.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! react */ \"(rsc)/../../node_modules/.pnpm/next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_14__);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction createReader(repoPath, config) {\n    const fs$1 = {\n        async fileExists (path$1) {\n            try {\n                await node_fs_promises__WEBPACK_IMPORTED_MODULE_1___default().stat(node_path__WEBPACK_IMPORTED_MODULE_0___default().join(repoPath, path$1));\n                return true;\n            } catch (err) {\n                if (err.code === \"ENOENT\") return false;\n                throw err;\n            }\n        },\n        async readdir (path$1) {\n            try {\n                const entries = await node_fs_promises__WEBPACK_IMPORTED_MODULE_1___default().readdir(node_path__WEBPACK_IMPORTED_MODULE_0___default().join(repoPath, path$1), {\n                    withFileTypes: true\n                });\n                const filtered = [];\n                for (const entry of entries){\n                    if (entry.isDirectory()) {\n                        filtered.push({\n                            name: entry.name,\n                            kind: \"directory\"\n                        });\n                    }\n                    if (entry.isFile()) {\n                        filtered.push({\n                            name: entry.name,\n                            kind: \"file\"\n                        });\n                    }\n                }\n                return filtered;\n            } catch (err) {\n                if (err.code === \"ENOENT\") return [];\n                throw err;\n            }\n        },\n        async readFile (path$1) {\n            try {\n                return await node_fs_promises__WEBPACK_IMPORTED_MODULE_1___default().readFile(node_path__WEBPACK_IMPORTED_MODULE_0___default().join(repoPath, path$1));\n            } catch (err) {\n                if (err.code === \"ENOENT\") return null;\n                throw err;\n            }\n        }\n    };\n    return {\n        collections: Object.fromEntries(Object.keys(config.collections || {}).map((key)=>[\n                key,\n                (0,_dist_generic_ddb9bd13_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.c)(key, config, fs$1)\n            ])),\n        singletons: Object.fromEntries(Object.keys(config.singletons || {}).map((key)=>[\n                key,\n                (0,_dist_generic_ddb9bd13_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.s)(key, config, fs$1)\n            ])),\n        repoPath,\n        config\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BrZXlzdGF0aWMrY29yZUAwLjEuN19uZXh0QDEzLjUuNl9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvQGtleXN0YXRpYy9jb3JlL3JlYWRlci9kaXN0L2tleXN0YXRpYy1jb3JlLXJlYWRlci5ub2RlLnJlYWN0LXNlcnZlci5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2QjtBQUNLO0FBQ2lGO0FBQ3hGO0FBQ2lDO0FBQ2xDO0FBQ1g7QUFDVztBQUNYO0FBQ0k7QUFDSDtBQUNxRDtBQUN0QztBQUNBO0FBQ0U7QUFDb0M7QUFDcEQ7QUFDRjtBQUVmLFNBQVNNLGFBQWFDLFFBQVEsRUFBRUMsTUFBTTtJQUNwQyxNQUFNQyxPQUFPO1FBQ1gsTUFBTUMsWUFBV0MsTUFBTTtZQUNyQixJQUFJO2dCQUNGLE1BQU1WLDREQUFPLENBQUNELHFEQUFTLENBQUNPLFVBQVVJO2dCQUNsQyxPQUFPO1lBQ1QsRUFBRSxPQUFPRyxLQUFLO2dCQUNaLElBQUlBLElBQUlDLElBQUksS0FBSyxVQUFVLE9BQU87Z0JBQ2xDLE1BQU1EO1lBQ1I7UUFDRjtRQUNBLE1BQU1FLFNBQVFMLE1BQU07WUFDbEIsSUFBSTtnQkFDRixNQUFNTSxVQUFVLE1BQU1oQiwrREFBVSxDQUFDRCxxREFBUyxDQUFDTyxVQUFVSSxTQUFTO29CQUM1RE8sZUFBZTtnQkFDakI7Z0JBQ0EsTUFBTUMsV0FBVyxFQUFFO2dCQUNuQixLQUFLLE1BQU1DLFNBQVNILFFBQVM7b0JBQzNCLElBQUlHLE1BQU1DLFdBQVcsSUFBSTt3QkFDdkJGLFNBQVNHLElBQUksQ0FBQzs0QkFDWkMsTUFBTUgsTUFBTUcsSUFBSTs0QkFDaEJDLE1BQU07d0JBQ1I7b0JBQ0Y7b0JBQ0EsSUFBSUosTUFBTUssTUFBTSxJQUFJO3dCQUNsQk4sU0FBU0csSUFBSSxDQUFDOzRCQUNaQyxNQUFNSCxNQUFNRyxJQUFJOzRCQUNoQkMsTUFBTTt3QkFDUjtvQkFDRjtnQkFDRjtnQkFDQSxPQUFPTDtZQUNULEVBQUUsT0FBT0wsS0FBSztnQkFDWixJQUFJQSxJQUFJQyxJQUFJLEtBQUssVUFBVSxPQUFPLEVBQUU7Z0JBQ3BDLE1BQU1EO1lBQ1I7UUFDRjtRQUNBLE1BQU1ZLFVBQVNmLE1BQU07WUFDbkIsSUFBSTtnQkFDRixPQUFPLE1BQU1WLGdFQUFXLENBQUNELHFEQUFTLENBQUNPLFVBQVVJO1lBQy9DLEVBQUUsT0FBT0csS0FBSztnQkFDWixJQUFJQSxJQUFJQyxJQUFJLEtBQUssVUFBVSxPQUFPO2dCQUNsQyxNQUFNRDtZQUNSO1FBQ0Y7SUFDRjtJQUNBLE9BQU87UUFDTGEsYUFBYUMsT0FBT0MsV0FBVyxDQUFDRCxPQUFPRSxJQUFJLENBQUN0QixPQUFPbUIsV0FBVyxJQUFJLENBQUMsR0FBR0ksR0FBRyxDQUFDQyxDQUFBQSxNQUFPO2dCQUFDQTtnQkFBSzdCLGtGQUFnQkEsQ0FBQzZCLEtBQUt4QixRQUFRQzthQUFNO1FBQzNId0IsWUFBWUwsT0FBT0MsV0FBVyxDQUFDRCxPQUFPRSxJQUFJLENBQUN0QixPQUFPeUIsVUFBVSxJQUFJLENBQUMsR0FBR0YsR0FBRyxDQUFDQyxDQUFBQSxNQUFPO2dCQUFDQTtnQkFBSzNCLGtGQUFlQSxDQUFDMkIsS0FBS3hCLFFBQVFDO2FBQU07UUFDeEhGO1FBQ0FDO0lBQ0Y7QUFDRjtBQUV3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2tleXN0YXRpYy1zdGFydGVyLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Aa2V5c3RhdGljK2NvcmVAMC4xLjdfbmV4dEAxMy41LjZfcmVhY3QtZG9tQDE4LjIuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL0BrZXlzdGF0aWMvY29yZS9yZWFkZXIvZGlzdC9rZXlzdGF0aWMtY29yZS1yZWFkZXIubm9kZS5yZWFjdC1zZXJ2ZXIuZXNtLmpzPzRlNTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGggZnJvbSAnbm9kZTpwYXRoJztcbmltcG9ydCBmcyBmcm9tICdub2RlOmZzL3Byb21pc2VzJztcbmltcG9ydCB7IGMgYXMgY29sbGVjdGlvblJlYWRlciwgcyBhcyBzaW5nbGV0b25SZWFkZXIgfSBmcm9tICcuLi8uLi9kaXN0L2dlbmVyaWMtZGRiOWJkMTMubm9kZS5yZWFjdC1zZXJ2ZXIuZXNtLmpzJztcbmltcG9ydCAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0ICcuLi8uLi9kaXN0L2luZGV4LWIwZWVlOTIzLm5vZGUucmVhY3Qtc2VydmVyLmVzbS5qcyc7XG5pbXBvcnQgJ0BtYXJrZG9jL21hcmtkb2MnO1xuaW1wb3J0ICdzbGF0ZSc7XG5pbXBvcnQgJ2VtZXJ5L2Fzc2VydGlvbnMnO1xuaW1wb3J0ICdlbWVyeSc7XG5pbXBvcnQgJ2pzLWJhc2U2NCc7XG5pbXBvcnQgJ2NyeXB0byc7XG5pbXBvcnQgJy4uLy4uL2Rpc3QvZW1wdHktZmllbGQtdWktNWIwOGVlMDcubm9kZS5yZWFjdC1zZXJ2ZXIuZXNtLmpzJztcbmltcG9ydCAnQGVtb3Rpb24vd2Vhay1tZW1vaXplJztcbmltcG9ydCAnQHNpbmRyZXNvcmh1cy9zbHVnaWZ5JztcbmltcG9ydCAnQGJyYWludHJlZS9zYW5pdGl6ZS11cmwnO1xuaW1wb3J0ICcuLi8uLi9kaXN0L3JlcXVpcmVkLWZpbGVzLTU4YjFhYjM1Lm5vZGUucmVhY3Qtc2VydmVyLmVzbS5qcyc7XG5pbXBvcnQgJ2pzLXlhbWwnO1xuaW1wb3J0ICdyZWFjdCc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlYWRlcihyZXBvUGF0aCwgY29uZmlnKSB7XG4gIGNvbnN0IGZzJDEgPSB7XG4gICAgYXN5bmMgZmlsZUV4aXN0cyhwYXRoJDEpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGZzLnN0YXQocGF0aC5qb2luKHJlcG9QYXRoLCBwYXRoJDEpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyByZWFkZGlyKHBhdGgkMSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZW50cmllcyA9IGF3YWl0IGZzLnJlYWRkaXIocGF0aC5qb2luKHJlcG9QYXRoLCBwYXRoJDEpLCB7XG4gICAgICAgICAgd2l0aEZpbGVUeXBlczogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkLnB1c2goe1xuICAgICAgICAgICAgICBuYW1lOiBlbnRyeS5uYW1lLFxuICAgICAgICAgICAgICBraW5kOiAnZGlyZWN0b3J5J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbnRyeS5pc0ZpbGUoKSkge1xuICAgICAgICAgICAgZmlsdGVyZWQucHVzaCh7XG4gICAgICAgICAgICAgIG5hbWU6IGVudHJ5Lm5hbWUsXG4gICAgICAgICAgICAgIGtpbmQ6ICdmaWxlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZDtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09ICdFTk9FTlQnKSByZXR1cm4gW107XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIHJlYWRGaWxlKHBhdGgkMSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGZzLnJlYWRGaWxlKHBhdGguam9pbihyZXBvUGF0aCwgcGF0aCQxKSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykgcmV0dXJuIG51bGw7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgY29sbGVjdGlvbnM6IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3Qua2V5cyhjb25maWcuY29sbGVjdGlvbnMgfHwge30pLm1hcChrZXkgPT4gW2tleSwgY29sbGVjdGlvblJlYWRlcihrZXksIGNvbmZpZywgZnMkMSldKSksXG4gICAgc2luZ2xldG9uczogT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5rZXlzKGNvbmZpZy5zaW5nbGV0b25zIHx8IHt9KS5tYXAoa2V5ID0+IFtrZXksIHNpbmdsZXRvblJlYWRlcihrZXksIGNvbmZpZywgZnMkMSldKSksXG4gICAgcmVwb1BhdGgsXG4gICAgY29uZmlnXG4gIH07XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVJlYWRlciB9O1xuIl0sIm5hbWVzIjpbInBhdGgiLCJmcyIsImMiLCJjb2xsZWN0aW9uUmVhZGVyIiwicyIsInNpbmdsZXRvblJlYWRlciIsImNyZWF0ZVJlYWRlciIsInJlcG9QYXRoIiwiY29uZmlnIiwiZnMkMSIsImZpbGVFeGlzdHMiLCJwYXRoJDEiLCJzdGF0Iiwiam9pbiIsImVyciIsImNvZGUiLCJyZWFkZGlyIiwiZW50cmllcyIsIndpdGhGaWxlVHlwZXMiLCJmaWx0ZXJlZCIsImVudHJ5IiwiaXNEaXJlY3RvcnkiLCJwdXNoIiwibmFtZSIsImtpbmQiLCJpc0ZpbGUiLCJyZWFkRmlsZSIsImNvbGxlY3Rpb25zIiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJrZXlzIiwibWFwIiwia2V5Iiwic2luZ2xldG9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@keystatic+core@0.1.7_next@13.5.6_react-dom@18.2.0_react@18.2.0/node_modules/@keystatic/core/reader/dist/keystatic-core-reader.node.react-server.esm.js\n");

/***/ })

};
;