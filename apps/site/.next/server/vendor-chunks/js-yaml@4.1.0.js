"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/js-yaml@4.1.0";
exports.ids = ["vendor-chunks/js-yaml@4.1.0"];
exports.modules = {

/***/ "(rsc)/../../node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/dist/js-yaml.mjs":
/*!************************************************************************************!*\
  !*** ../../node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/dist/js-yaml.mjs ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CORE_SCHEMA: () => (/* binding */ CORE_SCHEMA),\n/* harmony export */   DEFAULT_SCHEMA: () => (/* binding */ DEFAULT_SCHEMA),\n/* harmony export */   FAILSAFE_SCHEMA: () => (/* binding */ FAILSAFE_SCHEMA),\n/* harmony export */   JSON_SCHEMA: () => (/* binding */ JSON_SCHEMA),\n/* harmony export */   Schema: () => (/* binding */ Schema),\n/* harmony export */   Type: () => (/* binding */ Type),\n/* harmony export */   YAMLException: () => (/* binding */ YAMLException),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   dump: () => (/* binding */ dump),\n/* harmony export */   load: () => (/* binding */ load),\n/* harmony export */   loadAll: () => (/* binding */ loadAll),\n/* harmony export */   safeDump: () => (/* binding */ safeDump),\n/* harmony export */   safeLoad: () => (/* binding */ safeLoad),\n/* harmony export */   safeLoadAll: () => (/* binding */ safeLoadAll),\n/* harmony export */   types: () => (/* binding */ types)\n/* harmony export */ });\n/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */ function isNothing(subject) {\n    return typeof subject === \"undefined\" || subject === null;\n}\nfunction isObject(subject) {\n    return typeof subject === \"object\" && subject !== null;\n}\nfunction toArray(sequence) {\n    if (Array.isArray(sequence)) return sequence;\n    else if (isNothing(sequence)) return [];\n    return [\n        sequence\n    ];\n}\nfunction extend(target, source) {\n    var index, length, key, sourceKeys;\n    if (source) {\n        sourceKeys = Object.keys(source);\n        for(index = 0, length = sourceKeys.length; index < length; index += 1){\n            key = sourceKeys[index];\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction repeat(string, count) {\n    var result = \"\", cycle;\n    for(cycle = 0; cycle < count; cycle += 1){\n        result += string;\n    }\n    return result;\n}\nfunction isNegativeZero(number) {\n    return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;\n}\nvar isNothing_1 = isNothing;\nvar isObject_1 = isObject;\nvar toArray_1 = toArray;\nvar repeat_1 = repeat;\nvar isNegativeZero_1 = isNegativeZero;\nvar extend_1 = extend;\nvar common = {\n    isNothing: isNothing_1,\n    isObject: isObject_1,\n    toArray: toArray_1,\n    repeat: repeat_1,\n    isNegativeZero: isNegativeZero_1,\n    extend: extend_1\n};\n// YAML error class. http://stackoverflow.com/questions/8458984\nfunction formatError(exception, compact) {\n    var where = \"\", message = exception.reason || \"(unknown reason)\";\n    if (!exception.mark) return message;\n    if (exception.mark.name) {\n        where += 'in \"' + exception.mark.name + '\" ';\n    }\n    where += \"(\" + (exception.mark.line + 1) + \":\" + (exception.mark.column + 1) + \")\";\n    if (!compact && exception.mark.snippet) {\n        where += \"\\n\\n\" + exception.mark.snippet;\n    }\n    return message + \" \" + where;\n}\nfunction YAMLException$1(reason, mark) {\n    // Super constructor\n    Error.call(this);\n    this.name = \"YAMLException\";\n    this.reason = reason;\n    this.mark = mark;\n    this.message = formatError(this, false);\n    // Include stack trace in error object\n    if (Error.captureStackTrace) {\n        // Chrome and NodeJS\n        Error.captureStackTrace(this, this.constructor);\n    } else {\n        // FF, IE 10+ and Safari 6+. Fallback for others\n        this.stack = new Error().stack || \"\";\n    }\n}\n// Inherit from Error\nYAMLException$1.prototype = Object.create(Error.prototype);\nYAMLException$1.prototype.constructor = YAMLException$1;\nYAMLException$1.prototype.toString = function toString(compact) {\n    return this.name + \": \" + formatError(this, compact);\n};\nvar exception = YAMLException$1;\n// get snippet for a single line, respecting maxLength\nfunction getLine(buffer, lineStart, lineEnd, position, maxLineLength) {\n    var head = \"\";\n    var tail = \"\";\n    var maxHalfLength = Math.floor(maxLineLength / 2) - 1;\n    if (position - lineStart > maxHalfLength) {\n        head = \" ... \";\n        lineStart = position - maxHalfLength + head.length;\n    }\n    if (lineEnd - position > maxHalfLength) {\n        tail = \" ...\";\n        lineEnd = position + maxHalfLength - tail.length;\n    }\n    return {\n        str: head + buffer.slice(lineStart, lineEnd).replace(/\\t/g, \"→\") + tail,\n        pos: position - lineStart + head.length // relative position\n    };\n}\nfunction padStart(string, max) {\n    return common.repeat(\" \", max - string.length) + string;\n}\nfunction makeSnippet(mark, options) {\n    options = Object.create(options || null);\n    if (!mark.buffer) return null;\n    if (!options.maxLength) options.maxLength = 79;\n    if (typeof options.indent !== \"number\") options.indent = 1;\n    if (typeof options.linesBefore !== \"number\") options.linesBefore = 3;\n    if (typeof options.linesAfter !== \"number\") options.linesAfter = 2;\n    var re = /\\r?\\n|\\r|\\0/g;\n    var lineStarts = [\n        0\n    ];\n    var lineEnds = [];\n    var match;\n    var foundLineNo = -1;\n    while(match = re.exec(mark.buffer)){\n        lineEnds.push(match.index);\n        lineStarts.push(match.index + match[0].length);\n        if (mark.position <= match.index && foundLineNo < 0) {\n            foundLineNo = lineStarts.length - 2;\n        }\n    }\n    if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;\n    var result = \"\", i, line;\n    var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;\n    var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);\n    for(i = 1; i <= options.linesBefore; i++){\n        if (foundLineNo - i < 0) break;\n        line = getLine(mark.buffer, lineStarts[foundLineNo - i], lineEnds[foundLineNo - i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]), maxLineLength);\n        result = common.repeat(\" \", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + \" | \" + line.str + \"\\n\" + result;\n    }\n    line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);\n    result += common.repeat(\" \", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + \" | \" + line.str + \"\\n\";\n    result += common.repeat(\"-\", options.indent + lineNoLength + 3 + line.pos) + \"^\" + \"\\n\";\n    for(i = 1; i <= options.linesAfter; i++){\n        if (foundLineNo + i >= lineEnds.length) break;\n        line = getLine(mark.buffer, lineStarts[foundLineNo + i], lineEnds[foundLineNo + i], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]), maxLineLength);\n        result += common.repeat(\" \", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + \" | \" + line.str + \"\\n\";\n    }\n    return result.replace(/\\n$/, \"\");\n}\nvar snippet = makeSnippet;\nvar TYPE_CONSTRUCTOR_OPTIONS = [\n    \"kind\",\n    \"multi\",\n    \"resolve\",\n    \"construct\",\n    \"instanceOf\",\n    \"predicate\",\n    \"represent\",\n    \"representName\",\n    \"defaultStyle\",\n    \"styleAliases\"\n];\nvar YAML_NODE_KINDS = [\n    \"scalar\",\n    \"sequence\",\n    \"mapping\"\n];\nfunction compileStyleAliases(map) {\n    var result = {};\n    if (map !== null) {\n        Object.keys(map).forEach(function(style) {\n            map[style].forEach(function(alias) {\n                result[String(alias)] = style;\n            });\n        });\n    }\n    return result;\n}\nfunction Type$1(tag, options) {\n    options = options || {};\n    Object.keys(options).forEach(function(name) {\n        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n            throw new exception('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n        }\n    });\n    // TODO: Add tag format check.\n    this.options = options; // keep original options in case user wants to extend this type later\n    this.tag = tag;\n    this.kind = options[\"kind\"] || null;\n    this.resolve = options[\"resolve\"] || function() {\n        return true;\n    };\n    this.construct = options[\"construct\"] || function(data) {\n        return data;\n    };\n    this.instanceOf = options[\"instanceOf\"] || null;\n    this.predicate = options[\"predicate\"] || null;\n    this.represent = options[\"represent\"] || null;\n    this.representName = options[\"representName\"] || null;\n    this.defaultStyle = options[\"defaultStyle\"] || null;\n    this.multi = options[\"multi\"] || false;\n    this.styleAliases = compileStyleAliases(options[\"styleAliases\"] || null);\n    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n        throw new exception('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n    }\n}\nvar type = Type$1;\n/*eslint-disable max-len*/ function compileList(schema, name) {\n    var result = [];\n    schema[name].forEach(function(currentType) {\n        var newIndex = result.length;\n        result.forEach(function(previousType, previousIndex) {\n            if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {\n                newIndex = previousIndex;\n            }\n        });\n        result[newIndex] = currentType;\n    });\n    return result;\n}\nfunction compileMap() {\n    var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {},\n        multi: {\n            scalar: [],\n            sequence: [],\n            mapping: [],\n            fallback: []\n        }\n    }, index, length;\n    function collectType(type) {\n        if (type.multi) {\n            result.multi[type.kind].push(type);\n            result.multi[\"fallback\"].push(type);\n        } else {\n            result[type.kind][type.tag] = result[\"fallback\"][type.tag] = type;\n        }\n    }\n    for(index = 0, length = arguments.length; index < length; index += 1){\n        arguments[index].forEach(collectType);\n    }\n    return result;\n}\nfunction Schema$1(definition) {\n    return this.extend(definition);\n}\nSchema$1.prototype.extend = function extend(definition) {\n    var implicit = [];\n    var explicit = [];\n    if (definition instanceof type) {\n        // Schema.extend(type)\n        explicit.push(definition);\n    } else if (Array.isArray(definition)) {\n        // Schema.extend([ type1, type2, ... ])\n        explicit = explicit.concat(definition);\n    } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {\n        // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })\n        if (definition.implicit) implicit = implicit.concat(definition.implicit);\n        if (definition.explicit) explicit = explicit.concat(definition.explicit);\n    } else {\n        throw new exception(\"Schema.extend argument should be a Type, [ Type ], \" + \"or a schema definition ({ implicit: [...], explicit: [...] })\");\n    }\n    implicit.forEach(function(type$1) {\n        if (!(type$1 instanceof type)) {\n            throw new exception(\"Specified list of YAML types (or a single Type object) contains a non-Type object.\");\n        }\n        if (type$1.loadKind && type$1.loadKind !== \"scalar\") {\n            throw new exception(\"There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.\");\n        }\n        if (type$1.multi) {\n            throw new exception(\"There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.\");\n        }\n    });\n    explicit.forEach(function(type$1) {\n        if (!(type$1 instanceof type)) {\n            throw new exception(\"Specified list of YAML types (or a single Type object) contains a non-Type object.\");\n        }\n    });\n    var result = Object.create(Schema$1.prototype);\n    result.implicit = (this.implicit || []).concat(implicit);\n    result.explicit = (this.explicit || []).concat(explicit);\n    result.compiledImplicit = compileList(result, \"implicit\");\n    result.compiledExplicit = compileList(result, \"explicit\");\n    result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);\n    return result;\n};\nvar schema = Schema$1;\nvar str = new type(\"tag:yaml.org,2002:str\", {\n    kind: \"scalar\",\n    construct: function(data) {\n        return data !== null ? data : \"\";\n    }\n});\nvar seq = new type(\"tag:yaml.org,2002:seq\", {\n    kind: \"sequence\",\n    construct: function(data) {\n        return data !== null ? data : [];\n    }\n});\nvar map = new type(\"tag:yaml.org,2002:map\", {\n    kind: \"mapping\",\n    construct: function(data) {\n        return data !== null ? data : {};\n    }\n});\nvar failsafe = new schema({\n    explicit: [\n        str,\n        seq,\n        map\n    ]\n});\nfunction resolveYamlNull(data) {\n    if (data === null) return true;\n    var max = data.length;\n    return max === 1 && data === \"~\" || max === 4 && (data === \"null\" || data === \"Null\" || data === \"NULL\");\n}\nfunction constructYamlNull() {\n    return null;\n}\nfunction isNull(object) {\n    return object === null;\n}\nvar _null = new type(\"tag:yaml.org,2002:null\", {\n    kind: \"scalar\",\n    resolve: resolveYamlNull,\n    construct: constructYamlNull,\n    predicate: isNull,\n    represent: {\n        canonical: function() {\n            return \"~\";\n        },\n        lowercase: function() {\n            return \"null\";\n        },\n        uppercase: function() {\n            return \"NULL\";\n        },\n        camelcase: function() {\n            return \"Null\";\n        },\n        empty: function() {\n            return \"\";\n        }\n    },\n    defaultStyle: \"lowercase\"\n});\nfunction resolveYamlBoolean(data) {\n    if (data === null) return false;\n    var max = data.length;\n    return max === 4 && (data === \"true\" || data === \"True\" || data === \"TRUE\") || max === 5 && (data === \"false\" || data === \"False\" || data === \"FALSE\");\n}\nfunction constructYamlBoolean(data) {\n    return data === \"true\" || data === \"True\" || data === \"TRUE\";\n}\nfunction isBoolean(object) {\n    return Object.prototype.toString.call(object) === \"[object Boolean]\";\n}\nvar bool = new type(\"tag:yaml.org,2002:bool\", {\n    kind: \"scalar\",\n    resolve: resolveYamlBoolean,\n    construct: constructYamlBoolean,\n    predicate: isBoolean,\n    represent: {\n        lowercase: function(object) {\n            return object ? \"true\" : \"false\";\n        },\n        uppercase: function(object) {\n            return object ? \"TRUE\" : \"FALSE\";\n        },\n        camelcase: function(object) {\n            return object ? \"True\" : \"False\";\n        }\n    },\n    defaultStyle: \"lowercase\"\n});\nfunction isHexCode(c) {\n    return 0x30 /* 0 */  <= c && c <= 0x39 /* 9 */  || 0x41 /* A */  <= c && c <= 0x46 /* F */  || 0x61 /* a */  <= c && c <= 0x66 /* f */ ;\n}\nfunction isOctCode(c) {\n    return 0x30 /* 0 */  <= c && c <= 0x37 /* 7 */ ;\n}\nfunction isDecCode(c) {\n    return 0x30 /* 0 */  <= c && c <= 0x39 /* 9 */ ;\n}\nfunction resolveYamlInteger(data) {\n    if (data === null) return false;\n    var max = data.length, index = 0, hasDigits = false, ch;\n    if (!max) return false;\n    ch = data[index];\n    // sign\n    if (ch === \"-\" || ch === \"+\") {\n        ch = data[++index];\n    }\n    if (ch === \"0\") {\n        // 0\n        if (index + 1 === max) return true;\n        ch = data[++index];\n        // base 2, base 8, base 16\n        if (ch === \"b\") {\n            // base 2\n            index++;\n            for(; index < max; index++){\n                ch = data[index];\n                if (ch === \"_\") continue;\n                if (ch !== \"0\" && ch !== \"1\") return false;\n                hasDigits = true;\n            }\n            return hasDigits && ch !== \"_\";\n        }\n        if (ch === \"x\") {\n            // base 16\n            index++;\n            for(; index < max; index++){\n                ch = data[index];\n                if (ch === \"_\") continue;\n                if (!isHexCode(data.charCodeAt(index))) return false;\n                hasDigits = true;\n            }\n            return hasDigits && ch !== \"_\";\n        }\n        if (ch === \"o\") {\n            // base 8\n            index++;\n            for(; index < max; index++){\n                ch = data[index];\n                if (ch === \"_\") continue;\n                if (!isOctCode(data.charCodeAt(index))) return false;\n                hasDigits = true;\n            }\n            return hasDigits && ch !== \"_\";\n        }\n    }\n    // base 10 (except 0)\n    // value should not start with `_`;\n    if (ch === \"_\") return false;\n    for(; index < max; index++){\n        ch = data[index];\n        if (ch === \"_\") continue;\n        if (!isDecCode(data.charCodeAt(index))) {\n            return false;\n        }\n        hasDigits = true;\n    }\n    // Should have digits and should not end with `_`\n    if (!hasDigits || ch === \"_\") return false;\n    return true;\n}\nfunction constructYamlInteger(data) {\n    var value = data, sign = 1, ch;\n    if (value.indexOf(\"_\") !== -1) {\n        value = value.replace(/_/g, \"\");\n    }\n    ch = value[0];\n    if (ch === \"-\" || ch === \"+\") {\n        if (ch === \"-\") sign = -1;\n        value = value.slice(1);\n        ch = value[0];\n    }\n    if (value === \"0\") return 0;\n    if (ch === \"0\") {\n        if (value[1] === \"b\") return sign * parseInt(value.slice(2), 2);\n        if (value[1] === \"x\") return sign * parseInt(value.slice(2), 16);\n        if (value[1] === \"o\") return sign * parseInt(value.slice(2), 8);\n    }\n    return sign * parseInt(value, 10);\n}\nfunction isInteger(object) {\n    return Object.prototype.toString.call(object) === \"[object Number]\" && object % 1 === 0 && !common.isNegativeZero(object);\n}\nvar int = new type(\"tag:yaml.org,2002:int\", {\n    kind: \"scalar\",\n    resolve: resolveYamlInteger,\n    construct: constructYamlInteger,\n    predicate: isInteger,\n    represent: {\n        binary: function(obj) {\n            return obj >= 0 ? \"0b\" + obj.toString(2) : \"-0b\" + obj.toString(2).slice(1);\n        },\n        octal: function(obj) {\n            return obj >= 0 ? \"0o\" + obj.toString(8) : \"-0o\" + obj.toString(8).slice(1);\n        },\n        decimal: function(obj) {\n            return obj.toString(10);\n        },\n        /* eslint-disable max-len */ hexadecimal: function(obj) {\n            return obj >= 0 ? \"0x\" + obj.toString(16).toUpperCase() : \"-0x\" + obj.toString(16).toUpperCase().slice(1);\n        }\n    },\n    defaultStyle: \"decimal\",\n    styleAliases: {\n        binary: [\n            2,\n            \"bin\"\n        ],\n        octal: [\n            8,\n            \"oct\"\n        ],\n        decimal: [\n            10,\n            \"dec\"\n        ],\n        hexadecimal: [\n            16,\n            \"hex\"\n        ]\n    }\n});\nvar YAML_FLOAT_PATTERN = new RegExp(// 2.5e4, 2.5 and integers\n\"^(?:[-+]?(?:[0-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?\" + // .2e4, .2\n// special case, seems not from spec\n\"|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?\" + // .inf\n\"|[-+]?\\\\.(?:inf|Inf|INF)\" + // .nan\n\"|\\\\.(?:nan|NaN|NAN))$\");\nfunction resolveYamlFloat(data) {\n    if (data === null) return false;\n    if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`\n    // Probably should update regexp & check speed\n    data[data.length - 1] === \"_\") {\n        return false;\n    }\n    return true;\n}\nfunction constructYamlFloat(data) {\n    var value, sign;\n    value = data.replace(/_/g, \"\").toLowerCase();\n    sign = value[0] === \"-\" ? -1 : 1;\n    if (\"+-\".indexOf(value[0]) >= 0) {\n        value = value.slice(1);\n    }\n    if (value === \".inf\") {\n        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n    } else if (value === \".nan\") {\n        return NaN;\n    }\n    return sign * parseFloat(value, 10);\n}\nvar SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\nfunction representYamlFloat(object, style) {\n    var res;\n    if (isNaN(object)) {\n        switch(style){\n            case \"lowercase\":\n                return \".nan\";\n            case \"uppercase\":\n                return \".NAN\";\n            case \"camelcase\":\n                return \".NaN\";\n        }\n    } else if (Number.POSITIVE_INFINITY === object) {\n        switch(style){\n            case \"lowercase\":\n                return \".inf\";\n            case \"uppercase\":\n                return \".INF\";\n            case \"camelcase\":\n                return \".Inf\";\n        }\n    } else if (Number.NEGATIVE_INFINITY === object) {\n        switch(style){\n            case \"lowercase\":\n                return \"-.inf\";\n            case \"uppercase\":\n                return \"-.INF\";\n            case \"camelcase\":\n                return \"-.Inf\";\n        }\n    } else if (common.isNegativeZero(object)) {\n        return \"-0.0\";\n    }\n    res = object.toString(10);\n    // JS stringifier can build scientific format without dots: 5e-100,\n    // while YAML requres dot: 5.e-100. Fix it with simple hack\n    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace(\"e\", \".e\") : res;\n}\nfunction isFloat(object) {\n    return Object.prototype.toString.call(object) === \"[object Number]\" && (object % 1 !== 0 || common.isNegativeZero(object));\n}\nvar float = new type(\"tag:yaml.org,2002:float\", {\n    kind: \"scalar\",\n    resolve: resolveYamlFloat,\n    construct: constructYamlFloat,\n    predicate: isFloat,\n    represent: representYamlFloat,\n    defaultStyle: \"lowercase\"\n});\nvar json = failsafe.extend({\n    implicit: [\n        _null,\n        bool,\n        int,\n        float\n    ]\n});\nvar core = json;\nvar YAML_DATE_REGEXP = new RegExp(\"^([0-9][0-9][0-9][0-9])\" + // [1] year\n\"-([0-9][0-9])\" + // [2] month\n\"-([0-9][0-9])$\"); // [3] day\nvar YAML_TIMESTAMP_REGEXP = new RegExp(\"^([0-9][0-9][0-9][0-9])\" + // [1] year\n\"-([0-9][0-9]?)\" + // [2] month\n\"-([0-9][0-9]?)\" + // [3] day\n\"(?:[Tt]|[ \\\\t]+)\" + // ...\n\"([0-9][0-9]?)\" + // [4] hour\n\":([0-9][0-9])\" + // [5] minute\n\":([0-9][0-9])\" + // [6] second\n\"(?:\\\\.([0-9]*))?\" + // [7] fraction\n\"(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)\" + // [8] tz [9] tz_sign [10] tz_hour\n\"(?::([0-9][0-9]))?))?$\"); // [11] tz_minute\nfunction resolveYamlTimestamp(data) {\n    if (data === null) return false;\n    if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n    return false;\n}\nfunction constructYamlTimestamp(data) {\n    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;\n    match = YAML_DATE_REGEXP.exec(data);\n    if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n    if (match === null) throw new Error(\"Date resolve error\");\n    // match: [1] year [2] month [3] day\n    year = +match[1];\n    month = +match[2] - 1; // JS month starts with 0\n    day = +match[3];\n    if (!match[4]) {\n        return new Date(Date.UTC(year, month, day));\n    }\n    // match: [4] hour [5] minute [6] second [7] fraction\n    hour = +match[4];\n    minute = +match[5];\n    second = +match[6];\n    if (match[7]) {\n        fraction = match[7].slice(0, 3);\n        while(fraction.length < 3){\n            fraction += \"0\";\n        }\n        fraction = +fraction;\n    }\n    // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n    if (match[9]) {\n        tz_hour = +match[10];\n        tz_minute = +(match[11] || 0);\n        delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n        if (match[9] === \"-\") delta = -delta;\n    }\n    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n    if (delta) date.setTime(date.getTime() - delta);\n    return date;\n}\nfunction representYamlTimestamp(object /*, style*/ ) {\n    return object.toISOString();\n}\nvar timestamp = new type(\"tag:yaml.org,2002:timestamp\", {\n    kind: \"scalar\",\n    resolve: resolveYamlTimestamp,\n    construct: constructYamlTimestamp,\n    instanceOf: Date,\n    represent: representYamlTimestamp\n});\nfunction resolveYamlMerge(data) {\n    return data === \"<<\" || data === null;\n}\nvar merge = new type(\"tag:yaml.org,2002:merge\", {\n    kind: \"scalar\",\n    resolve: resolveYamlMerge\n});\n/*eslint-disable no-bitwise*/ // [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r\";\nfunction resolveYamlBinary(data) {\n    if (data === null) return false;\n    var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n    // Convert one by one.\n    for(idx = 0; idx < max; idx++){\n        code = map.indexOf(data.charAt(idx));\n        // Skip CR/LF\n        if (code > 64) continue;\n        // Fail on illegal characters\n        if (code < 0) return false;\n        bitlen += 6;\n    }\n    // If there are any bits left, source was corrupted\n    return bitlen % 8 === 0;\n}\nfunction constructYamlBinary(data) {\n    var idx, tailbits, input = data.replace(/[\\r\\n=]/g, \"\"), max = input.length, map = BASE64_MAP, bits = 0, result = [];\n    // Collect by 6*4 bits (3 bytes)\n    for(idx = 0; idx < max; idx++){\n        if (idx % 4 === 0 && idx) {\n            result.push(bits >> 16 & 0xFF);\n            result.push(bits >> 8 & 0xFF);\n            result.push(bits & 0xFF);\n        }\n        bits = bits << 6 | map.indexOf(input.charAt(idx));\n    }\n    // Dump tail\n    tailbits = max % 4 * 6;\n    if (tailbits === 0) {\n        result.push(bits >> 16 & 0xFF);\n        result.push(bits >> 8 & 0xFF);\n        result.push(bits & 0xFF);\n    } else if (tailbits === 18) {\n        result.push(bits >> 10 & 0xFF);\n        result.push(bits >> 2 & 0xFF);\n    } else if (tailbits === 12) {\n        result.push(bits >> 4 & 0xFF);\n    }\n    return new Uint8Array(result);\n}\nfunction representYamlBinary(object /*, style*/ ) {\n    var result = \"\", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;\n    // Convert every three bytes to 4 ASCII characters.\n    for(idx = 0; idx < max; idx++){\n        if (idx % 3 === 0 && idx) {\n            result += map[bits >> 18 & 0x3F];\n            result += map[bits >> 12 & 0x3F];\n            result += map[bits >> 6 & 0x3F];\n            result += map[bits & 0x3F];\n        }\n        bits = (bits << 8) + object[idx];\n    }\n    // Dump tail\n    tail = max % 3;\n    if (tail === 0) {\n        result += map[bits >> 18 & 0x3F];\n        result += map[bits >> 12 & 0x3F];\n        result += map[bits >> 6 & 0x3F];\n        result += map[bits & 0x3F];\n    } else if (tail === 2) {\n        result += map[bits >> 10 & 0x3F];\n        result += map[bits >> 4 & 0x3F];\n        result += map[bits << 2 & 0x3F];\n        result += map[64];\n    } else if (tail === 1) {\n        result += map[bits >> 2 & 0x3F];\n        result += map[bits << 4 & 0x3F];\n        result += map[64];\n        result += map[64];\n    }\n    return result;\n}\nfunction isBinary(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Uint8Array]\";\n}\nvar binary = new type(\"tag:yaml.org,2002:binary\", {\n    kind: \"scalar\",\n    resolve: resolveYamlBinary,\n    construct: constructYamlBinary,\n    predicate: isBinary,\n    represent: representYamlBinary\n});\nvar _hasOwnProperty$3 = Object.prototype.hasOwnProperty;\nvar _toString$2 = Object.prototype.toString;\nfunction resolveYamlOmap(data) {\n    if (data === null) return true;\n    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;\n    for(index = 0, length = object.length; index < length; index += 1){\n        pair = object[index];\n        pairHasKey = false;\n        if (_toString$2.call(pair) !== \"[object Object]\") return false;\n        for(pairKey in pair){\n            if (_hasOwnProperty$3.call(pair, pairKey)) {\n                if (!pairHasKey) pairHasKey = true;\n                else return false;\n            }\n        }\n        if (!pairHasKey) return false;\n        if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);\n        else return false;\n    }\n    return true;\n}\nfunction constructYamlOmap(data) {\n    return data !== null ? data : [];\n}\nvar omap = new type(\"tag:yaml.org,2002:omap\", {\n    kind: \"sequence\",\n    resolve: resolveYamlOmap,\n    construct: constructYamlOmap\n});\nvar _toString$1 = Object.prototype.toString;\nfunction resolveYamlPairs(data) {\n    if (data === null) return true;\n    var index, length, pair, keys, result, object = data;\n    result = new Array(object.length);\n    for(index = 0, length = object.length; index < length; index += 1){\n        pair = object[index];\n        if (_toString$1.call(pair) !== \"[object Object]\") return false;\n        keys = Object.keys(pair);\n        if (keys.length !== 1) return false;\n        result[index] = [\n            keys[0],\n            pair[keys[0]]\n        ];\n    }\n    return true;\n}\nfunction constructYamlPairs(data) {\n    if (data === null) return [];\n    var index, length, pair, keys, result, object = data;\n    result = new Array(object.length);\n    for(index = 0, length = object.length; index < length; index += 1){\n        pair = object[index];\n        keys = Object.keys(pair);\n        result[index] = [\n            keys[0],\n            pair[keys[0]]\n        ];\n    }\n    return result;\n}\nvar pairs = new type(\"tag:yaml.org,2002:pairs\", {\n    kind: \"sequence\",\n    resolve: resolveYamlPairs,\n    construct: constructYamlPairs\n});\nvar _hasOwnProperty$2 = Object.prototype.hasOwnProperty;\nfunction resolveYamlSet(data) {\n    if (data === null) return true;\n    var key, object = data;\n    for(key in object){\n        if (_hasOwnProperty$2.call(object, key)) {\n            if (object[key] !== null) return false;\n        }\n    }\n    return true;\n}\nfunction constructYamlSet(data) {\n    return data !== null ? data : {};\n}\nvar set = new type(\"tag:yaml.org,2002:set\", {\n    kind: \"mapping\",\n    resolve: resolveYamlSet,\n    construct: constructYamlSet\n});\nvar _default = core.extend({\n    implicit: [\n        timestamp,\n        merge\n    ],\n    explicit: [\n        binary,\n        omap,\n        pairs,\n        set\n    ]\n});\n/*eslint-disable max-len,no-use-before-define*/ var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;\nvar CONTEXT_FLOW_IN = 1;\nvar CONTEXT_FLOW_OUT = 2;\nvar CONTEXT_BLOCK_IN = 3;\nvar CONTEXT_BLOCK_OUT = 4;\nvar CHOMPING_CLIP = 1;\nvar CHOMPING_STRIP = 2;\nvar CHOMPING_KEEP = 3;\nvar PATTERN_NON_PRINTABLE = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nvar PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\nvar PATTERN_FLOW_INDICATORS = /[,\\[\\]\\{\\}]/;\nvar PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\\-]+!)$/i;\nvar PATTERN_TAG_URI = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\nfunction _class(obj) {\n    return Object.prototype.toString.call(obj);\n}\nfunction is_EOL(c) {\n    return c === 0x0A /* LF */  || c === 0x0D /* CR */ ;\n}\nfunction is_WHITE_SPACE(c) {\n    return c === 0x09 /* Tab */  || c === 0x20 /* Space */ ;\n}\nfunction is_WS_OR_EOL(c) {\n    return c === 0x09 /* Tab */  || c === 0x20 /* Space */  || c === 0x0A /* LF */  || c === 0x0D /* CR */ ;\n}\nfunction is_FLOW_INDICATOR(c) {\n    return c === 0x2C /* , */  || c === 0x5B /* [ */  || c === 0x5D /* ] */  || c === 0x7B /* { */  || c === 0x7D /* } */ ;\n}\nfunction fromHexCode(c) {\n    var lc;\n    if (0x30 /* 0 */  <= c && c <= 0x39 /* 9 */ ) {\n        return c - 0x30;\n    }\n    /*eslint-disable no-bitwise*/ lc = c | 0x20;\n    if (0x61 /* a */  <= lc && lc <= 0x66 /* f */ ) {\n        return lc - 0x61 + 10;\n    }\n    return -1;\n}\nfunction escapedHexLen(c) {\n    if (c === 0x78 /* x */ ) {\n        return 2;\n    }\n    if (c === 0x75 /* u */ ) {\n        return 4;\n    }\n    if (c === 0x55 /* U */ ) {\n        return 8;\n    }\n    return 0;\n}\nfunction fromDecimalCode(c) {\n    if (0x30 /* 0 */  <= c && c <= 0x39 /* 9 */ ) {\n        return c - 0x30;\n    }\n    return -1;\n}\nfunction simpleEscapeSequence(c) {\n    /* eslint-disable indent */ return c === 0x30 /* 0 */  ? \"\\x00\" : c === 0x61 /* a */  ? \"\\x07\" : c === 0x62 /* b */  ? \"\\b\" : c === 0x74 /* t */  ? \"\t\" : c === 0x09 /* Tab */  ? \"\t\" : c === 0x6E /* n */  ? \"\\n\" : c === 0x76 /* v */  ? \"\\v\" : c === 0x66 /* f */  ? \"\\f\" : c === 0x72 /* r */  ? \"\\r\" : c === 0x65 /* e */  ? \"\\x1b\" : c === 0x20 /* Space */  ? \" \" : c === 0x22 /* \" */  ? '\"' : c === 0x2F /* / */  ? \"/\" : c === 0x5C /* \\ */  ? \"\\\\\" : c === 0x4E /* N */  ? \"\\x85\" : c === 0x5F /* _ */  ? \"\\xa0\" : c === 0x4C /* L */  ? \"\\u2028\" : c === 0x50 /* P */  ? \"\\u2029\" : \"\";\n}\nfunction charFromCodepoint(c) {\n    if (c <= 0xFFFF) {\n        return String.fromCharCode(c);\n    }\n    // Encode UTF-16 surrogate pair\n    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n    return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);\n}\nvar simpleEscapeCheck = new Array(256); // integer, for fast access\nvar simpleEscapeMap = new Array(256);\nfor(var i = 0; i < 256; i++){\n    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n    simpleEscapeMap[i] = simpleEscapeSequence(i);\n}\nfunction State$1(input, options) {\n    this.input = input;\n    this.filename = options[\"filename\"] || null;\n    this.schema = options[\"schema\"] || _default;\n    this.onWarning = options[\"onWarning\"] || null;\n    // (Hidden) Remove? makes the loader to expect YAML 1.1 documents\n    // if such documents have no explicit %YAML directive\n    this.legacy = options[\"legacy\"] || false;\n    this.json = options[\"json\"] || false;\n    this.listener = options[\"listener\"] || null;\n    this.implicitTypes = this.schema.compiledImplicit;\n    this.typeMap = this.schema.compiledTypeMap;\n    this.length = input.length;\n    this.position = 0;\n    this.line = 0;\n    this.lineStart = 0;\n    this.lineIndent = 0;\n    // position of first leading tab in the current line,\n    // used to make sure there are no tabs in the indentation\n    this.firstTabInLine = -1;\n    this.documents = [];\n/*\n  this.version;\n  this.checkLineBreaks;\n  this.tagMap;\n  this.anchorMap;\n  this.tag;\n  this.anchor;\n  this.kind;\n  this.result;*/ }\nfunction generateError(state, message) {\n    var mark = {\n        name: state.filename,\n        buffer: state.input.slice(0, -1),\n        position: state.position,\n        line: state.line,\n        column: state.position - state.lineStart\n    };\n    mark.snippet = snippet(mark);\n    return new exception(message, mark);\n}\nfunction throwError(state, message) {\n    throw generateError(state, message);\n}\nfunction throwWarning(state, message) {\n    if (state.onWarning) {\n        state.onWarning.call(null, generateError(state, message));\n    }\n}\nvar directiveHandlers = {\n    YAML: function handleYamlDirective(state, name, args) {\n        var match, major, minor;\n        if (state.version !== null) {\n            throwError(state, \"duplication of %YAML directive\");\n        }\n        if (args.length !== 1) {\n            throwError(state, \"YAML directive accepts exactly one argument\");\n        }\n        match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n        if (match === null) {\n            throwError(state, \"ill-formed argument of the YAML directive\");\n        }\n        major = parseInt(match[1], 10);\n        minor = parseInt(match[2], 10);\n        if (major !== 1) {\n            throwError(state, \"unacceptable YAML version of the document\");\n        }\n        state.version = args[0];\n        state.checkLineBreaks = minor < 2;\n        if (minor !== 1 && minor !== 2) {\n            throwWarning(state, \"unsupported YAML version of the document\");\n        }\n    },\n    TAG: function handleTagDirective(state, name, args) {\n        var handle, prefix;\n        if (args.length !== 2) {\n            throwError(state, \"TAG directive accepts exactly two arguments\");\n        }\n        handle = args[0];\n        prefix = args[1];\n        if (!PATTERN_TAG_HANDLE.test(handle)) {\n            throwError(state, \"ill-formed tag handle (first argument) of the TAG directive\");\n        }\n        if (_hasOwnProperty$1.call(state.tagMap, handle)) {\n            throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n        }\n        if (!PATTERN_TAG_URI.test(prefix)) {\n            throwError(state, \"ill-formed tag prefix (second argument) of the TAG directive\");\n        }\n        try {\n            prefix = decodeURIComponent(prefix);\n        } catch (err) {\n            throwError(state, \"tag prefix is malformed: \" + prefix);\n        }\n        state.tagMap[handle] = prefix;\n    }\n};\nfunction captureSegment(state, start, end, checkJson) {\n    var _position, _length, _character, _result;\n    if (start < end) {\n        _result = state.input.slice(start, end);\n        if (checkJson) {\n            for(_position = 0, _length = _result.length; _position < _length; _position += 1){\n                _character = _result.charCodeAt(_position);\n                if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) {\n                    throwError(state, \"expected valid JSON character\");\n                }\n            }\n        } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n            throwError(state, \"the stream contains non-printable characters\");\n        }\n        state.result += _result;\n    }\n}\nfunction mergeMappings(state, destination, source, overridableKeys) {\n    var sourceKeys, key, index, quantity;\n    if (!common.isObject(source)) {\n        throwError(state, \"cannot merge mappings; the provided source object is unacceptable\");\n    }\n    sourceKeys = Object.keys(source);\n    for(index = 0, quantity = sourceKeys.length; index < quantity; index += 1){\n        key = sourceKeys[index];\n        if (!_hasOwnProperty$1.call(destination, key)) {\n            destination[key] = source[key];\n            overridableKeys[key] = true;\n        }\n    }\n}\nfunction storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {\n    var index, quantity;\n    // The output is a plain object here, so keys can only be strings.\n    // We need to convert keyNode to a string, but doing so can hang the process\n    // (deeply nested arrays that explode exponentially using aliases).\n    if (Array.isArray(keyNode)) {\n        keyNode = Array.prototype.slice.call(keyNode);\n        for(index = 0, quantity = keyNode.length; index < quantity; index += 1){\n            if (Array.isArray(keyNode[index])) {\n                throwError(state, \"nested arrays are not supported inside keys\");\n            }\n            if (typeof keyNode === \"object\" && _class(keyNode[index]) === \"[object Object]\") {\n                keyNode[index] = \"[object Object]\";\n            }\n        }\n    }\n    // Avoid code execution in load() via toString property\n    // (still use its own toString for arrays, timestamps,\n    // and whatever user schema extensions happen to have @@toStringTag)\n    if (typeof keyNode === \"object\" && _class(keyNode) === \"[object Object]\") {\n        keyNode = \"[object Object]\";\n    }\n    keyNode = String(keyNode);\n    if (_result === null) {\n        _result = {};\n    }\n    if (keyTag === \"tag:yaml.org,2002:merge\") {\n        if (Array.isArray(valueNode)) {\n            for(index = 0, quantity = valueNode.length; index < quantity; index += 1){\n                mergeMappings(state, _result, valueNode[index], overridableKeys);\n            }\n        } else {\n            mergeMappings(state, _result, valueNode, overridableKeys);\n        }\n    } else {\n        if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {\n            state.line = startLine || state.line;\n            state.lineStart = startLineStart || state.lineStart;\n            state.position = startPos || state.position;\n            throwError(state, \"duplicated mapping key\");\n        }\n        // used for this specific key only because Object.defineProperty is slow\n        if (keyNode === \"__proto__\") {\n            Object.defineProperty(_result, keyNode, {\n                configurable: true,\n                enumerable: true,\n                writable: true,\n                value: valueNode\n            });\n        } else {\n            _result[keyNode] = valueNode;\n        }\n        delete overridableKeys[keyNode];\n    }\n    return _result;\n}\nfunction readLineBreak(state) {\n    var ch;\n    ch = state.input.charCodeAt(state.position);\n    if (ch === 0x0A /* LF */ ) {\n        state.position++;\n    } else if (ch === 0x0D /* CR */ ) {\n        state.position++;\n        if (state.input.charCodeAt(state.position) === 0x0A /* LF */ ) {\n            state.position++;\n        }\n    } else {\n        throwError(state, \"a line break is expected\");\n    }\n    state.line += 1;\n    state.lineStart = state.position;\n    state.firstTabInLine = -1;\n}\nfunction skipSeparationSpace(state, allowComments, checkIndent) {\n    var lineBreaks = 0, ch = state.input.charCodeAt(state.position);\n    while(ch !== 0){\n        while(is_WHITE_SPACE(ch)){\n            if (ch === 0x09 /* Tab */  && state.firstTabInLine === -1) {\n                state.firstTabInLine = state.position;\n            }\n            ch = state.input.charCodeAt(++state.position);\n        }\n        if (allowComments && ch === 0x23 /* # */ ) {\n            do {\n                ch = state.input.charCodeAt(++state.position);\n            }while (ch !== 0x0A /* LF */  && ch !== 0x0D /* CR */  && ch !== 0);\n        }\n        if (is_EOL(ch)) {\n            readLineBreak(state);\n            ch = state.input.charCodeAt(state.position);\n            lineBreaks++;\n            state.lineIndent = 0;\n            while(ch === 0x20 /* Space */ ){\n                state.lineIndent++;\n                ch = state.input.charCodeAt(++state.position);\n            }\n        } else {\n            break;\n        }\n    }\n    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n        throwWarning(state, \"deficient indentation\");\n    }\n    return lineBreaks;\n}\nfunction testDocumentSeparator(state) {\n    var _position = state.position, ch;\n    ch = state.input.charCodeAt(_position);\n    // Condition state.position === state.lineStart is tested\n    // in parent on each call, for efficiency. No needs to test here again.\n    if ((ch === 0x2D /* - */  || ch === 0x2E /* . */ ) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {\n        _position += 3;\n        ch = state.input.charCodeAt(_position);\n        if (ch === 0 || is_WS_OR_EOL(ch)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction writeFoldedLines(state, count) {\n    if (count === 1) {\n        state.result += \" \";\n    } else if (count > 1) {\n        state.result += common.repeat(\"\\n\", count - 1);\n    }\n}\nfunction readPlainScalar(state, nodeIndent, withinFlowCollection) {\n    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;\n    ch = state.input.charCodeAt(state.position);\n    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23 /* # */  || ch === 0x26 /* & */  || ch === 0x2A /* * */  || ch === 0x21 /* ! */  || ch === 0x7C /* | */  || ch === 0x3E /* > */  || ch === 0x27 /* ' */  || ch === 0x22 /* \" */  || ch === 0x25 /* % */  || ch === 0x40 /* @ */  || ch === 0x60 /* ` */ ) {\n        return false;\n    }\n    if (ch === 0x3F /* ? */  || ch === 0x2D /* - */ ) {\n        following = state.input.charCodeAt(state.position + 1);\n        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n            return false;\n        }\n    }\n    state.kind = \"scalar\";\n    state.result = \"\";\n    captureStart = captureEnd = state.position;\n    hasPendingContent = false;\n    while(ch !== 0){\n        if (ch === 0x3A /* : */ ) {\n            following = state.input.charCodeAt(state.position + 1);\n            if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n                break;\n            }\n        } else if (ch === 0x23 /* # */ ) {\n            preceding = state.input.charCodeAt(state.position - 1);\n            if (is_WS_OR_EOL(preceding)) {\n                break;\n            }\n        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n            break;\n        } else if (is_EOL(ch)) {\n            _line = state.line;\n            _lineStart = state.lineStart;\n            _lineIndent = state.lineIndent;\n            skipSeparationSpace(state, false, -1);\n            if (state.lineIndent >= nodeIndent) {\n                hasPendingContent = true;\n                ch = state.input.charCodeAt(state.position);\n                continue;\n            } else {\n                state.position = captureEnd;\n                state.line = _line;\n                state.lineStart = _lineStart;\n                state.lineIndent = _lineIndent;\n                break;\n            }\n        }\n        if (hasPendingContent) {\n            captureSegment(state, captureStart, captureEnd, false);\n            writeFoldedLines(state, state.line - _line);\n            captureStart = captureEnd = state.position;\n            hasPendingContent = false;\n        }\n        if (!is_WHITE_SPACE(ch)) {\n            captureEnd = state.position + 1;\n        }\n        ch = state.input.charCodeAt(++state.position);\n    }\n    captureSegment(state, captureStart, captureEnd, false);\n    if (state.result) {\n        return true;\n    }\n    state.kind = _kind;\n    state.result = _result;\n    return false;\n}\nfunction readSingleQuotedScalar(state, nodeIndent) {\n    var ch, captureStart, captureEnd;\n    ch = state.input.charCodeAt(state.position);\n    if (ch !== 0x27 /* ' */ ) {\n        return false;\n    }\n    state.kind = \"scalar\";\n    state.result = \"\";\n    state.position++;\n    captureStart = captureEnd = state.position;\n    while((ch = state.input.charCodeAt(state.position)) !== 0){\n        if (ch === 0x27 /* ' */ ) {\n            captureSegment(state, captureStart, state.position, true);\n            ch = state.input.charCodeAt(++state.position);\n            if (ch === 0x27 /* ' */ ) {\n                captureStart = state.position;\n                state.position++;\n                captureEnd = state.position;\n            } else {\n                return true;\n            }\n        } else if (is_EOL(ch)) {\n            captureSegment(state, captureStart, captureEnd, true);\n            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n            captureStart = captureEnd = state.position;\n        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n            throwError(state, \"unexpected end of the document within a single quoted scalar\");\n        } else {\n            state.position++;\n            captureEnd = state.position;\n        }\n    }\n    throwError(state, \"unexpected end of the stream within a single quoted scalar\");\n}\nfunction readDoubleQuotedScalar(state, nodeIndent) {\n    var captureStart, captureEnd, hexLength, hexResult, tmp, ch;\n    ch = state.input.charCodeAt(state.position);\n    if (ch !== 0x22 /* \" */ ) {\n        return false;\n    }\n    state.kind = \"scalar\";\n    state.result = \"\";\n    state.position++;\n    captureStart = captureEnd = state.position;\n    while((ch = state.input.charCodeAt(state.position)) !== 0){\n        if (ch === 0x22 /* \" */ ) {\n            captureSegment(state, captureStart, state.position, true);\n            state.position++;\n            return true;\n        } else if (ch === 0x5C /* \\ */ ) {\n            captureSegment(state, captureStart, state.position, true);\n            ch = state.input.charCodeAt(++state.position);\n            if (is_EOL(ch)) {\n                skipSeparationSpace(state, false, nodeIndent);\n            // TODO: rework to inline fn with no type cast?\n            } else if (ch < 256 && simpleEscapeCheck[ch]) {\n                state.result += simpleEscapeMap[ch];\n                state.position++;\n            } else if ((tmp = escapedHexLen(ch)) > 0) {\n                hexLength = tmp;\n                hexResult = 0;\n                for(; hexLength > 0; hexLength--){\n                    ch = state.input.charCodeAt(++state.position);\n                    if ((tmp = fromHexCode(ch)) >= 0) {\n                        hexResult = (hexResult << 4) + tmp;\n                    } else {\n                        throwError(state, \"expected hexadecimal character\");\n                    }\n                }\n                state.result += charFromCodepoint(hexResult);\n                state.position++;\n            } else {\n                throwError(state, \"unknown escape sequence\");\n            }\n            captureStart = captureEnd = state.position;\n        } else if (is_EOL(ch)) {\n            captureSegment(state, captureStart, captureEnd, true);\n            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n            captureStart = captureEnd = state.position;\n        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n            throwError(state, \"unexpected end of the document within a double quoted scalar\");\n        } else {\n            state.position++;\n            captureEnd = state.position;\n        }\n    }\n    throwError(state, \"unexpected end of the stream within a double quoted scalar\");\n}\nfunction readFlowCollection(state, nodeIndent) {\n    var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = Object.create(null), keyNode, keyTag, valueNode, ch;\n    ch = state.input.charCodeAt(state.position);\n    if (ch === 0x5B /* [ */ ) {\n        terminator = 0x5D; /* ] */ \n        isMapping = false;\n        _result = [];\n    } else if (ch === 0x7B /* { */ ) {\n        terminator = 0x7D; /* } */ \n        isMapping = true;\n        _result = {};\n    } else {\n        return false;\n    }\n    if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = _result;\n    }\n    ch = state.input.charCodeAt(++state.position);\n    while(ch !== 0){\n        skipSeparationSpace(state, true, nodeIndent);\n        ch = state.input.charCodeAt(state.position);\n        if (ch === terminator) {\n            state.position++;\n            state.tag = _tag;\n            state.anchor = _anchor;\n            state.kind = isMapping ? \"mapping\" : \"sequence\";\n            state.result = _result;\n            return true;\n        } else if (!readNext) {\n            throwError(state, \"missed comma between flow collection entries\");\n        } else if (ch === 0x2C /* , */ ) {\n            // \"flow collection entries can never be completely empty\", as per YAML 1.2, section 7.4\n            throwError(state, \"expected the node content, but found ','\");\n        }\n        keyTag = keyNode = valueNode = null;\n        isPair = isExplicitPair = false;\n        if (ch === 0x3F /* ? */ ) {\n            following = state.input.charCodeAt(state.position + 1);\n            if (is_WS_OR_EOL(following)) {\n                isPair = isExplicitPair = true;\n                state.position++;\n                skipSeparationSpace(state, true, nodeIndent);\n            }\n        }\n        _line = state.line; // Save the current line.\n        _lineStart = state.lineStart;\n        _pos = state.position;\n        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n        keyTag = state.tag;\n        keyNode = state.result;\n        skipSeparationSpace(state, true, nodeIndent);\n        ch = state.input.charCodeAt(state.position);\n        if ((isExplicitPair || state.line === _line) && ch === 0x3A /* : */ ) {\n            isPair = true;\n            ch = state.input.charCodeAt(++state.position);\n            skipSeparationSpace(state, true, nodeIndent);\n            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n            valueNode = state.result;\n        }\n        if (isMapping) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);\n        } else if (isPair) {\n            _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));\n        } else {\n            _result.push(keyNode);\n        }\n        skipSeparationSpace(state, true, nodeIndent);\n        ch = state.input.charCodeAt(state.position);\n        if (ch === 0x2C /* , */ ) {\n            readNext = true;\n            ch = state.input.charCodeAt(++state.position);\n        } else {\n            readNext = false;\n        }\n    }\n    throwError(state, \"unexpected end of the stream within a flow collection\");\n}\nfunction readBlockScalar(state, nodeIndent) {\n    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;\n    ch = state.input.charCodeAt(state.position);\n    if (ch === 0x7C /* | */ ) {\n        folding = false;\n    } else if (ch === 0x3E /* > */ ) {\n        folding = true;\n    } else {\n        return false;\n    }\n    state.kind = \"scalar\";\n    state.result = \"\";\n    while(ch !== 0){\n        ch = state.input.charCodeAt(++state.position);\n        if (ch === 0x2B /* + */  || ch === 0x2D /* - */ ) {\n            if (CHOMPING_CLIP === chomping) {\n                chomping = ch === 0x2B /* + */  ? CHOMPING_KEEP : CHOMPING_STRIP;\n            } else {\n                throwError(state, \"repeat of a chomping mode identifier\");\n            }\n        } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n            if (tmp === 0) {\n                throwError(state, \"bad explicit indentation width of a block scalar; it cannot be less than one\");\n            } else if (!detectedIndent) {\n                textIndent = nodeIndent + tmp - 1;\n                detectedIndent = true;\n            } else {\n                throwError(state, \"repeat of an indentation width identifier\");\n            }\n        } else {\n            break;\n        }\n    }\n    if (is_WHITE_SPACE(ch)) {\n        do {\n            ch = state.input.charCodeAt(++state.position);\n        }while (is_WHITE_SPACE(ch));\n        if (ch === 0x23 /* # */ ) {\n            do {\n                ch = state.input.charCodeAt(++state.position);\n            }while (!is_EOL(ch) && ch !== 0);\n        }\n    }\n    while(ch !== 0){\n        readLineBreak(state);\n        state.lineIndent = 0;\n        ch = state.input.charCodeAt(state.position);\n        while((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20 /* Space */ ){\n            state.lineIndent++;\n            ch = state.input.charCodeAt(++state.position);\n        }\n        if (!detectedIndent && state.lineIndent > textIndent) {\n            textIndent = state.lineIndent;\n        }\n        if (is_EOL(ch)) {\n            emptyLines++;\n            continue;\n        }\n        // End of the scalar.\n        if (state.lineIndent < textIndent) {\n            // Perform the chomping.\n            if (chomping === CHOMPING_KEEP) {\n                state.result += common.repeat(\"\\n\", didReadContent ? 1 + emptyLines : emptyLines);\n            } else if (chomping === CHOMPING_CLIP) {\n                if (didReadContent) {\n                    state.result += \"\\n\";\n                }\n            }\n            break;\n        }\n        // Folded style: use fancy rules to handle line breaks.\n        if (folding) {\n            // Lines starting with white space characters (more-indented lines) are not folded.\n            if (is_WHITE_SPACE(ch)) {\n                atMoreIndented = true;\n                // except for the first content line (cf. Example 8.1)\n                state.result += common.repeat(\"\\n\", didReadContent ? 1 + emptyLines : emptyLines);\n            // End of more-indented block.\n            } else if (atMoreIndented) {\n                atMoreIndented = false;\n                state.result += common.repeat(\"\\n\", emptyLines + 1);\n            // Just one line break - perceive as the same line.\n            } else if (emptyLines === 0) {\n                if (didReadContent) {\n                    state.result += \" \";\n                }\n            // Several line breaks - perceive as different lines.\n            } else {\n                state.result += common.repeat(\"\\n\", emptyLines);\n            }\n        // Literal style: just add exact number of line breaks between content lines.\n        } else {\n            // Keep all line breaks except the header line break.\n            state.result += common.repeat(\"\\n\", didReadContent ? 1 + emptyLines : emptyLines);\n        }\n        didReadContent = true;\n        detectedIndent = true;\n        emptyLines = 0;\n        captureStart = state.position;\n        while(!is_EOL(ch) && ch !== 0){\n            ch = state.input.charCodeAt(++state.position);\n        }\n        captureSegment(state, captureStart, state.position, false);\n    }\n    return true;\n}\nfunction readBlockSequence(state, nodeIndent) {\n    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;\n    // there is a leading tab before this token, so it can't be a block sequence/mapping;\n    // it can still be flow sequence/mapping or a scalar\n    if (state.firstTabInLine !== -1) return false;\n    if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = _result;\n    }\n    ch = state.input.charCodeAt(state.position);\n    while(ch !== 0){\n        if (state.firstTabInLine !== -1) {\n            state.position = state.firstTabInLine;\n            throwError(state, \"tab characters must not be used in indentation\");\n        }\n        if (ch !== 0x2D /* - */ ) {\n            break;\n        }\n        following = state.input.charCodeAt(state.position + 1);\n        if (!is_WS_OR_EOL(following)) {\n            break;\n        }\n        detected = true;\n        state.position++;\n        if (skipSeparationSpace(state, true, -1)) {\n            if (state.lineIndent <= nodeIndent) {\n                _result.push(null);\n                ch = state.input.charCodeAt(state.position);\n                continue;\n            }\n        }\n        _line = state.line;\n        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n        _result.push(state.result);\n        skipSeparationSpace(state, true, -1);\n        ch = state.input.charCodeAt(state.position);\n        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {\n            throwError(state, \"bad indentation of a sequence entry\");\n        } else if (state.lineIndent < nodeIndent) {\n            break;\n        }\n    }\n    if (detected) {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        state.kind = \"sequence\";\n        state.result = _result;\n        return true;\n    }\n    return false;\n}\nfunction readBlockMapping(state, nodeIndent, flowIndent) {\n    var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;\n    // there is a leading tab before this token, so it can't be a block sequence/mapping;\n    // it can still be flow sequence/mapping or a scalar\n    if (state.firstTabInLine !== -1) return false;\n    if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = _result;\n    }\n    ch = state.input.charCodeAt(state.position);\n    while(ch !== 0){\n        if (!atExplicitKey && state.firstTabInLine !== -1) {\n            state.position = state.firstTabInLine;\n            throwError(state, \"tab characters must not be used in indentation\");\n        }\n        following = state.input.charCodeAt(state.position + 1);\n        _line = state.line; // Save the current line.\n        //\n        // Explicit notation case. There are two separate blocks:\n        // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n        //\n        if ((ch === 0x3F /* ? */  || ch === 0x3A /* : */ ) && is_WS_OR_EOL(following)) {\n            if (ch === 0x3F /* ? */ ) {\n                if (atExplicitKey) {\n                    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n                    keyTag = keyNode = valueNode = null;\n                }\n                detected = true;\n                atExplicitKey = true;\n                allowCompact = true;\n            } else if (atExplicitKey) {\n                // i.e. 0x3A/* : */ === character after the explicit key.\n                atExplicitKey = false;\n                allowCompact = true;\n            } else {\n                throwError(state, \"incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line\");\n            }\n            state.position += 1;\n            ch = following;\n        //\n        // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n        //\n        } else {\n            _keyLine = state.line;\n            _keyLineStart = state.lineStart;\n            _keyPos = state.position;\n            if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n                break;\n            }\n            if (state.line === _line) {\n                ch = state.input.charCodeAt(state.position);\n                while(is_WHITE_SPACE(ch)){\n                    ch = state.input.charCodeAt(++state.position);\n                }\n                if (ch === 0x3A /* : */ ) {\n                    ch = state.input.charCodeAt(++state.position);\n                    if (!is_WS_OR_EOL(ch)) {\n                        throwError(state, \"a whitespace character is expected after the key-value separator within a block mapping\");\n                    }\n                    if (atExplicitKey) {\n                        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n                        keyTag = keyNode = valueNode = null;\n                    }\n                    detected = true;\n                    atExplicitKey = false;\n                    allowCompact = false;\n                    keyTag = state.tag;\n                    keyNode = state.result;\n                } else if (detected) {\n                    throwError(state, \"can not read an implicit mapping pair; a colon is missed\");\n                } else {\n                    state.tag = _tag;\n                    state.anchor = _anchor;\n                    return true; // Keep the result of `composeNode`.\n                }\n            } else if (detected) {\n                throwError(state, \"can not read a block mapping entry; a multiline key may not be an implicit key\");\n            } else {\n                state.tag = _tag;\n                state.anchor = _anchor;\n                return true; // Keep the result of `composeNode`.\n            }\n        }\n        //\n        // Common reading code for both explicit and implicit notations.\n        //\n        if (state.line === _line || state.lineIndent > nodeIndent) {\n            if (atExplicitKey) {\n                _keyLine = state.line;\n                _keyLineStart = state.lineStart;\n                _keyPos = state.position;\n            }\n            if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n                if (atExplicitKey) {\n                    keyNode = state.result;\n                } else {\n                    valueNode = state.result;\n                }\n            }\n            if (!atExplicitKey) {\n                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);\n                keyTag = keyNode = valueNode = null;\n            }\n            skipSeparationSpace(state, true, -1);\n            ch = state.input.charCodeAt(state.position);\n        }\n        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {\n            throwError(state, \"bad indentation of a mapping entry\");\n        } else if (state.lineIndent < nodeIndent) {\n            break;\n        }\n    }\n    //\n    // Epilogue.\n    //\n    // Special case: last mapping's node contains only the key in explicit notation.\n    if (atExplicitKey) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n    }\n    // Expose the resulting mapping.\n    if (detected) {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        state.kind = \"mapping\";\n        state.result = _result;\n    }\n    return detected;\n}\nfunction readTagProperty(state) {\n    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;\n    ch = state.input.charCodeAt(state.position);\n    if (ch !== 0x21 /* ! */ ) return false;\n    if (state.tag !== null) {\n        throwError(state, \"duplication of a tag property\");\n    }\n    ch = state.input.charCodeAt(++state.position);\n    if (ch === 0x3C /* < */ ) {\n        isVerbatim = true;\n        ch = state.input.charCodeAt(++state.position);\n    } else if (ch === 0x21 /* ! */ ) {\n        isNamed = true;\n        tagHandle = \"!!\";\n        ch = state.input.charCodeAt(++state.position);\n    } else {\n        tagHandle = \"!\";\n    }\n    _position = state.position;\n    if (isVerbatim) {\n        do {\n            ch = state.input.charCodeAt(++state.position);\n        }while (ch !== 0 && ch !== 0x3E /* > */ );\n        if (state.position < state.length) {\n            tagName = state.input.slice(_position, state.position);\n            ch = state.input.charCodeAt(++state.position);\n        } else {\n            throwError(state, \"unexpected end of the stream within a verbatim tag\");\n        }\n    } else {\n        while(ch !== 0 && !is_WS_OR_EOL(ch)){\n            if (ch === 0x21 /* ! */ ) {\n                if (!isNamed) {\n                    tagHandle = state.input.slice(_position - 1, state.position + 1);\n                    if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n                        throwError(state, \"named tag handle cannot contain such characters\");\n                    }\n                    isNamed = true;\n                    _position = state.position + 1;\n                } else {\n                    throwError(state, \"tag suffix cannot contain exclamation marks\");\n                }\n            }\n            ch = state.input.charCodeAt(++state.position);\n        }\n        tagName = state.input.slice(_position, state.position);\n        if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n            throwError(state, \"tag suffix cannot contain flow indicator characters\");\n        }\n    }\n    if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n        throwError(state, \"tag name cannot contain such characters: \" + tagName);\n    }\n    try {\n        tagName = decodeURIComponent(tagName);\n    } catch (err) {\n        throwError(state, \"tag name is malformed: \" + tagName);\n    }\n    if (isVerbatim) {\n        state.tag = tagName;\n    } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {\n        state.tag = state.tagMap[tagHandle] + tagName;\n    } else if (tagHandle === \"!\") {\n        state.tag = \"!\" + tagName;\n    } else if (tagHandle === \"!!\") {\n        state.tag = \"tag:yaml.org,2002:\" + tagName;\n    } else {\n        throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n    }\n    return true;\n}\nfunction readAnchorProperty(state) {\n    var _position, ch;\n    ch = state.input.charCodeAt(state.position);\n    if (ch !== 0x26 /* & */ ) return false;\n    if (state.anchor !== null) {\n        throwError(state, \"duplication of an anchor property\");\n    }\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n    while(ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)){\n        ch = state.input.charCodeAt(++state.position);\n    }\n    if (state.position === _position) {\n        throwError(state, \"name of an anchor node must contain at least one character\");\n    }\n    state.anchor = state.input.slice(_position, state.position);\n    return true;\n}\nfunction readAlias(state) {\n    var _position, alias, ch;\n    ch = state.input.charCodeAt(state.position);\n    if (ch !== 0x2A /* * */ ) return false;\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n    while(ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)){\n        ch = state.input.charCodeAt(++state.position);\n    }\n    if (state.position === _position) {\n        throwError(state, \"name of an alias node must contain at least one character\");\n    }\n    alias = state.input.slice(_position, state.position);\n    if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {\n        throwError(state, 'unidentified alias \"' + alias + '\"');\n    }\n    state.result = state.anchorMap[alias];\n    skipSeparationSpace(state, true, -1);\n    return true;\n}\nfunction composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type, flowIndent, blockIndent;\n    if (state.listener !== null) {\n        state.listener(\"open\", state);\n    }\n    state.tag = null;\n    state.anchor = null;\n    state.kind = null;\n    state.result = null;\n    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;\n    if (allowToSeek) {\n        if (skipSeparationSpace(state, true, -1)) {\n            atNewLine = true;\n            if (state.lineIndent > parentIndent) {\n                indentStatus = 1;\n            } else if (state.lineIndent === parentIndent) {\n                indentStatus = 0;\n            } else if (state.lineIndent < parentIndent) {\n                indentStatus = -1;\n            }\n        }\n    }\n    if (indentStatus === 1) {\n        while(readTagProperty(state) || readAnchorProperty(state)){\n            if (skipSeparationSpace(state, true, -1)) {\n                atNewLine = true;\n                allowBlockCollections = allowBlockStyles;\n                if (state.lineIndent > parentIndent) {\n                    indentStatus = 1;\n                } else if (state.lineIndent === parentIndent) {\n                    indentStatus = 0;\n                } else if (state.lineIndent < parentIndent) {\n                    indentStatus = -1;\n                }\n            } else {\n                allowBlockCollections = false;\n            }\n        }\n    }\n    if (allowBlockCollections) {\n        allowBlockCollections = atNewLine || allowCompact;\n    }\n    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n            flowIndent = parentIndent;\n        } else {\n            flowIndent = parentIndent + 1;\n        }\n        blockIndent = state.position - state.lineStart;\n        if (indentStatus === 1) {\n            if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {\n                hasContent = true;\n            } else {\n                if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {\n                    hasContent = true;\n                } else if (readAlias(state)) {\n                    hasContent = true;\n                    if (state.tag !== null || state.anchor !== null) {\n                        throwError(state, \"alias node should not have any properties\");\n                    }\n                } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n                    hasContent = true;\n                    if (state.tag === null) {\n                        state.tag = \"?\";\n                    }\n                }\n                if (state.anchor !== null) {\n                    state.anchorMap[state.anchor] = state.result;\n                }\n            }\n        } else if (indentStatus === 0) {\n            // Special case: block sequences are allowed to have same indentation level as the parent.\n            // http://www.yaml.org/spec/1.2/spec.html#id2799784\n            hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n        }\n    }\n    if (state.tag === null) {\n        if (state.anchor !== null) {\n            state.anchorMap[state.anchor] = state.result;\n        }\n    } else if (state.tag === \"?\") {\n        // Implicit resolving is not allowed for non-scalar types, and '?'\n        // non-specific tag is only automatically assigned to plain scalars.\n        //\n        // We only need to check kind conformity in case user explicitly assigns '?'\n        // tag, for example like this: \"!<?> [0]\"\n        //\n        if (state.result !== null && state.kind !== \"scalar\") {\n            throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n        }\n        for(typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1){\n            type = state.implicitTypes[typeIndex];\n            if (type.resolve(state.result)) {\n                state.result = type.construct(state.result);\n                state.tag = type.tag;\n                if (state.anchor !== null) {\n                    state.anchorMap[state.anchor] = state.result;\n                }\n                break;\n            }\n        }\n    } else if (state.tag !== \"!\") {\n        if (_hasOwnProperty$1.call(state.typeMap[state.kind || \"fallback\"], state.tag)) {\n            type = state.typeMap[state.kind || \"fallback\"][state.tag];\n        } else {\n            // looking for multi type\n            type = null;\n            typeList = state.typeMap.multi[state.kind || \"fallback\"];\n            for(typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1){\n                if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {\n                    type = typeList[typeIndex];\n                    break;\n                }\n            }\n        }\n        if (!type) {\n            throwError(state, \"unknown tag !<\" + state.tag + \">\");\n        }\n        if (state.result !== null && type.kind !== state.kind) {\n            throwError(state, \"unacceptable node kind for !<\" + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n        }\n        if (!type.resolve(state.result, state.tag)) {\n            throwError(state, \"cannot resolve a node with !<\" + state.tag + \"> explicit tag\");\n        } else {\n            state.result = type.construct(state.result, state.tag);\n            if (state.anchor !== null) {\n                state.anchorMap[state.anchor] = state.result;\n            }\n        }\n    }\n    if (state.listener !== null) {\n        state.listener(\"close\", state);\n    }\n    return state.tag !== null || state.anchor !== null || hasContent;\n}\nfunction readDocument(state) {\n    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;\n    state.version = null;\n    state.checkLineBreaks = state.legacy;\n    state.tagMap = Object.create(null);\n    state.anchorMap = Object.create(null);\n    while((ch = state.input.charCodeAt(state.position)) !== 0){\n        skipSeparationSpace(state, true, -1);\n        ch = state.input.charCodeAt(state.position);\n        if (state.lineIndent > 0 || ch !== 0x25 /* % */ ) {\n            break;\n        }\n        hasDirectives = true;\n        ch = state.input.charCodeAt(++state.position);\n        _position = state.position;\n        while(ch !== 0 && !is_WS_OR_EOL(ch)){\n            ch = state.input.charCodeAt(++state.position);\n        }\n        directiveName = state.input.slice(_position, state.position);\n        directiveArgs = [];\n        if (directiveName.length < 1) {\n            throwError(state, \"directive name must not be less than one character in length\");\n        }\n        while(ch !== 0){\n            while(is_WHITE_SPACE(ch)){\n                ch = state.input.charCodeAt(++state.position);\n            }\n            if (ch === 0x23 /* # */ ) {\n                do {\n                    ch = state.input.charCodeAt(++state.position);\n                }while (ch !== 0 && !is_EOL(ch));\n                break;\n            }\n            if (is_EOL(ch)) break;\n            _position = state.position;\n            while(ch !== 0 && !is_WS_OR_EOL(ch)){\n                ch = state.input.charCodeAt(++state.position);\n            }\n            directiveArgs.push(state.input.slice(_position, state.position));\n        }\n        if (ch !== 0) readLineBreak(state);\n        if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {\n            directiveHandlers[directiveName](state, directiveName, directiveArgs);\n        } else {\n            throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n        }\n    }\n    skipSeparationSpace(state, true, -1);\n    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D /* - */  && state.input.charCodeAt(state.position + 1) === 0x2D /* - */  && state.input.charCodeAt(state.position + 2) === 0x2D /* - */ ) {\n        state.position += 3;\n        skipSeparationSpace(state, true, -1);\n    } else if (hasDirectives) {\n        throwError(state, \"directives end mark is expected\");\n    }\n    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n    skipSeparationSpace(state, true, -1);\n    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n        throwWarning(state, \"non-ASCII line breaks are interpreted as content\");\n    }\n    state.documents.push(state.result);\n    if (state.position === state.lineStart && testDocumentSeparator(state)) {\n        if (state.input.charCodeAt(state.position) === 0x2E /* . */ ) {\n            state.position += 3;\n            skipSeparationSpace(state, true, -1);\n        }\n        return;\n    }\n    if (state.position < state.length - 1) {\n        throwError(state, \"end of the stream or a document separator is expected\");\n    } else {\n        return;\n    }\n}\nfunction loadDocuments(input, options) {\n    input = String(input);\n    options = options || {};\n    if (input.length !== 0) {\n        // Add tailing `\\n` if not exists\n        if (input.charCodeAt(input.length - 1) !== 0x0A /* LF */  && input.charCodeAt(input.length - 1) !== 0x0D /* CR */ ) {\n            input += \"\\n\";\n        }\n        // Strip BOM\n        if (input.charCodeAt(0) === 0xFEFF) {\n            input = input.slice(1);\n        }\n    }\n    var state = new State$1(input, options);\n    var nullpos = input.indexOf(\"\\x00\");\n    if (nullpos !== -1) {\n        state.position = nullpos;\n        throwError(state, \"null byte is not allowed in input\");\n    }\n    // Use 0 as string terminator. That significantly simplifies bounds check.\n    state.input += \"\\x00\";\n    while(state.input.charCodeAt(state.position) === 0x20 /* Space */ ){\n        state.lineIndent += 1;\n        state.position += 1;\n    }\n    while(state.position < state.length - 1){\n        readDocument(state);\n    }\n    return state.documents;\n}\nfunction loadAll$1(input, iterator, options) {\n    if (iterator !== null && typeof iterator === \"object\" && typeof options === \"undefined\") {\n        options = iterator;\n        iterator = null;\n    }\n    var documents = loadDocuments(input, options);\n    if (typeof iterator !== \"function\") {\n        return documents;\n    }\n    for(var index = 0, length = documents.length; index < length; index += 1){\n        iterator(documents[index]);\n    }\n}\nfunction load$1(input, options) {\n    var documents = loadDocuments(input, options);\n    if (documents.length === 0) {\n        /*eslint-disable no-undefined*/ return undefined;\n    } else if (documents.length === 1) {\n        return documents[0];\n    }\n    throw new exception(\"expected a single document in the stream, but found more\");\n}\nvar loadAll_1 = loadAll$1;\nvar load_1 = load$1;\nvar loader = {\n    loadAll: loadAll_1,\n    load: load_1\n};\n/*eslint-disable no-use-before-define*/ var _toString = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar CHAR_BOM = 0xFEFF;\nvar CHAR_TAB = 0x09; /* Tab */ \nvar CHAR_LINE_FEED = 0x0A; /* LF */ \nvar CHAR_CARRIAGE_RETURN = 0x0D; /* CR */ \nvar CHAR_SPACE = 0x20; /* Space */ \nvar CHAR_EXCLAMATION = 0x21; /* ! */ \nvar CHAR_DOUBLE_QUOTE = 0x22; /* \" */ \nvar CHAR_SHARP = 0x23; /* # */ \nvar CHAR_PERCENT = 0x25; /* % */ \nvar CHAR_AMPERSAND = 0x26; /* & */ \nvar CHAR_SINGLE_QUOTE = 0x27; /* ' */ \nvar CHAR_ASTERISK = 0x2A; /* * */ \nvar CHAR_COMMA = 0x2C; /* , */ \nvar CHAR_MINUS = 0x2D; /* - */ \nvar CHAR_COLON = 0x3A; /* : */ \nvar CHAR_EQUALS = 0x3D; /* = */ \nvar CHAR_GREATER_THAN = 0x3E; /* > */ \nvar CHAR_QUESTION = 0x3F; /* ? */ \nvar CHAR_COMMERCIAL_AT = 0x40; /* @ */ \nvar CHAR_LEFT_SQUARE_BRACKET = 0x5B; /* [ */ \nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */ \nvar CHAR_GRAVE_ACCENT = 0x60; /* ` */ \nvar CHAR_LEFT_CURLY_BRACKET = 0x7B; /* { */ \nvar CHAR_VERTICAL_LINE = 0x7C; /* | */ \nvar CHAR_RIGHT_CURLY_BRACKET = 0x7D; /* } */ \nvar ESCAPE_SEQUENCES = {};\nESCAPE_SEQUENCES[0x00] = \"\\\\0\";\nESCAPE_SEQUENCES[0x07] = \"\\\\a\";\nESCAPE_SEQUENCES[0x08] = \"\\\\b\";\nESCAPE_SEQUENCES[0x09] = \"\\\\t\";\nESCAPE_SEQUENCES[0x0A] = \"\\\\n\";\nESCAPE_SEQUENCES[0x0B] = \"\\\\v\";\nESCAPE_SEQUENCES[0x0C] = \"\\\\f\";\nESCAPE_SEQUENCES[0x0D] = \"\\\\r\";\nESCAPE_SEQUENCES[0x1B] = \"\\\\e\";\nESCAPE_SEQUENCES[0x22] = '\\\\\"';\nESCAPE_SEQUENCES[0x5C] = \"\\\\\\\\\";\nESCAPE_SEQUENCES[0x85] = \"\\\\N\";\nESCAPE_SEQUENCES[0xA0] = \"\\\\_\";\nESCAPE_SEQUENCES[0x2028] = \"\\\\L\";\nESCAPE_SEQUENCES[0x2029] = \"\\\\P\";\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n    \"y\",\n    \"Y\",\n    \"yes\",\n    \"Yes\",\n    \"YES\",\n    \"on\",\n    \"On\",\n    \"ON\",\n    \"n\",\n    \"N\",\n    \"no\",\n    \"No\",\n    \"NO\",\n    \"off\",\n    \"Off\",\n    \"OFF\"\n];\nvar DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\.[0-9_]*)?$/;\nfunction compileStyleMap(schema, map) {\n    var result, keys, index, length, tag, style, type;\n    if (map === null) return {};\n    result = {};\n    keys = Object.keys(map);\n    for(index = 0, length = keys.length; index < length; index += 1){\n        tag = keys[index];\n        style = String(map[tag]);\n        if (tag.slice(0, 2) === \"!!\") {\n            tag = \"tag:yaml.org,2002:\" + tag.slice(2);\n        }\n        type = schema.compiledTypeMap[\"fallback\"][tag];\n        if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n            style = type.styleAliases[style];\n        }\n        result[tag] = style;\n    }\n    return result;\n}\nfunction encodeHex(character) {\n    var string, handle, length;\n    string = character.toString(16).toUpperCase();\n    if (character <= 0xFF) {\n        handle = \"x\";\n        length = 2;\n    } else if (character <= 0xFFFF) {\n        handle = \"u\";\n        length = 4;\n    } else if (character <= 0xFFFFFFFF) {\n        handle = \"U\";\n        length = 8;\n    } else {\n        throw new exception(\"code point within a string may not be greater than 0xFFFFFFFF\");\n    }\n    return \"\\\\\" + handle + common.repeat(\"0\", length - string.length) + string;\n}\nvar QUOTING_TYPE_SINGLE = 1, QUOTING_TYPE_DOUBLE = 2;\nfunction State(options) {\n    this.schema = options[\"schema\"] || _default;\n    this.indent = Math.max(1, options[\"indent\"] || 2);\n    this.noArrayIndent = options[\"noArrayIndent\"] || false;\n    this.skipInvalid = options[\"skipInvalid\"] || false;\n    this.flowLevel = common.isNothing(options[\"flowLevel\"]) ? -1 : options[\"flowLevel\"];\n    this.styleMap = compileStyleMap(this.schema, options[\"styles\"] || null);\n    this.sortKeys = options[\"sortKeys\"] || false;\n    this.lineWidth = options[\"lineWidth\"] || 80;\n    this.noRefs = options[\"noRefs\"] || false;\n    this.noCompatMode = options[\"noCompatMode\"] || false;\n    this.condenseFlow = options[\"condenseFlow\"] || false;\n    this.quotingType = options[\"quotingType\"] === '\"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;\n    this.forceQuotes = options[\"forceQuotes\"] || false;\n    this.replacer = typeof options[\"replacer\"] === \"function\" ? options[\"replacer\"] : null;\n    this.implicitTypes = this.schema.compiledImplicit;\n    this.explicitTypes = this.schema.compiledExplicit;\n    this.tag = null;\n    this.result = \"\";\n    this.duplicates = [];\n    this.usedDuplicates = null;\n}\n// Indents every line in a string. Empty lines (\\n only) are not indented.\nfunction indentString(string, spaces) {\n    var ind = common.repeat(\" \", spaces), position = 0, next = -1, result = \"\", line, length = string.length;\n    while(position < length){\n        next = string.indexOf(\"\\n\", position);\n        if (next === -1) {\n            line = string.slice(position);\n            position = length;\n        } else {\n            line = string.slice(position, next + 1);\n            position = next + 1;\n        }\n        if (line.length && line !== \"\\n\") result += ind;\n        result += line;\n    }\n    return result;\n}\nfunction generateNextLine(state, level) {\n    return \"\\n\" + common.repeat(\" \", state.indent * level);\n}\nfunction testImplicitResolving(state, str) {\n    var index, length, type;\n    for(index = 0, length = state.implicitTypes.length; index < length; index += 1){\n        type = state.implicitTypes[index];\n        if (type.resolve(str)) {\n            return true;\n        }\n    }\n    return false;\n}\n// [33] s-white ::= s-space | s-tab\nfunction isWhitespace(c) {\n    return c === CHAR_SPACE || c === CHAR_TAB;\n}\n// Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isn’t mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\nfunction isPrintable(c) {\n    return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== CHAR_BOM || 0x10000 <= c && c <= 0x10FFFF;\n}\n// [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// Including s-white (for some reason, examples doesn't match specs in this aspect)\n// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark\nfunction isNsCharOrWhitespace(c) {\n    return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;\n}\n// [127]  ns-plain-safe(c) ::= c = flow-out  ⇒ ns-plain-safe-out\n//                             c = flow-in   ⇒ ns-plain-safe-in\n//                             c = block-key ⇒ ns-plain-safe-out\n//                             c = flow-key  ⇒ ns-plain-safe-in\n// [128] ns-plain-safe-out ::= ns-char\n// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator\n// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - “:” - “#” )\n//                            | ( /* An ns-char preceding */ “#” )\n//                            | ( “:” /* Followed by an ns-plain-safe(c) */ )\nfunction isPlainSafe(c, prev, inblock) {\n    var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);\n    var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);\n    return(// ns-plain-safe\n    (inblock ? cIsNsCharOrWhitespace : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP // false on '#'\n     && !(prev === CHAR_COLON && !cIsNsChar // false on ': '\n    ) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP // change to true on '[^ ]#'\n     || prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'\n}\n// Simplified test for values allowed as the first character in plain style.\nfunction isPlainSafeFirst(c) {\n    // Uses a subset of ns-char - c-indicator\n    // where ns-char = nb-char - s-white.\n    // No support of ( ( “?” | “:” | “-” ) /* Followed by an ns-plain-safe(c)) */ ) part\n    return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) // - s-white\n     && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;\n}\n// Simplified test for values allowed as the last character in plain style.\nfunction isPlainSafeLast(c) {\n    // just not whitespace or colon, it will be checked to be plain character later\n    return !isWhitespace(c) && c !== CHAR_COLON;\n}\n// Same as 'string'.codePointAt(pos), but works in older browsers.\nfunction codePointAt(string, pos) {\n    var first = string.charCodeAt(pos), second;\n    if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {\n        second = string.charCodeAt(pos + 1);\n        if (second >= 0xDC00 && second <= 0xDFFF) {\n            // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n        }\n    }\n    return first;\n}\n// Determines whether block indentation indicator is required.\nfunction needIndentIndicator(string) {\n    var leadingSpaceRe = /^\\n* /;\n    return leadingSpaceRe.test(string);\n}\nvar STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;\n// Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {\n    var i;\n    var char = 0;\n    var prevChar = null;\n    var hasLineBreak = false;\n    var hasFoldableLine = false; // only checked if shouldTrackWidth\n    var shouldTrackWidth = lineWidth !== -1;\n    var previousLineBreak = -1; // count the first line correctly\n    var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));\n    if (singleLineOnly || forceQuotes) {\n        // Case: no block styles.\n        // Check for disallowed characters to rule out plain and single.\n        for(i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++){\n            char = codePointAt(string, i);\n            if (!isPrintable(char)) {\n                return STYLE_DOUBLE;\n            }\n            plain = plain && isPlainSafe(char, prevChar, inblock);\n            prevChar = char;\n        }\n    } else {\n        // Case: block styles permitted.\n        for(i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++){\n            char = codePointAt(string, i);\n            if (char === CHAR_LINE_FEED) {\n                hasLineBreak = true;\n                // Check if any line can be folded.\n                if (shouldTrackWidth) {\n                    hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.\n                    i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== \" \";\n                    previousLineBreak = i;\n                }\n            } else if (!isPrintable(char)) {\n                return STYLE_DOUBLE;\n            }\n            plain = plain && isPlainSafe(char, prevChar, inblock);\n            prevChar = char;\n        }\n        // in case the end is missing a \\n\n        hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== \" \";\n    }\n    // Although every style can represent \\n without escaping, prefer block styles\n    // for multiline, since they're more readable and they don't add empty lines.\n    // Also prefer folding a super-long line.\n    if (!hasLineBreak && !hasFoldableLine) {\n        // Strings interpretable as another type have to be quoted;\n        // e.g. the string 'true' vs. the boolean true.\n        if (plain && !forceQuotes && !testAmbiguousType(string)) {\n            return STYLE_PLAIN;\n        }\n        return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n    }\n    // Edge case: block indentation indicator can only have one digit.\n    if (indentPerLevel > 9 && needIndentIndicator(string)) {\n        return STYLE_DOUBLE;\n    }\n    // At this point we know block styles are valid.\n    // Prefer literal style unless we want to fold.\n    if (!forceQuotes) {\n        return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n    }\n    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n}\n// Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//    • No ending newline => unaffected; already using strip \"-\" chomping.\n//    • Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\nfunction writeScalar(state, string, level, iskey, inblock) {\n    state.dump = function() {\n        if (string.length === 0) {\n            return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"\"' : \"''\";\n        }\n        if (!state.noCompatMode) {\n            if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {\n                return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"' + string + '\"' : \"'\" + string + \"'\";\n            }\n        }\n        var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n        // As indentation gets deeper, let the width decrease monotonically\n        // to the lower bound min(state.lineWidth, 40).\n        // Note that this implies\n        //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.\n        //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n        // This behaves better than a constant minimum width which disallows narrower options,\n        // or an indent threshold which causes the width to suddenly increase.\n        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n        // Without knowing if keys are implicit/explicit, assume implicit for safety.\n        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;\n        function testAmbiguity(string) {\n            return testImplicitResolving(state, string);\n        }\n        switch(chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)){\n            case STYLE_PLAIN:\n                return string;\n            case STYLE_SINGLE:\n                return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n            case STYLE_LITERAL:\n                return \"|\" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));\n            case STYLE_FOLDED:\n                return \">\" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n            case STYLE_DOUBLE:\n                return '\"' + escapeString(string) + '\"';\n            default:\n                throw new exception(\"impossible error: invalid scalar style\");\n        }\n    }();\n}\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\nfunction blockHeader(string, indentPerLevel) {\n    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : \"\";\n    // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n    var clip = string[string.length - 1] === \"\\n\";\n    var keep = clip && (string[string.length - 2] === \"\\n\" || string === \"\\n\");\n    var chomp = keep ? \"+\" : clip ? \"\" : \"-\";\n    return indentIndicator + chomp + \"\\n\";\n}\n// (See the note for writeScalar.)\nfunction dropEndingNewline(string) {\n    return string[string.length - 1] === \"\\n\" ? string.slice(0, -1) : string;\n}\n// Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\nfunction foldString(string, width) {\n    // In folded style, $k$ consecutive newlines output as $k+1$ newlines—\n    // unless they're before or after a more-indented line, or at the very\n    // beginning or end, in which case $k$ maps to $k$.\n    // Therefore, parse each chunk as newline(s) followed by a content line.\n    var lineRe = /(\\n+)([^\\n]*)/g;\n    // first line (possibly an empty line)\n    var result = function() {\n        var nextLF = string.indexOf(\"\\n\");\n        nextLF = nextLF !== -1 ? nextLF : string.length;\n        lineRe.lastIndex = nextLF;\n        return foldLine(string.slice(0, nextLF), width);\n    }();\n    // If we haven't reached the first content line yet, don't add an extra \\n.\n    var prevMoreIndented = string[0] === \"\\n\" || string[0] === \" \";\n    var moreIndented;\n    // rest of the lines\n    var match;\n    while(match = lineRe.exec(string)){\n        var prefix = match[1], line = match[2];\n        moreIndented = line[0] === \" \";\n        result += prefix + (!prevMoreIndented && !moreIndented && line !== \"\" ? \"\\n\" : \"\") + foldLine(line, width);\n        prevMoreIndented = moreIndented;\n    }\n    return result;\n}\n// Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\nfunction foldLine(line, width) {\n    if (line === \"\" || line[0] === \" \") return line;\n    // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n    var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n    var match;\n    // start is an inclusive index. end, curr, and next are exclusive.\n    var start = 0, end, curr = 0, next = 0;\n    var result = \"\";\n    // Invariants: 0 <= start <= length-1.\n    //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n    // Inside the loop:\n    //   A match implies length >= 2, so curr and next are <= length-2.\n    while(match = breakRe.exec(line)){\n        next = match.index;\n        // maintain invariant: curr - start <= width\n        if (next - start > width) {\n            end = curr > start ? curr : next; // derive end <= length-2\n            result += \"\\n\" + line.slice(start, end);\n            // skip the space that was output as \\n\n            start = end + 1; // derive start <= length-1\n        }\n        curr = next;\n    }\n    // By the invariants, start <= length-1, so there is something left over.\n    // It is either the whole string or a part starting from non-whitespace.\n    result += \"\\n\";\n    // Insert a break if the remainder is too long and there is a break available.\n    if (line.length - start > width && curr > start) {\n        result += line.slice(start, curr) + \"\\n\" + line.slice(curr + 1);\n    } else {\n        result += line.slice(start);\n    }\n    return result.slice(1); // drop extra \\n joiner\n}\n// Escapes a double-quoted string.\nfunction escapeString(string) {\n    var result = \"\";\n    var char = 0;\n    var escapeSeq;\n    for(var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++){\n        char = codePointAt(string, i);\n        escapeSeq = ESCAPE_SEQUENCES[char];\n        if (!escapeSeq && isPrintable(char)) {\n            result += string[i];\n            if (char >= 0x10000) result += string[i + 1];\n        } else {\n            result += escapeSeq || encodeHex(char);\n        }\n    }\n    return result;\n}\nfunction writeFlowSequence(state, level, object) {\n    var _result = \"\", _tag = state.tag, index, length, value;\n    for(index = 0, length = object.length; index < length; index += 1){\n        value = object[index];\n        if (state.replacer) {\n            value = state.replacer.call(object, String(index), value);\n        }\n        // Write only valid elements, put null instead of invalid elements.\n        if (writeNode(state, level, value, false, false) || typeof value === \"undefined\" && writeNode(state, level, null, false, false)) {\n            if (_result !== \"\") _result += \",\" + (!state.condenseFlow ? \" \" : \"\");\n            _result += state.dump;\n        }\n    }\n    state.tag = _tag;\n    state.dump = \"[\" + _result + \"]\";\n}\nfunction writeBlockSequence(state, level, object, compact) {\n    var _result = \"\", _tag = state.tag, index, length, value;\n    for(index = 0, length = object.length; index < length; index += 1){\n        value = object[index];\n        if (state.replacer) {\n            value = state.replacer.call(object, String(index), value);\n        }\n        // Write only valid elements, put null instead of invalid elements.\n        if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === \"undefined\" && writeNode(state, level + 1, null, true, true, false, true)) {\n            if (!compact || _result !== \"\") {\n                _result += generateNextLine(state, level);\n            }\n            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n                _result += \"-\";\n            } else {\n                _result += \"- \";\n            }\n            _result += state.dump;\n        }\n    }\n    state.tag = _tag;\n    state.dump = _result || \"[]\"; // Empty sequence if no valid values.\n}\nfunction writeFlowMapping(state, level, object) {\n    var _result = \"\", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;\n    for(index = 0, length = objectKeyList.length; index < length; index += 1){\n        pairBuffer = \"\";\n        if (_result !== \"\") pairBuffer += \", \";\n        if (state.condenseFlow) pairBuffer += '\"';\n        objectKey = objectKeyList[index];\n        objectValue = object[objectKey];\n        if (state.replacer) {\n            objectValue = state.replacer.call(object, objectKey, objectValue);\n        }\n        if (!writeNode(state, level, objectKey, false, false)) {\n            continue; // Skip this pair because of invalid key;\n        }\n        if (state.dump.length > 1024) pairBuffer += \"? \";\n        pairBuffer += state.dump + (state.condenseFlow ? '\"' : \"\") + \":\" + (state.condenseFlow ? \"\" : \" \");\n        if (!writeNode(state, level, objectValue, false, false)) {\n            continue; // Skip this pair because of invalid value.\n        }\n        pairBuffer += state.dump;\n        // Both key and value are valid.\n        _result += pairBuffer;\n    }\n    state.tag = _tag;\n    state.dump = \"{\" + _result + \"}\";\n}\nfunction writeBlockMapping(state, level, object, compact) {\n    var _result = \"\", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;\n    // Allow sorting keys so that the output file is deterministic\n    if (state.sortKeys === true) {\n        // Default sorting\n        objectKeyList.sort();\n    } else if (typeof state.sortKeys === \"function\") {\n        // Custom sort function\n        objectKeyList.sort(state.sortKeys);\n    } else if (state.sortKeys) {\n        // Something is wrong\n        throw new exception(\"sortKeys must be a boolean or a function\");\n    }\n    for(index = 0, length = objectKeyList.length; index < length; index += 1){\n        pairBuffer = \"\";\n        if (!compact || _result !== \"\") {\n            pairBuffer += generateNextLine(state, level);\n        }\n        objectKey = objectKeyList[index];\n        objectValue = object[objectKey];\n        if (state.replacer) {\n            objectValue = state.replacer.call(object, objectKey, objectValue);\n        }\n        if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n            continue; // Skip this pair because of invalid key.\n        }\n        explicitPair = state.tag !== null && state.tag !== \"?\" || state.dump && state.dump.length > 1024;\n        if (explicitPair) {\n            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n                pairBuffer += \"?\";\n            } else {\n                pairBuffer += \"? \";\n            }\n        }\n        pairBuffer += state.dump;\n        if (explicitPair) {\n            pairBuffer += generateNextLine(state, level);\n        }\n        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n            continue; // Skip this pair because of invalid value.\n        }\n        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n            pairBuffer += \":\";\n        } else {\n            pairBuffer += \": \";\n        }\n        pairBuffer += state.dump;\n        // Both key and value are valid.\n        _result += pairBuffer;\n    }\n    state.tag = _tag;\n    state.dump = _result || \"{}\"; // Empty mapping if no valid pairs.\n}\nfunction detectType(state, object, explicit) {\n    var _result, typeList, index, length, type, style;\n    typeList = explicit ? state.explicitTypes : state.implicitTypes;\n    for(index = 0, length = typeList.length; index < length; index += 1){\n        type = typeList[index];\n        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === \"object\" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {\n            if (explicit) {\n                if (type.multi && type.representName) {\n                    state.tag = type.representName(object);\n                } else {\n                    state.tag = type.tag;\n                }\n            } else {\n                state.tag = \"?\";\n            }\n            if (type.represent) {\n                style = state.styleMap[type.tag] || type.defaultStyle;\n                if (_toString.call(type.represent) === \"[object Function]\") {\n                    _result = type.represent(object, style);\n                } else if (_hasOwnProperty.call(type.represent, style)) {\n                    _result = type.represent[style](object, style);\n                } else {\n                    throw new exception(\"!<\" + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n                }\n                state.dump = _result;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact, iskey, isblockseq) {\n    state.tag = null;\n    state.dump = object;\n    if (!detectType(state, object, false)) {\n        detectType(state, object, true);\n    }\n    var type = _toString.call(state.dump);\n    var inblock = block;\n    var tagStr;\n    if (block) {\n        block = state.flowLevel < 0 || state.flowLevel > level;\n    }\n    var objectOrArray = type === \"[object Object]\" || type === \"[object Array]\", duplicateIndex, duplicate;\n    if (objectOrArray) {\n        duplicateIndex = state.duplicates.indexOf(object);\n        duplicate = duplicateIndex !== -1;\n    }\n    if (state.tag !== null && state.tag !== \"?\" || duplicate || state.indent !== 2 && level > 0) {\n        compact = false;\n    }\n    if (duplicate && state.usedDuplicates[duplicateIndex]) {\n        state.dump = \"*ref_\" + duplicateIndex;\n    } else {\n        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n            state.usedDuplicates[duplicateIndex] = true;\n        }\n        if (type === \"[object Object]\") {\n            if (block && Object.keys(state.dump).length !== 0) {\n                writeBlockMapping(state, level, state.dump, compact);\n                if (duplicate) {\n                    state.dump = \"&ref_\" + duplicateIndex + state.dump;\n                }\n            } else {\n                writeFlowMapping(state, level, state.dump);\n                if (duplicate) {\n                    state.dump = \"&ref_\" + duplicateIndex + \" \" + state.dump;\n                }\n            }\n        } else if (type === \"[object Array]\") {\n            if (block && state.dump.length !== 0) {\n                if (state.noArrayIndent && !isblockseq && level > 0) {\n                    writeBlockSequence(state, level - 1, state.dump, compact);\n                } else {\n                    writeBlockSequence(state, level, state.dump, compact);\n                }\n                if (duplicate) {\n                    state.dump = \"&ref_\" + duplicateIndex + state.dump;\n                }\n            } else {\n                writeFlowSequence(state, level, state.dump);\n                if (duplicate) {\n                    state.dump = \"&ref_\" + duplicateIndex + \" \" + state.dump;\n                }\n            }\n        } else if (type === \"[object String]\") {\n            if (state.tag !== \"?\") {\n                writeScalar(state, state.dump, level, iskey, inblock);\n            }\n        } else if (type === \"[object Undefined]\") {\n            return false;\n        } else {\n            if (state.skipInvalid) return false;\n            throw new exception(\"unacceptable kind of an object to dump \" + type);\n        }\n        if (state.tag !== null && state.tag !== \"?\") {\n            // Need to encode all characters except those allowed by the spec:\n            //\n            // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */\n            // [36] ns-hex-digit    ::=  ns-dec-digit\n            //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */\n            // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */\n            // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | “-”\n            // [39] ns-uri-char     ::=  “%” ns-hex-digit ns-hex-digit | ns-word-char | “#”\n            //                         | “;” | “/” | “?” | “:” | “@” | “&” | “=” | “+” | “$” | “,”\n            //                         | “_” | “.” | “!” | “~” | “*” | “'” | “(” | “)” | “[” | “]”\n            //\n            // Also need to encode '!' because it has special meaning (end of tag prefix).\n            //\n            tagStr = encodeURI(state.tag[0] === \"!\" ? state.tag.slice(1) : state.tag).replace(/!/g, \"%21\");\n            if (state.tag[0] === \"!\") {\n                tagStr = \"!\" + tagStr;\n            } else if (tagStr.slice(0, 18) === \"tag:yaml.org,2002:\") {\n                tagStr = \"!!\" + tagStr.slice(18);\n            } else {\n                tagStr = \"!<\" + tagStr + \">\";\n            }\n            state.dump = tagStr + \" \" + state.dump;\n        }\n    }\n    return true;\n}\nfunction getDuplicateReferences(object, state) {\n    var objects = [], duplicatesIndexes = [], index, length;\n    inspectNode(object, objects, duplicatesIndexes);\n    for(index = 0, length = duplicatesIndexes.length; index < length; index += 1){\n        state.duplicates.push(objects[duplicatesIndexes[index]]);\n    }\n    state.usedDuplicates = new Array(length);\n}\nfunction inspectNode(object, objects, duplicatesIndexes) {\n    var objectKeyList, index, length;\n    if (object !== null && typeof object === \"object\") {\n        index = objects.indexOf(object);\n        if (index !== -1) {\n            if (duplicatesIndexes.indexOf(index) === -1) {\n                duplicatesIndexes.push(index);\n            }\n        } else {\n            objects.push(object);\n            if (Array.isArray(object)) {\n                for(index = 0, length = object.length; index < length; index += 1){\n                    inspectNode(object[index], objects, duplicatesIndexes);\n                }\n            } else {\n                objectKeyList = Object.keys(object);\n                for(index = 0, length = objectKeyList.length; index < length; index += 1){\n                    inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n                }\n            }\n        }\n    }\n}\nfunction dump$1(input, options) {\n    options = options || {};\n    var state = new State(options);\n    if (!state.noRefs) getDuplicateReferences(input, state);\n    var value = input;\n    if (state.replacer) {\n        value = state.replacer.call({\n            \"\": value\n        }, \"\", value);\n    }\n    if (writeNode(state, 0, value, true, true)) return state.dump + \"\\n\";\n    return \"\";\n}\nvar dump_1 = dump$1;\nvar dumper = {\n    dump: dump_1\n};\nfunction renamed(from, to) {\n    return function() {\n        throw new Error(\"Function yaml.\" + from + \" is removed in js-yaml 4. \" + \"Use yaml.\" + to + \" instead, which is now safe by default.\");\n    };\n}\nvar Type = type;\nvar Schema = schema;\nvar FAILSAFE_SCHEMA = failsafe;\nvar JSON_SCHEMA = json;\nvar CORE_SCHEMA = core;\nvar DEFAULT_SCHEMA = _default;\nvar load = loader.load;\nvar loadAll = loader.loadAll;\nvar dump = dumper.dump;\nvar YAMLException = exception;\n// Re-export all types in case user wants to create custom schema\nvar types = {\n    binary: binary,\n    float: float,\n    map: map,\n    null: _null,\n    pairs: pairs,\n    set: set,\n    timestamp: timestamp,\n    bool: bool,\n    int: int,\n    merge: merge,\n    omap: omap,\n    seq: seq,\n    str: str\n};\n// Removed functions from JS-YAML 3.0.x\nvar safeLoad = renamed(\"safeLoad\", \"load\");\nvar safeLoadAll = renamed(\"safeLoadAll\", \"loadAll\");\nvar safeDump = renamed(\"safeDump\", \"dump\");\nvar jsYaml = {\n    Type: Type,\n    Schema: Schema,\n    FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,\n    JSON_SCHEMA: JSON_SCHEMA,\n    CORE_SCHEMA: CORE_SCHEMA,\n    DEFAULT_SCHEMA: DEFAULT_SCHEMA,\n    load: load,\n    loadAll: loadAll,\n    dump: dump,\n    YAMLException: YAMLException,\n    types: types,\n    safeLoad: safeLoad,\n    safeLoadAll: safeLoadAll,\n    safeDump: safeDump\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (jsYaml);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2pzLXlhbWxANC4xLjAvbm9kZV9tb2R1bGVzL2pzLXlhbWwvZGlzdC9qcy15YW1sLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxpRUFBaUUsR0FDakUsU0FBU0EsVUFBVUMsT0FBTztJQUN4QixPQUFPLE9BQVFBLFlBQVksZUFBaUJBLFlBQVk7QUFDMUQ7QUFHQSxTQUFTQyxTQUFTRCxPQUFPO0lBQ3ZCLE9BQU8sT0FBUUEsWUFBWSxZQUFjQSxZQUFZO0FBQ3ZEO0FBR0EsU0FBU0UsUUFBUUMsUUFBUTtJQUN2QixJQUFJQyxNQUFNQyxPQUFPLENBQUNGLFdBQVcsT0FBT0E7U0FDL0IsSUFBSUosVUFBVUksV0FBVyxPQUFPLEVBQUU7SUFFdkMsT0FBTztRQUFFQTtLQUFVO0FBQ3JCO0FBR0EsU0FBU0csT0FBT0MsTUFBTSxFQUFFQyxNQUFNO0lBQzVCLElBQUlDLE9BQU9DLFFBQVFDLEtBQUtDO0lBRXhCLElBQUlKLFFBQVE7UUFDVkksYUFBYUMsT0FBT0MsSUFBSSxDQUFDTjtRQUV6QixJQUFLQyxRQUFRLEdBQUdDLFNBQVNFLFdBQVdGLE1BQU0sRUFBRUQsUUFBUUMsUUFBUUQsU0FBUyxFQUFHO1lBQ3RFRSxNQUFNQyxVQUFVLENBQUNILE1BQU07WUFDdkJGLE1BQU0sQ0FBQ0ksSUFBSSxHQUFHSCxNQUFNLENBQUNHLElBQUk7UUFDM0I7SUFDRjtJQUVBLE9BQU9KO0FBQ1Q7QUFHQSxTQUFTUSxPQUFPQyxNQUFNLEVBQUVDLEtBQUs7SUFDM0IsSUFBSUMsU0FBUyxJQUFJQztJQUVqQixJQUFLQSxRQUFRLEdBQUdBLFFBQVFGLE9BQU9FLFNBQVMsRUFBRztRQUN6Q0QsVUFBVUY7SUFDWjtJQUVBLE9BQU9FO0FBQ1Q7QUFHQSxTQUFTRSxlQUFlQyxNQUFNO0lBQzVCLE9BQU8sV0FBWSxLQUFPQyxPQUFPQyxpQkFBaUIsS0FBSyxJQUFJRjtBQUM3RDtBQUdBLElBQUlHLGNBQW1CekI7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STtBQUNyQyxJQUFJdUQsZ0JBQXNCdmdCO0FBRTFCLGlFQUFpRTtBQUNqRSxJQUFJd2dCLFFBQVE7SUFDVnpZLFFBQVdBO0lBQ1hvQixPQUFXQTtJQUNYNUYsS0FBV0E7SUFDWGtkLE1BQVdsYTtJQUNYaUcsT0FBV0E7SUFDWEksS0FBV0E7SUFDWGpDLFdBQVdBO0lBQ1gzRCxNQUFXQTtJQUNYYyxLQUFXQTtJQUNYK0MsT0FBV0E7SUFDWHVCLE1BQVdBO0lBQ1huRyxLQUFXQTtJQUNYbkUsS0FBV0E7QUFDYjtBQUVBLHVDQUF1QztBQUN2QyxJQUFJNGUsV0FBc0JaLFFBQVEsWUFBWTtBQUM5QyxJQUFJYSxjQUFzQmIsUUFBUSxlQUFlO0FBQ2pELElBQUljLFdBQXNCZCxRQUFRLFlBQVk7QUFFOUMsSUFBSWUsU0FBUztJQUNaWixNQUFNQTtJQUNOQyxRQUFRQTtJQUNSQyxpQkFBaUJBO0lBQ2pCQyxhQUFhQTtJQUNiQyxhQUFhQTtJQUNiQyxnQkFBZ0JBO0lBQ2hCakosTUFBTUE7SUFDTkQsU0FBU0E7SUFDVDRGLE1BQU1BO0lBQ051RCxlQUFlQTtJQUNmQyxPQUFPQTtJQUNQRSxVQUFVQTtJQUNWQyxhQUFhQTtJQUNiQyxVQUFVQTtBQUNYO0FBRUEsaUVBQWVDLE1BQU1BLEVBQUM7QUFDeUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rZXlzdGF0aWMtc3RhcnRlci8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vanMteWFtbEA0LjEuMC9ub2RlX21vZHVsZXMvanMteWFtbC9kaXN0L2pzLXlhbWwubWpzPzc2Y2EiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKiEganMteWFtbCA0LjEuMCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL2pzLXlhbWwgQGxpY2Vuc2UgTUlUICovXG5mdW5jdGlvbiBpc05vdGhpbmcoc3ViamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBzdWJqZWN0ID09PSAndW5kZWZpbmVkJykgfHwgKHN1YmplY3QgPT09IG51bGwpO1xufVxuXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHN1YmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcpICYmIChzdWJqZWN0ICE9PSBudWxsKTtcbn1cblxuXG5mdW5jdGlvbiB0b0FycmF5KHNlcXVlbmNlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHNlcXVlbmNlKSkgcmV0dXJuIHNlcXVlbmNlO1xuICBlbHNlIGlmIChpc05vdGhpbmcoc2VxdWVuY2UpKSByZXR1cm4gW107XG5cbiAgcmV0dXJuIFsgc2VxdWVuY2UgXTtcbn1cblxuXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgdmFyIGluZGV4LCBsZW5ndGgsIGtleSwgc291cmNlS2V5cztcblxuICBpZiAoc291cmNlKSB7XG4gICAgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gc291cmNlS2V5cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICBrZXkgPSBzb3VyY2VLZXlzW2luZGV4XTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuXG5mdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBjb3VudCkge1xuICB2YXIgcmVzdWx0ID0gJycsIGN5Y2xlO1xuXG4gIGZvciAoY3ljbGUgPSAwOyBjeWNsZSA8IGNvdW50OyBjeWNsZSArPSAxKSB7XG4gICAgcmVzdWx0ICs9IHN0cmluZztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gaXNOZWdhdGl2ZVplcm8obnVtYmVyKSB7XG4gIHJldHVybiAobnVtYmVyID09PSAwKSAmJiAoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZID09PSAxIC8gbnVtYmVyKTtcbn1cblxuXG52YXIgaXNOb3RoaW5nXzEgICAgICA9IGlzTm90aGluZztcbnZhciBpc09iamVjdF8xICAgICAgID0gaXNPYmplY3Q7XG52YXIgdG9BcnJheV8xICAgICAgICA9IHRvQXJyYXk7XG52YXIgcmVwZWF0XzEgICAgICAgICA9IHJlcGVhdDtcbnZhciBpc05lZ2F0aXZlWmVyb18xID0gaXNOZWdhdGl2ZVplcm87XG52YXIgZXh0ZW5kXzEgICAgICAgICA9IGV4dGVuZDtcblxudmFyIGNvbW1vbiA9IHtcblx0aXNOb3RoaW5nOiBpc05vdGhpbmdfMSxcblx0aXNPYmplY3Q6IGlzT2JqZWN0XzEsXG5cdHRvQXJyYXk6IHRvQXJyYXlfMSxcblx0cmVwZWF0OiByZXBlYXRfMSxcblx0aXNOZWdhdGl2ZVplcm86IGlzTmVnYXRpdmVaZXJvXzEsXG5cdGV4dGVuZDogZXh0ZW5kXzFcbn07XG5cbi8vIFlBTUwgZXJyb3IgY2xhc3MuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ1ODk4NFxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKGV4Y2VwdGlvbiwgY29tcGFjdCkge1xuICB2YXIgd2hlcmUgPSAnJywgbWVzc2FnZSA9IGV4Y2VwdGlvbi5yZWFzb24gfHwgJyh1bmtub3duIHJlYXNvbiknO1xuXG4gIGlmICghZXhjZXB0aW9uLm1hcmspIHJldHVybiBtZXNzYWdlO1xuXG4gIGlmIChleGNlcHRpb24ubWFyay5uYW1lKSB7XG4gICAgd2hlcmUgKz0gJ2luIFwiJyArIGV4Y2VwdGlvbi5tYXJrLm5hbWUgKyAnXCIgJztcbiAgfVxuXG4gIHdoZXJlICs9ICcoJyArIChleGNlcHRpb24ubWFyay5saW5lICsgMSkgKyAnOicgKyAoZXhjZXB0aW9uLm1hcmsuY29sdW1uICsgMSkgKyAnKSc7XG5cbiAgaWYgKCFjb21wYWN0ICYmIGV4Y2VwdGlvbi5tYXJrLnNuaXBwZXQpIHtcbiAgICB3aGVyZSArPSAnXFxuXFxuJyArIGV4Y2VwdGlvbi5tYXJrLnNuaXBwZXQ7XG4gIH1cblxuICByZXR1cm4gbWVzc2FnZSArICcgJyArIHdoZXJlO1xufVxuXG5cbmZ1bmN0aW9uIFlBTUxFeGNlcHRpb24kMShyZWFzb24sIG1hcmspIHtcbiAgLy8gU3VwZXIgY29uc3RydWN0b3JcbiAgRXJyb3IuY2FsbCh0aGlzKTtcblxuICB0aGlzLm5hbWUgPSAnWUFNTEV4Y2VwdGlvbic7XG4gIHRoaXMucmVhc29uID0gcmVhc29uO1xuICB0aGlzLm1hcmsgPSBtYXJrO1xuICB0aGlzLm1lc3NhZ2UgPSBmb3JtYXRFcnJvcih0aGlzLCBmYWxzZSk7XG5cbiAgLy8gSW5jbHVkZSBzdGFjayB0cmFjZSBpbiBlcnJvciBvYmplY3RcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgLy8gQ2hyb21lIGFuZCBOb2RlSlNcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBGRiwgSUUgMTArIGFuZCBTYWZhcmkgNisuIEZhbGxiYWNrIGZvciBvdGhlcnNcbiAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjayB8fCAnJztcbiAgfVxufVxuXG5cbi8vIEluaGVyaXQgZnJvbSBFcnJvclxuWUFNTEV4Y2VwdGlvbiQxLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbllBTUxFeGNlcHRpb24kMS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBZQU1MRXhjZXB0aW9uJDE7XG5cblxuWUFNTEV4Y2VwdGlvbiQxLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGNvbXBhY3QpIHtcbiAgcmV0dXJuIHRoaXMubmFtZSArICc6ICcgKyBmb3JtYXRFcnJvcih0aGlzLCBjb21wYWN0KTtcbn07XG5cblxudmFyIGV4Y2VwdGlvbiA9IFlBTUxFeGNlcHRpb24kMTtcblxuLy8gZ2V0IHNuaXBwZXQgZm9yIGEgc2luZ2xlIGxpbmUsIHJlc3BlY3RpbmcgbWF4TGVuZ3RoXG5mdW5jdGlvbiBnZXRMaW5lKGJ1ZmZlciwgbGluZVN0YXJ0LCBsaW5lRW5kLCBwb3NpdGlvbiwgbWF4TGluZUxlbmd0aCkge1xuICB2YXIgaGVhZCA9ICcnO1xuICB2YXIgdGFpbCA9ICcnO1xuICB2YXIgbWF4SGFsZkxlbmd0aCA9IE1hdGguZmxvb3IobWF4TGluZUxlbmd0aCAvIDIpIC0gMTtcblxuICBpZiAocG9zaXRpb24gLSBsaW5lU3RhcnQgPiBtYXhIYWxmTGVuZ3RoKSB7XG4gICAgaGVhZCA9ICcgLi4uICc7XG4gICAgbGluZVN0YXJ0ID0gcG9zaXRpb24gLSBtYXhIYWxmTGVuZ3RoICsgaGVhZC5sZW5ndGg7XG4gIH1cblxuICBpZiAobGluZUVuZCAtIHBvc2l0aW9uID4gbWF4SGFsZkxlbmd0aCkge1xuICAgIHRhaWwgPSAnIC4uLic7XG4gICAgbGluZUVuZCA9IHBvc2l0aW9uICsgbWF4SGFsZkxlbmd0aCAtIHRhaWwubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdHI6IGhlYWQgKyBidWZmZXIuc2xpY2UobGluZVN0YXJ0LCBsaW5lRW5kKS5yZXBsYWNlKC9cXHQvZywgJ+KGkicpICsgdGFpbCxcbiAgICBwb3M6IHBvc2l0aW9uIC0gbGluZVN0YXJ0ICsgaGVhZC5sZW5ndGggLy8gcmVsYXRpdmUgcG9zaXRpb25cbiAgfTtcbn1cblxuXG5mdW5jdGlvbiBwYWRTdGFydChzdHJpbmcsIG1heCkge1xuICByZXR1cm4gY29tbW9uLnJlcGVhdCgnICcsIG1heCAtIHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufVxuXG5cbmZ1bmN0aW9uIG1ha2VTbmlwcGV0KG1hcmssIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyB8fCBudWxsKTtcblxuICBpZiAoIW1hcmsuYnVmZmVyKSByZXR1cm4gbnVsbDtcblxuICBpZiAoIW9wdGlvbnMubWF4TGVuZ3RoKSBvcHRpb25zLm1heExlbmd0aCA9IDc5O1xuICBpZiAodHlwZW9mIG9wdGlvbnMuaW5kZW50ICAgICAgIT09ICdudW1iZXInKSBvcHRpb25zLmluZGVudCAgICAgID0gMTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmxpbmVzQmVmb3JlICE9PSAnbnVtYmVyJykgb3B0aW9ucy5saW5lc0JlZm9yZSA9IDM7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5saW5lc0FmdGVyICAhPT0gJ251bWJlcicpIG9wdGlvbnMubGluZXNBZnRlciAgPSAyO1xuXG4gIHZhciByZSA9IC9cXHI/XFxufFxccnxcXDAvZztcbiAgdmFyIGxpbmVTdGFydHMgPSBbIDAgXTtcbiAgdmFyIGxpbmVFbmRzID0gW107XG4gIHZhciBtYXRjaDtcbiAgdmFyIGZvdW5kTGluZU5vID0gLTE7XG5cbiAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMobWFyay5idWZmZXIpKSkge1xuICAgIGxpbmVFbmRzLnB1c2gobWF0Y2guaW5kZXgpO1xuICAgIGxpbmVTdGFydHMucHVzaChtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG5cbiAgICBpZiAobWFyay5wb3NpdGlvbiA8PSBtYXRjaC5pbmRleCAmJiBmb3VuZExpbmVObyA8IDApIHtcbiAgICAgIGZvdW5kTGluZU5vID0gbGluZVN0YXJ0cy5sZW5ndGggLSAyO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmb3VuZExpbmVObyA8IDApIGZvdW5kTGluZU5vID0gbGluZVN0YXJ0cy5sZW5ndGggLSAxO1xuXG4gIHZhciByZXN1bHQgPSAnJywgaSwgbGluZTtcbiAgdmFyIGxpbmVOb0xlbmd0aCA9IE1hdGgubWluKG1hcmsubGluZSArIG9wdGlvbnMubGluZXNBZnRlciwgbGluZUVuZHMubGVuZ3RoKS50b1N0cmluZygpLmxlbmd0aDtcbiAgdmFyIG1heExpbmVMZW5ndGggPSBvcHRpb25zLm1heExlbmd0aCAtIChvcHRpb25zLmluZGVudCArIGxpbmVOb0xlbmd0aCArIDMpO1xuXG4gIGZvciAoaSA9IDE7IGkgPD0gb3B0aW9ucy5saW5lc0JlZm9yZTsgaSsrKSB7XG4gICAgaWYgKGZvdW5kTGluZU5vIC0gaSA8IDApIGJyZWFrO1xuICAgIGxpbmUgPSBnZXRMaW5lKFxuICAgICAgbWFyay5idWZmZXIsXG4gICAgICBsaW5lU3RhcnRzW2ZvdW5kTGluZU5vIC0gaV0sXG4gICAgICBsaW5lRW5kc1tmb3VuZExpbmVObyAtIGldLFxuICAgICAgbWFyay5wb3NpdGlvbiAtIChsaW5lU3RhcnRzW2ZvdW5kTGluZU5vXSAtIGxpbmVTdGFydHNbZm91bmRMaW5lTm8gLSBpXSksXG4gICAgICBtYXhMaW5lTGVuZ3RoXG4gICAgKTtcbiAgICByZXN1bHQgPSBjb21tb24ucmVwZWF0KCcgJywgb3B0aW9ucy5pbmRlbnQpICsgcGFkU3RhcnQoKG1hcmsubGluZSAtIGkgKyAxKS50b1N0cmluZygpLCBsaW5lTm9MZW5ndGgpICtcbiAgICAgICcgfCAnICsgbGluZS5zdHIgKyAnXFxuJyArIHJlc3VsdDtcbiAgfVxuXG4gIGxpbmUgPSBnZXRMaW5lKG1hcmsuYnVmZmVyLCBsaW5lU3RhcnRzW2ZvdW5kTGluZU5vXSwgbGluZUVuZHNbZm91bmRMaW5lTm9dLCBtYXJrLnBvc2l0aW9uLCBtYXhMaW5lTGVuZ3RoKTtcbiAgcmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJyAnLCBvcHRpb25zLmluZGVudCkgKyBwYWRTdGFydCgobWFyay5saW5lICsgMSkudG9TdHJpbmcoKSwgbGluZU5vTGVuZ3RoKSArXG4gICAgJyB8ICcgKyBsaW5lLnN0ciArICdcXG4nO1xuICByZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnLScsIG9wdGlvbnMuaW5kZW50ICsgbGluZU5vTGVuZ3RoICsgMyArIGxpbmUucG9zKSArICdeJyArICdcXG4nO1xuXG4gIGZvciAoaSA9IDE7IGkgPD0gb3B0aW9ucy5saW5lc0FmdGVyOyBpKyspIHtcbiAgICBpZiAoZm91bmRMaW5lTm8gKyBpID49IGxpbmVFbmRzLmxlbmd0aCkgYnJlYWs7XG4gICAgbGluZSA9IGdldExpbmUoXG4gICAgICBtYXJrLmJ1ZmZlcixcbiAgICAgIGxpbmVTdGFydHNbZm91bmRMaW5lTm8gKyBpXSxcbiAgICAgIGxpbmVFbmRzW2ZvdW5kTGluZU5vICsgaV0sXG4gICAgICBtYXJrLnBvc2l0aW9uIC0gKGxpbmVTdGFydHNbZm91bmRMaW5lTm9dIC0gbGluZVN0YXJ0c1tmb3VuZExpbmVObyArIGldKSxcbiAgICAgIG1heExpbmVMZW5ndGhcbiAgICApO1xuICAgIHJlc3VsdCArPSBjb21tb24ucmVwZWF0KCcgJywgb3B0aW9ucy5pbmRlbnQpICsgcGFkU3RhcnQoKG1hcmsubGluZSArIGkgKyAxKS50b1N0cmluZygpLCBsaW5lTm9MZW5ndGgpICtcbiAgICAgICcgfCAnICsgbGluZS5zdHIgKyAnXFxuJztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQucmVwbGFjZSgvXFxuJC8sICcnKTtcbn1cblxuXG52YXIgc25pcHBldCA9IG1ha2VTbmlwcGV0O1xuXG52YXIgVFlQRV9DT05TVFJVQ1RPUl9PUFRJT05TID0gW1xuICAna2luZCcsXG4gICdtdWx0aScsXG4gICdyZXNvbHZlJyxcbiAgJ2NvbnN0cnVjdCcsXG4gICdpbnN0YW5jZU9mJyxcbiAgJ3ByZWRpY2F0ZScsXG4gICdyZXByZXNlbnQnLFxuICAncmVwcmVzZW50TmFtZScsXG4gICdkZWZhdWx0U3R5bGUnLFxuICAnc3R5bGVBbGlhc2VzJ1xuXTtcblxudmFyIFlBTUxfTk9ERV9LSU5EUyA9IFtcbiAgJ3NjYWxhcicsXG4gICdzZXF1ZW5jZScsXG4gICdtYXBwaW5nJ1xuXTtcblxuZnVuY3Rpb24gY29tcGlsZVN0eWxlQWxpYXNlcyhtYXApIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gIGlmIChtYXAgIT09IG51bGwpIHtcbiAgICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICBtYXBbc3R5bGVdLmZvckVhY2goZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgICAgIHJlc3VsdFtTdHJpbmcoYWxpYXMpXSA9IHN0eWxlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBUeXBlJDEodGFnLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAoVFlQRV9DT05TVFJVQ1RPUl9PUFRJT05TLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdVbmtub3duIG9wdGlvbiBcIicgKyBuYW1lICsgJ1wiIGlzIG1ldCBpbiBkZWZpbml0aW9uIG9mIFwiJyArIHRhZyArICdcIiBZQU1MIHR5cGUuJyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBUT0RPOiBBZGQgdGFnIGZvcm1hdCBjaGVjay5cbiAgdGhpcy5vcHRpb25zICAgICAgID0gb3B0aW9uczsgLy8ga2VlcCBvcmlnaW5hbCBvcHRpb25zIGluIGNhc2UgdXNlciB3YW50cyB0byBleHRlbmQgdGhpcyB0eXBlIGxhdGVyXG4gIHRoaXMudGFnICAgICAgICAgICA9IHRhZztcbiAgdGhpcy5raW5kICAgICAgICAgID0gb3B0aW9uc1sna2luZCddICAgICAgICAgIHx8IG51bGw7XG4gIHRoaXMucmVzb2x2ZSAgICAgICA9IG9wdGlvbnNbJ3Jlc29sdmUnXSAgICAgICB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICB0aGlzLmNvbnN0cnVjdCAgICAgPSBvcHRpb25zWydjb25zdHJ1Y3QnXSAgICAgfHwgZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGE7IH07XG4gIHRoaXMuaW5zdGFuY2VPZiAgICA9IG9wdGlvbnNbJ2luc3RhbmNlT2YnXSAgICB8fCBudWxsO1xuICB0aGlzLnByZWRpY2F0ZSAgICAgPSBvcHRpb25zWydwcmVkaWNhdGUnXSAgICAgfHwgbnVsbDtcbiAgdGhpcy5yZXByZXNlbnQgICAgID0gb3B0aW9uc1sncmVwcmVzZW50J10gICAgIHx8IG51bGw7XG4gIHRoaXMucmVwcmVzZW50TmFtZSA9IG9wdGlvbnNbJ3JlcHJlc2VudE5hbWUnXSB8fCBudWxsO1xuICB0aGlzLmRlZmF1bHRTdHlsZSAgPSBvcHRpb25zWydkZWZhdWx0U3R5bGUnXSAgfHwgbnVsbDtcbiAgdGhpcy5tdWx0aSAgICAgICAgID0gb3B0aW9uc1snbXVsdGknXSAgICAgICAgIHx8IGZhbHNlO1xuICB0aGlzLnN0eWxlQWxpYXNlcyAgPSBjb21waWxlU3R5bGVBbGlhc2VzKG9wdGlvbnNbJ3N0eWxlQWxpYXNlcyddIHx8IG51bGwpO1xuXG4gIGlmIChZQU1MX05PREVfS0lORFMuaW5kZXhPZih0aGlzLmtpbmQpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBleGNlcHRpb24oJ1Vua25vd24ga2luZCBcIicgKyB0aGlzLmtpbmQgKyAnXCIgaXMgc3BlY2lmaWVkIGZvciBcIicgKyB0YWcgKyAnXCIgWUFNTCB0eXBlLicpO1xuICB9XG59XG5cbnZhciB0eXBlID0gVHlwZSQxO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4qL1xuXG5cblxuXG5cbmZ1bmN0aW9uIGNvbXBpbGVMaXN0KHNjaGVtYSwgbmFtZSkge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgc2NoZW1hW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbnRUeXBlKSB7XG4gICAgdmFyIG5ld0luZGV4ID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgIHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChwcmV2aW91c1R5cGUsIHByZXZpb3VzSW5kZXgpIHtcbiAgICAgIGlmIChwcmV2aW91c1R5cGUudGFnID09PSBjdXJyZW50VHlwZS50YWcgJiZcbiAgICAgICAgICBwcmV2aW91c1R5cGUua2luZCA9PT0gY3VycmVudFR5cGUua2luZCAmJlxuICAgICAgICAgIHByZXZpb3VzVHlwZS5tdWx0aSA9PT0gY3VycmVudFR5cGUubXVsdGkpIHtcblxuICAgICAgICBuZXdJbmRleCA9IHByZXZpb3VzSW5kZXg7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXN1bHRbbmV3SW5kZXhdID0gY3VycmVudFR5cGU7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gY29tcGlsZU1hcCgvKiBsaXN0cy4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBzY2FsYXI6IHt9LFxuICAgICAgICBzZXF1ZW5jZToge30sXG4gICAgICAgIG1hcHBpbmc6IHt9LFxuICAgICAgICBmYWxsYmFjazoge30sXG4gICAgICAgIG11bHRpOiB7XG4gICAgICAgICAgc2NhbGFyOiBbXSxcbiAgICAgICAgICBzZXF1ZW5jZTogW10sXG4gICAgICAgICAgbWFwcGluZzogW10sXG4gICAgICAgICAgZmFsbGJhY2s6IFtdXG4gICAgICAgIH1cbiAgICAgIH0sIGluZGV4LCBsZW5ndGg7XG5cbiAgZnVuY3Rpb24gY29sbGVjdFR5cGUodHlwZSkge1xuICAgIGlmICh0eXBlLm11bHRpKSB7XG4gICAgICByZXN1bHQubXVsdGlbdHlwZS5raW5kXS5wdXNoKHR5cGUpO1xuICAgICAgcmVzdWx0Lm11bHRpWydmYWxsYmFjayddLnB1c2godHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFt0eXBlLmtpbmRdW3R5cGUudGFnXSA9IHJlc3VsdFsnZmFsbGJhY2snXVt0eXBlLnRhZ10gPSB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIGFyZ3VtZW50c1tpbmRleF0uZm9yRWFjaChjb2xsZWN0VHlwZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBTY2hlbWEkMShkZWZpbml0aW9uKSB7XG4gIHJldHVybiB0aGlzLmV4dGVuZChkZWZpbml0aW9uKTtcbn1cblxuXG5TY2hlbWEkMS5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kKGRlZmluaXRpb24pIHtcbiAgdmFyIGltcGxpY2l0ID0gW107XG4gIHZhciBleHBsaWNpdCA9IFtdO1xuXG4gIGlmIChkZWZpbml0aW9uIGluc3RhbmNlb2YgdHlwZSkge1xuICAgIC8vIFNjaGVtYS5leHRlbmQodHlwZSlcbiAgICBleHBsaWNpdC5wdXNoKGRlZmluaXRpb24pO1xuXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkZWZpbml0aW9uKSkge1xuICAgIC8vIFNjaGVtYS5leHRlbmQoWyB0eXBlMSwgdHlwZTIsIC4uLiBdKVxuICAgIGV4cGxpY2l0ID0gZXhwbGljaXQuY29uY2F0KGRlZmluaXRpb24pO1xuXG4gIH0gZWxzZSBpZiAoZGVmaW5pdGlvbiAmJiAoQXJyYXkuaXNBcnJheShkZWZpbml0aW9uLmltcGxpY2l0KSB8fCBBcnJheS5pc0FycmF5KGRlZmluaXRpb24uZXhwbGljaXQpKSkge1xuICAgIC8vIFNjaGVtYS5leHRlbmQoeyBleHBsaWNpdDogWyB0eXBlMSwgdHlwZTIsIC4uLiBdLCBpbXBsaWNpdDogWyB0eXBlMSwgdHlwZTIsIC4uLiBdIH0pXG4gICAgaWYgKGRlZmluaXRpb24uaW1wbGljaXQpIGltcGxpY2l0ID0gaW1wbGljaXQuY29uY2F0KGRlZmluaXRpb24uaW1wbGljaXQpO1xuICAgIGlmIChkZWZpbml0aW9uLmV4cGxpY2l0KSBleHBsaWNpdCA9IGV4cGxpY2l0LmNvbmNhdChkZWZpbml0aW9uLmV4cGxpY2l0KTtcblxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBleGNlcHRpb24oJ1NjaGVtYS5leHRlbmQgYXJndW1lbnQgc2hvdWxkIGJlIGEgVHlwZSwgWyBUeXBlIF0sICcgK1xuICAgICAgJ29yIGEgc2NoZW1hIGRlZmluaXRpb24gKHsgaW1wbGljaXQ6IFsuLi5dLCBleHBsaWNpdDogWy4uLl0gfSknKTtcbiAgfVxuXG4gIGltcGxpY2l0LmZvckVhY2goZnVuY3Rpb24gKHR5cGUkMSkge1xuICAgIGlmICghKHR5cGUkMSBpbnN0YW5jZW9mIHR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdTcGVjaWZpZWQgbGlzdCBvZiBZQU1MIHR5cGVzIChvciBhIHNpbmdsZSBUeXBlIG9iamVjdCkgY29udGFpbnMgYSBub24tVHlwZSBvYmplY3QuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUkMS5sb2FkS2luZCAmJiB0eXBlJDEubG9hZEtpbmQgIT09ICdzY2FsYXInKSB7XG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdUaGVyZSBpcyBhIG5vbi1zY2FsYXIgdHlwZSBpbiB0aGUgaW1wbGljaXQgbGlzdCBvZiBhIHNjaGVtYS4gSW1wbGljaXQgcmVzb2x2aW5nIG9mIHN1Y2ggdHlwZXMgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSQxLm11bHRpKSB7XG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdUaGVyZSBpcyBhIG11bHRpIHR5cGUgaW4gdGhlIGltcGxpY2l0IGxpc3Qgb2YgYSBzY2hlbWEuIE11bHRpIHRhZ3MgY2FuIG9ubHkgYmUgbGlzdGVkIGFzIGV4cGxpY2l0LicpO1xuICAgIH1cbiAgfSk7XG5cbiAgZXhwbGljaXQuZm9yRWFjaChmdW5jdGlvbiAodHlwZSQxKSB7XG4gICAgaWYgKCEodHlwZSQxIGluc3RhbmNlb2YgdHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBleGNlcHRpb24oJ1NwZWNpZmllZCBsaXN0IG9mIFlBTUwgdHlwZXMgKG9yIGEgc2luZ2xlIFR5cGUgb2JqZWN0KSBjb250YWlucyBhIG5vbi1UeXBlIG9iamVjdC4nKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKFNjaGVtYSQxLnByb3RvdHlwZSk7XG5cbiAgcmVzdWx0LmltcGxpY2l0ID0gKHRoaXMuaW1wbGljaXQgfHwgW10pLmNvbmNhdChpbXBsaWNpdCk7XG4gIHJlc3VsdC5leHBsaWNpdCA9ICh0aGlzLmV4cGxpY2l0IHx8IFtdKS5jb25jYXQoZXhwbGljaXQpO1xuXG4gIHJlc3VsdC5jb21waWxlZEltcGxpY2l0ID0gY29tcGlsZUxpc3QocmVzdWx0LCAnaW1wbGljaXQnKTtcbiAgcmVzdWx0LmNvbXBpbGVkRXhwbGljaXQgPSBjb21waWxlTGlzdChyZXN1bHQsICdleHBsaWNpdCcpO1xuICByZXN1bHQuY29tcGlsZWRUeXBlTWFwICA9IGNvbXBpbGVNYXAocmVzdWx0LmNvbXBpbGVkSW1wbGljaXQsIHJlc3VsdC5jb21waWxlZEV4cGxpY2l0KTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG52YXIgc2NoZW1hID0gU2NoZW1hJDE7XG5cbnZhciBzdHIgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c3RyJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiAnJzsgfVxufSk7XG5cbnZhciBzZXEgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c2VxJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IFtdOyB9XG59KTtcblxudmFyIG1hcCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLCB7XG4gIGtpbmQ6ICdtYXBwaW5nJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiB7fTsgfVxufSk7XG5cbnZhciBmYWlsc2FmZSA9IG5ldyBzY2hlbWEoe1xuICBleHBsaWNpdDogW1xuICAgIHN0cixcbiAgICBzZXEsXG4gICAgbWFwXG4gIF1cbn0pO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE51bGwoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoO1xuXG4gIHJldHVybiAobWF4ID09PSAxICYmIGRhdGEgPT09ICd+JykgfHxcbiAgICAgICAgIChtYXggPT09IDQgJiYgKGRhdGEgPT09ICdudWxsJyB8fCBkYXRhID09PSAnTnVsbCcgfHwgZGF0YSA9PT0gJ05VTEwnKSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNOdWxsKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09PSBudWxsO1xufVxuXG52YXIgX251bGwgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bnVsbCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sTnVsbCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sTnVsbCxcbiAgcHJlZGljYXRlOiBpc051bGwsXG4gIHJlcHJlc2VudDoge1xuICAgIGNhbm9uaWNhbDogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ34nOyAgICB9LFxuICAgIGxvd2VyY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ251bGwnOyB9LFxuICAgIHVwcGVyY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ05VTEwnOyB9LFxuICAgIGNhbWVsY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ051bGwnOyB9LFxuICAgIGVtcHR5OiAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gJyc7ICAgICB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZSdcbn0pO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEJvb2xlYW4oZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aDtcblxuICByZXR1cm4gKG1heCA9PT0gNCAmJiAoZGF0YSA9PT0gJ3RydWUnIHx8IGRhdGEgPT09ICdUcnVlJyB8fCBkYXRhID09PSAnVFJVRScpKSB8fFxuICAgICAgICAgKG1heCA9PT0gNSAmJiAoZGF0YSA9PT0gJ2ZhbHNlJyB8fCBkYXRhID09PSAnRmFsc2UnIHx8IGRhdGEgPT09ICdGQUxTRScpKTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEJvb2xlYW4oZGF0YSkge1xuICByZXR1cm4gZGF0YSA9PT0gJ3RydWUnIHx8XG4gICAgICAgICBkYXRhID09PSAnVHJ1ZScgfHxcbiAgICAgICAgIGRhdGEgPT09ICdUUlVFJztcbn1cblxuZnVuY3Rpb24gaXNCb29sZWFuKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEJvb2xlYW5dJztcbn1cblxudmFyIGJvb2wgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sQm9vbGVhbixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sQm9vbGVhbixcbiAgcHJlZGljYXRlOiBpc0Jvb2xlYW4sXG4gIHJlcHJlc2VudDoge1xuICAgIGxvd2VyY2FzZTogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ID8gJ3RydWUnIDogJ2ZhbHNlJzsgfSxcbiAgICB1cHBlcmNhc2U6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIG9iamVjdCA/ICdUUlVFJyA6ICdGQUxTRSc7IH0sXG4gICAgY2FtZWxjYXNlOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgPyAnVHJ1ZScgOiAnRmFsc2UnOyB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZSdcbn0pO1xuXG5mdW5jdGlvbiBpc0hleENvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpIHx8XG4gICAgICAgICAoKDB4NDEvKiBBICovIDw9IGMpICYmIChjIDw9IDB4NDYvKiBGICovKSkgfHxcbiAgICAgICAgICgoMHg2MS8qIGEgKi8gPD0gYykgJiYgKGMgPD0gMHg2Ni8qIGYgKi8pKTtcbn1cblxuZnVuY3Rpb24gaXNPY3RDb2RlKGMpIHtcbiAgcmV0dXJuICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzNy8qIDcgKi8pKTtcbn1cblxuZnVuY3Rpb24gaXNEZWNDb2RlKGMpIHtcbiAgcmV0dXJuICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxJbnRlZ2VyKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGgsXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBoYXNEaWdpdHMgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIGlmICghbWF4KSByZXR1cm4gZmFsc2U7XG5cbiAgY2ggPSBkYXRhW2luZGV4XTtcblxuICAvLyBzaWduXG4gIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICBjaCA9IGRhdGFbKytpbmRleF07XG4gIH1cblxuICBpZiAoY2ggPT09ICcwJykge1xuICAgIC8vIDBcbiAgICBpZiAoaW5kZXggKyAxID09PSBtYXgpIHJldHVybiB0cnVlO1xuICAgIGNoID0gZGF0YVsrK2luZGV4XTtcblxuICAgIC8vIGJhc2UgMiwgYmFzZSA4LCBiYXNlIDE2XG5cbiAgICBpZiAoY2ggPT09ICdiJykge1xuICAgICAgLy8gYmFzZSAyXG4gICAgICBpbmRleCsrO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoY2ggIT09ICcwJyAmJiBjaCAhPT0gJzEnKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzRGlnaXRzICYmIGNoICE9PSAnXyc7XG4gICAgfVxuXG5cbiAgICBpZiAoY2ggPT09ICd4Jykge1xuICAgICAgLy8gYmFzZSAxNlxuICAgICAgaW5kZXgrKztcblxuICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChjaCA9PT0gJ18nKSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFpc0hleENvZGUoZGF0YS5jaGFyQ29kZUF0KGluZGV4KSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNEaWdpdHMgJiYgY2ggIT09ICdfJztcbiAgICB9XG5cblxuICAgIGlmIChjaCA9PT0gJ28nKSB7XG4gICAgICAvLyBiYXNlIDhcbiAgICAgIGluZGV4Kys7XG5cbiAgICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgICAgIGlmICghaXNPY3RDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzRGlnaXRzICYmIGNoICE9PSAnXyc7XG4gICAgfVxuICB9XG5cbiAgLy8gYmFzZSAxMCAoZXhjZXB0IDApXG5cbiAgLy8gdmFsdWUgc2hvdWxkIG5vdCBzdGFydCB3aXRoIGBfYDtcbiAgaWYgKGNoID09PSAnXycpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgIGlmIChjaCA9PT0gJ18nKSBjb250aW51ZTtcbiAgICBpZiAoIWlzRGVjQ29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICB9XG5cbiAgLy8gU2hvdWxkIGhhdmUgZGlnaXRzIGFuZCBzaG91bGQgbm90IGVuZCB3aXRoIGBfYFxuICBpZiAoIWhhc0RpZ2l0cyB8fCBjaCA9PT0gJ18nKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxJbnRlZ2VyKGRhdGEpIHtcbiAgdmFyIHZhbHVlID0gZGF0YSwgc2lnbiA9IDEsIGNoO1xuXG4gIGlmICh2YWx1ZS5pbmRleE9mKCdfJykgIT09IC0xKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9fL2csICcnKTtcbiAgfVxuXG4gIGNoID0gdmFsdWVbMF07XG5cbiAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgIGlmIChjaCA9PT0gJy0nKSBzaWduID0gLTE7XG4gICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgICBjaCA9IHZhbHVlWzBdO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSAnMCcpIHJldHVybiAwO1xuXG4gIGlmIChjaCA9PT0gJzAnKSB7XG4gICAgaWYgKHZhbHVlWzFdID09PSAnYicpIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIDIpO1xuICAgIGlmICh2YWx1ZVsxXSA9PT0gJ3gnKSByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCAxNik7XG4gICAgaWYgKHZhbHVlWzFdID09PSAnbycpIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIDgpO1xuICB9XG5cbiAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZSwgMTApO1xufVxuXG5mdW5jdGlvbiBpc0ludGVnZXIob2JqZWN0KSB7XG4gIHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJlxuICAgICAgICAgKG9iamVjdCAlIDEgPT09IDAgJiYgIWNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKTtcbn1cblxudmFyIGludCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEludGVnZXIsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEludGVnZXIsXG4gIHByZWRpY2F0ZTogaXNJbnRlZ2VyLFxuICByZXByZXNlbnQ6IHtcbiAgICBiaW5hcnk6ICAgICAgZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqID49IDAgPyAnMGInICsgb2JqLnRvU3RyaW5nKDIpIDogJy0wYicgKyBvYmoudG9TdHJpbmcoMikuc2xpY2UoMSk7IH0sXG4gICAgb2N0YWw6ICAgICAgIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiA+PSAwID8gJzBvJyAgKyBvYmoudG9TdHJpbmcoOCkgOiAnLTBvJyAgKyBvYmoudG9TdHJpbmcoOCkuc2xpY2UoMSk7IH0sXG4gICAgZGVjaW1hbDogICAgIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iai50b1N0cmluZygxMCk7IH0sXG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgIGhleGFkZWNpbWFsOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogPj0gMCA/ICcweCcgKyBvYmoudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgOiAgJy0weCcgKyBvYmoudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkuc2xpY2UoMSk7IH1cbiAgfSxcbiAgZGVmYXVsdFN0eWxlOiAnZGVjaW1hbCcsXG4gIHN0eWxlQWxpYXNlczoge1xuICAgIGJpbmFyeTogICAgICBbIDIsICAnYmluJyBdLFxuICAgIG9jdGFsOiAgICAgICBbIDgsICAnb2N0JyBdLFxuICAgIGRlY2ltYWw6ICAgICBbIDEwLCAnZGVjJyBdLFxuICAgIGhleGFkZWNpbWFsOiBbIDE2LCAnaGV4JyBdXG4gIH1cbn0pO1xuXG52YXIgWUFNTF9GTE9BVF9QQVRURVJOID0gbmV3IFJlZ0V4cChcbiAgLy8gMi41ZTQsIDIuNSBhbmQgaW50ZWdlcnNcbiAgJ14oPzpbLStdPyg/OlswLTldWzAtOV9dKikoPzpcXFxcLlswLTlfXSopPyg/OltlRV1bLStdP1swLTldKyk/JyArXG4gIC8vIC4yZTQsIC4yXG4gIC8vIHNwZWNpYWwgY2FzZSwgc2VlbXMgbm90IGZyb20gc3BlY1xuICAnfFxcXFwuWzAtOV9dKyg/OltlRV1bLStdP1swLTldKyk/JyArXG4gIC8vIC5pbmZcbiAgJ3xbLStdP1xcXFwuKD86aW5mfEluZnxJTkYpJyArXG4gIC8vIC5uYW5cbiAgJ3xcXFxcLig/Om5hbnxOYU58TkFOKSkkJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sRmxvYXQoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICghWUFNTF9GTE9BVF9QQVRURVJOLnRlc3QoZGF0YSkgfHxcbiAgICAgIC8vIFF1aWNrIGhhY2sgdG8gbm90IGFsbG93IGludGVnZXJzIGVuZCB3aXRoIGBfYFxuICAgICAgLy8gUHJvYmFibHkgc2hvdWxkIHVwZGF0ZSByZWdleHAgJiBjaGVjayBzcGVlZFxuICAgICAgZGF0YVtkYXRhLmxlbmd0aCAtIDFdID09PSAnXycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEZsb2F0KGRhdGEpIHtcbiAgdmFyIHZhbHVlLCBzaWduO1xuXG4gIHZhbHVlICA9IGRhdGEucmVwbGFjZSgvXy9nLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgc2lnbiAgID0gdmFsdWVbMF0gPT09ICctJyA/IC0xIDogMTtcblxuICBpZiAoJystJy5pbmRleE9mKHZhbHVlWzBdKSA+PSAwKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gJy5pbmYnKSB7XG4gICAgcmV0dXJuIChzaWduID09PSAxKSA/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnLm5hbicpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG4gIHJldHVybiBzaWduICogcGFyc2VGbG9hdCh2YWx1ZSwgMTApO1xufVxuXG5cbnZhciBTQ0lFTlRJRklDX1dJVEhPVVRfRE9UID0gL15bLStdP1swLTldK2UvO1xuXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sRmxvYXQob2JqZWN0LCBzdHlsZSkge1xuICB2YXIgcmVzO1xuXG4gIGlmIChpc05hTihvYmplY3QpKSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgY2FzZSAnbG93ZXJjYXNlJzogcmV0dXJuICcubmFuJztcbiAgICAgIGNhc2UgJ3VwcGVyY2FzZSc6IHJldHVybiAnLk5BTic7XG4gICAgICBjYXNlICdjYW1lbGNhc2UnOiByZXR1cm4gJy5OYU4nO1xuICAgIH1cbiAgfSBlbHNlIGlmIChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgPT09IG9iamVjdCkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgIGNhc2UgJ2xvd2VyY2FzZSc6IHJldHVybiAnLmluZic7XG4gICAgICBjYXNlICd1cHBlcmNhc2UnOiByZXR1cm4gJy5JTkYnO1xuICAgICAgY2FzZSAnY2FtZWxjYXNlJzogcmV0dXJuICcuSW5mJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZID09PSBvYmplY3QpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICBjYXNlICdsb3dlcmNhc2UnOiByZXR1cm4gJy0uaW5mJztcbiAgICAgIGNhc2UgJ3VwcGVyY2FzZSc6IHJldHVybiAnLS5JTkYnO1xuICAgICAgY2FzZSAnY2FtZWxjYXNlJzogcmV0dXJuICctLkluZic7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKSB7XG4gICAgcmV0dXJuICctMC4wJztcbiAgfVxuXG4gIHJlcyA9IG9iamVjdC50b1N0cmluZygxMCk7XG5cbiAgLy8gSlMgc3RyaW5naWZpZXIgY2FuIGJ1aWxkIHNjaWVudGlmaWMgZm9ybWF0IHdpdGhvdXQgZG90czogNWUtMTAwLFxuICAvLyB3aGlsZSBZQU1MIHJlcXVyZXMgZG90OiA1LmUtMTAwLiBGaXggaXQgd2l0aCBzaW1wbGUgaGFja1xuXG4gIHJldHVybiBTQ0lFTlRJRklDX1dJVEhPVVRfRE9ULnRlc3QocmVzKSA/IHJlcy5yZXBsYWNlKCdlJywgJy5lJykgOiByZXM7XG59XG5cbmZ1bmN0aW9uIGlzRmxvYXQob2JqZWN0KSB7XG4gIHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IE51bWJlcl0nKSAmJlxuICAgICAgICAgKG9iamVjdCAlIDEgIT09IDAgfHwgY29tbW9uLmlzTmVnYXRpdmVaZXJvKG9iamVjdCkpO1xufVxuXG52YXIgZmxvYXQgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEZsb2F0LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxGbG9hdCxcbiAgcHJlZGljYXRlOiBpc0Zsb2F0LFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxGbG9hdCxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG5cbnZhciBqc29uID0gZmFpbHNhZmUuZXh0ZW5kKHtcbiAgaW1wbGljaXQ6IFtcbiAgICBfbnVsbCxcbiAgICBib29sLFxuICAgIGludCxcbiAgICBmbG9hdFxuICBdXG59KTtcblxudmFyIGNvcmUgPSBqc29uO1xuXG52YXIgWUFNTF9EQVRFX1JFR0VYUCA9IG5ldyBSZWdFeHAoXG4gICdeKFswLTldWzAtOV1bMC05XVswLTldKScgICAgICAgICAgKyAvLyBbMV0geWVhclxuICAnLShbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzJdIG1vbnRoXG4gICctKFswLTldWzAtOV0pJCcpOyAgICAgICAgICAgICAgICAgICAvLyBbM10gZGF5XG5cbnZhciBZQU1MX1RJTUVTVEFNUF9SRUdFWFAgPSBuZXcgUmVnRXhwKFxuICAnXihbMC05XVswLTldWzAtOV1bMC05XSknICAgICAgICAgICsgLy8gWzFdIHllYXJcbiAgJy0oWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICArIC8vIFsyXSBtb250aFxuICAnLShbMC05XVswLTldPyknICAgICAgICAgICAgICAgICAgICsgLy8gWzNdIGRheVxuICAnKD86W1R0XXxbIFxcXFx0XSspJyAgICAgICAgICAgICAgICAgKyAvLyAuLi5cbiAgJyhbMC05XVswLTldPyknICAgICAgICAgICAgICAgICAgICArIC8vIFs0XSBob3VyXG4gICc6KFswLTldWzAtOV0pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNV0gbWludXRlXG4gICc6KFswLTldWzAtOV0pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNl0gc2Vjb25kXG4gICcoPzpcXFxcLihbMC05XSopKT8nICAgICAgICAgICAgICAgICArIC8vIFs3XSBmcmFjdGlvblxuICAnKD86WyBcXFxcdF0qKFp8KFstK10pKFswLTldWzAtOV0/KScgKyAvLyBbOF0gdHogWzldIHR6X3NpZ24gWzEwXSB0el9ob3VyXG4gICcoPzo6KFswLTldWzAtOV0pKT8pKT8kJyk7ICAgICAgICAgICAvLyBbMTFdIHR6X21pbnV0ZVxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbFRpbWVzdGFtcChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIGlmIChZQU1MX0RBVEVfUkVHRVhQLmV4ZWMoZGF0YSkgIT09IG51bGwpIHJldHVybiB0cnVlO1xuICBpZiAoWUFNTF9USU1FU1RBTVBfUkVHRVhQLmV4ZWMoZGF0YSkgIT09IG51bGwpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxUaW1lc3RhbXAoZGF0YSkge1xuICB2YXIgbWF0Y2gsIHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBmcmFjdGlvbiA9IDAsXG4gICAgICBkZWx0YSA9IG51bGwsIHR6X2hvdXIsIHR6X21pbnV0ZSwgZGF0ZTtcblxuICBtYXRjaCA9IFlBTUxfREFURV9SRUdFWFAuZXhlYyhkYXRhKTtcbiAgaWYgKG1hdGNoID09PSBudWxsKSBtYXRjaCA9IFlBTUxfVElNRVNUQU1QX1JFR0VYUC5leGVjKGRhdGEpO1xuXG4gIGlmIChtYXRjaCA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdEYXRlIHJlc29sdmUgZXJyb3InKTtcblxuICAvLyBtYXRjaDogWzFdIHllYXIgWzJdIG1vbnRoIFszXSBkYXlcblxuICB5ZWFyID0gKyhtYXRjaFsxXSk7XG4gIG1vbnRoID0gKyhtYXRjaFsyXSkgLSAxOyAvLyBKUyBtb250aCBzdGFydHMgd2l0aCAwXG4gIGRheSA9ICsobWF0Y2hbM10pO1xuXG4gIGlmICghbWF0Y2hbNF0pIHsgLy8gbm8gaG91clxuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5KSk7XG4gIH1cblxuICAvLyBtYXRjaDogWzRdIGhvdXIgWzVdIG1pbnV0ZSBbNl0gc2Vjb25kIFs3XSBmcmFjdGlvblxuXG4gIGhvdXIgPSArKG1hdGNoWzRdKTtcbiAgbWludXRlID0gKyhtYXRjaFs1XSk7XG4gIHNlY29uZCA9ICsobWF0Y2hbNl0pO1xuXG4gIGlmIChtYXRjaFs3XSkge1xuICAgIGZyYWN0aW9uID0gbWF0Y2hbN10uc2xpY2UoMCwgMyk7XG4gICAgd2hpbGUgKGZyYWN0aW9uLmxlbmd0aCA8IDMpIHsgLy8gbWlsbGktc2Vjb25kc1xuICAgICAgZnJhY3Rpb24gKz0gJzAnO1xuICAgIH1cbiAgICBmcmFjdGlvbiA9ICtmcmFjdGlvbjtcbiAgfVxuXG4gIC8vIG1hdGNoOiBbOF0gdHogWzldIHR6X3NpZ24gWzEwXSB0el9ob3VyIFsxMV0gdHpfbWludXRlXG5cbiAgaWYgKG1hdGNoWzldKSB7XG4gICAgdHpfaG91ciA9ICsobWF0Y2hbMTBdKTtcbiAgICB0el9taW51dGUgPSArKG1hdGNoWzExXSB8fCAwKTtcbiAgICBkZWx0YSA9ICh0el9ob3VyICogNjAgKyB0el9taW51dGUpICogNjAwMDA7IC8vIGRlbHRhIGluIG1pbGktc2Vjb25kc1xuICAgIGlmIChtYXRjaFs5XSA9PT0gJy0nKSBkZWx0YSA9IC1kZWx0YTtcbiAgfVxuXG4gIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgZnJhY3Rpb24pKTtcblxuICBpZiAoZGVsdGEpIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSAtIGRlbHRhKTtcblxuICByZXR1cm4gZGF0ZTtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbFRpbWVzdGFtcChvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgcmV0dXJuIG9iamVjdC50b0lTT1N0cmluZygpO1xufVxuXG52YXIgdGltZXN0YW1wID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sVGltZXN0YW1wLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxUaW1lc3RhbXAsXG4gIGluc3RhbmNlT2Y6IERhdGUsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbFRpbWVzdGFtcFxufSk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sTWVyZ2UoZGF0YSkge1xuICByZXR1cm4gZGF0YSA9PT0gJzw8JyB8fCBkYXRhID09PSBudWxsO1xufVxuXG52YXIgbWVyZ2UgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE1lcmdlXG59KTtcblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlKi9cblxuXG5cblxuXG4vLyBbIDY0LCA2NSwgNjYgXSAtPiBbIHBhZGRpbmcsIENSLCBMRiBdXG52YXIgQkFTRTY0X01BUCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVxcblxccic7XG5cblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxCaW5hcnkoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBjb2RlLCBpZHgsIGJpdGxlbiA9IDAsIG1heCA9IGRhdGEubGVuZ3RoLCBtYXAgPSBCQVNFNjRfTUFQO1xuXG4gIC8vIENvbnZlcnQgb25lIGJ5IG9uZS5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgY29kZSA9IG1hcC5pbmRleE9mKGRhdGEuY2hhckF0KGlkeCkpO1xuXG4gICAgLy8gU2tpcCBDUi9MRlxuICAgIGlmIChjb2RlID4gNjQpIGNvbnRpbnVlO1xuXG4gICAgLy8gRmFpbCBvbiBpbGxlZ2FsIGNoYXJhY3RlcnNcbiAgICBpZiAoY29kZSA8IDApIHJldHVybiBmYWxzZTtcblxuICAgIGJpdGxlbiArPSA2O1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgYXJlIGFueSBiaXRzIGxlZnQsIHNvdXJjZSB3YXMgY29ycnVwdGVkXG4gIHJldHVybiAoYml0bGVuICUgOCkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxCaW5hcnkoZGF0YSkge1xuICB2YXIgaWR4LCB0YWlsYml0cyxcbiAgICAgIGlucHV0ID0gZGF0YS5yZXBsYWNlKC9bXFxyXFxuPV0vZywgJycpLCAvLyByZW1vdmUgQ1IvTEYgJiBwYWRkaW5nIHRvIHNpbXBsaWZ5IHNjYW5cbiAgICAgIG1heCA9IGlucHV0Lmxlbmd0aCxcbiAgICAgIG1hcCA9IEJBU0U2NF9NQVAsXG4gICAgICBiaXRzID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIC8vIENvbGxlY3QgYnkgNio0IGJpdHMgKDMgYnl0ZXMpXG5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgaWYgKChpZHggJSA0ID09PSAwKSAmJiBpZHgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDE2KSAmIDB4RkYpO1xuICAgICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gOCkgJiAweEZGKTtcbiAgICAgIHJlc3VsdC5wdXNoKGJpdHMgJiAweEZGKTtcbiAgICB9XG5cbiAgICBiaXRzID0gKGJpdHMgPDwgNikgfCBtYXAuaW5kZXhPZihpbnB1dC5jaGFyQXQoaWR4KSk7XG4gIH1cblxuICAvLyBEdW1wIHRhaWxcblxuICB0YWlsYml0cyA9IChtYXggJSA0KSAqIDY7XG5cbiAgaWYgKHRhaWxiaXRzID09PSAwKSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMTYpICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gOCkgJiAweEZGKTtcbiAgICByZXN1bHQucHVzaChiaXRzICYgMHhGRik7XG4gIH0gZWxzZSBpZiAodGFpbGJpdHMgPT09IDE4KSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMTApICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMikgJiAweEZGKTtcbiAgfSBlbHNlIGlmICh0YWlsYml0cyA9PT0gMTIpIHtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiA0KSAmIDB4RkYpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxCaW5hcnkob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHZhciByZXN1bHQgPSAnJywgYml0cyA9IDAsIGlkeCwgdGFpbCxcbiAgICAgIG1heCA9IG9iamVjdC5sZW5ndGgsXG4gICAgICBtYXAgPSBCQVNFNjRfTUFQO1xuXG4gIC8vIENvbnZlcnQgZXZlcnkgdGhyZWUgYnl0ZXMgdG8gNCBBU0NJSSBjaGFyYWN0ZXJzLlxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGlmICgoaWR4ICUgMyA9PT0gMCkgJiYgaWR4KSB7XG4gICAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDE4KSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxMikgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNikgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICAgIH1cblxuICAgIGJpdHMgPSAoYml0cyA8PCA4KSArIG9iamVjdFtpZHhdO1xuICB9XG5cbiAgLy8gRHVtcCB0YWlsXG5cbiAgdGFpbCA9IG1heCAlIDM7XG5cbiAgaWYgKHRhaWwgPT09IDApIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDE4KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA2KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICB9IGVsc2UgaWYgKHRhaWwgPT09IDIpIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDEwKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzIDw8IDIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gIH0gZWxzZSBpZiAodGFpbCA9PT0gMSkge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzIDw8IDQpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc0JpbmFyeShvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAgJ1tvYmplY3QgVWludDhBcnJheV0nO1xufVxuXG52YXIgYmluYXJ5ID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeScsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sQmluYXJ5LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxCaW5hcnksXG4gIHByZWRpY2F0ZTogaXNCaW5hcnksXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbEJpbmFyeVxufSk7XG5cbnZhciBfaGFzT3duUHJvcGVydHkkMyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX3RvU3RyaW5nJDIgICAgICAgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE9tYXAoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIG9iamVjdEtleXMgPSBbXSwgaW5kZXgsIGxlbmd0aCwgcGFpciwgcGFpcktleSwgcGFpckhhc0tleSxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG4gICAgcGFpckhhc0tleSA9IGZhbHNlO1xuXG4gICAgaWYgKF90b1N0cmluZyQyLmNhbGwocGFpcikgIT09ICdbb2JqZWN0IE9iamVjdF0nKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHBhaXJLZXkgaW4gcGFpcikge1xuICAgICAgaWYgKF9oYXNPd25Qcm9wZXJ0eSQzLmNhbGwocGFpciwgcGFpcktleSkpIHtcbiAgICAgICAgaWYgKCFwYWlySGFzS2V5KSBwYWlySGFzS2V5ID0gdHJ1ZTtcbiAgICAgICAgZWxzZSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYWlySGFzS2V5KSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAob2JqZWN0S2V5cy5pbmRleE9mKHBhaXJLZXkpID09PSAtMSkgb2JqZWN0S2V5cy5wdXNoKHBhaXJLZXkpO1xuICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxPbWFwKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDogW107XG59XG5cbnZhciBvbWFwID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sT21hcCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sT21hcFxufSk7XG5cbnZhciBfdG9TdHJpbmckMSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sUGFpcnMoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIGluZGV4LCBsZW5ndGgsIHBhaXIsIGtleXMsIHJlc3VsdCxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgcmVzdWx0ID0gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuXG4gICAgaWYgKF90b1N0cmluZyQxLmNhbGwocGFpcikgIT09ICdbb2JqZWN0IE9iamVjdF0nKSByZXR1cm4gZmFsc2U7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMocGFpcik7XG5cbiAgICBpZiAoa2V5cy5sZW5ndGggIT09IDEpIHJldHVybiBmYWxzZTtcblxuICAgIHJlc3VsdFtpbmRleF0gPSBbIGtleXNbMF0sIHBhaXJba2V5c1swXV0gXTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sUGFpcnMoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIFtdO1xuXG4gIHZhciBpbmRleCwgbGVuZ3RoLCBwYWlyLCBrZXlzLCByZXN1bHQsXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIHJlc3VsdCA9IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhwYWlyKTtcblxuICAgIHJlc3VsdFtpbmRleF0gPSBbIGtleXNbMF0sIHBhaXJba2V5c1swXV0gXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBwYWlycyA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycycsIHtcbiAga2luZDogJ3NlcXVlbmNlJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxQYWlycyxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sUGFpcnNcbn0pO1xuXG52YXIgX2hhc093blByb3BlcnR5JDIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbFNldChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIga2V5LCBvYmplY3QgPSBkYXRhO1xuXG4gIGZvciAoa2V5IGluIG9iamVjdCkge1xuICAgIGlmIChfaGFzT3duUHJvcGVydHkkMi5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgaWYgKG9iamVjdFtrZXldICE9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxTZXQoZGF0YSkge1xuICByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiB7fTtcbn1cblxudmFyIHNldCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnLCB7XG4gIGtpbmQ6ICdtYXBwaW5nJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxTZXQsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbFNldFxufSk7XG5cbnZhciBfZGVmYXVsdCA9IGNvcmUuZXh0ZW5kKHtcbiAgaW1wbGljaXQ6IFtcbiAgICB0aW1lc3RhbXAsXG4gICAgbWVyZ2VcbiAgXSxcbiAgZXhwbGljaXQ6IFtcbiAgICBiaW5hcnksXG4gICAgb21hcCxcbiAgICBwYWlycyxcbiAgICBzZXRcbiAgXVxufSk7XG5cbi8qZXNsaW50LWRpc2FibGUgbWF4LWxlbixuby11c2UtYmVmb3JlLWRlZmluZSovXG5cblxuXG5cblxuXG5cbnZhciBfaGFzT3duUHJvcGVydHkkMSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cblxudmFyIENPTlRFWFRfRkxPV19JTiAgID0gMTtcbnZhciBDT05URVhUX0ZMT1dfT1VUICA9IDI7XG52YXIgQ09OVEVYVF9CTE9DS19JTiAgPSAzO1xudmFyIENPTlRFWFRfQkxPQ0tfT1VUID0gNDtcblxuXG52YXIgQ0hPTVBJTkdfQ0xJUCAgPSAxO1xudmFyIENIT01QSU5HX1NUUklQID0gMjtcbnZhciBDSE9NUElOR19LRUVQICA9IDM7XG5cblxudmFyIFBBVFRFUk5fTk9OX1BSSU5UQUJMRSAgICAgICAgID0gL1tcXHgwMC1cXHgwOFxceDBCXFx4MENcXHgwRS1cXHgxRlxceDdGLVxceDg0XFx4ODYtXFx4OUZcXHVGRkZFXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vO1xudmFyIFBBVFRFUk5fTk9OX0FTQ0lJX0xJTkVfQlJFQUtTID0gL1tcXHg4NVxcdTIwMjhcXHUyMDI5XS87XG52YXIgUEFUVEVSTl9GTE9XX0lORElDQVRPUlMgICAgICAgPSAvWyxcXFtcXF1cXHtcXH1dLztcbnZhciBQQVRURVJOX1RBR19IQU5ETEUgICAgICAgICAgICA9IC9eKD86IXwhIXwhW2EtelxcLV0rISkkL2k7XG52YXIgUEFUVEVSTl9UQUdfVVJJICAgICAgICAgICAgICAgPSAvXig/OiF8W14sXFxbXFxdXFx7XFx9XSkoPzolWzAtOWEtZl17Mn18WzAtOWEtelxcLSM7XFwvXFw/OkAmPVxcK1xcJCxfXFwuIX5cXConXFwoXFwpXFxbXFxdXSkqJC9pO1xuXG5cbmZ1bmN0aW9uIF9jbGFzcyhvYmopIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopOyB9XG5cbmZ1bmN0aW9uIGlzX0VPTChjKSB7XG4gIHJldHVybiAoYyA9PT0gMHgwQS8qIExGICovKSB8fCAoYyA9PT0gMHgwRC8qIENSICovKTtcbn1cblxuZnVuY3Rpb24gaXNfV0hJVEVfU1BBQ0UoYykge1xuICByZXR1cm4gKGMgPT09IDB4MDkvKiBUYWIgKi8pIHx8IChjID09PSAweDIwLyogU3BhY2UgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19XU19PUl9FT0woYykge1xuICByZXR1cm4gKGMgPT09IDB4MDkvKiBUYWIgKi8pIHx8XG4gICAgICAgICAoYyA9PT0gMHgyMC8qIFNwYWNlICovKSB8fFxuICAgICAgICAgKGMgPT09IDB4MEEvKiBMRiAqLykgfHxcbiAgICAgICAgIChjID09PSAweDBELyogQ1IgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19GTE9XX0lORElDQVRPUihjKSB7XG4gIHJldHVybiBjID09PSAweDJDLyogLCAqLyB8fFxuICAgICAgICAgYyA9PT0gMHg1Qi8qIFsgKi8gfHxcbiAgICAgICAgIGMgPT09IDB4NUQvKiBdICovIHx8XG4gICAgICAgICBjID09PSAweDdCLyogeyAqLyB8fFxuICAgICAgICAgYyA9PT0gMHg3RC8qIH0gKi87XG59XG5cbmZ1bmN0aW9uIGZyb21IZXhDb2RlKGMpIHtcbiAgdmFyIGxjO1xuXG4gIGlmICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB7XG4gICAgcmV0dXJuIGMgLSAweDMwO1xuICB9XG5cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlKi9cbiAgbGMgPSBjIHwgMHgyMDtcblxuICBpZiAoKDB4NjEvKiBhICovIDw9IGxjKSAmJiAobGMgPD0gMHg2Ni8qIGYgKi8pKSB7XG4gICAgcmV0dXJuIGxjIC0gMHg2MSArIDEwO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVkSGV4TGVuKGMpIHtcbiAgaWYgKGMgPT09IDB4NzgvKiB4ICovKSB7IHJldHVybiAyOyB9XG4gIGlmIChjID09PSAweDc1LyogdSAqLykgeyByZXR1cm4gNDsgfVxuICBpZiAoYyA9PT0gMHg1NS8qIFUgKi8pIHsgcmV0dXJuIDg7IH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGZyb21EZWNpbWFsQ29kZShjKSB7XG4gIGlmICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB7XG4gICAgcmV0dXJuIGMgLSAweDMwO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFc2NhcGVTZXF1ZW5jZShjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuICByZXR1cm4gKGMgPT09IDB4MzAvKiAwICovKSA/ICdcXHgwMCcgOlxuICAgICAgICAoYyA9PT0gMHg2MS8qIGEgKi8pID8gJ1xceDA3JyA6XG4gICAgICAgIChjID09PSAweDYyLyogYiAqLykgPyAnXFx4MDgnIDpcbiAgICAgICAgKGMgPT09IDB4NzQvKiB0ICovKSA/ICdcXHgwOScgOlxuICAgICAgICAoYyA9PT0gMHgwOS8qIFRhYiAqLykgPyAnXFx4MDknIDpcbiAgICAgICAgKGMgPT09IDB4NkUvKiBuICovKSA/ICdcXHgwQScgOlxuICAgICAgICAoYyA9PT0gMHg3Ni8qIHYgKi8pID8gJ1xceDBCJyA6XG4gICAgICAgIChjID09PSAweDY2LyogZiAqLykgPyAnXFx4MEMnIDpcbiAgICAgICAgKGMgPT09IDB4NzIvKiByICovKSA/ICdcXHgwRCcgOlxuICAgICAgICAoYyA9PT0gMHg2NS8qIGUgKi8pID8gJ1xceDFCJyA6XG4gICAgICAgIChjID09PSAweDIwLyogU3BhY2UgKi8pID8gJyAnIDpcbiAgICAgICAgKGMgPT09IDB4MjIvKiBcIiAqLykgPyAnXFx4MjInIDpcbiAgICAgICAgKGMgPT09IDB4MkYvKiAvICovKSA/ICcvJyA6XG4gICAgICAgIChjID09PSAweDVDLyogXFwgKi8pID8gJ1xceDVDJyA6XG4gICAgICAgIChjID09PSAweDRFLyogTiAqLykgPyAnXFx4ODUnIDpcbiAgICAgICAgKGMgPT09IDB4NUYvKiBfICovKSA/ICdcXHhBMCcgOlxuICAgICAgICAoYyA9PT0gMHg0Qy8qIEwgKi8pID8gJ1xcdTIwMjgnIDpcbiAgICAgICAgKGMgPT09IDB4NTAvKiBQICovKSA/ICdcXHUyMDI5JyA6ICcnO1xufVxuXG5mdW5jdGlvbiBjaGFyRnJvbUNvZGVwb2ludChjKSB7XG4gIGlmIChjIDw9IDB4RkZGRikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICB9XG4gIC8vIEVuY29kZSBVVEYtMTYgc3Vycm9nYXRlIHBhaXJcbiAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTE2I0NvZGVfcG9pbnRzX1UuMkIwMTAwMDBfdG9fVS4yQjEwRkZGRlxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAoKGMgLSAweDAxMDAwMCkgPj4gMTApICsgMHhEODAwLFxuICAgICgoYyAtIDB4MDEwMDAwKSAmIDB4MDNGRikgKyAweERDMDBcbiAgKTtcbn1cblxudmFyIHNpbXBsZUVzY2FwZUNoZWNrID0gbmV3IEFycmF5KDI1Nik7IC8vIGludGVnZXIsIGZvciBmYXN0IGFjY2Vzc1xudmFyIHNpbXBsZUVzY2FwZU1hcCA9IG5ldyBBcnJheSgyNTYpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICBzaW1wbGVFc2NhcGVDaGVja1tpXSA9IHNpbXBsZUVzY2FwZVNlcXVlbmNlKGkpID8gMSA6IDA7XG4gIHNpbXBsZUVzY2FwZU1hcFtpXSA9IHNpbXBsZUVzY2FwZVNlcXVlbmNlKGkpO1xufVxuXG5cbmZ1bmN0aW9uIFN0YXRlJDEoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdGhpcy5pbnB1dCA9IGlucHV0O1xuXG4gIHRoaXMuZmlsZW5hbWUgID0gb3B0aW9uc1snZmlsZW5hbWUnXSAgfHwgbnVsbDtcbiAgdGhpcy5zY2hlbWEgICAgPSBvcHRpb25zWydzY2hlbWEnXSAgICB8fCBfZGVmYXVsdDtcbiAgdGhpcy5vbldhcm5pbmcgPSBvcHRpb25zWydvbldhcm5pbmcnXSB8fCBudWxsO1xuICAvLyAoSGlkZGVuKSBSZW1vdmU/IG1ha2VzIHRoZSBsb2FkZXIgdG8gZXhwZWN0IFlBTUwgMS4xIGRvY3VtZW50c1xuICAvLyBpZiBzdWNoIGRvY3VtZW50cyBoYXZlIG5vIGV4cGxpY2l0ICVZQU1MIGRpcmVjdGl2ZVxuICB0aGlzLmxlZ2FjeSAgICA9IG9wdGlvbnNbJ2xlZ2FjeSddICAgIHx8IGZhbHNlO1xuXG4gIHRoaXMuanNvbiAgICAgID0gb3B0aW9uc1snanNvbiddICAgICAgfHwgZmFsc2U7XG4gIHRoaXMubGlzdGVuZXIgID0gb3B0aW9uc1snbGlzdGVuZXInXSAgfHwgbnVsbDtcblxuICB0aGlzLmltcGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEltcGxpY2l0O1xuICB0aGlzLnR5cGVNYXAgICAgICAgPSB0aGlzLnNjaGVtYS5jb21waWxlZFR5cGVNYXA7XG5cbiAgdGhpcy5sZW5ndGggICAgID0gaW5wdXQubGVuZ3RoO1xuICB0aGlzLnBvc2l0aW9uICAgPSAwO1xuICB0aGlzLmxpbmUgICAgICAgPSAwO1xuICB0aGlzLmxpbmVTdGFydCAgPSAwO1xuICB0aGlzLmxpbmVJbmRlbnQgPSAwO1xuXG4gIC8vIHBvc2l0aW9uIG9mIGZpcnN0IGxlYWRpbmcgdGFiIGluIHRoZSBjdXJyZW50IGxpbmUsXG4gIC8vIHVzZWQgdG8gbWFrZSBzdXJlIHRoZXJlIGFyZSBubyB0YWJzIGluIHRoZSBpbmRlbnRhdGlvblxuICB0aGlzLmZpcnN0VGFiSW5MaW5lID0gLTE7XG5cbiAgdGhpcy5kb2N1bWVudHMgPSBbXTtcblxuICAvKlxuICB0aGlzLnZlcnNpb247XG4gIHRoaXMuY2hlY2tMaW5lQnJlYWtzO1xuICB0aGlzLnRhZ01hcDtcbiAgdGhpcy5hbmNob3JNYXA7XG4gIHRoaXMudGFnO1xuICB0aGlzLmFuY2hvcjtcbiAgdGhpcy5raW5kO1xuICB0aGlzLnJlc3VsdDsqL1xuXG59XG5cblxuZnVuY3Rpb24gZ2VuZXJhdGVFcnJvcihzdGF0ZSwgbWVzc2FnZSkge1xuICB2YXIgbWFyayA9IHtcbiAgICBuYW1lOiAgICAgc3RhdGUuZmlsZW5hbWUsXG4gICAgYnVmZmVyOiAgIHN0YXRlLmlucHV0LnNsaWNlKDAsIC0xKSwgLy8gb21pdCB0cmFpbGluZyBcXDBcbiAgICBwb3NpdGlvbjogc3RhdGUucG9zaXRpb24sXG4gICAgbGluZTogICAgIHN0YXRlLmxpbmUsXG4gICAgY29sdW1uOiAgIHN0YXRlLnBvc2l0aW9uIC0gc3RhdGUubGluZVN0YXJ0XG4gIH07XG5cbiAgbWFyay5zbmlwcGV0ID0gc25pcHBldChtYXJrKTtcblxuICByZXR1cm4gbmV3IGV4Y2VwdGlvbihtZXNzYWdlLCBtYXJrKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dFcnJvcihzdGF0ZSwgbWVzc2FnZSkge1xuICB0aHJvdyBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dXYXJuaW5nKHN0YXRlLCBtZXNzYWdlKSB7XG4gIGlmIChzdGF0ZS5vbldhcm5pbmcpIHtcbiAgICBzdGF0ZS5vbldhcm5pbmcuY2FsbChudWxsLCBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKSk7XG4gIH1cbn1cblxuXG52YXIgZGlyZWN0aXZlSGFuZGxlcnMgPSB7XG5cbiAgWUFNTDogZnVuY3Rpb24gaGFuZGxlWWFtbERpcmVjdGl2ZShzdGF0ZSwgbmFtZSwgYXJncykge1xuXG4gICAgdmFyIG1hdGNoLCBtYWpvciwgbWlub3I7XG5cbiAgICBpZiAoc3RhdGUudmVyc2lvbiAhPT0gbnVsbCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mICVZQU1MIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ1lBTUwgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSBvbmUgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBtYXRjaCA9IC9eKFswLTldKylcXC4oWzAtOV0rKSQvLmV4ZWMoYXJnc1swXSk7XG5cbiAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIGFyZ3VtZW50IG9mIHRoZSBZQU1MIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIG1ham9yID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICBtaW5vciA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCk7XG5cbiAgICBpZiAobWFqb3IgIT09IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgIH1cblxuICAgIHN0YXRlLnZlcnNpb24gPSBhcmdzWzBdO1xuICAgIHN0YXRlLmNoZWNrTGluZUJyZWFrcyA9IChtaW5vciA8IDIpO1xuXG4gICAgaWYgKG1pbm9yICE9PSAxICYmIG1pbm9yICE9PSAyKSB7XG4gICAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICd1bnN1cHBvcnRlZCBZQU1MIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50Jyk7XG4gICAgfVxuICB9LFxuXG4gIFRBRzogZnVuY3Rpb24gaGFuZGxlVGFnRGlyZWN0aXZlKHN0YXRlLCBuYW1lLCBhcmdzKSB7XG5cbiAgICB2YXIgaGFuZGxlLCBwcmVmaXg7XG5cbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdUQUcgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSB0d28gYXJndW1lbnRzJyk7XG4gICAgfVxuXG4gICAgaGFuZGxlID0gYXJnc1swXTtcbiAgICBwcmVmaXggPSBhcmdzWzFdO1xuXG4gICAgaWYgKCFQQVRURVJOX1RBR19IQU5ETEUudGVzdChoYW5kbGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCB0YWcgaGFuZGxlIChmaXJzdCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBpZiAoX2hhc093blByb3BlcnR5JDEuY2FsbChzdGF0ZS50YWdNYXAsIGhhbmRsZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0aGVyZSBpcyBhIHByZXZpb3VzbHkgZGVjbGFyZWQgc3VmZml4IGZvciBcIicgKyBoYW5kbGUgKyAnXCIgdGFnIGhhbmRsZScpO1xuICAgIH1cblxuICAgIGlmICghUEFUVEVSTl9UQUdfVVJJLnRlc3QocHJlZml4KSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2lsbC1mb3JtZWQgdGFnIHByZWZpeCAoc2Vjb25kIGFyZ3VtZW50KSBvZiB0aGUgVEFHIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBwcmVmaXggPSBkZWNvZGVVUklDb21wb25lbnQocHJlZml4KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgcHJlZml4IGlzIG1hbGZvcm1lZDogJyArIHByZWZpeCk7XG4gICAgfVxuXG4gICAgc3RhdGUudGFnTWFwW2hhbmRsZV0gPSBwcmVmaXg7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gY2FwdHVyZVNlZ21lbnQoc3RhdGUsIHN0YXJ0LCBlbmQsIGNoZWNrSnNvbikge1xuICB2YXIgX3Bvc2l0aW9uLCBfbGVuZ3RoLCBfY2hhcmFjdGVyLCBfcmVzdWx0O1xuXG4gIGlmIChzdGFydCA8IGVuZCkge1xuICAgIF9yZXN1bHQgPSBzdGF0ZS5pbnB1dC5zbGljZShzdGFydCwgZW5kKTtcblxuICAgIGlmIChjaGVja0pzb24pIHtcbiAgICAgIGZvciAoX3Bvc2l0aW9uID0gMCwgX2xlbmd0aCA9IF9yZXN1bHQubGVuZ3RoOyBfcG9zaXRpb24gPCBfbGVuZ3RoOyBfcG9zaXRpb24gKz0gMSkge1xuICAgICAgICBfY2hhcmFjdGVyID0gX3Jlc3VsdC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG4gICAgICAgIGlmICghKF9jaGFyYWN0ZXIgPT09IDB4MDkgfHxcbiAgICAgICAgICAgICAgKDB4MjAgPD0gX2NoYXJhY3RlciAmJiBfY2hhcmFjdGVyIDw9IDB4MTBGRkZGKSkpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgdmFsaWQgSlNPTiBjaGFyYWN0ZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoUEFUVEVSTl9OT05fUFJJTlRBQkxFLnRlc3QoX3Jlc3VsdCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0aGUgc3RyZWFtIGNvbnRhaW5zIG5vbi1wcmludGFibGUgY2hhcmFjdGVycycpO1xuICAgIH1cblxuICAgIHN0YXRlLnJlc3VsdCArPSBfcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlTWFwcGluZ3Moc3RhdGUsIGRlc3RpbmF0aW9uLCBzb3VyY2UsIG92ZXJyaWRhYmxlS2V5cykge1xuICB2YXIgc291cmNlS2V5cywga2V5LCBpbmRleCwgcXVhbnRpdHk7XG5cbiAgaWYgKCFjb21tb24uaXNPYmplY3Qoc291cmNlKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW5ub3QgbWVyZ2UgbWFwcGluZ3M7IHRoZSBwcm92aWRlZCBzb3VyY2Ugb2JqZWN0IGlzIHVuYWNjZXB0YWJsZScpO1xuICB9XG5cbiAgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgZm9yIChpbmRleCA9IDAsIHF1YW50aXR5ID0gc291cmNlS2V5cy5sZW5ndGg7IGluZGV4IDwgcXVhbnRpdHk7IGluZGV4ICs9IDEpIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2luZGV4XTtcblxuICAgIGlmICghX2hhc093blByb3BlcnR5JDEuY2FsbChkZXN0aW5hdGlvbiwga2V5KSkge1xuICAgICAgZGVzdGluYXRpb25ba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgb3ZlcnJpZGFibGVLZXlzW2tleV0gPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlLFxuICBzdGFydExpbmUsIHN0YXJ0TGluZVN0YXJ0LCBzdGFydFBvcykge1xuXG4gIHZhciBpbmRleCwgcXVhbnRpdHk7XG5cbiAgLy8gVGhlIG91dHB1dCBpcyBhIHBsYWluIG9iamVjdCBoZXJlLCBzbyBrZXlzIGNhbiBvbmx5IGJlIHN0cmluZ3MuXG4gIC8vIFdlIG5lZWQgdG8gY29udmVydCBrZXlOb2RlIHRvIGEgc3RyaW5nLCBidXQgZG9pbmcgc28gY2FuIGhhbmcgdGhlIHByb2Nlc3NcbiAgLy8gKGRlZXBseSBuZXN0ZWQgYXJyYXlzIHRoYXQgZXhwbG9kZSBleHBvbmVudGlhbGx5IHVzaW5nIGFsaWFzZXMpLlxuICBpZiAoQXJyYXkuaXNBcnJheShrZXlOb2RlKSkge1xuICAgIGtleU5vZGUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChrZXlOb2RlKTtcblxuICAgIGZvciAoaW5kZXggPSAwLCBxdWFudGl0eSA9IGtleU5vZGUubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXlOb2RlW2luZGV4XSkpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25lc3RlZCBhcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW5zaWRlIGtleXMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBrZXlOb2RlID09PSAnb2JqZWN0JyAmJiBfY2xhc3Moa2V5Tm9kZVtpbmRleF0pID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICBrZXlOb2RlW2luZGV4XSA9ICdbb2JqZWN0IE9iamVjdF0nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEF2b2lkIGNvZGUgZXhlY3V0aW9uIGluIGxvYWQoKSB2aWEgdG9TdHJpbmcgcHJvcGVydHlcbiAgLy8gKHN0aWxsIHVzZSBpdHMgb3duIHRvU3RyaW5nIGZvciBhcnJheXMsIHRpbWVzdGFtcHMsXG4gIC8vIGFuZCB3aGF0ZXZlciB1c2VyIHNjaGVtYSBleHRlbnNpb25zIGhhcHBlbiB0byBoYXZlIEBAdG9TdHJpbmdUYWcpXG4gIGlmICh0eXBlb2Yga2V5Tm9kZSA9PT0gJ29iamVjdCcgJiYgX2NsYXNzKGtleU5vZGUpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIGtleU5vZGUgPSAnW29iamVjdCBPYmplY3RdJztcbiAgfVxuXG5cbiAga2V5Tm9kZSA9IFN0cmluZyhrZXlOb2RlKTtcblxuICBpZiAoX3Jlc3VsdCA9PT0gbnVsbCkge1xuICAgIF9yZXN1bHQgPSB7fTtcbiAgfVxuXG4gIGlmIChrZXlUYWcgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjptZXJnZScpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZU5vZGUpKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgcXVhbnRpdHkgPSB2YWx1ZU5vZGUubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAgICAgIG1lcmdlTWFwcGluZ3Moc3RhdGUsIF9yZXN1bHQsIHZhbHVlTm9kZVtpbmRleF0sIG92ZXJyaWRhYmxlS2V5cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlTWFwcGluZ3Moc3RhdGUsIF9yZXN1bHQsIHZhbHVlTm9kZSwgb3ZlcnJpZGFibGVLZXlzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFzdGF0ZS5qc29uICYmXG4gICAgICAgICFfaGFzT3duUHJvcGVydHkkMS5jYWxsKG92ZXJyaWRhYmxlS2V5cywga2V5Tm9kZSkgJiZcbiAgICAgICAgX2hhc093blByb3BlcnR5JDEuY2FsbChfcmVzdWx0LCBrZXlOb2RlKSkge1xuICAgICAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSB8fCBzdGF0ZS5saW5lO1xuICAgICAgc3RhdGUubGluZVN0YXJ0ID0gc3RhcnRMaW5lU3RhcnQgfHwgc3RhdGUubGluZVN0YXJ0O1xuICAgICAgc3RhdGUucG9zaXRpb24gPSBzdGFydFBvcyB8fCBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGVkIG1hcHBpbmcga2V5Jyk7XG4gICAgfVxuXG4gICAgLy8gdXNlZCBmb3IgdGhpcyBzcGVjaWZpYyBrZXkgb25seSBiZWNhdXNlIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBpcyBzbG93XG4gICAgaWYgKGtleU5vZGUgPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3Jlc3VsdCwga2V5Tm9kZSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdmFsdWVOb2RlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3Jlc3VsdFtrZXlOb2RlXSA9IHZhbHVlTm9kZTtcbiAgICB9XG4gICAgZGVsZXRlIG92ZXJyaWRhYmxlS2V5c1trZXlOb2RlXTtcbiAgfVxuXG4gIHJldHVybiBfcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZWFkTGluZUJyZWFrKHN0YXRlKSB7XG4gIHZhciBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHgwQS8qIExGICovKSB7XG4gICAgc3RhdGUucG9zaXRpb24rKztcbiAgfSBlbHNlIGlmIChjaCA9PT0gMHgwRC8qIENSICovKSB7XG4gICAgc3RhdGUucG9zaXRpb24rKztcbiAgICBpZiAoc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgPT09IDB4MEEvKiBMRiAqLykge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2EgbGluZSBicmVhayBpcyBleHBlY3RlZCcpO1xuICB9XG5cbiAgc3RhdGUubGluZSArPSAxO1xuICBzdGF0ZS5saW5lU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgc3RhdGUuZmlyc3RUYWJJbkxpbmUgPSAtMTtcbn1cblxuZnVuY3Rpb24gc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgYWxsb3dDb21tZW50cywgY2hlY2tJbmRlbnQpIHtcbiAgdmFyIGxpbmVCcmVha3MgPSAwLFxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICBpZiAoY2ggPT09IDB4MDkvKiBUYWIgKi8gJiYgc3RhdGUuZmlyc3RUYWJJbkxpbmUgPT09IC0xKSB7XG4gICAgICAgIHN0YXRlLmZpcnN0VGFiSW5MaW5lID0gc3RhdGUucG9zaXRpb247XG4gICAgICB9XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93Q29tbWVudHMgJiYgY2ggPT09IDB4MjMvKiAjICovKSB7XG4gICAgICBkbyB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH0gd2hpbGUgKGNoICE9PSAweDBBLyogTEYgKi8gJiYgY2ggIT09IDB4MEQvKiBDUiAqLyAmJiBjaCAhPT0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuXG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgbGluZUJyZWFrcysrO1xuICAgICAgc3RhdGUubGluZUluZGVudCA9IDA7XG5cbiAgICAgIHdoaWxlIChjaCA9PT0gMHgyMC8qIFNwYWNlICovKSB7XG4gICAgICAgIHN0YXRlLmxpbmVJbmRlbnQrKztcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoY2hlY2tJbmRlbnQgIT09IC0xICYmIGxpbmVCcmVha3MgIT09IDAgJiYgc3RhdGUubGluZUluZGVudCA8IGNoZWNrSW5kZW50KSB7XG4gICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAnZGVmaWNpZW50IGluZGVudGF0aW9uJyk7XG4gIH1cblxuICByZXR1cm4gbGluZUJyZWFrcztcbn1cblxuZnVuY3Rpb24gdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbixcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24pO1xuXG4gIC8vIENvbmRpdGlvbiBzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0IGlzIHRlc3RlZFxuICAvLyBpbiBwYXJlbnQgb24gZWFjaCBjYWxsLCBmb3IgZWZmaWNpZW5jeS4gTm8gbmVlZHMgdG8gdGVzdCBoZXJlIGFnYWluLlxuICBpZiAoKGNoID09PSAweDJELyogLSAqLyB8fCBjaCA9PT0gMHgyRS8qIC4gKi8pICYmXG4gICAgICBjaCA9PT0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24gKyAxKSAmJlxuICAgICAgY2ggPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uICsgMikpIHtcblxuICAgIF9wb3NpdGlvbiArPSAzO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IDAgfHwgaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBjb3VudCkge1xuICBpZiAoY291bnQgPT09IDEpIHtcbiAgICBzdGF0ZS5yZXN1bHQgKz0gJyAnO1xuICB9IGVsc2UgaWYgKGNvdW50ID4gMSkge1xuICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBjb3VudCAtIDEpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gcmVhZFBsYWluU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50LCB3aXRoaW5GbG93Q29sbGVjdGlvbikge1xuICB2YXIgcHJlY2VkaW5nLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgY2FwdHVyZVN0YXJ0LFxuICAgICAgY2FwdHVyZUVuZCxcbiAgICAgIGhhc1BlbmRpbmdDb250ZW50LFxuICAgICAgX2xpbmUsXG4gICAgICBfbGluZVN0YXJ0LFxuICAgICAgX2xpbmVJbmRlbnQsXG4gICAgICBfa2luZCA9IHN0YXRlLmtpbmQsXG4gICAgICBfcmVzdWx0ID0gc3RhdGUucmVzdWx0LFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoaXNfV1NfT1JfRU9MKGNoKSAgICAgIHx8XG4gICAgICBpc19GTE9XX0lORElDQVRPUihjaCkgfHxcbiAgICAgIGNoID09PSAweDIzLyogIyAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjYvKiAmICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyQS8qICogKi8gICAgfHxcbiAgICAgIGNoID09PSAweDIxLyogISAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4N0MvKiB8ICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgzRS8qID4gKi8gICAgfHxcbiAgICAgIGNoID09PSAweDI3LyogJyAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjIvKiBcIiAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjUvKiAlICovICAgIHx8XG4gICAgICBjaCA9PT0gMHg0MC8qIEAgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDYwLyogYCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChjaCA9PT0gMHgzRi8qID8gKi8gfHwgY2ggPT09IDB4MkQvKiAtICovKSB7XG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpIHx8XG4gICAgICAgIHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmIGlzX0ZMT1dfSU5ESUNBVE9SKGZvbGxvd2luZykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDNBLyogOiAqLykge1xuICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykgfHxcbiAgICAgICAgICB3aXRoaW5GbG93Q29sbGVjdGlvbiAmJiBpc19GTE9XX0lORElDQVRPUihmb2xsb3dpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgIHByZWNlZGluZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gLSAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChwcmVjZWRpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB8fFxuICAgICAgICAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoY2gpKSB7XG4gICAgICBicmVhaztcblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgX2xpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcbiAgICAgIF9saW5lSW5kZW50ID0gc3RhdGUubGluZUluZGVudDtcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCAtMSk7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID49IG5vZGVJbmRlbnQpIHtcbiAgICAgICAgaGFzUGVuZGluZ0NvbnRlbnQgPSB0cnVlO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uID0gY2FwdHVyZUVuZDtcbiAgICAgICAgc3RhdGUubGluZSA9IF9saW5lO1xuICAgICAgICBzdGF0ZS5saW5lU3RhcnQgPSBfbGluZVN0YXJ0O1xuICAgICAgICBzdGF0ZS5saW5lSW5kZW50ID0gX2xpbmVJbmRlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNQZW5kaW5nQ29udGVudCkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc3RhdGUubGluZSAtIF9saW5lKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbiArIDE7XG4gICAgfVxuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICB9XG5cbiAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuXG4gIGlmIChzdGF0ZS5yZXN1bHQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSBfa2luZDtcbiAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjaCxcbiAgICAgIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyNy8qICcgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBzdGF0ZS5wb3NpdGlvbisrO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSAhPT0gMCkge1xuICAgIGlmIChjaCA9PT0gMHgyNy8qICcgKi8pIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgaWYgKGNoID09PSAweDI3LyogJyAqLykge1xuICAgICAgICBjYXB0dXJlU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIHRydWUpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyJyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBzaW5nbGUgcXVvdGVkIHNjYWxhcicpO1xufVxuXG5mdW5jdGlvbiByZWFkRG91YmxlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjYXB0dXJlU3RhcnQsXG4gICAgICBjYXB0dXJlRW5kLFxuICAgICAgaGV4TGVuZ3RoLFxuICAgICAgaGV4UmVzdWx0LFxuICAgICAgdG1wLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjIvKiBcIiAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIHN0YXRlLnBvc2l0aW9uKys7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDIyLyogXCIgKi8pIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4NUMvKiBcXCAqLykge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCk7XG5cbiAgICAgICAgLy8gVE9ETzogcmV3b3JrIHRvIGlubGluZSBmbiB3aXRoIG5vIHR5cGUgY2FzdD9cbiAgICAgIH0gZWxzZSBpZiAoY2ggPCAyNTYgJiYgc2ltcGxlRXNjYXBlQ2hlY2tbY2hdKSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBzaW1wbGVFc2NhcGVNYXBbY2hdO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuXG4gICAgICB9IGVsc2UgaWYgKCh0bXAgPSBlc2NhcGVkSGV4TGVuKGNoKSkgPiAwKSB7XG4gICAgICAgIGhleExlbmd0aCA9IHRtcDtcbiAgICAgICAgaGV4UmVzdWx0ID0gMDtcblxuICAgICAgICBmb3IgKDsgaGV4TGVuZ3RoID4gMDsgaGV4TGVuZ3RoLS0pIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgICBpZiAoKHRtcCA9IGZyb21IZXhDb2RlKGNoKSkgPj0gMCkge1xuICAgICAgICAgICAgaGV4UmVzdWx0ID0gKGhleFJlc3VsdCA8PCA0KSArIHRtcDtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgaGV4YWRlY2ltYWwgY2hhcmFjdGVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNoYXJGcm9tQ29kZXBvaW50KGhleFJlc3VsdCk7XG5cbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3Vua25vd24gZXNjYXBlIHNlcXVlbmNlJyk7XG4gICAgICB9XG5cbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgdHJ1ZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCkpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgZG9jdW1lbnQgd2l0aGluIGEgZG91YmxlIHF1b3RlZCBzY2FsYXInKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWRGbG93Q29sbGVjdGlvbihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgcmVhZE5leHQgPSB0cnVlLFxuICAgICAgX2xpbmUsXG4gICAgICBfbGluZVN0YXJ0LFxuICAgICAgX3BvcyxcbiAgICAgIF90YWcgICAgID0gc3RhdGUudGFnLFxuICAgICAgX3Jlc3VsdCxcbiAgICAgIF9hbmNob3IgID0gc3RhdGUuYW5jaG9yLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgdGVybWluYXRvcixcbiAgICAgIGlzUGFpcixcbiAgICAgIGlzRXhwbGljaXRQYWlyLFxuICAgICAgaXNNYXBwaW5nLFxuICAgICAgb3ZlcnJpZGFibGVLZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIGtleU5vZGUsXG4gICAgICBrZXlUYWcsXG4gICAgICB2YWx1ZU5vZGUsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHg1Qi8qIFsgKi8pIHtcbiAgICB0ZXJtaW5hdG9yID0gMHg1RDsvKiBdICovXG4gICAgaXNNYXBwaW5nID0gZmFsc2U7XG4gICAgX3Jlc3VsdCA9IFtdO1xuICB9IGVsc2UgaWYgKGNoID09PSAweDdCLyogeyAqLykge1xuICAgIHRlcm1pbmF0b3IgPSAweDdEOy8qIH0gKi9cbiAgICBpc01hcHBpbmcgPSB0cnVlO1xuICAgIF9yZXN1bHQgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBfcmVzdWx0O1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gdGVybWluYXRvcikge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgICAgc3RhdGUua2luZCA9IGlzTWFwcGluZyA/ICdtYXBwaW5nJyA6ICdzZXF1ZW5jZSc7XG4gICAgICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICghcmVhZE5leHQpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdtaXNzZWQgY29tbWEgYmV0d2VlbiBmbG93IGNvbGxlY3Rpb24gZW50cmllcycpO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MkMvKiAsICovKSB7XG4gICAgICAvLyBcImZsb3cgY29sbGVjdGlvbiBlbnRyaWVzIGNhbiBuZXZlciBiZSBjb21wbGV0ZWx5IGVtcHR5XCIsIGFzIHBlciBZQU1MIDEuMiwgc2VjdGlvbiA3LjRcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsIFwiZXhwZWN0ZWQgdGhlIG5vZGUgY29udGVudCwgYnV0IGZvdW5kICcsJ1wiKTtcbiAgICB9XG5cbiAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICBpc1BhaXIgPSBpc0V4cGxpY2l0UGFpciA9IGZhbHNlO1xuXG4gICAgaWYgKGNoID09PSAweDNGLyogPyAqLykge1xuICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykpIHtcbiAgICAgICAgaXNQYWlyID0gaXNFeHBsaWNpdFBhaXIgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7IC8vIFNhdmUgdGhlIGN1cnJlbnQgbGluZS5cbiAgICBfbGluZVN0YXJ0ID0gc3RhdGUubGluZVN0YXJ0O1xuICAgIF9wb3MgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICBjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9GTE9XX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAga2V5VGFnID0gc3RhdGUudGFnO1xuICAgIGtleU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKChpc0V4cGxpY2l0UGFpciB8fCBzdGF0ZS5saW5lID09PSBfbGluZSkgJiYgY2ggPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICBpc1BhaXIgPSB0cnVlO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG4gICAgICBjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9GTE9XX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB2YWx1ZU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKGlzTWFwcGluZykge1xuICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSwgX2xpbmUsIF9saW5lU3RhcnQsIF9wb3MpO1xuICAgIH0gZWxzZSBpZiAoaXNQYWlyKSB7XG4gICAgICBfcmVzdWx0LnB1c2goc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgbnVsbCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSwgX2xpbmUsIF9saW5lU3RhcnQsIF9wb3MpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3Jlc3VsdC5wdXNoKGtleU5vZGUpO1xuICAgIH1cblxuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gMHgyQy8qICwgKi8pIHtcbiAgICAgIHJlYWROZXh0ID0gdHJ1ZTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVhZE5leHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBmbG93IGNvbGxlY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjYXB0dXJlU3RhcnQsXG4gICAgICBmb2xkaW5nLFxuICAgICAgY2hvbXBpbmcgICAgICAgPSBDSE9NUElOR19DTElQLFxuICAgICAgZGlkUmVhZENvbnRlbnQgPSBmYWxzZSxcbiAgICAgIGRldGVjdGVkSW5kZW50ID0gZmFsc2UsXG4gICAgICB0ZXh0SW5kZW50ICAgICA9IG5vZGVJbmRlbnQsXG4gICAgICBlbXB0eUxpbmVzICAgICA9IDAsXG4gICAgICBhdE1vcmVJbmRlbnRlZCA9IGZhbHNlLFxuICAgICAgdG1wLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4N0MvKiB8ICovKSB7XG4gICAgZm9sZGluZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGNoID09PSAweDNFLyogPiAqLykge1xuICAgIGZvbGRpbmcgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSAweDJCLyogKyAqLyB8fCBjaCA9PT0gMHgyRC8qIC0gKi8pIHtcbiAgICAgIGlmIChDSE9NUElOR19DTElQID09PSBjaG9tcGluZykge1xuICAgICAgICBjaG9tcGluZyA9IChjaCA9PT0gMHgyQi8qICsgKi8pID8gQ0hPTVBJTkdfS0VFUCA6IENIT01QSU5HX1NUUklQO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3JlcGVhdCBvZiBhIGNob21waW5nIG1vZGUgaWRlbnRpZmllcicpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgodG1wID0gZnJvbURlY2ltYWxDb2RlKGNoKSkgPj0gMCkge1xuICAgICAgaWYgKHRtcCA9PT0gMCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGV4cGxpY2l0IGluZGVudGF0aW9uIHdpZHRoIG9mIGEgYmxvY2sgc2NhbGFyOyBpdCBjYW5ub3QgYmUgbGVzcyB0aGFuIG9uZScpO1xuICAgICAgfSBlbHNlIGlmICghZGV0ZWN0ZWRJbmRlbnQpIHtcbiAgICAgICAgdGV4dEluZGVudCA9IG5vZGVJbmRlbnQgKyB0bXAgLSAxO1xuICAgICAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAncmVwZWF0IG9mIGFuIGluZGVudGF0aW9uIHdpZHRoIGlkZW50aWZpZXInKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKTtcblxuICAgIGlmIChjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgICB3aGlsZSAoIWlzX0VPTChjaCkgJiYgKGNoICE9PSAwKSk7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG4gICAgc3RhdGUubGluZUluZGVudCA9IDA7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgd2hpbGUgKCghZGV0ZWN0ZWRJbmRlbnQgfHwgc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpICYmXG4gICAgICAgICAgIChjaCA9PT0gMHgyMC8qIFNwYWNlICovKSkge1xuICAgICAgc3RhdGUubGluZUluZGVudCsrO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmICghZGV0ZWN0ZWRJbmRlbnQgJiYgc3RhdGUubGluZUluZGVudCA+IHRleHRJbmRlbnQpIHtcbiAgICAgIHRleHRJbmRlbnQgPSBzdGF0ZS5saW5lSW5kZW50O1xuICAgIH1cblxuICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBlbXB0eUxpbmVzKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBFbmQgb2YgdGhlIHNjYWxhci5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpIHtcblxuICAgICAgLy8gUGVyZm9ybSB0aGUgY2hvbXBpbmcuXG4gICAgICBpZiAoY2hvbXBpbmcgPT09IENIT01QSU5HX0tFRVApIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGRpZFJlYWRDb250ZW50ID8gMSArIGVtcHR5TGluZXMgOiBlbXB0eUxpbmVzKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hvbXBpbmcgPT09IENIT01QSU5HX0NMSVApIHtcbiAgICAgICAgaWYgKGRpZFJlYWRDb250ZW50KSB7IC8vIGkuZS4gb25seSBpZiB0aGUgc2NhbGFyIGlzIG5vdCBlbXB0eS5cbiAgICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQnJlYWsgdGhpcyBgd2hpbGVgIGN5Y2xlIGFuZCBnbyB0byB0aGUgZnVuY2l0b24ncyBlcGlsb2d1ZS5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIEZvbGRlZCBzdHlsZTogdXNlIGZhbmN5IHJ1bGVzIHRvIGhhbmRsZSBsaW5lIGJyZWFrcy5cbiAgICBpZiAoZm9sZGluZykge1xuXG4gICAgICAvLyBMaW5lcyBzdGFydGluZyB3aXRoIHdoaXRlIHNwYWNlIGNoYXJhY3RlcnMgKG1vcmUtaW5kZW50ZWQgbGluZXMpIGFyZSBub3QgZm9sZGVkLlxuICAgICAgaWYgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgICBhdE1vcmVJbmRlbnRlZCA9IHRydWU7XG4gICAgICAgIC8vIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IGNvbnRlbnQgbGluZSAoY2YuIEV4YW1wbGUgOC4xKVxuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuXG4gICAgICAvLyBFbmQgb2YgbW9yZS1pbmRlbnRlZCBibG9jay5cbiAgICAgIH0gZWxzZSBpZiAoYXRNb3JlSW5kZW50ZWQpIHtcbiAgICAgICAgYXRNb3JlSW5kZW50ZWQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMgKyAxKTtcblxuICAgICAgLy8gSnVzdCBvbmUgbGluZSBicmVhayAtIHBlcmNlaXZlIGFzIHRoZSBzYW1lIGxpbmUuXG4gICAgICB9IGVsc2UgaWYgKGVtcHR5TGluZXMgPT09IDApIHtcbiAgICAgICAgaWYgKGRpZFJlYWRDb250ZW50KSB7IC8vIGkuZS4gb25seSBpZiB3ZSBoYXZlIGFscmVhZHkgcmVhZCBzb21lIHNjYWxhciBjb250ZW50LlxuICAgICAgICAgIHN0YXRlLnJlc3VsdCArPSAnICc7XG4gICAgICAgIH1cblxuICAgICAgLy8gU2V2ZXJhbCBsaW5lIGJyZWFrcyAtIHBlcmNlaXZlIGFzIGRpZmZlcmVudCBsaW5lcy5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBlbXB0eUxpbmVzKTtcbiAgICAgIH1cblxuICAgIC8vIExpdGVyYWwgc3R5bGU6IGp1c3QgYWRkIGV4YWN0IG51bWJlciBvZiBsaW5lIGJyZWFrcyBiZXR3ZWVuIGNvbnRlbnQgbGluZXMuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEtlZXAgYWxsIGxpbmUgYnJlYWtzIGV4Y2VwdCB0aGUgaGVhZGVyIGxpbmUgYnJlYWsuXG4gICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuICAgIH1cblxuICAgIGRpZFJlYWRDb250ZW50ID0gdHJ1ZTtcbiAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgZW1wdHlMaW5lcyA9IDA7XG4gICAgY2FwdHVyZVN0YXJ0ID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB3aGlsZSAoIWlzX0VPTChjaCkgJiYgKGNoICE9PSAwKSkge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCBmYWxzZSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrU2VxdWVuY2Uoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIF9saW5lLFxuICAgICAgX3RhZyAgICAgID0gc3RhdGUudGFnLFxuICAgICAgX2FuY2hvciAgID0gc3RhdGUuYW5jaG9yLFxuICAgICAgX3Jlc3VsdCAgID0gW10sXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICBkZXRlY3RlZCAgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIC8vIHRoZXJlIGlzIGEgbGVhZGluZyB0YWIgYmVmb3JlIHRoaXMgdG9rZW4sIHNvIGl0IGNhbid0IGJlIGEgYmxvY2sgc2VxdWVuY2UvbWFwcGluZztcbiAgLy8gaXQgY2FuIHN0aWxsIGJlIGZsb3cgc2VxdWVuY2UvbWFwcGluZyBvciBhIHNjYWxhclxuICBpZiAoc3RhdGUuZmlyc3RUYWJJbkxpbmUgIT09IC0xKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gX3Jlc3VsdDtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgaWYgKHN0YXRlLmZpcnN0VGFiSW5MaW5lICE9PSAtMSkge1xuICAgICAgc3RhdGUucG9zaXRpb24gPSBzdGF0ZS5maXJzdFRhYkluTGluZTtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWIgY2hhcmFjdGVycyBtdXN0IG5vdCBiZSB1c2VkIGluIGluZGVudGF0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKGNoICE9PSAweDJELyogLSAqLykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKCFpc19XU19PUl9FT0woZm9sbG93aW5nKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgIHN0YXRlLnBvc2l0aW9uKys7XG5cbiAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICBpZiAoc3RhdGUubGluZUluZGVudCA8PSBub2RlSW5kZW50KSB7XG4gICAgICAgIF9yZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0JMT0NLX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAgX3Jlc3VsdC5wdXNoKHN0YXRlLnJlc3VsdCk7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmICgoc3RhdGUubGluZSA9PT0gX2xpbmUgfHwgc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQpICYmIChjaCAhPT0gMCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdiYWQgaW5kZW50YXRpb24gb2YgYSBzZXF1ZW5jZSBlbnRyeScpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IG5vZGVJbmRlbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkZXRlY3RlZCkge1xuICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICBzdGF0ZS5raW5kID0gJ3NlcXVlbmNlJztcbiAgICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgbm9kZUluZGVudCwgZmxvd0luZGVudCkge1xuICB2YXIgZm9sbG93aW5nLFxuICAgICAgYWxsb3dDb21wYWN0LFxuICAgICAgX2xpbmUsXG4gICAgICBfa2V5TGluZSxcbiAgICAgIF9rZXlMaW5lU3RhcnQsXG4gICAgICBfa2V5UG9zLFxuICAgICAgX3RhZyAgICAgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIF9hbmNob3IgICAgICAgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBfcmVzdWx0ICAgICAgID0ge30sXG4gICAgICBvdmVycmlkYWJsZUtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAga2V5VGFnICAgICAgICA9IG51bGwsXG4gICAgICBrZXlOb2RlICAgICAgID0gbnVsbCxcbiAgICAgIHZhbHVlTm9kZSAgICAgPSBudWxsLFxuICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlLFxuICAgICAgZGV0ZWN0ZWQgICAgICA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgLy8gdGhlcmUgaXMgYSBsZWFkaW5nIHRhYiBiZWZvcmUgdGhpcyB0b2tlbiwgc28gaXQgY2FuJ3QgYmUgYSBibG9jayBzZXF1ZW5jZS9tYXBwaW5nO1xuICAvLyBpdCBjYW4gc3RpbGwgYmUgZmxvdyBzZXF1ZW5jZS9tYXBwaW5nIG9yIGEgc2NhbGFyXG4gIGlmIChzdGF0ZS5maXJzdFRhYkluTGluZSAhPT0gLTEpIHJldHVybiBmYWxzZTtcblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBfcmVzdWx0O1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBpZiAoIWF0RXhwbGljaXRLZXkgJiYgc3RhdGUuZmlyc3RUYWJJbkxpbmUgIT09IC0xKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbiA9IHN0YXRlLmZpcnN0VGFiSW5MaW5lO1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhYiBjaGFyYWN0ZXJzIG11c3Qgbm90IGJlIHVzZWQgaW4gaW5kZW50YXRpb24nKTtcbiAgICB9XG5cbiAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lOyAvLyBTYXZlIHRoZSBjdXJyZW50IGxpbmUuXG5cbiAgICAvL1xuICAgIC8vIEV4cGxpY2l0IG5vdGF0aW9uIGNhc2UuIFRoZXJlIGFyZSB0d28gc2VwYXJhdGUgYmxvY2tzOlxuICAgIC8vIGZpcnN0IGZvciB0aGUga2V5IChkZW5vdGVkIGJ5IFwiP1wiKSBhbmQgc2Vjb25kIGZvciB0aGUgdmFsdWUgKGRlbm90ZWQgYnkgXCI6XCIpXG4gICAgLy9cbiAgICBpZiAoKGNoID09PSAweDNGLyogPyAqLyB8fCBjaCA9PT0gMHgzQS8qIDogKi8pICYmIGlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG5cbiAgICAgIGlmIChjaCA9PT0gMHgzRi8qID8gKi8pIHtcbiAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgbnVsbCwgX2tleUxpbmUsIF9rZXlMaW5lU3RhcnQsIF9rZXlQb3MpO1xuICAgICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICBhdEV4cGxpY2l0S2V5ID0gdHJ1ZTtcbiAgICAgICAgYWxsb3dDb21wYWN0ID0gdHJ1ZTtcblxuICAgICAgfSBlbHNlIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgIC8vIGkuZS4gMHgzQS8qIDogKi8gPT09IGNoYXJhY3RlciBhZnRlciB0aGUgZXhwbGljaXQga2V5LlxuICAgICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgICAgIGFsbG93Q29tcGFjdCA9IHRydWU7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbmNvbXBsZXRlIGV4cGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBrZXkgbm9kZSBpcyBtaXNzZWQ7IG9yIGZvbGxvd2VkIGJ5IGEgbm9uLXRhYnVsYXRlZCBlbXB0eSBsaW5lJyk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnBvc2l0aW9uICs9IDE7XG4gICAgICBjaCA9IGZvbGxvd2luZztcblxuICAgIC8vXG4gICAgLy8gSW1wbGljaXQgbm90YXRpb24gY2FzZS4gRmxvdy1zdHlsZSBub2RlIGFzIHRoZSBrZXkgZmlyc3QsIHRoZW4gXCI6XCIsIGFuZCB0aGUgdmFsdWUuXG4gICAgLy9cbiAgICB9IGVsc2Uge1xuICAgICAgX2tleUxpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgX2tleUxpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcbiAgICAgIF9rZXlQb3MgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgICAgaWYgKCFjb21wb3NlTm9kZShzdGF0ZSwgZmxvd0luZGVudCwgQ09OVEVYVF9GTE9XX09VVCwgZmFsc2UsIHRydWUpKSB7XG4gICAgICAgIC8vIE5laXRoZXIgaW1wbGljaXQgbm9yIGV4cGxpY2l0IG5vdGF0aW9uLlxuICAgICAgICAvLyBSZWFkaW5nIGlzIGRvbmUuIEdvIHRvIHRoZSBlcGlsb2d1ZS5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lID09PSBfbGluZSkge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2ggPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgICAgaWYgKCFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYSB3aGl0ZXNwYWNlIGNoYXJhY3RlciBpcyBleHBlY3RlZCBhZnRlciB0aGUga2V5LXZhbHVlIHNlcGFyYXRvciB3aXRoaW4gYSBibG9jayBtYXBwaW5nJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCBudWxsLCBfa2V5TGluZSwgX2tleUxpbmVTdGFydCwgX2tleVBvcyk7XG4gICAgICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICAgIGFsbG93Q29tcGFjdCA9IGZhbHNlO1xuICAgICAgICAgIGtleVRhZyA9IHN0YXRlLnRhZztcbiAgICAgICAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZGV0ZWN0ZWQpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2FuIG5vdCByZWFkIGFuIGltcGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBjb2xvbiBpcyBtaXNzZWQnKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gS2VlcCB0aGUgcmVzdWx0IG9mIGBjb21wb3NlTm9kZWAuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmIChkZXRlY3RlZCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2FuIG5vdCByZWFkIGEgYmxvY2sgbWFwcGluZyBlbnRyeTsgYSBtdWx0aWxpbmUga2V5IG1heSBub3QgYmUgYW4gaW1wbGljaXQga2V5Jyk7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBLZWVwIHRoZSByZXN1bHQgb2YgYGNvbXBvc2VOb2RlYC5cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIENvbW1vbiByZWFkaW5nIGNvZGUgZm9yIGJvdGggZXhwbGljaXQgYW5kIGltcGxpY2l0IG5vdGF0aW9ucy5cbiAgICAvL1xuICAgIGlmIChzdGF0ZS5saW5lID09PSBfbGluZSB8fCBzdGF0ZS5saW5lSW5kZW50ID4gbm9kZUluZGVudCkge1xuICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgX2tleUxpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgICBfa2V5TGluZVN0YXJ0ID0gc3RhdGUubGluZVN0YXJ0O1xuICAgICAgICBfa2V5UG9zID0gc3RhdGUucG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9CTE9DS19PVVQsIHRydWUsIGFsbG93Q29tcGFjdCkpIHtcbiAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlTm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSwgX2tleUxpbmUsIF9rZXlMaW5lU3RhcnQsIF9rZXlQb3MpO1xuICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoKHN0YXRlLmxpbmUgPT09IF9saW5lIHx8IHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50KSAmJiAoY2ggIT09IDApKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGluZGVudGF0aW9uIG9mIGEgbWFwcGluZyBlbnRyeScpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IG5vZGVJbmRlbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vXG4gIC8vIEVwaWxvZ3VlLlxuICAvL1xuXG4gIC8vIFNwZWNpYWwgY2FzZTogbGFzdCBtYXBwaW5nJ3Mgbm9kZSBjb250YWlucyBvbmx5IHRoZSBrZXkgaW4gZXhwbGljaXQgbm90YXRpb24uXG4gIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIG51bGwsIF9rZXlMaW5lLCBfa2V5TGluZVN0YXJ0LCBfa2V5UG9zKTtcbiAgfVxuXG4gIC8vIEV4cG9zZSB0aGUgcmVzdWx0aW5nIG1hcHBpbmcuXG4gIGlmIChkZXRlY3RlZCkge1xuICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICBzdGF0ZS5raW5kID0gJ21hcHBpbmcnO1xuICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gZGV0ZWN0ZWQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRUYWdQcm9wZXJ0eShzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLFxuICAgICAgaXNWZXJiYXRpbSA9IGZhbHNlLFxuICAgICAgaXNOYW1lZCAgICA9IGZhbHNlLFxuICAgICAgdGFnSGFuZGxlLFxuICAgICAgdGFnTmFtZSxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDIxLyogISAqLykgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChzdGF0ZS50YWcgIT09IG51bGwpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZHVwbGljYXRpb24gb2YgYSB0YWcgcHJvcGVydHknKTtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4M0MvKiA8ICovKSB7XG4gICAgaXNWZXJiYXRpbSA9IHRydWU7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4MjEvKiAhICovKSB7XG4gICAgaXNOYW1lZCA9IHRydWU7XG4gICAgdGFnSGFuZGxlID0gJyEhJztcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgfSBlbHNlIHtcbiAgICB0YWdIYW5kbGUgPSAnISc7XG4gIH1cblxuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICBpZiAoaXNWZXJiYXRpbSkge1xuICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgd2hpbGUgKGNoICE9PSAwICYmIGNoICE9PSAweDNFLyogPiAqLyk7XG5cbiAgICBpZiAoc3RhdGUucG9zaXRpb24gPCBzdGF0ZS5sZW5ndGgpIHtcbiAgICAgIHRhZ05hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgdmVyYmF0aW0gdGFnJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuXG4gICAgICBpZiAoY2ggPT09IDB4MjEvKiAhICovKSB7XG4gICAgICAgIGlmICghaXNOYW1lZCkge1xuICAgICAgICAgIHRhZ0hhbmRsZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiAtIDEsIHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICAgICAgICBpZiAoIVBBVFRFUk5fVEFHX0hBTkRMRS50ZXN0KHRhZ0hhbmRsZSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lZCB0YWcgaGFuZGxlIGNhbm5vdCBjb250YWluIHN1Y2ggY2hhcmFjdGVycycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlzTmFtZWQgPSB0cnVlO1xuICAgICAgICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIHN1ZmZpeCBjYW5ub3QgY29udGFpbiBleGNsYW1hdGlvbiBtYXJrcycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICB0YWdOYW1lID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoUEFUVEVSTl9GTE9XX0lORElDQVRPUlMudGVzdCh0YWdOYW1lKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBzdWZmaXggY2Fubm90IGNvbnRhaW4gZmxvdyBpbmRpY2F0b3IgY2hhcmFjdGVycycpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0YWdOYW1lICYmICFQQVRURVJOX1RBR19VUkkudGVzdCh0YWdOYW1lKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgbmFtZSBjYW5ub3QgY29udGFpbiBzdWNoIGNoYXJhY3RlcnM6ICcgKyB0YWdOYW1lKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdGFnTmFtZSA9IGRlY29kZVVSSUNvbXBvbmVudCh0YWdOYW1lKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBuYW1lIGlzIG1hbGZvcm1lZDogJyArIHRhZ05hbWUpO1xuICB9XG5cbiAgaWYgKGlzVmVyYmF0aW0pIHtcbiAgICBzdGF0ZS50YWcgPSB0YWdOYW1lO1xuXG4gIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5JDEuY2FsbChzdGF0ZS50YWdNYXAsIHRhZ0hhbmRsZSkpIHtcbiAgICBzdGF0ZS50YWcgPSBzdGF0ZS50YWdNYXBbdGFnSGFuZGxlXSArIHRhZ05hbWU7XG5cbiAgfSBlbHNlIGlmICh0YWdIYW5kbGUgPT09ICchJykge1xuICAgIHN0YXRlLnRhZyA9ICchJyArIHRhZ05hbWU7XG5cbiAgfSBlbHNlIGlmICh0YWdIYW5kbGUgPT09ICchIScpIHtcbiAgICBzdGF0ZS50YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6JyArIHRhZ05hbWU7XG5cbiAgfSBlbHNlIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5kZWNsYXJlZCB0YWcgaGFuZGxlIFwiJyArIHRhZ0hhbmRsZSArICdcIicpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRBbmNob3JQcm9wZXJ0eShzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjYvKiAmICovKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiBhbiBhbmNob3IgcHJvcGVydHknKTtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpICYmICFpc19GTE9XX0lORElDQVRPUihjaCkpIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIH1cblxuICBpZiAoc3RhdGUucG9zaXRpb24gPT09IF9wb3NpdGlvbikge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lIG9mIGFuIGFuY2hvciBub2RlIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyJyk7XG4gIH1cblxuICBzdGF0ZS5hbmNob3IgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRBbGlhcyhzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLCBhbGlhcyxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDJBLyogKiAqLykgcmV0dXJuIGZhbHNlO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpICYmICFpc19GTE9XX0lORElDQVRPUihjaCkpIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIH1cblxuICBpZiAoc3RhdGUucG9zaXRpb24gPT09IF9wb3NpdGlvbikge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lIG9mIGFuIGFsaWFzIG5vZGUgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXInKTtcbiAgfVxuXG4gIGFsaWFzID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKCFfaGFzT3duUHJvcGVydHkkMS5jYWxsKHN0YXRlLmFuY2hvck1hcCwgYWxpYXMpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuaWRlbnRpZmllZCBhbGlhcyBcIicgKyBhbGlhcyArICdcIicpO1xuICB9XG5cbiAgc3RhdGUucmVzdWx0ID0gc3RhdGUuYW5jaG9yTWFwW2FsaWFzXTtcbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29tcG9zZU5vZGUoc3RhdGUsIHBhcmVudEluZGVudCwgbm9kZUNvbnRleHQsIGFsbG93VG9TZWVrLCBhbGxvd0NvbXBhY3QpIHtcbiAgdmFyIGFsbG93QmxvY2tTdHlsZXMsXG4gICAgICBhbGxvd0Jsb2NrU2NhbGFycyxcbiAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyxcbiAgICAgIGluZGVudFN0YXR1cyA9IDEsIC8vIDE6IHRoaXM+cGFyZW50LCAwOiB0aGlzPXBhcmVudCwgLTE6IHRoaXM8cGFyZW50XG4gICAgICBhdE5ld0xpbmUgID0gZmFsc2UsXG4gICAgICBoYXNDb250ZW50ID0gZmFsc2UsXG4gICAgICB0eXBlSW5kZXgsXG4gICAgICB0eXBlUXVhbnRpdHksXG4gICAgICB0eXBlTGlzdCxcbiAgICAgIHR5cGUsXG4gICAgICBmbG93SW5kZW50LFxuICAgICAgYmxvY2tJbmRlbnQ7XG5cbiAgaWYgKHN0YXRlLmxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgc3RhdGUubGlzdGVuZXIoJ29wZW4nLCBzdGF0ZSk7XG4gIH1cblxuICBzdGF0ZS50YWcgICAgPSBudWxsO1xuICBzdGF0ZS5hbmNob3IgPSBudWxsO1xuICBzdGF0ZS5raW5kICAgPSBudWxsO1xuICBzdGF0ZS5yZXN1bHQgPSBudWxsO1xuXG4gIGFsbG93QmxvY2tTdHlsZXMgPSBhbGxvd0Jsb2NrU2NhbGFycyA9IGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9XG4gICAgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0IHx8XG4gICAgQ09OVEVYVF9CTE9DS19JTiAgPT09IG5vZGVDb250ZXh0O1xuXG4gIGlmIChhbGxvd1RvU2Vlaykge1xuICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgIGF0TmV3TGluZSA9IHRydWU7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICBpbmRlbnRTdGF0dXMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbmRlbnRTdGF0dXMgPT09IDEpIHtcbiAgICB3aGlsZSAocmVhZFRhZ1Byb3BlcnR5KHN0YXRlKSB8fCByZWFkQW5jaG9yUHJvcGVydHkoc3RhdGUpKSB7XG4gICAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICAgIGF0TmV3TGluZSA9IHRydWU7XG4gICAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGFsbG93QmxvY2tTdHlsZXM7XG5cbiAgICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgICBpbmRlbnRTdGF0dXMgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zKSB7XG4gICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gYXROZXdMaW5lIHx8IGFsbG93Q29tcGFjdDtcbiAgfVxuXG4gIGlmIChpbmRlbnRTdGF0dXMgPT09IDEgfHwgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0KSB7XG4gICAgaWYgKENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQgfHwgQ09OVEVYVF9GTE9XX09VVCA9PT0gbm9kZUNvbnRleHQpIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQgKyAxO1xuICAgIH1cblxuICAgIGJsb2NrSW5kZW50ID0gc3RhdGUucG9zaXRpb24gLSBzdGF0ZS5saW5lU3RhcnQ7XG5cbiAgICBpZiAoaW5kZW50U3RhdHVzID09PSAxKSB7XG4gICAgICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmXG4gICAgICAgICAgKHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCkgfHxcbiAgICAgICAgICAgcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgYmxvY2tJbmRlbnQsIGZsb3dJbmRlbnQpKSB8fFxuICAgICAgICAgIHJlYWRGbG93Q29sbGVjdGlvbihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKGFsbG93QmxvY2tTY2FsYXJzICYmIHJlYWRCbG9ja1NjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHx8XG4gICAgICAgICAgICByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSB8fFxuICAgICAgICAgICAgcmVhZERvdWJsZVF1b3RlZFNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlYWRBbGlhcyhzdGF0ZSkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChzdGF0ZS50YWcgIT09IG51bGwgfHwgc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYWxpYXMgbm9kZSBzaG91bGQgbm90IGhhdmUgYW55IHByb3BlcnRpZXMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWFkUGxhaW5TY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQpKSB7XG4gICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoc3RhdGUudGFnID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZS50YWcgPSAnPyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbmRlbnRTdGF0dXMgPT09IDApIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZTogYmxvY2sgc2VxdWVuY2VzIGFyZSBhbGxvd2VkIHRvIGhhdmUgc2FtZSBpbmRlbnRhdGlvbiBsZXZlbCBhcyB0aGUgcGFyZW50LlxuICAgICAgLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyNzk5Nzg0XG4gICAgICBoYXNDb250ZW50ID0gYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmIHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnRhZyA9PT0gbnVsbCkge1xuICAgIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgIH1cblxuICB9IGVsc2UgaWYgKHN0YXRlLnRhZyA9PT0gJz8nKSB7XG4gICAgLy8gSW1wbGljaXQgcmVzb2x2aW5nIGlzIG5vdCBhbGxvd2VkIGZvciBub24tc2NhbGFyIHR5cGVzLCBhbmQgJz8nXG4gICAgLy8gbm9uLXNwZWNpZmljIHRhZyBpcyBvbmx5IGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgdG8gcGxhaW4gc2NhbGFycy5cbiAgICAvL1xuICAgIC8vIFdlIG9ubHkgbmVlZCB0byBjaGVjayBraW5kIGNvbmZvcm1pdHkgaW4gY2FzZSB1c2VyIGV4cGxpY2l0bHkgYXNzaWducyAnPydcbiAgICAvLyB0YWcsIGZvciBleGFtcGxlIGxpa2UgdGhpczogXCIhPD8+IFswXVwiXG4gICAgLy9cbiAgICBpZiAoc3RhdGUucmVzdWx0ICE9PSBudWxsICYmIHN0YXRlLmtpbmQgIT09ICdzY2FsYXInKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5hY2NlcHRhYmxlIG5vZGUga2luZCBmb3IgITw/PiB0YWc7IGl0IHNob3VsZCBiZSBcInNjYWxhclwiLCBub3QgXCInICsgc3RhdGUua2luZCArICdcIicpO1xuICAgIH1cblxuICAgIGZvciAodHlwZUluZGV4ID0gMCwgdHlwZVF1YW50aXR5ID0gc3RhdGUuaW1wbGljaXRUeXBlcy5sZW5ndGg7IHR5cGVJbmRleCA8IHR5cGVRdWFudGl0eTsgdHlwZUluZGV4ICs9IDEpIHtcbiAgICAgIHR5cGUgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzW3R5cGVJbmRleF07XG5cbiAgICAgIGlmICh0eXBlLnJlc29sdmUoc3RhdGUucmVzdWx0KSkgeyAvLyBgc3RhdGUucmVzdWx0YCB1cGRhdGVkIGluIHJlc29sdmVyIGlmIG1hdGNoZWRcbiAgICAgICAgc3RhdGUucmVzdWx0ID0gdHlwZS5jb25zdHJ1Y3Qoc3RhdGUucmVzdWx0KTtcbiAgICAgICAgc3RhdGUudGFnID0gdHlwZS50YWc7XG4gICAgICAgIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RhdGUudGFnICE9PSAnIScpIHtcbiAgICBpZiAoX2hhc093blByb3BlcnR5JDEuY2FsbChzdGF0ZS50eXBlTWFwW3N0YXRlLmtpbmQgfHwgJ2ZhbGxiYWNrJ10sIHN0YXRlLnRhZykpIHtcbiAgICAgIHR5cGUgPSBzdGF0ZS50eXBlTWFwW3N0YXRlLmtpbmQgfHwgJ2ZhbGxiYWNrJ11bc3RhdGUudGFnXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbG9va2luZyBmb3IgbXVsdGkgdHlwZVxuICAgICAgdHlwZSA9IG51bGw7XG4gICAgICB0eXBlTGlzdCA9IHN0YXRlLnR5cGVNYXAubXVsdGlbc3RhdGUua2luZCB8fCAnZmFsbGJhY2snXTtcblxuICAgICAgZm9yICh0eXBlSW5kZXggPSAwLCB0eXBlUXVhbnRpdHkgPSB0eXBlTGlzdC5sZW5ndGg7IHR5cGVJbmRleCA8IHR5cGVRdWFudGl0eTsgdHlwZUluZGV4ICs9IDEpIHtcbiAgICAgICAgaWYgKHN0YXRlLnRhZy5zbGljZSgwLCB0eXBlTGlzdFt0eXBlSW5kZXhdLnRhZy5sZW5ndGgpID09PSB0eXBlTGlzdFt0eXBlSW5kZXhdLnRhZykge1xuICAgICAgICAgIHR5cGUgPSB0eXBlTGlzdFt0eXBlSW5kZXhdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5rbm93biB0YWcgITwnICsgc3RhdGUudGFnICsgJz4nKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUucmVzdWx0ICE9PSBudWxsICYmIHR5cGUua2luZCAhPT0gc3RhdGUua2luZCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuYWNjZXB0YWJsZSBub2RlIGtpbmQgZm9yICE8JyArIHN0YXRlLnRhZyArICc+IHRhZzsgaXQgc2hvdWxkIGJlIFwiJyArIHR5cGUua2luZCArICdcIiwgbm90IFwiJyArIHN0YXRlLmtpbmQgKyAnXCInKTtcbiAgICB9XG5cbiAgICBpZiAoIXR5cGUucmVzb2x2ZShzdGF0ZS5yZXN1bHQsIHN0YXRlLnRhZykpIHsgLy8gYHN0YXRlLnJlc3VsdGAgdXBkYXRlZCBpbiByZXNvbHZlciBpZiBtYXRjaGVkXG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2Fubm90IHJlc29sdmUgYSBub2RlIHdpdGggITwnICsgc3RhdGUudGFnICsgJz4gZXhwbGljaXQgdGFnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnJlc3VsdCA9IHR5cGUuY29uc3RydWN0KHN0YXRlLnJlc3VsdCwgc3RhdGUudGFnKTtcbiAgICAgIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLmxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgc3RhdGUubGlzdGVuZXIoJ2Nsb3NlJywgc3RhdGUpO1xuICB9XG4gIHJldHVybiBzdGF0ZS50YWcgIT09IG51bGwgfHwgIHN0YXRlLmFuY2hvciAhPT0gbnVsbCB8fCBoYXNDb250ZW50O1xufVxuXG5mdW5jdGlvbiByZWFkRG9jdW1lbnQoc3RhdGUpIHtcbiAgdmFyIGRvY3VtZW50U3RhcnQgPSBzdGF0ZS5wb3NpdGlvbixcbiAgICAgIF9wb3NpdGlvbixcbiAgICAgIGRpcmVjdGl2ZU5hbWUsXG4gICAgICBkaXJlY3RpdmVBcmdzLFxuICAgICAgaGFzRGlyZWN0aXZlcyA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgc3RhdGUudmVyc2lvbiA9IG51bGw7XG4gIHN0YXRlLmNoZWNrTGluZUJyZWFrcyA9IHN0YXRlLmxlZ2FjeTtcbiAgc3RhdGUudGFnTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc3RhdGUuYW5jaG9yTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gMCB8fCBjaCAhPT0gMHgyNS8qICUgKi8pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGhhc0RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGRpcmVjdGl2ZU5hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgICBkaXJlY3RpdmVBcmdzID0gW107XG5cbiAgICBpZiAoZGlyZWN0aXZlTmFtZS5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZGlyZWN0aXZlIG5hbWUgbXVzdCBub3QgYmUgbGVzcyB0aGFuIG9uZSBjaGFyYWN0ZXIgaW4gbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoID09PSAweDIzLyogIyAqLykge1xuICAgICAgICBkbyB7IGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTsgfVxuICAgICAgICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX0VPTChjaCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGlzX0VPTChjaCkpIGJyZWFrO1xuXG4gICAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGlyZWN0aXZlQXJncy5wdXNoKHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pKTtcbiAgICB9XG5cbiAgICBpZiAoY2ggIT09IDApIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuXG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eSQxLmNhbGwoZGlyZWN0aXZlSGFuZGxlcnMsIGRpcmVjdGl2ZU5hbWUpKSB7XG4gICAgICBkaXJlY3RpdmVIYW5kbGVyc1tkaXJlY3RpdmVOYW1lXShzdGF0ZSwgZGlyZWN0aXZlTmFtZSwgZGlyZWN0aXZlQXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ3Vua25vd24gZG9jdW1lbnQgZGlyZWN0aXZlIFwiJyArIGRpcmVjdGl2ZU5hbWUgKyAnXCInKTtcbiAgICB9XG4gIH1cblxuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IDAgJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pICAgICA9PT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKSA9PT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAyKSA9PT0gMHgyRC8qIC0gKi8pIHtcbiAgICBzdGF0ZS5wb3NpdGlvbiArPSAzO1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICB9IGVsc2UgaWYgKGhhc0RpcmVjdGl2ZXMpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZGlyZWN0aXZlcyBlbmQgbWFyayBpcyBleHBlY3RlZCcpO1xuICB9XG5cbiAgY29tcG9zZU5vZGUoc3RhdGUsIHN0YXRlLmxpbmVJbmRlbnQgLSAxLCBDT05URVhUX0JMT0NLX09VVCwgZmFsc2UsIHRydWUpO1xuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgaWYgKHN0YXRlLmNoZWNrTGluZUJyZWFrcyAmJlxuICAgICAgUEFUVEVSTl9OT05fQVNDSUlfTElORV9CUkVBS1MudGVzdChzdGF0ZS5pbnB1dC5zbGljZShkb2N1bWVudFN0YXJ0LCBzdGF0ZS5wb3NpdGlvbikpKSB7XG4gICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAnbm9uLUFTQ0lJIGxpbmUgYnJlYWtzIGFyZSBpbnRlcnByZXRlZCBhcyBjb250ZW50Jyk7XG4gIH1cblxuICBzdGF0ZS5kb2N1bWVudHMucHVzaChzdGF0ZS5yZXN1bHQpO1xuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcblxuICAgIGlmIChzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSA9PT0gMHgyRS8qIC4gKi8pIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uICs9IDM7XG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA8IChzdGF0ZS5sZW5ndGggLSAxKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdlbmQgb2YgdGhlIHN0cmVhbSBvciBhIGRvY3VtZW50IHNlcGFyYXRvciBpcyBleHBlY3RlZCcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGxvYWREb2N1bWVudHMoaW5wdXQsIG9wdGlvbnMpIHtcbiAgaW5wdXQgPSBTdHJpbmcoaW5wdXQpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5wdXQubGVuZ3RoICE9PSAwKSB7XG5cbiAgICAvLyBBZGQgdGFpbGluZyBgXFxuYCBpZiBub3QgZXhpc3RzXG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoaW5wdXQubGVuZ3RoIC0gMSkgIT09IDB4MEEvKiBMRiAqLyAmJlxuICAgICAgICBpbnB1dC5jaGFyQ29kZUF0KGlucHV0Lmxlbmd0aCAtIDEpICE9PSAweDBELyogQ1IgKi8pIHtcbiAgICAgIGlucHV0ICs9ICdcXG4nO1xuICAgIH1cblxuICAgIC8vIFN0cmlwIEJPTVxuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0YXRlID0gbmV3IFN0YXRlJDEoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIHZhciBudWxscG9zID0gaW5wdXQuaW5kZXhPZignXFwwJyk7XG5cbiAgaWYgKG51bGxwb3MgIT09IC0xKSB7XG4gICAgc3RhdGUucG9zaXRpb24gPSBudWxscG9zO1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdudWxsIGJ5dGUgaXMgbm90IGFsbG93ZWQgaW4gaW5wdXQnKTtcbiAgfVxuXG4gIC8vIFVzZSAwIGFzIHN0cmluZyB0ZXJtaW5hdG9yLiBUaGF0IHNpZ25pZmljYW50bHkgc2ltcGxpZmllcyBib3VuZHMgY2hlY2suXG4gIHN0YXRlLmlucHV0ICs9ICdcXDAnO1xuXG4gIHdoaWxlIChzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSA9PT0gMHgyMC8qIFNwYWNlICovKSB7XG4gICAgc3RhdGUubGluZUluZGVudCArPSAxO1xuICAgIHN0YXRlLnBvc2l0aW9uICs9IDE7XG4gIH1cblxuICB3aGlsZSAoc3RhdGUucG9zaXRpb24gPCAoc3RhdGUubGVuZ3RoIC0gMSkpIHtcbiAgICByZWFkRG9jdW1lbnQoc3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmRvY3VtZW50cztcbn1cblxuXG5mdW5jdGlvbiBsb2FkQWxsJDEoaW5wdXQsIGl0ZXJhdG9yLCBvcHRpb25zKSB7XG4gIGlmIChpdGVyYXRvciAhPT0gbnVsbCAmJiB0eXBlb2YgaXRlcmF0b3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIG9wdGlvbnMgPSBpdGVyYXRvcjtcbiAgICBpdGVyYXRvciA9IG51bGw7XG4gIH1cblxuICB2YXIgZG9jdW1lbnRzID0gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucyk7XG5cbiAgaWYgKHR5cGVvZiBpdGVyYXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBkb2N1bWVudHM7XG4gIH1cblxuICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGRvY3VtZW50cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgaXRlcmF0b3IoZG9jdW1lbnRzW2luZGV4XSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBsb2FkJDEoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGRvY3VtZW50cyA9IGxvYWREb2N1bWVudHMoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIGlmIChkb2N1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQqL1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBkb2N1bWVudHNbMF07XG4gIH1cbiAgdGhyb3cgbmV3IGV4Y2VwdGlvbignZXhwZWN0ZWQgYSBzaW5nbGUgZG9jdW1lbnQgaW4gdGhlIHN0cmVhbSwgYnV0IGZvdW5kIG1vcmUnKTtcbn1cblxuXG52YXIgbG9hZEFsbF8xID0gbG9hZEFsbCQxO1xudmFyIGxvYWRfMSAgICA9IGxvYWQkMTtcblxudmFyIGxvYWRlciA9IHtcblx0bG9hZEFsbDogbG9hZEFsbF8xLFxuXHRsb2FkOiBsb2FkXzFcbn07XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUqL1xuXG5cblxuXG5cbnZhciBfdG9TdHJpbmcgICAgICAgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBDSEFSX0JPTSAgICAgICAgICAgICAgICAgID0gMHhGRUZGO1xudmFyIENIQVJfVEFCICAgICAgICAgICAgICAgICAgPSAweDA5OyAvKiBUYWIgKi9cbnZhciBDSEFSX0xJTkVfRkVFRCAgICAgICAgICAgID0gMHgwQTsgLyogTEYgKi9cbnZhciBDSEFSX0NBUlJJQUdFX1JFVFVSTiAgICAgID0gMHgwRDsgLyogQ1IgKi9cbnZhciBDSEFSX1NQQUNFICAgICAgICAgICAgICAgID0gMHgyMDsgLyogU3BhY2UgKi9cbnZhciBDSEFSX0VYQ0xBTUFUSU9OICAgICAgICAgID0gMHgyMTsgLyogISAqL1xudmFyIENIQVJfRE9VQkxFX1FVT1RFICAgICAgICAgPSAweDIyOyAvKiBcIiAqL1xudmFyIENIQVJfU0hBUlAgICAgICAgICAgICAgICAgPSAweDIzOyAvKiAjICovXG52YXIgQ0hBUl9QRVJDRU5UICAgICAgICAgICAgICA9IDB4MjU7IC8qICUgKi9cbnZhciBDSEFSX0FNUEVSU0FORCAgICAgICAgICAgID0gMHgyNjsgLyogJiAqL1xudmFyIENIQVJfU0lOR0xFX1FVT1RFICAgICAgICAgPSAweDI3OyAvKiAnICovXG52YXIgQ0hBUl9BU1RFUklTSyAgICAgICAgICAgICA9IDB4MkE7IC8qICogKi9cbnZhciBDSEFSX0NPTU1BICAgICAgICAgICAgICAgID0gMHgyQzsgLyogLCAqL1xudmFyIENIQVJfTUlOVVMgICAgICAgICAgICAgICAgPSAweDJEOyAvKiAtICovXG52YXIgQ0hBUl9DT0xPTiAgICAgICAgICAgICAgICA9IDB4M0E7IC8qIDogKi9cbnZhciBDSEFSX0VRVUFMUyAgICAgICAgICAgICAgID0gMHgzRDsgLyogPSAqL1xudmFyIENIQVJfR1JFQVRFUl9USEFOICAgICAgICAgPSAweDNFOyAvKiA+ICovXG52YXIgQ0hBUl9RVUVTVElPTiAgICAgICAgICAgICA9IDB4M0Y7IC8qID8gKi9cbnZhciBDSEFSX0NPTU1FUkNJQUxfQVQgICAgICAgID0gMHg0MDsgLyogQCAqL1xudmFyIENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCAgPSAweDVCOyAvKiBbICovXG52YXIgQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCA9IDB4NUQ7IC8qIF0gKi9cbnZhciBDSEFSX0dSQVZFX0FDQ0VOVCAgICAgICAgID0gMHg2MDsgLyogYCAqL1xudmFyIENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUICAgPSAweDdCOyAvKiB7ICovXG52YXIgQ0hBUl9WRVJUSUNBTF9MSU5FICAgICAgICA9IDB4N0M7IC8qIHwgKi9cbnZhciBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVQgID0gMHg3RDsgLyogfSAqL1xuXG52YXIgRVNDQVBFX1NFUVVFTkNFUyA9IHt9O1xuXG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDBdICAgPSAnXFxcXDAnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDA3XSAgID0gJ1xcXFxhJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwOF0gICA9ICdcXFxcYic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDldICAgPSAnXFxcXHQnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBBXSAgID0gJ1xcXFxuJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwQl0gICA9ICdcXFxcdic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MENdICAgPSAnXFxcXGYnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBEXSAgID0gJ1xcXFxyJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgxQl0gICA9ICdcXFxcZSc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MjJdICAgPSAnXFxcXFwiJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHg1Q10gICA9ICdcXFxcXFxcXCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4ODVdICAgPSAnXFxcXE4nO1xuRVNDQVBFX1NFUVVFTkNFU1sweEEwXSAgID0gJ1xcXFxfJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMDI4XSA9ICdcXFxcTCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MjAyOV0gPSAnXFxcXFAnO1xuXG52YXIgREVQUkVDQVRFRF9CT09MRUFOU19TWU5UQVggPSBbXG4gICd5JywgJ1knLCAneWVzJywgJ1llcycsICdZRVMnLCAnb24nLCAnT24nLCAnT04nLFxuICAnbicsICdOJywgJ25vJywgJ05vJywgJ05PJywgJ29mZicsICdPZmYnLCAnT0ZGJ1xuXTtcblxudmFyIERFUFJFQ0FURURfQkFTRTYwX1NZTlRBWCA9IC9eWy0rXT9bMC05X10rKD86OlswLTlfXSspKyg/OlxcLlswLTlfXSopPyQvO1xuXG5mdW5jdGlvbiBjb21waWxlU3R5bGVNYXAoc2NoZW1hLCBtYXApIHtcbiAgdmFyIHJlc3VsdCwga2V5cywgaW5kZXgsIGxlbmd0aCwgdGFnLCBzdHlsZSwgdHlwZTtcblxuICBpZiAobWFwID09PSBudWxsKSByZXR1cm4ge307XG5cbiAgcmVzdWx0ID0ge307XG4gIGtleXMgPSBPYmplY3Qua2V5cyhtYXApO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0YWcgPSBrZXlzW2luZGV4XTtcbiAgICBzdHlsZSA9IFN0cmluZyhtYXBbdGFnXSk7XG5cbiAgICBpZiAodGFnLnNsaWNlKDAsIDIpID09PSAnISEnKSB7XG4gICAgICB0YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6JyArIHRhZy5zbGljZSgyKTtcbiAgICB9XG4gICAgdHlwZSA9IHNjaGVtYS5jb21waWxlZFR5cGVNYXBbJ2ZhbGxiYWNrJ11bdGFnXTtcblxuICAgIGlmICh0eXBlICYmIF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHR5cGUuc3R5bGVBbGlhc2VzLCBzdHlsZSkpIHtcbiAgICAgIHN0eWxlID0gdHlwZS5zdHlsZUFsaWFzZXNbc3R5bGVdO1xuICAgIH1cblxuICAgIHJlc3VsdFt0YWddID0gc3R5bGU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVIZXgoY2hhcmFjdGVyKSB7XG4gIHZhciBzdHJpbmcsIGhhbmRsZSwgbGVuZ3RoO1xuXG4gIHN0cmluZyA9IGNoYXJhY3Rlci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblxuICBpZiAoY2hhcmFjdGVyIDw9IDB4RkYpIHtcbiAgICBoYW5kbGUgPSAneCc7XG4gICAgbGVuZ3RoID0gMjtcbiAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPD0gMHhGRkZGKSB7XG4gICAgaGFuZGxlID0gJ3UnO1xuICAgIGxlbmd0aCA9IDQ7XG4gIH0gZWxzZSBpZiAoY2hhcmFjdGVyIDw9IDB4RkZGRkZGRkYpIHtcbiAgICBoYW5kbGUgPSAnVSc7XG4gICAgbGVuZ3RoID0gODtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdjb2RlIHBvaW50IHdpdGhpbiBhIHN0cmluZyBtYXkgbm90IGJlIGdyZWF0ZXIgdGhhbiAweEZGRkZGRkZGJyk7XG4gIH1cblxuICByZXR1cm4gJ1xcXFwnICsgaGFuZGxlICsgY29tbW9uLnJlcGVhdCgnMCcsIGxlbmd0aCAtIHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufVxuXG5cbnZhciBRVU9USU5HX1RZUEVfU0lOR0xFID0gMSxcbiAgICBRVU9USU5HX1RZUEVfRE9VQkxFID0gMjtcblxuZnVuY3Rpb24gU3RhdGUob3B0aW9ucykge1xuICB0aGlzLnNjaGVtYSAgICAgICAgPSBvcHRpb25zWydzY2hlbWEnXSB8fCBfZGVmYXVsdDtcbiAgdGhpcy5pbmRlbnQgICAgICAgID0gTWF0aC5tYXgoMSwgKG9wdGlvbnNbJ2luZGVudCddIHx8IDIpKTtcbiAgdGhpcy5ub0FycmF5SW5kZW50ID0gb3B0aW9uc1snbm9BcnJheUluZGVudCddIHx8IGZhbHNlO1xuICB0aGlzLnNraXBJbnZhbGlkICAgPSBvcHRpb25zWydza2lwSW52YWxpZCddIHx8IGZhbHNlO1xuICB0aGlzLmZsb3dMZXZlbCAgICAgPSAoY29tbW9uLmlzTm90aGluZyhvcHRpb25zWydmbG93TGV2ZWwnXSkgPyAtMSA6IG9wdGlvbnNbJ2Zsb3dMZXZlbCddKTtcbiAgdGhpcy5zdHlsZU1hcCAgICAgID0gY29tcGlsZVN0eWxlTWFwKHRoaXMuc2NoZW1hLCBvcHRpb25zWydzdHlsZXMnXSB8fCBudWxsKTtcbiAgdGhpcy5zb3J0S2V5cyAgICAgID0gb3B0aW9uc1snc29ydEtleXMnXSB8fCBmYWxzZTtcbiAgdGhpcy5saW5lV2lkdGggICAgID0gb3B0aW9uc1snbGluZVdpZHRoJ10gfHwgODA7XG4gIHRoaXMubm9SZWZzICAgICAgICA9IG9wdGlvbnNbJ25vUmVmcyddIHx8IGZhbHNlO1xuICB0aGlzLm5vQ29tcGF0TW9kZSAgPSBvcHRpb25zWydub0NvbXBhdE1vZGUnXSB8fCBmYWxzZTtcbiAgdGhpcy5jb25kZW5zZUZsb3cgID0gb3B0aW9uc1snY29uZGVuc2VGbG93J10gfHwgZmFsc2U7XG4gIHRoaXMucXVvdGluZ1R5cGUgICA9IG9wdGlvbnNbJ3F1b3RpbmdUeXBlJ10gPT09ICdcIicgPyBRVU9USU5HX1RZUEVfRE9VQkxFIDogUVVPVElOR19UWVBFX1NJTkdMRTtcbiAgdGhpcy5mb3JjZVF1b3RlcyAgID0gb3B0aW9uc1snZm9yY2VRdW90ZXMnXSB8fCBmYWxzZTtcbiAgdGhpcy5yZXBsYWNlciAgICAgID0gdHlwZW9mIG9wdGlvbnNbJ3JlcGxhY2VyJ10gPT09ICdmdW5jdGlvbicgPyBvcHRpb25zWydyZXBsYWNlciddIDogbnVsbDtcblxuICB0aGlzLmltcGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEltcGxpY2l0O1xuICB0aGlzLmV4cGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEV4cGxpY2l0O1xuXG4gIHRoaXMudGFnID0gbnVsbDtcbiAgdGhpcy5yZXN1bHQgPSAnJztcblxuICB0aGlzLmR1cGxpY2F0ZXMgPSBbXTtcbiAgdGhpcy51c2VkRHVwbGljYXRlcyA9IG51bGw7XG59XG5cbi8vIEluZGVudHMgZXZlcnkgbGluZSBpbiBhIHN0cmluZy4gRW1wdHkgbGluZXMgKFxcbiBvbmx5KSBhcmUgbm90IGluZGVudGVkLlxuZnVuY3Rpb24gaW5kZW50U3RyaW5nKHN0cmluZywgc3BhY2VzKSB7XG4gIHZhciBpbmQgPSBjb21tb24ucmVwZWF0KCcgJywgc3BhY2VzKSxcbiAgICAgIHBvc2l0aW9uID0gMCxcbiAgICAgIG5leHQgPSAtMSxcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgbGluZSxcbiAgICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgd2hpbGUgKHBvc2l0aW9uIDwgbGVuZ3RoKSB7XG4gICAgbmV4dCA9IHN0cmluZy5pbmRleE9mKCdcXG4nLCBwb3NpdGlvbik7XG4gICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICBsaW5lID0gc3RyaW5nLnNsaWNlKHBvc2l0aW9uKTtcbiAgICAgIHBvc2l0aW9uID0gbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lID0gc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBuZXh0ICsgMSk7XG4gICAgICBwb3NpdGlvbiA9IG5leHQgKyAxO1xuICAgIH1cblxuICAgIGlmIChsaW5lLmxlbmd0aCAmJiBsaW5lICE9PSAnXFxuJykgcmVzdWx0ICs9IGluZDtcblxuICAgIHJlc3VsdCArPSBsaW5lO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpIHtcbiAgcmV0dXJuICdcXG4nICsgY29tbW9uLnJlcGVhdCgnICcsIHN0YXRlLmluZGVudCAqIGxldmVsKTtcbn1cblxuZnVuY3Rpb24gdGVzdEltcGxpY2l0UmVzb2x2aW5nKHN0YXRlLCBzdHIpIHtcbiAgdmFyIGluZGV4LCBsZW5ndGgsIHR5cGU7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHN0YXRlLmltcGxpY2l0VHlwZXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHR5cGUgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzW2luZGV4XTtcblxuICAgIGlmICh0eXBlLnJlc29sdmUoc3RyKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBbMzNdIHMtd2hpdGUgOjo9IHMtc3BhY2UgfCBzLXRhYlxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGMpIHtcbiAgcmV0dXJuIGMgPT09IENIQVJfU1BBQ0UgfHwgYyA9PT0gQ0hBUl9UQUI7XG59XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2hhcmFjdGVyIGNhbiBiZSBwcmludGVkIHdpdGhvdXQgZXNjYXBpbmcuXG4vLyBGcm9tIFlBTUwgMS4yOiBcImFueSBhbGxvd2VkIGNoYXJhY3RlcnMga25vd24gdG8gYmUgbm9uLXByaW50YWJsZVxuLy8gc2hvdWxkIGFsc28gYmUgZXNjYXBlZC4gW0hvd2V2ZXIsXSBUaGlzIGlzbuKAmXQgbWFuZGF0b3J5XCJcbi8vIERlcml2ZWQgZnJvbSBuYi1jaGFyIC0gXFx0IC0gI3g4NSAtICN4QTAgLSAjeDIwMjggLSAjeDIwMjkuXG5mdW5jdGlvbiBpc1ByaW50YWJsZShjKSB7XG4gIHJldHVybiAgKDB4MDAwMjAgPD0gYyAmJiBjIDw9IDB4MDAwMDdFKVxuICAgICAgfHwgKCgweDAwMEExIDw9IGMgJiYgYyA8PSAweDAwRDdGRikgJiYgYyAhPT0gMHgyMDI4ICYmIGMgIT09IDB4MjAyOSlcbiAgICAgIHx8ICgoMHgwRTAwMCA8PSBjICYmIGMgPD0gMHgwMEZGRkQpICYmIGMgIT09IENIQVJfQk9NKVxuICAgICAgfHwgICgweDEwMDAwIDw9IGMgJiYgYyA8PSAweDEwRkZGRik7XG59XG5cbi8vIFszNF0gbnMtY2hhciA6Oj0gbmItY2hhciAtIHMtd2hpdGVcbi8vIFsyN10gbmItY2hhciA6Oj0gYy1wcmludGFibGUgLSBiLWNoYXIgLSBjLWJ5dGUtb3JkZXItbWFya1xuLy8gWzI2XSBiLWNoYXIgIDo6PSBiLWxpbmUtZmVlZCB8IGItY2FycmlhZ2UtcmV0dXJuXG4vLyBJbmNsdWRpbmcgcy13aGl0ZSAoZm9yIHNvbWUgcmVhc29uLCBleGFtcGxlcyBkb2Vzbid0IG1hdGNoIHNwZWNzIGluIHRoaXMgYXNwZWN0KVxuLy8gbnMtY2hhciA6Oj0gYy1wcmludGFibGUgLSBiLWxpbmUtZmVlZCAtIGItY2FycmlhZ2UtcmV0dXJuIC0gYy1ieXRlLW9yZGVyLW1hcmtcbmZ1bmN0aW9uIGlzTnNDaGFyT3JXaGl0ZXNwYWNlKGMpIHtcbiAgcmV0dXJuIGlzUHJpbnRhYmxlKGMpXG4gICAgJiYgYyAhPT0gQ0hBUl9CT01cbiAgICAvLyAtIGItY2hhclxuICAgICYmIGMgIT09IENIQVJfQ0FSUklBR0VfUkVUVVJOXG4gICAgJiYgYyAhPT0gQ0hBUl9MSU5FX0ZFRUQ7XG59XG5cbi8vIFsxMjddICBucy1wbGFpbi1zYWZlKGMpIDo6PSBjID0gZmxvdy1vdXQgIOKHkiBucy1wbGFpbi1zYWZlLW91dFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBmbG93LWluICAg4oeSIG5zLXBsYWluLXNhZmUtaW5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gYmxvY2sta2V5IOKHkiBucy1wbGFpbi1zYWZlLW91dFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBmbG93LWtleSAg4oeSIG5zLXBsYWluLXNhZmUtaW5cbi8vIFsxMjhdIG5zLXBsYWluLXNhZmUtb3V0IDo6PSBucy1jaGFyXG4vLyBbMTI5XSAgbnMtcGxhaW4tc2FmZS1pbiA6Oj0gbnMtY2hhciAtIGMtZmxvdy1pbmRpY2F0b3Jcbi8vIFsxMzBdICBucy1wbGFpbi1jaGFyKGMpIDo6PSAgKCBucy1wbGFpbi1zYWZlKGMpIC0g4oCcOuKAnSAtIOKAnCPigJ0gKVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAoIC8qIEFuIG5zLWNoYXIgcHJlY2VkaW5nICovIOKAnCPigJ0gKVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAoIOKAnDrigJ0gLyogRm9sbG93ZWQgYnkgYW4gbnMtcGxhaW4tc2FmZShjKSAqLyApXG5mdW5jdGlvbiBpc1BsYWluU2FmZShjLCBwcmV2LCBpbmJsb2NrKSB7XG4gIHZhciBjSXNOc0NoYXJPcldoaXRlc3BhY2UgPSBpc05zQ2hhck9yV2hpdGVzcGFjZShjKTtcbiAgdmFyIGNJc05zQ2hhciA9IGNJc05zQ2hhck9yV2hpdGVzcGFjZSAmJiAhaXNXaGl0ZXNwYWNlKGMpO1xuICByZXR1cm4gKFxuICAgIC8vIG5zLXBsYWluLXNhZmVcbiAgICBpbmJsb2NrID8gLy8gYyA9IGZsb3ctaW5cbiAgICAgIGNJc05zQ2hhck9yV2hpdGVzcGFjZVxuICAgICAgOiBjSXNOc0NoYXJPcldoaXRlc3BhY2VcbiAgICAgICAgLy8gLSBjLWZsb3ctaW5kaWNhdG9yXG4gICAgICAgICYmIGMgIT09IENIQVJfQ09NTUFcbiAgICAgICAgJiYgYyAhPT0gQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUXG4gICAgICAgICYmIGMgIT09IENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVRcbiAgICAgICAgJiYgYyAhPT0gQ0hBUl9MRUZUX0NVUkxZX0JSQUNLRVRcbiAgICAgICAgJiYgYyAhPT0gQ0hBUl9SSUdIVF9DVVJMWV9CUkFDS0VUXG4gIClcbiAgICAvLyBucy1wbGFpbi1jaGFyXG4gICAgJiYgYyAhPT0gQ0hBUl9TSEFSUCAvLyBmYWxzZSBvbiAnIydcbiAgICAmJiAhKHByZXYgPT09IENIQVJfQ09MT04gJiYgIWNJc05zQ2hhcikgLy8gZmFsc2Ugb24gJzogJ1xuICAgIHx8IChpc05zQ2hhck9yV2hpdGVzcGFjZShwcmV2KSAmJiAhaXNXaGl0ZXNwYWNlKHByZXYpICYmIGMgPT09IENIQVJfU0hBUlApIC8vIGNoYW5nZSB0byB0cnVlIG9uICdbXiBdIydcbiAgICB8fCAocHJldiA9PT0gQ0hBUl9DT0xPTiAmJiBjSXNOc0NoYXIpOyAvLyBjaGFuZ2UgdG8gdHJ1ZSBvbiAnOlteIF0nXG59XG5cbi8vIFNpbXBsaWZpZWQgdGVzdCBmb3IgdmFsdWVzIGFsbG93ZWQgYXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBwbGFpbiBzdHlsZS5cbmZ1bmN0aW9uIGlzUGxhaW5TYWZlRmlyc3QoYykge1xuICAvLyBVc2VzIGEgc3Vic2V0IG9mIG5zLWNoYXIgLSBjLWluZGljYXRvclxuICAvLyB3aGVyZSBucy1jaGFyID0gbmItY2hhciAtIHMtd2hpdGUuXG4gIC8vIE5vIHN1cHBvcnQgb2YgKCAoIOKAnD/igJ0gfCDigJw64oCdIHwg4oCcLeKAnSApIC8qIEZvbGxvd2VkIGJ5IGFuIG5zLXBsYWluLXNhZmUoYykpICovICkgcGFydFxuICByZXR1cm4gaXNQcmludGFibGUoYykgJiYgYyAhPT0gQ0hBUl9CT01cbiAgICAmJiAhaXNXaGl0ZXNwYWNlKGMpIC8vIC0gcy13aGl0ZVxuICAgIC8vIC0gKGMtaW5kaWNhdG9yIDo6PVxuICAgIC8vIOKAnC3igJ0gfCDigJw/4oCdIHwg4oCcOuKAnSB8IOKAnCzigJ0gfCDigJxb4oCdIHwg4oCcXeKAnSB8IOKAnHvigJ0gfCDigJx94oCdXG4gICAgJiYgYyAhPT0gQ0hBUl9NSU5VU1xuICAgICYmIGMgIT09IENIQVJfUVVFU1RJT05cbiAgICAmJiBjICE9PSBDSEFSX0NPTE9OXG4gICAgJiYgYyAhPT0gQ0hBUl9DT01NQVxuICAgICYmIGMgIT09IENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVRcbiAgICAmJiBjICE9PSBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVFxuICAgIC8vIHwg4oCcI+KAnSB8IOKAnCbigJ0gfCDigJwq4oCdIHwg4oCcIeKAnSB8IOKAnHzigJ0gfCDigJw94oCdIHwg4oCcPuKAnSB8IOKAnCfigJ0gfCDigJxcIuKAnVxuICAgICYmIGMgIT09IENIQVJfU0hBUlBcbiAgICAmJiBjICE9PSBDSEFSX0FNUEVSU0FORFxuICAgICYmIGMgIT09IENIQVJfQVNURVJJU0tcbiAgICAmJiBjICE9PSBDSEFSX0VYQ0xBTUFUSU9OXG4gICAgJiYgYyAhPT0gQ0hBUl9WRVJUSUNBTF9MSU5FXG4gICAgJiYgYyAhPT0gQ0hBUl9FUVVBTFNcbiAgICAmJiBjICE9PSBDSEFSX0dSRUFURVJfVEhBTlxuICAgICYmIGMgIT09IENIQVJfU0lOR0xFX1FVT1RFXG4gICAgJiYgYyAhPT0gQ0hBUl9ET1VCTEVfUVVPVEVcbiAgICAvLyB8IOKAnCXigJ0gfCDigJxA4oCdIHwg4oCcYOKAnSlcbiAgICAmJiBjICE9PSBDSEFSX1BFUkNFTlRcbiAgICAmJiBjICE9PSBDSEFSX0NPTU1FUkNJQUxfQVRcbiAgICAmJiBjICE9PSBDSEFSX0dSQVZFX0FDQ0VOVDtcbn1cblxuLy8gU2ltcGxpZmllZCB0ZXN0IGZvciB2YWx1ZXMgYWxsb3dlZCBhcyB0aGUgbGFzdCBjaGFyYWN0ZXIgaW4gcGxhaW4gc3R5bGUuXG5mdW5jdGlvbiBpc1BsYWluU2FmZUxhc3QoYykge1xuICAvLyBqdXN0IG5vdCB3aGl0ZXNwYWNlIG9yIGNvbG9uLCBpdCB3aWxsIGJlIGNoZWNrZWQgdG8gYmUgcGxhaW4gY2hhcmFjdGVyIGxhdGVyXG4gIHJldHVybiAhaXNXaGl0ZXNwYWNlKGMpICYmIGMgIT09IENIQVJfQ09MT047XG59XG5cbi8vIFNhbWUgYXMgJ3N0cmluZycuY29kZVBvaW50QXQocG9zKSwgYnV0IHdvcmtzIGluIG9sZGVyIGJyb3dzZXJzLlxuZnVuY3Rpb24gY29kZVBvaW50QXQoc3RyaW5nLCBwb3MpIHtcbiAgdmFyIGZpcnN0ID0gc3RyaW5nLmNoYXJDb2RlQXQocG9zKSwgc2Vjb25kO1xuICBpZiAoZmlyc3QgPj0gMHhEODAwICYmIGZpcnN0IDw9IDB4REJGRiAmJiBwb3MgKyAxIDwgc3RyaW5nLmxlbmd0aCkge1xuICAgIHNlY29uZCA9IHN0cmluZy5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICAgIGlmIChzZWNvbmQgPj0gMHhEQzAwICYmIHNlY29uZCA8PSAweERGRkYpIHtcbiAgICAgIC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuICAgICAgcmV0dXJuIChmaXJzdCAtIDB4RDgwMCkgKiAweDQwMCArIHNlY29uZCAtIDB4REMwMCArIDB4MTAwMDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaXJzdDtcbn1cblxuLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIGJsb2NrIGluZGVudGF0aW9uIGluZGljYXRvciBpcyByZXF1aXJlZC5cbmZ1bmN0aW9uIG5lZWRJbmRlbnRJbmRpY2F0b3Ioc3RyaW5nKSB7XG4gIHZhciBsZWFkaW5nU3BhY2VSZSA9IC9eXFxuKiAvO1xuICByZXR1cm4gbGVhZGluZ1NwYWNlUmUudGVzdChzdHJpbmcpO1xufVxuXG52YXIgU1RZTEVfUExBSU4gICA9IDEsXG4gICAgU1RZTEVfU0lOR0xFICA9IDIsXG4gICAgU1RZTEVfTElURVJBTCA9IDMsXG4gICAgU1RZTEVfRk9MREVEICA9IDQsXG4gICAgU1RZTEVfRE9VQkxFICA9IDU7XG5cbi8vIERldGVybWluZXMgd2hpY2ggc2NhbGFyIHN0eWxlcyBhcmUgcG9zc2libGUgYW5kIHJldHVybnMgdGhlIHByZWZlcnJlZCBzdHlsZS5cbi8vIGxpbmVXaWR0aCA9IC0xID0+IG5vIGxpbWl0LlxuLy8gUHJlLWNvbmRpdGlvbnM6IHN0ci5sZW5ndGggPiAwLlxuLy8gUG9zdC1jb25kaXRpb25zOlxuLy8gICAgU1RZTEVfUExBSU4gb3IgU1RZTEVfU0lOR0xFID0+IG5vIFxcbiBhcmUgaW4gdGhlIHN0cmluZy5cbi8vICAgIFNUWUxFX0xJVEVSQUwgPT4gbm8gbGluZXMgYXJlIHN1aXRhYmxlIGZvciBmb2xkaW5nIChvciBsaW5lV2lkdGggaXMgLTEpLlxuLy8gICAgU1RZTEVfRk9MREVEID0+IGEgbGluZSA+IGxpbmVXaWR0aCBhbmQgY2FuIGJlIGZvbGRlZCAoYW5kIGxpbmVXaWR0aCAhPSAtMSkuXG5mdW5jdGlvbiBjaG9vc2VTY2FsYXJTdHlsZShzdHJpbmcsIHNpbmdsZUxpbmVPbmx5LCBpbmRlbnRQZXJMZXZlbCwgbGluZVdpZHRoLFxuICB0ZXN0QW1iaWd1b3VzVHlwZSwgcXVvdGluZ1R5cGUsIGZvcmNlUXVvdGVzLCBpbmJsb2NrKSB7XG5cbiAgdmFyIGk7XG4gIHZhciBjaGFyID0gMDtcbiAgdmFyIHByZXZDaGFyID0gbnVsbDtcbiAgdmFyIGhhc0xpbmVCcmVhayA9IGZhbHNlO1xuICB2YXIgaGFzRm9sZGFibGVMaW5lID0gZmFsc2U7IC8vIG9ubHkgY2hlY2tlZCBpZiBzaG91bGRUcmFja1dpZHRoXG4gIHZhciBzaG91bGRUcmFja1dpZHRoID0gbGluZVdpZHRoICE9PSAtMTtcbiAgdmFyIHByZXZpb3VzTGluZUJyZWFrID0gLTE7IC8vIGNvdW50IHRoZSBmaXJzdCBsaW5lIGNvcnJlY3RseVxuICB2YXIgcGxhaW4gPSBpc1BsYWluU2FmZUZpcnN0KGNvZGVQb2ludEF0KHN0cmluZywgMCkpXG4gICAgICAgICAgJiYgaXNQbGFpblNhZmVMYXN0KGNvZGVQb2ludEF0KHN0cmluZywgc3RyaW5nLmxlbmd0aCAtIDEpKTtcblxuICBpZiAoc2luZ2xlTGluZU9ubHkgfHwgZm9yY2VRdW90ZXMpIHtcbiAgICAvLyBDYXNlOiBubyBibG9jayBzdHlsZXMuXG4gICAgLy8gQ2hlY2sgZm9yIGRpc2FsbG93ZWQgY2hhcmFjdGVycyB0byBydWxlIG91dCBwbGFpbiBhbmQgc2luZ2xlLlxuICAgIGZvciAoaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBjaGFyID49IDB4MTAwMDAgPyBpICs9IDIgOiBpKyspIHtcbiAgICAgIGNoYXIgPSBjb2RlUG9pbnRBdChzdHJpbmcsIGkpO1xuICAgICAgaWYgKCFpc1ByaW50YWJsZShjaGFyKSkge1xuICAgICAgICByZXR1cm4gU1RZTEVfRE9VQkxFO1xuICAgICAgfVxuICAgICAgcGxhaW4gPSBwbGFpbiAmJiBpc1BsYWluU2FmZShjaGFyLCBwcmV2Q2hhciwgaW5ibG9jayk7XG4gICAgICBwcmV2Q2hhciA9IGNoYXI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIENhc2U6IGJsb2NrIHN0eWxlcyBwZXJtaXR0ZWQuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGNoYXIgPj0gMHgxMDAwMCA/IGkgKz0gMiA6IGkrKykge1xuICAgICAgY2hhciA9IGNvZGVQb2ludEF0KHN0cmluZywgaSk7XG4gICAgICBpZiAoY2hhciA9PT0gQ0hBUl9MSU5FX0ZFRUQpIHtcbiAgICAgICAgaGFzTGluZUJyZWFrID0gdHJ1ZTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgYW55IGxpbmUgY2FuIGJlIGZvbGRlZC5cbiAgICAgICAgaWYgKHNob3VsZFRyYWNrV2lkdGgpIHtcbiAgICAgICAgICBoYXNGb2xkYWJsZUxpbmUgPSBoYXNGb2xkYWJsZUxpbmUgfHxcbiAgICAgICAgICAgIC8vIEZvbGRhYmxlIGxpbmUgPSB0b28gbG9uZywgYW5kIG5vdCBtb3JlLWluZGVudGVkLlxuICAgICAgICAgICAgKGkgLSBwcmV2aW91c0xpbmVCcmVhayAtIDEgPiBsaW5lV2lkdGggJiZcbiAgICAgICAgICAgICBzdHJpbmdbcHJldmlvdXNMaW5lQnJlYWsgKyAxXSAhPT0gJyAnKTtcbiAgICAgICAgICBwcmV2aW91c0xpbmVCcmVhayA9IGk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWlzUHJpbnRhYmxlKGNoYXIpKSB7XG4gICAgICAgIHJldHVybiBTVFlMRV9ET1VCTEU7XG4gICAgICB9XG4gICAgICBwbGFpbiA9IHBsYWluICYmIGlzUGxhaW5TYWZlKGNoYXIsIHByZXZDaGFyLCBpbmJsb2NrKTtcbiAgICAgIHByZXZDaGFyID0gY2hhcjtcbiAgICB9XG4gICAgLy8gaW4gY2FzZSB0aGUgZW5kIGlzIG1pc3NpbmcgYSBcXG5cbiAgICBoYXNGb2xkYWJsZUxpbmUgPSBoYXNGb2xkYWJsZUxpbmUgfHwgKHNob3VsZFRyYWNrV2lkdGggJiZcbiAgICAgIChpIC0gcHJldmlvdXNMaW5lQnJlYWsgLSAxID4gbGluZVdpZHRoICYmXG4gICAgICAgc3RyaW5nW3ByZXZpb3VzTGluZUJyZWFrICsgMV0gIT09ICcgJykpO1xuICB9XG4gIC8vIEFsdGhvdWdoIGV2ZXJ5IHN0eWxlIGNhbiByZXByZXNlbnQgXFxuIHdpdGhvdXQgZXNjYXBpbmcsIHByZWZlciBibG9jayBzdHlsZXNcbiAgLy8gZm9yIG11bHRpbGluZSwgc2luY2UgdGhleSdyZSBtb3JlIHJlYWRhYmxlIGFuZCB0aGV5IGRvbid0IGFkZCBlbXB0eSBsaW5lcy5cbiAgLy8gQWxzbyBwcmVmZXIgZm9sZGluZyBhIHN1cGVyLWxvbmcgbGluZS5cbiAgaWYgKCFoYXNMaW5lQnJlYWsgJiYgIWhhc0ZvbGRhYmxlTGluZSkge1xuICAgIC8vIFN0cmluZ3MgaW50ZXJwcmV0YWJsZSBhcyBhbm90aGVyIHR5cGUgaGF2ZSB0byBiZSBxdW90ZWQ7XG4gICAgLy8gZS5nLiB0aGUgc3RyaW5nICd0cnVlJyB2cy4gdGhlIGJvb2xlYW4gdHJ1ZS5cbiAgICBpZiAocGxhaW4gJiYgIWZvcmNlUXVvdGVzICYmICF0ZXN0QW1iaWd1b3VzVHlwZShzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gU1RZTEVfUExBSU47XG4gICAgfVxuICAgIHJldHVybiBxdW90aW5nVHlwZSA9PT0gUVVPVElOR19UWVBFX0RPVUJMRSA/IFNUWUxFX0RPVUJMRSA6IFNUWUxFX1NJTkdMRTtcbiAgfVxuICAvLyBFZGdlIGNhc2U6IGJsb2NrIGluZGVudGF0aW9uIGluZGljYXRvciBjYW4gb25seSBoYXZlIG9uZSBkaWdpdC5cbiAgaWYgKGluZGVudFBlckxldmVsID4gOSAmJiBuZWVkSW5kZW50SW5kaWNhdG9yKHN0cmluZykpIHtcbiAgICByZXR1cm4gU1RZTEVfRE9VQkxFO1xuICB9XG4gIC8vIEF0IHRoaXMgcG9pbnQgd2Uga25vdyBibG9jayBzdHlsZXMgYXJlIHZhbGlkLlxuICAvLyBQcmVmZXIgbGl0ZXJhbCBzdHlsZSB1bmxlc3Mgd2Ugd2FudCB0byBmb2xkLlxuICBpZiAoIWZvcmNlUXVvdGVzKSB7XG4gICAgcmV0dXJuIGhhc0ZvbGRhYmxlTGluZSA/IFNUWUxFX0ZPTERFRCA6IFNUWUxFX0xJVEVSQUw7XG4gIH1cbiAgcmV0dXJuIHF1b3RpbmdUeXBlID09PSBRVU9USU5HX1RZUEVfRE9VQkxFID8gU1RZTEVfRE9VQkxFIDogU1RZTEVfU0lOR0xFO1xufVxuXG4vLyBOb3RlOiBsaW5lIGJyZWFraW5nL2ZvbGRpbmcgaXMgaW1wbGVtZW50ZWQgZm9yIG9ubHkgdGhlIGZvbGRlZCBzdHlsZS5cbi8vIE5CLiBXZSBkcm9wIHRoZSBsYXN0IHRyYWlsaW5nIG5ld2xpbmUgKGlmIGFueSkgb2YgYSByZXR1cm5lZCBibG9jayBzY2FsYXJcbi8vICBzaW5jZSB0aGUgZHVtcGVyIGFkZHMgaXRzIG93biBuZXdsaW5lLiBUaGlzIGFsd2F5cyB3b3Jrczpcbi8vICAgIOKAoiBObyBlbmRpbmcgbmV3bGluZSA9PiB1bmFmZmVjdGVkOyBhbHJlYWR5IHVzaW5nIHN0cmlwIFwiLVwiIGNob21waW5nLlxuLy8gICAg4oCiIEVuZGluZyBuZXdsaW5lICAgID0+IHJlbW92ZWQgdGhlbiByZXN0b3JlZC5cbi8vICBJbXBvcnRhbnRseSwgdGhpcyBrZWVwcyB0aGUgXCIrXCIgY2hvbXAgaW5kaWNhdG9yIGZyb20gZ2FpbmluZyBhbiBleHRyYSBsaW5lLlxuZnVuY3Rpb24gd3JpdGVTY2FsYXIoc3RhdGUsIHN0cmluZywgbGV2ZWwsIGlza2V5LCBpbmJsb2NrKSB7XG4gIHN0YXRlLmR1bXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGlmIChzdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gc3RhdGUucXVvdGluZ1R5cGUgPT09IFFVT1RJTkdfVFlQRV9ET1VCTEUgPyAnXCJcIicgOiBcIicnXCI7XG4gICAgfVxuICAgIGlmICghc3RhdGUubm9Db21wYXRNb2RlKSB7XG4gICAgICBpZiAoREVQUkVDQVRFRF9CT09MRUFOU19TWU5UQVguaW5kZXhPZihzdHJpbmcpICE9PSAtMSB8fCBERVBSRUNBVEVEX0JBU0U2MF9TWU5UQVgudGVzdChzdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5xdW90aW5nVHlwZSA9PT0gUVVPVElOR19UWVBFX0RPVUJMRSA/ICgnXCInICsgc3RyaW5nICsgJ1wiJykgOiAoXCInXCIgKyBzdHJpbmcgKyBcIidcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGluZGVudCA9IHN0YXRlLmluZGVudCAqIE1hdGgubWF4KDEsIGxldmVsKTsgLy8gbm8gMC1pbmRlbnQgc2NhbGFyc1xuICAgIC8vIEFzIGluZGVudGF0aW9uIGdldHMgZGVlcGVyLCBsZXQgdGhlIHdpZHRoIGRlY3JlYXNlIG1vbm90b25pY2FsbHlcbiAgICAvLyB0byB0aGUgbG93ZXIgYm91bmQgbWluKHN0YXRlLmxpbmVXaWR0aCwgNDApLlxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIGltcGxpZXNcbiAgICAvLyAgc3RhdGUubGluZVdpZHRoIOKJpCA0MCArIHN0YXRlLmluZGVudDogd2lkdGggaXMgZml4ZWQgYXQgdGhlIGxvd2VyIGJvdW5kLlxuICAgIC8vICBzdGF0ZS5saW5lV2lkdGggPiA0MCArIHN0YXRlLmluZGVudDogd2lkdGggZGVjcmVhc2VzIHVudGlsIHRoZSBsb3dlciBib3VuZC5cbiAgICAvLyBUaGlzIGJlaGF2ZXMgYmV0dGVyIHRoYW4gYSBjb25zdGFudCBtaW5pbXVtIHdpZHRoIHdoaWNoIGRpc2FsbG93cyBuYXJyb3dlciBvcHRpb25zLFxuICAgIC8vIG9yIGFuIGluZGVudCB0aHJlc2hvbGQgd2hpY2ggY2F1c2VzIHRoZSB3aWR0aCB0byBzdWRkZW5seSBpbmNyZWFzZS5cbiAgICB2YXIgbGluZVdpZHRoID0gc3RhdGUubGluZVdpZHRoID09PSAtMVxuICAgICAgPyAtMSA6IE1hdGgubWF4KE1hdGgubWluKHN0YXRlLmxpbmVXaWR0aCwgNDApLCBzdGF0ZS5saW5lV2lkdGggLSBpbmRlbnQpO1xuXG4gICAgLy8gV2l0aG91dCBrbm93aW5nIGlmIGtleXMgYXJlIGltcGxpY2l0L2V4cGxpY2l0LCBhc3N1bWUgaW1wbGljaXQgZm9yIHNhZmV0eS5cbiAgICB2YXIgc2luZ2xlTGluZU9ubHkgPSBpc2tleVxuICAgICAgLy8gTm8gYmxvY2sgc3R5bGVzIGluIGZsb3cgbW9kZS5cbiAgICAgIHx8IChzdGF0ZS5mbG93TGV2ZWwgPiAtMSAmJiBsZXZlbCA+PSBzdGF0ZS5mbG93TGV2ZWwpO1xuICAgIGZ1bmN0aW9uIHRlc3RBbWJpZ3VpdHkoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gdGVzdEltcGxpY2l0UmVzb2x2aW5nKHN0YXRlLCBzdHJpbmcpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY2hvb3NlU2NhbGFyU3R5bGUoc3RyaW5nLCBzaW5nbGVMaW5lT25seSwgc3RhdGUuaW5kZW50LCBsaW5lV2lkdGgsXG4gICAgICB0ZXN0QW1iaWd1aXR5LCBzdGF0ZS5xdW90aW5nVHlwZSwgc3RhdGUuZm9yY2VRdW90ZXMgJiYgIWlza2V5LCBpbmJsb2NrKSkge1xuXG4gICAgICBjYXNlIFNUWUxFX1BMQUlOOlxuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgY2FzZSBTVFlMRV9TSU5HTEU6XG4gICAgICAgIHJldHVybiBcIidcIiArIHN0cmluZy5yZXBsYWNlKC8nL2csIFwiJydcIikgKyBcIidcIjtcbiAgICAgIGNhc2UgU1RZTEVfTElURVJBTDpcbiAgICAgICAgcmV0dXJuICd8JyArIGJsb2NrSGVhZGVyKHN0cmluZywgc3RhdGUuaW5kZW50KVxuICAgICAgICAgICsgZHJvcEVuZGluZ05ld2xpbmUoaW5kZW50U3RyaW5nKHN0cmluZywgaW5kZW50KSk7XG4gICAgICBjYXNlIFNUWUxFX0ZPTERFRDpcbiAgICAgICAgcmV0dXJuICc+JyArIGJsb2NrSGVhZGVyKHN0cmluZywgc3RhdGUuaW5kZW50KVxuICAgICAgICAgICsgZHJvcEVuZGluZ05ld2xpbmUoaW5kZW50U3RyaW5nKGZvbGRTdHJpbmcoc3RyaW5nLCBsaW5lV2lkdGgpLCBpbmRlbnQpKTtcbiAgICAgIGNhc2UgU1RZTEVfRE9VQkxFOlxuICAgICAgICByZXR1cm4gJ1wiJyArIGVzY2FwZVN0cmluZyhzdHJpbmcpICsgJ1wiJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb24oJ2ltcG9zc2libGUgZXJyb3I6IGludmFsaWQgc2NhbGFyIHN0eWxlJyk7XG4gICAgfVxuICB9KCkpO1xufVxuXG4vLyBQcmUtY29uZGl0aW9uczogc3RyaW5nIGlzIHZhbGlkIGZvciBhIGJsb2NrIHNjYWxhciwgMSA8PSBpbmRlbnRQZXJMZXZlbCA8PSA5LlxuZnVuY3Rpb24gYmxvY2tIZWFkZXIoc3RyaW5nLCBpbmRlbnRQZXJMZXZlbCkge1xuICB2YXIgaW5kZW50SW5kaWNhdG9yID0gbmVlZEluZGVudEluZGljYXRvcihzdHJpbmcpID8gU3RyaW5nKGluZGVudFBlckxldmVsKSA6ICcnO1xuXG4gIC8vIG5vdGUgdGhlIHNwZWNpYWwgY2FzZTogdGhlIHN0cmluZyAnXFxuJyBjb3VudHMgYXMgYSBcInRyYWlsaW5nXCIgZW1wdHkgbGluZS5cbiAgdmFyIGNsaXAgPSAgICAgICAgICBzdHJpbmdbc3RyaW5nLmxlbmd0aCAtIDFdID09PSAnXFxuJztcbiAgdmFyIGtlZXAgPSBjbGlwICYmIChzdHJpbmdbc3RyaW5nLmxlbmd0aCAtIDJdID09PSAnXFxuJyB8fCBzdHJpbmcgPT09ICdcXG4nKTtcbiAgdmFyIGNob21wID0ga2VlcCA/ICcrJyA6IChjbGlwID8gJycgOiAnLScpO1xuXG4gIHJldHVybiBpbmRlbnRJbmRpY2F0b3IgKyBjaG9tcCArICdcXG4nO1xufVxuXG4vLyAoU2VlIHRoZSBub3RlIGZvciB3cml0ZVNjYWxhci4pXG5mdW5jdGlvbiBkcm9wRW5kaW5nTmV3bGluZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gMV0gPT09ICdcXG4nID8gc3RyaW5nLnNsaWNlKDAsIC0xKSA6IHN0cmluZztcbn1cblxuLy8gTm90ZTogYSBsb25nIGxpbmUgd2l0aG91dCBhIHN1aXRhYmxlIGJyZWFrIHBvaW50IHdpbGwgZXhjZWVkIHRoZSB3aWR0aCBsaW1pdC5cbi8vIFByZS1jb25kaXRpb25zOiBldmVyeSBjaGFyIGluIHN0ciBpc1ByaW50YWJsZSwgc3RyLmxlbmd0aCA+IDAsIHdpZHRoID4gMC5cbmZ1bmN0aW9uIGZvbGRTdHJpbmcoc3RyaW5nLCB3aWR0aCkge1xuICAvLyBJbiBmb2xkZWQgc3R5bGUsICRrJCBjb25zZWN1dGl2ZSBuZXdsaW5lcyBvdXRwdXQgYXMgJGsrMSQgbmV3bGluZXPigJRcbiAgLy8gdW5sZXNzIHRoZXkncmUgYmVmb3JlIG9yIGFmdGVyIGEgbW9yZS1pbmRlbnRlZCBsaW5lLCBvciBhdCB0aGUgdmVyeVxuICAvLyBiZWdpbm5pbmcgb3IgZW5kLCBpbiB3aGljaCBjYXNlICRrJCBtYXBzIHRvICRrJC5cbiAgLy8gVGhlcmVmb3JlLCBwYXJzZSBlYWNoIGNodW5rIGFzIG5ld2xpbmUocykgZm9sbG93ZWQgYnkgYSBjb250ZW50IGxpbmUuXG4gIHZhciBsaW5lUmUgPSAvKFxcbispKFteXFxuXSopL2c7XG5cbiAgLy8gZmlyc3QgbGluZSAocG9zc2libHkgYW4gZW1wdHkgbGluZSlcbiAgdmFyIHJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5leHRMRiA9IHN0cmluZy5pbmRleE9mKCdcXG4nKTtcbiAgICBuZXh0TEYgPSBuZXh0TEYgIT09IC0xID8gbmV4dExGIDogc3RyaW5nLmxlbmd0aDtcbiAgICBsaW5lUmUubGFzdEluZGV4ID0gbmV4dExGO1xuICAgIHJldHVybiBmb2xkTGluZShzdHJpbmcuc2xpY2UoMCwgbmV4dExGKSwgd2lkdGgpO1xuICB9KCkpO1xuICAvLyBJZiB3ZSBoYXZlbid0IHJlYWNoZWQgdGhlIGZpcnN0IGNvbnRlbnQgbGluZSB5ZXQsIGRvbid0IGFkZCBhbiBleHRyYSBcXG4uXG4gIHZhciBwcmV2TW9yZUluZGVudGVkID0gc3RyaW5nWzBdID09PSAnXFxuJyB8fCBzdHJpbmdbMF0gPT09ICcgJztcbiAgdmFyIG1vcmVJbmRlbnRlZDtcblxuICAvLyByZXN0IG9mIHRoZSBsaW5lc1xuICB2YXIgbWF0Y2g7XG4gIHdoaWxlICgobWF0Y2ggPSBsaW5lUmUuZXhlYyhzdHJpbmcpKSkge1xuICAgIHZhciBwcmVmaXggPSBtYXRjaFsxXSwgbGluZSA9IG1hdGNoWzJdO1xuICAgIG1vcmVJbmRlbnRlZCA9IChsaW5lWzBdID09PSAnICcpO1xuICAgIHJlc3VsdCArPSBwcmVmaXhcbiAgICAgICsgKCFwcmV2TW9yZUluZGVudGVkICYmICFtb3JlSW5kZW50ZWQgJiYgbGluZSAhPT0gJydcbiAgICAgICAgPyAnXFxuJyA6ICcnKVxuICAgICAgKyBmb2xkTGluZShsaW5lLCB3aWR0aCk7XG4gICAgcHJldk1vcmVJbmRlbnRlZCA9IG1vcmVJbmRlbnRlZDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIEdyZWVkeSBsaW5lIGJyZWFraW5nLlxuLy8gUGlja3MgdGhlIGxvbmdlc3QgbGluZSB1bmRlciB0aGUgbGltaXQgZWFjaCB0aW1lLFxuLy8gb3RoZXJ3aXNlIHNldHRsZXMgZm9yIHRoZSBzaG9ydGVzdCBsaW5lIG92ZXIgdGhlIGxpbWl0LlxuLy8gTkIuIE1vcmUtaW5kZW50ZWQgbGluZXMgKmNhbm5vdCogYmUgZm9sZGVkLCBhcyB0aGF0IHdvdWxkIGFkZCBhbiBleHRyYSBcXG4uXG5mdW5jdGlvbiBmb2xkTGluZShsaW5lLCB3aWR0aCkge1xuICBpZiAobGluZSA9PT0gJycgfHwgbGluZVswXSA9PT0gJyAnKSByZXR1cm4gbGluZTtcblxuICAvLyBTaW5jZSBhIG1vcmUtaW5kZW50ZWQgbGluZSBhZGRzIGEgXFxuLCBicmVha3MgY2FuJ3QgYmUgZm9sbG93ZWQgYnkgYSBzcGFjZS5cbiAgdmFyIGJyZWFrUmUgPSAvIFteIF0vZzsgLy8gbm90ZTogdGhlIG1hdGNoIGluZGV4IHdpbGwgYWx3YXlzIGJlIDw9IGxlbmd0aC0yLlxuICB2YXIgbWF0Y2g7XG4gIC8vIHN0YXJ0IGlzIGFuIGluY2x1c2l2ZSBpbmRleC4gZW5kLCBjdXJyLCBhbmQgbmV4dCBhcmUgZXhjbHVzaXZlLlxuICB2YXIgc3RhcnQgPSAwLCBlbmQsIGN1cnIgPSAwLCBuZXh0ID0gMDtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIC8vIEludmFyaWFudHM6IDAgPD0gc3RhcnQgPD0gbGVuZ3RoLTEuXG4gIC8vICAgMCA8PSBjdXJyIDw9IG5leHQgPD0gbWF4KDAsIGxlbmd0aC0yKS4gY3VyciAtIHN0YXJ0IDw9IHdpZHRoLlxuICAvLyBJbnNpZGUgdGhlIGxvb3A6XG4gIC8vICAgQSBtYXRjaCBpbXBsaWVzIGxlbmd0aCA+PSAyLCBzbyBjdXJyIGFuZCBuZXh0IGFyZSA8PSBsZW5ndGgtMi5cbiAgd2hpbGUgKChtYXRjaCA9IGJyZWFrUmUuZXhlYyhsaW5lKSkpIHtcbiAgICBuZXh0ID0gbWF0Y2guaW5kZXg7XG4gICAgLy8gbWFpbnRhaW4gaW52YXJpYW50OiBjdXJyIC0gc3RhcnQgPD0gd2lkdGhcbiAgICBpZiAobmV4dCAtIHN0YXJ0ID4gd2lkdGgpIHtcbiAgICAgIGVuZCA9IChjdXJyID4gc3RhcnQpID8gY3VyciA6IG5leHQ7IC8vIGRlcml2ZSBlbmQgPD0gbGVuZ3RoLTJcbiAgICAgIHJlc3VsdCArPSAnXFxuJyArIGxpbmUuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAvLyBza2lwIHRoZSBzcGFjZSB0aGF0IHdhcyBvdXRwdXQgYXMgXFxuXG4gICAgICBzdGFydCA9IGVuZCArIDE7ICAgICAgICAgICAgICAgICAgICAvLyBkZXJpdmUgc3RhcnQgPD0gbGVuZ3RoLTFcbiAgICB9XG4gICAgY3VyciA9IG5leHQ7XG4gIH1cblxuICAvLyBCeSB0aGUgaW52YXJpYW50cywgc3RhcnQgPD0gbGVuZ3RoLTEsIHNvIHRoZXJlIGlzIHNvbWV0aGluZyBsZWZ0IG92ZXIuXG4gIC8vIEl0IGlzIGVpdGhlciB0aGUgd2hvbGUgc3RyaW5nIG9yIGEgcGFydCBzdGFydGluZyBmcm9tIG5vbi13aGl0ZXNwYWNlLlxuICByZXN1bHQgKz0gJ1xcbic7XG4gIC8vIEluc2VydCBhIGJyZWFrIGlmIHRoZSByZW1haW5kZXIgaXMgdG9vIGxvbmcgYW5kIHRoZXJlIGlzIGEgYnJlYWsgYXZhaWxhYmxlLlxuICBpZiAobGluZS5sZW5ndGggLSBzdGFydCA+IHdpZHRoICYmIGN1cnIgPiBzdGFydCkge1xuICAgIHJlc3VsdCArPSBsaW5lLnNsaWNlKHN0YXJ0LCBjdXJyKSArICdcXG4nICsgbGluZS5zbGljZShjdXJyICsgMSk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ICs9IGxpbmUuc2xpY2Uoc3RhcnQpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5zbGljZSgxKTsgLy8gZHJvcCBleHRyYSBcXG4gam9pbmVyXG59XG5cbi8vIEVzY2FwZXMgYSBkb3VibGUtcXVvdGVkIHN0cmluZy5cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyhzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB2YXIgY2hhciA9IDA7XG4gIHZhciBlc2NhcGVTZXE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBjaGFyID49IDB4MTAwMDAgPyBpICs9IDIgOiBpKyspIHtcbiAgICBjaGFyID0gY29kZVBvaW50QXQoc3RyaW5nLCBpKTtcbiAgICBlc2NhcGVTZXEgPSBFU0NBUEVfU0VRVUVOQ0VTW2NoYXJdO1xuXG4gICAgaWYgKCFlc2NhcGVTZXEgJiYgaXNQcmludGFibGUoY2hhcikpIHtcbiAgICAgIHJlc3VsdCArPSBzdHJpbmdbaV07XG4gICAgICBpZiAoY2hhciA+PSAweDEwMDAwKSByZXN1bHQgKz0gc3RyaW5nW2kgKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IGVzY2FwZVNlcSB8fCBlbmNvZGVIZXgoY2hhcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG93U2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBvYmplY3QpIHtcbiAgdmFyIF9yZXN1bHQgPSAnJyxcbiAgICAgIF90YWcgICAgPSBzdGF0ZS50YWcsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIHZhbHVlO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHZhbHVlID0gb2JqZWN0W2luZGV4XTtcblxuICAgIGlmIChzdGF0ZS5yZXBsYWNlcikge1xuICAgICAgdmFsdWUgPSBzdGF0ZS5yZXBsYWNlci5jYWxsKG9iamVjdCwgU3RyaW5nKGluZGV4KSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8vIFdyaXRlIG9ubHkgdmFsaWQgZWxlbWVudHMsIHB1dCBudWxsIGluc3RlYWQgb2YgaW52YWxpZCBlbGVtZW50cy5cbiAgICBpZiAod3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgdmFsdWUsIGZhbHNlLCBmYWxzZSkgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgIHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG51bGwsIGZhbHNlLCBmYWxzZSkpKSB7XG5cbiAgICAgIGlmIChfcmVzdWx0ICE9PSAnJykgX3Jlc3VsdCArPSAnLCcgKyAoIXN0YXRlLmNvbmRlbnNlRmxvdyA/ICcgJyA6ICcnKTtcbiAgICAgIF9yZXN1bHQgKz0gc3RhdGUuZHVtcDtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gJ1snICsgX3Jlc3VsdCArICddJztcbn1cblxuZnVuY3Rpb24gd3JpdGVCbG9ja1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBjb21wYWN0KSB7XG4gIHZhciBfcmVzdWx0ID0gJycsXG4gICAgICBfdGFnICAgID0gc3RhdGUudGFnLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICB2YWx1ZTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB2YWx1ZSA9IG9iamVjdFtpbmRleF07XG5cbiAgICBpZiAoc3RhdGUucmVwbGFjZXIpIHtcbiAgICAgIHZhbHVlID0gc3RhdGUucmVwbGFjZXIuY2FsbChvYmplY3QsIFN0cmluZyhpbmRleCksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBXcml0ZSBvbmx5IHZhbGlkIGVsZW1lbnRzLCBwdXQgbnVsbCBpbnN0ZWFkIG9mIGludmFsaWQgZWxlbWVudHMuXG4gICAgaWYgKHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UsIHRydWUpIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICB3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgbnVsbCwgdHJ1ZSwgdHJ1ZSwgZmFsc2UsIHRydWUpKSkge1xuXG4gICAgICBpZiAoIWNvbXBhY3QgfHwgX3Jlc3VsdCAhPT0gJycpIHtcbiAgICAgICAgX3Jlc3VsdCArPSBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5kdW1wICYmIENIQVJfTElORV9GRUVEID09PSBzdGF0ZS5kdW1wLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgX3Jlc3VsdCArPSAnLSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcmVzdWx0ICs9ICctICc7XG4gICAgICB9XG5cbiAgICAgIF9yZXN1bHQgKz0gc3RhdGUuZHVtcDtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gX3Jlc3VsdCB8fCAnW10nOyAvLyBFbXB0eSBzZXF1ZW5jZSBpZiBubyB2YWxpZCB2YWx1ZXMuXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvd01hcHBpbmcoc3RhdGUsIGxldmVsLCBvYmplY3QpIHtcbiAgdmFyIF9yZXN1bHQgICAgICAgPSAnJyxcbiAgICAgIF90YWcgICAgICAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBvYmplY3RLZXlMaXN0ID0gT2JqZWN0LmtleXMob2JqZWN0KSxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoLFxuICAgICAgb2JqZWN0S2V5LFxuICAgICAgb2JqZWN0VmFsdWUsXG4gICAgICBwYWlyQnVmZmVyO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcblxuICAgIHBhaXJCdWZmZXIgPSAnJztcbiAgICBpZiAoX3Jlc3VsdCAhPT0gJycpIHBhaXJCdWZmZXIgKz0gJywgJztcblxuICAgIGlmIChzdGF0ZS5jb25kZW5zZUZsb3cpIHBhaXJCdWZmZXIgKz0gJ1wiJztcblxuICAgIG9iamVjdEtleSA9IG9iamVjdEtleUxpc3RbaW5kZXhdO1xuICAgIG9iamVjdFZhbHVlID0gb2JqZWN0W29iamVjdEtleV07XG5cbiAgICBpZiAoc3RhdGUucmVwbGFjZXIpIHtcbiAgICAgIG9iamVjdFZhbHVlID0gc3RhdGUucmVwbGFjZXIuY2FsbChvYmplY3QsIG9iamVjdEtleSwgb2JqZWN0VmFsdWUpO1xuICAgIH1cblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0S2V5LCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIGtleTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuZHVtcC5sZW5ndGggPiAxMDI0KSBwYWlyQnVmZmVyICs9ICc/ICc7XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXAgKyAoc3RhdGUuY29uZGVuc2VGbG93ID8gJ1wiJyA6ICcnKSArICc6JyArIChzdGF0ZS5jb25kZW5zZUZsb3cgPyAnJyA6ICcgJyk7XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG9iamVjdFZhbHVlLCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIHZhbHVlLlxuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDtcblxuICAgIC8vIEJvdGgga2V5IGFuZCB2YWx1ZSBhcmUgdmFsaWQuXG4gICAgX3Jlc3VsdCArPSBwYWlyQnVmZmVyO1xuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9ICd7JyArIF9yZXN1bHQgKyAnfSc7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQmxvY2tNYXBwaW5nKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBjb21wYWN0KSB7XG4gIHZhciBfcmVzdWx0ICAgICAgID0gJycsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCksXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIG9iamVjdEtleSxcbiAgICAgIG9iamVjdFZhbHVlLFxuICAgICAgZXhwbGljaXRQYWlyLFxuICAgICAgcGFpckJ1ZmZlcjtcblxuICAvLyBBbGxvdyBzb3J0aW5nIGtleXMgc28gdGhhdCB0aGUgb3V0cHV0IGZpbGUgaXMgZGV0ZXJtaW5pc3RpY1xuICBpZiAoc3RhdGUuc29ydEtleXMgPT09IHRydWUpIHtcbiAgICAvLyBEZWZhdWx0IHNvcnRpbmdcbiAgICBvYmplY3RLZXlMaXN0LnNvcnQoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3RhdGUuc29ydEtleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBDdXN0b20gc29ydCBmdW5jdGlvblxuICAgIG9iamVjdEtleUxpc3Quc29ydChzdGF0ZS5zb3J0S2V5cyk7XG4gIH0gZWxzZSBpZiAoc3RhdGUuc29ydEtleXMpIHtcbiAgICAvLyBTb21ldGhpbmcgaXMgd3JvbmdcbiAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdzb3J0S2V5cyBtdXN0IGJlIGEgYm9vbGVhbiBvciBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpckJ1ZmZlciA9ICcnO1xuXG4gICAgaWYgKCFjb21wYWN0IHx8IF9yZXN1bHQgIT09ICcnKSB7XG4gICAgICBwYWlyQnVmZmVyICs9IGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKTtcbiAgICB9XG5cbiAgICBvYmplY3RLZXkgPSBvYmplY3RLZXlMaXN0W2luZGV4XTtcbiAgICBvYmplY3RWYWx1ZSA9IG9iamVjdFtvYmplY3RLZXldO1xuXG4gICAgaWYgKHN0YXRlLnJlcGxhY2VyKSB7XG4gICAgICBvYmplY3RWYWx1ZSA9IHN0YXRlLnJlcGxhY2VyLmNhbGwob2JqZWN0LCBvYmplY3RLZXksIG9iamVjdFZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBvYmplY3RLZXksIHRydWUsIHRydWUsIHRydWUpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIGtleS5cbiAgICB9XG5cbiAgICBleHBsaWNpdFBhaXIgPSAoc3RhdGUudGFnICE9PSBudWxsICYmIHN0YXRlLnRhZyAhPT0gJz8nKSB8fFxuICAgICAgICAgICAgICAgICAgIChzdGF0ZS5kdW1wICYmIHN0YXRlLmR1bXAubGVuZ3RoID4gMTAyNCk7XG5cbiAgICBpZiAoZXhwbGljaXRQYWlyKSB7XG4gICAgICBpZiAoc3RhdGUuZHVtcCAmJiBDSEFSX0xJTkVfRkVFRCA9PT0gc3RhdGUuZHVtcC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgIHBhaXJCdWZmZXIgKz0gJz8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFpckJ1ZmZlciArPSAnPyAnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDtcblxuICAgIGlmIChleHBsaWNpdFBhaXIpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgIH1cblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIG9iamVjdFZhbHVlLCB0cnVlLCBleHBsaWNpdFBhaXIpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIHZhbHVlLlxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5kdW1wICYmIENIQVJfTElORV9GRUVEID09PSBzdGF0ZS5kdW1wLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gJzonO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWlyQnVmZmVyICs9ICc6ICc7XG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgLy8gQm90aCBrZXkgYW5kIHZhbHVlIGFyZSB2YWxpZC5cbiAgICBfcmVzdWx0ICs9IHBhaXJCdWZmZXI7XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gX3Jlc3VsdCB8fCAne30nOyAvLyBFbXB0eSBtYXBwaW5nIGlmIG5vIHZhbGlkIHBhaXJzLlxufVxuXG5mdW5jdGlvbiBkZXRlY3RUeXBlKHN0YXRlLCBvYmplY3QsIGV4cGxpY2l0KSB7XG4gIHZhciBfcmVzdWx0LCB0eXBlTGlzdCwgaW5kZXgsIGxlbmd0aCwgdHlwZSwgc3R5bGU7XG5cbiAgdHlwZUxpc3QgPSBleHBsaWNpdCA/IHN0YXRlLmV4cGxpY2l0VHlwZXMgOiBzdGF0ZS5pbXBsaWNpdFR5cGVzO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB0eXBlTGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdHlwZSA9IHR5cGVMaXN0W2luZGV4XTtcblxuICAgIGlmICgodHlwZS5pbnN0YW5jZU9mICB8fCB0eXBlLnByZWRpY2F0ZSkgJiZcbiAgICAgICAgKCF0eXBlLmluc3RhbmNlT2YgfHwgKCh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JykgJiYgKG9iamVjdCBpbnN0YW5jZW9mIHR5cGUuaW5zdGFuY2VPZikpKSAmJlxuICAgICAgICAoIXR5cGUucHJlZGljYXRlICB8fCB0eXBlLnByZWRpY2F0ZShvYmplY3QpKSkge1xuXG4gICAgICBpZiAoZXhwbGljaXQpIHtcbiAgICAgICAgaWYgKHR5cGUubXVsdGkgJiYgdHlwZS5yZXByZXNlbnROYW1lKSB7XG4gICAgICAgICAgc3RhdGUudGFnID0gdHlwZS5yZXByZXNlbnROYW1lKG9iamVjdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUudGFnID0gdHlwZS50YWc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnRhZyA9ICc/JztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUucmVwcmVzZW50KSB7XG4gICAgICAgIHN0eWxlID0gc3RhdGUuc3R5bGVNYXBbdHlwZS50YWddIHx8IHR5cGUuZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgIGlmIChfdG9TdHJpbmcuY2FsbCh0eXBlLnJlcHJlc2VudCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgICBfcmVzdWx0ID0gdHlwZS5yZXByZXNlbnQob2JqZWN0LCBzdHlsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5LmNhbGwodHlwZS5yZXByZXNlbnQsIHN0eWxlKSkge1xuICAgICAgICAgIF9yZXN1bHQgPSB0eXBlLnJlcHJlc2VudFtzdHlsZV0ob2JqZWN0LCBzdHlsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignITwnICsgdHlwZS50YWcgKyAnPiB0YWcgcmVzb2x2ZXIgYWNjZXB0cyBub3QgXCInICsgc3R5bGUgKyAnXCIgc3R5bGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmR1bXAgPSBfcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIFNlcmlhbGl6ZXMgYG9iamVjdGAgYW5kIHdyaXRlcyBpdCB0byBnbG9iYWwgYHJlc3VsdGAuXG4vLyBSZXR1cm5zIHRydWUgb24gc3VjY2Vzcywgb3IgZmFsc2Ugb24gaW52YWxpZCBvYmplY3QuXG4vL1xuZnVuY3Rpb24gd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBibG9jaywgY29tcGFjdCwgaXNrZXksIGlzYmxvY2tzZXEpIHtcbiAgc3RhdGUudGFnID0gbnVsbDtcbiAgc3RhdGUuZHVtcCA9IG9iamVjdDtcblxuICBpZiAoIWRldGVjdFR5cGUoc3RhdGUsIG9iamVjdCwgZmFsc2UpKSB7XG4gICAgZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCB0cnVlKTtcbiAgfVxuXG4gIHZhciB0eXBlID0gX3RvU3RyaW5nLmNhbGwoc3RhdGUuZHVtcCk7XG4gIHZhciBpbmJsb2NrID0gYmxvY2s7XG4gIHZhciB0YWdTdHI7XG5cbiAgaWYgKGJsb2NrKSB7XG4gICAgYmxvY2sgPSAoc3RhdGUuZmxvd0xldmVsIDwgMCB8fCBzdGF0ZS5mbG93TGV2ZWwgPiBsZXZlbCk7XG4gIH1cblxuICB2YXIgb2JqZWN0T3JBcnJheSA9IHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBkdXBsaWNhdGVJbmRleCxcbiAgICAgIGR1cGxpY2F0ZTtcblxuICBpZiAob2JqZWN0T3JBcnJheSkge1xuICAgIGR1cGxpY2F0ZUluZGV4ID0gc3RhdGUuZHVwbGljYXRlcy5pbmRleE9mKG9iamVjdCk7XG4gICAgZHVwbGljYXRlID0gZHVwbGljYXRlSW5kZXggIT09IC0xO1xuICB9XG5cbiAgaWYgKChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycpIHx8IGR1cGxpY2F0ZSB8fCAoc3RhdGUuaW5kZW50ICE9PSAyICYmIGxldmVsID4gMCkpIHtcbiAgICBjb21wYWN0ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoZHVwbGljYXRlICYmIHN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSkge1xuICAgIHN0YXRlLmR1bXAgPSAnKnJlZl8nICsgZHVwbGljYXRlSW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9iamVjdE9yQXJyYXkgJiYgZHVwbGljYXRlICYmICFzdGF0ZS51c2VkRHVwbGljYXRlc1tkdXBsaWNhdGVJbmRleF0pIHtcbiAgICAgIHN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgaWYgKGJsb2NrICYmIChPYmplY3Qua2V5cyhzdGF0ZS5kdW1wKS5sZW5ndGggIT09IDApKSB7XG4gICAgICAgIHdyaXRlQmxvY2tNYXBwaW5nKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCwgY29tcGFjdCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVGbG93TWFwcGluZyhzdGF0ZSwgbGV2ZWwsIHN0YXRlLmR1bXApO1xuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArICcgJyArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIGlmIChibG9jayAmJiAoc3RhdGUuZHVtcC5sZW5ndGggIT09IDApKSB7XG4gICAgICAgIGlmIChzdGF0ZS5ub0FycmF5SW5kZW50ICYmICFpc2Jsb2Nrc2VxICYmIGxldmVsID4gMCkge1xuICAgICAgICAgIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwgLSAxLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3cml0ZUJsb2NrU2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlRmxvd1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgJyAnICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICAgIGlmIChzdGF0ZS50YWcgIT09ICc/Jykge1xuICAgICAgICB3cml0ZVNjYWxhcihzdGF0ZSwgc3RhdGUuZHVtcCwgbGV2ZWwsIGlza2V5LCBpbmJsb2NrKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFVuZGVmaW5lZF0nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS5za2lwSW52YWxpZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbigndW5hY2NlcHRhYmxlIGtpbmQgb2YgYW4gb2JqZWN0IHRvIGR1bXAgJyArIHR5cGUpO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycpIHtcbiAgICAgIC8vIE5lZWQgdG8gZW5jb2RlIGFsbCBjaGFyYWN0ZXJzIGV4Y2VwdCB0aG9zZSBhbGxvd2VkIGJ5IHRoZSBzcGVjOlxuICAgICAgLy9cbiAgICAgIC8vIFszNV0gbnMtZGVjLWRpZ2l0ICAgIDo6PSAgWyN4MzAtI3gzOV0gLyogMC05ICovXG4gICAgICAvLyBbMzZdIG5zLWhleC1kaWdpdCAgICA6Oj0gIG5zLWRlYy1kaWdpdFxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfCBbI3g0MS0jeDQ2XSAvKiBBLUYgKi8gfCBbI3g2MS0jeDY2XSAvKiBhLWYgKi9cbiAgICAgIC8vIFszN10gbnMtYXNjaWktbGV0dGVyIDo6PSAgWyN4NDEtI3g1QV0gLyogQS1aICovIHwgWyN4NjEtI3g3QV0gLyogYS16ICovXG4gICAgICAvLyBbMzhdIG5zLXdvcmQtY2hhciAgICA6Oj0gIG5zLWRlYy1kaWdpdCB8IG5zLWFzY2lpLWxldHRlciB8IOKAnC3igJ1cbiAgICAgIC8vIFszOV0gbnMtdXJpLWNoYXIgICAgIDo6PSAg4oCcJeKAnSBucy1oZXgtZGlnaXQgbnMtaGV4LWRpZ2l0IHwgbnMtd29yZC1jaGFyIHwg4oCcI+KAnVxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfCDigJw74oCdIHwg4oCcL+KAnSB8IOKAnD/igJ0gfCDigJw64oCdIHwg4oCcQOKAnSB8IOKAnCbigJ0gfCDigJw94oCdIHwg4oCcK+KAnSB8IOKAnCTigJ0gfCDigJws4oCdXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB8IOKAnF/igJ0gfCDigJwu4oCdIHwg4oCcIeKAnSB8IOKAnH7igJ0gfCDigJwq4oCdIHwg4oCcJ+KAnSB8IOKAnCjigJ0gfCDigJwp4oCdIHwg4oCcW+KAnSB8IOKAnF3igJ1cbiAgICAgIC8vXG4gICAgICAvLyBBbHNvIG5lZWQgdG8gZW5jb2RlICchJyBiZWNhdXNlIGl0IGhhcyBzcGVjaWFsIG1lYW5pbmcgKGVuZCBvZiB0YWcgcHJlZml4KS5cbiAgICAgIC8vXG4gICAgICB0YWdTdHIgPSBlbmNvZGVVUkkoXG4gICAgICAgIHN0YXRlLnRhZ1swXSA9PT0gJyEnID8gc3RhdGUudGFnLnNsaWNlKDEpIDogc3RhdGUudGFnXG4gICAgICApLnJlcGxhY2UoLyEvZywgJyUyMScpO1xuXG4gICAgICBpZiAoc3RhdGUudGFnWzBdID09PSAnIScpIHtcbiAgICAgICAgdGFnU3RyID0gJyEnICsgdGFnU3RyO1xuICAgICAgfSBlbHNlIGlmICh0YWdTdHIuc2xpY2UoMCwgMTgpID09PSAndGFnOnlhbWwub3JnLDIwMDI6Jykge1xuICAgICAgICB0YWdTdHIgPSAnISEnICsgdGFnU3RyLnNsaWNlKDE4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhZ1N0ciA9ICchPCcgKyB0YWdTdHIgKyAnPic7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLmR1bXAgPSB0YWdTdHIgKyAnICcgKyBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXREdXBsaWNhdGVSZWZlcmVuY2VzKG9iamVjdCwgc3RhdGUpIHtcbiAgdmFyIG9iamVjdHMgPSBbXSxcbiAgICAgIGR1cGxpY2F0ZXNJbmRleGVzID0gW10sXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBpbnNwZWN0Tm9kZShvYmplY3QsIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gZHVwbGljYXRlc0luZGV4ZXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHN0YXRlLmR1cGxpY2F0ZXMucHVzaChvYmplY3RzW2R1cGxpY2F0ZXNJbmRleGVzW2luZGV4XV0pO1xuICB9XG4gIHN0YXRlLnVzZWREdXBsaWNhdGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGluc3BlY3ROb2RlKG9iamVjdCwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpIHtcbiAgdmFyIG9iamVjdEtleUxpc3QsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBpZiAob2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSB7XG4gICAgaW5kZXggPSBvYmplY3RzLmluZGV4T2Yob2JqZWN0KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAoZHVwbGljYXRlc0luZGV4ZXMuaW5kZXhPZihpbmRleCkgPT09IC0xKSB7XG4gICAgICAgIGR1cGxpY2F0ZXNJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RzLnB1c2gob2JqZWN0KTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICBpbnNwZWN0Tm9kZShvYmplY3RbaW5kZXhdLCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICBpbnNwZWN0Tm9kZShvYmplY3Rbb2JqZWN0S2V5TGlzdFtpbmRleF1dLCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHVtcCQxKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShvcHRpb25zKTtcblxuICBpZiAoIXN0YXRlLm5vUmVmcykgZ2V0RHVwbGljYXRlUmVmZXJlbmNlcyhpbnB1dCwgc3RhdGUpO1xuXG4gIHZhciB2YWx1ZSA9IGlucHV0O1xuXG4gIGlmIChzdGF0ZS5yZXBsYWNlcikge1xuICAgIHZhbHVlID0gc3RhdGUucmVwbGFjZXIuY2FsbCh7ICcnOiB2YWx1ZSB9LCAnJywgdmFsdWUpO1xuICB9XG5cbiAgaWYgKHdyaXRlTm9kZShzdGF0ZSwgMCwgdmFsdWUsIHRydWUsIHRydWUpKSByZXR1cm4gc3RhdGUuZHVtcCArICdcXG4nO1xuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGR1bXBfMSA9IGR1bXAkMTtcblxudmFyIGR1bXBlciA9IHtcblx0ZHVtcDogZHVtcF8xXG59O1xuXG5mdW5jdGlvbiByZW5hbWVkKGZyb20sIHRvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiB5YW1sLicgKyBmcm9tICsgJyBpcyByZW1vdmVkIGluIGpzLXlhbWwgNC4gJyArXG4gICAgICAnVXNlIHlhbWwuJyArIHRvICsgJyBpbnN0ZWFkLCB3aGljaCBpcyBub3cgc2FmZSBieSBkZWZhdWx0LicpO1xuICB9O1xufVxuXG5cbnZhciBUeXBlICAgICAgICAgICAgICAgID0gdHlwZTtcbnZhciBTY2hlbWEgICAgICAgICAgICAgID0gc2NoZW1hO1xudmFyIEZBSUxTQUZFX1NDSEVNQSAgICAgPSBmYWlsc2FmZTtcbnZhciBKU09OX1NDSEVNQSAgICAgICAgID0ganNvbjtcbnZhciBDT1JFX1NDSEVNQSAgICAgICAgID0gY29yZTtcbnZhciBERUZBVUxUX1NDSEVNQSAgICAgID0gX2RlZmF1bHQ7XG52YXIgbG9hZCAgICAgICAgICAgICAgICA9IGxvYWRlci5sb2FkO1xudmFyIGxvYWRBbGwgICAgICAgICAgICAgPSBsb2FkZXIubG9hZEFsbDtcbnZhciBkdW1wICAgICAgICAgICAgICAgID0gZHVtcGVyLmR1bXA7XG52YXIgWUFNTEV4Y2VwdGlvbiAgICAgICA9IGV4Y2VwdGlvbjtcblxuLy8gUmUtZXhwb3J0IGFsbCB0eXBlcyBpbiBjYXNlIHVzZXIgd2FudHMgdG8gY3JlYXRlIGN1c3RvbSBzY2hlbWFcbnZhciB0eXBlcyA9IHtcbiAgYmluYXJ5OiAgICBiaW5hcnksXG4gIGZsb2F0OiAgICAgZmxvYXQsXG4gIG1hcDogICAgICAgbWFwLFxuICBudWxsOiAgICAgIF9udWxsLFxuICBwYWlyczogICAgIHBhaXJzLFxuICBzZXQ6ICAgICAgIHNldCxcbiAgdGltZXN0YW1wOiB0aW1lc3RhbXAsXG4gIGJvb2w6ICAgICAgYm9vbCxcbiAgaW50OiAgICAgICBpbnQsXG4gIG1lcmdlOiAgICAgbWVyZ2UsXG4gIG9tYXA6ICAgICAgb21hcCxcbiAgc2VxOiAgICAgICBzZXEsXG4gIHN0cjogICAgICAgc3RyXG59O1xuXG4vLyBSZW1vdmVkIGZ1bmN0aW9ucyBmcm9tIEpTLVlBTUwgMy4wLnhcbnZhciBzYWZlTG9hZCAgICAgICAgICAgID0gcmVuYW1lZCgnc2FmZUxvYWQnLCAnbG9hZCcpO1xudmFyIHNhZmVMb2FkQWxsICAgICAgICAgPSByZW5hbWVkKCdzYWZlTG9hZEFsbCcsICdsb2FkQWxsJyk7XG52YXIgc2FmZUR1bXAgICAgICAgICAgICA9IHJlbmFtZWQoJ3NhZmVEdW1wJywgJ2R1bXAnKTtcblxudmFyIGpzWWFtbCA9IHtcblx0VHlwZTogVHlwZSxcblx0U2NoZW1hOiBTY2hlbWEsXG5cdEZBSUxTQUZFX1NDSEVNQTogRkFJTFNBRkVfU0NIRU1BLFxuXHRKU09OX1NDSEVNQTogSlNPTl9TQ0hFTUEsXG5cdENPUkVfU0NIRU1BOiBDT1JFX1NDSEVNQSxcblx0REVGQVVMVF9TQ0hFTUE6IERFRkFVTFRfU0NIRU1BLFxuXHRsb2FkOiBsb2FkLFxuXHRsb2FkQWxsOiBsb2FkQWxsLFxuXHRkdW1wOiBkdW1wLFxuXHRZQU1MRXhjZXB0aW9uOiBZQU1MRXhjZXB0aW9uLFxuXHR0eXBlczogdHlwZXMsXG5cdHNhZmVMb2FkOiBzYWZlTG9hZCxcblx0c2FmZUxvYWRBbGw6IHNhZmVMb2FkQWxsLFxuXHRzYWZlRHVtcDogc2FmZUR1bXBcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGpzWWFtbDtcbmV4cG9ydCB7IENPUkVfU0NIRU1BLCBERUZBVUxUX1NDSEVNQSwgRkFJTFNBRkVfU0NIRU1BLCBKU09OX1NDSEVNQSwgU2NoZW1hLCBUeXBlLCBZQU1MRXhjZXB0aW9uLCBkdW1wLCBsb2FkLCBsb2FkQWxsLCBzYWZlRHVtcCwgc2FmZUxvYWQsIHNhZmVMb2FkQWxsLCB0eXBlcyB9O1xuIl0sIm5hbWVzIjpbImlzTm90aGluZyIsInN1YmplY3QiLCJpc09iamVjdCIsInRvQXJyYXkiLCJzZXF1ZW5jZSIsIkFycmF5IiwiaXNBcnJheSIsImV4dGVuZCIsInRhcmdldCIsInNvdXJjZSIsImluZGV4IiwibGVuZ3RoIiwia2V5Iiwic291cmNlS2V5cyIsIk9iamVjdCIsImtleXMiLCJyZXBlYXQiLCJzdHJpbmciLCJjb3VudCIsInJlc3VsdCIsImN5Y2xlIiwiaXNOZWdhdGl2ZVplcm8iLCJudW1iZXIiLCJOdW1iZXIiLCJORUdBVElWRV9JTkZJTklUWSIsImlzTm90aGluZ18xIiwiaXNPYmplY3RfMSIsInRvQXJyYXlfMSIsInJlcGVhdF8xIiwiaXNOZWdhdGl2ZVplcm9fMSIsImV4dGVuZF8xIiwiY29tbW9uIiwiZm9ybWF0RXJyb3IiLCJleGNlcHRpb24iLCJjb21wYWN0Iiwid2hlcmUiLCJtZXNzYWdlIiwicmVhc29uIiwibWFyayIsIm5hbWUiLCJsaW5lIiwiY29sdW1uIiwic25pcHBldCIsIllBTUxFeGNlcHRpb24kMSIsIkVycm9yIiwiY2FsbCIsImNhcHR1cmVTdGFja1RyYWNlIiwiY29uc3RydWN0b3IiLCJzdGFjayIsInByb3RvdHlwZSIsImNyZWF0ZSIsInRvU3RyaW5nIiwiZ2V0TGluZSIsImJ1ZmZlciIsImxpbmVTdGFydCIsImxpbmVFbmQiLCJwb3NpdGlvbiIsIm1heExpbmVMZW5ndGgiLCJoZWFkIiwidGFpbCIsIm1heEhhbGZMZW5ndGgiLCJNYXRoIiwiZmxvb3IiLCJzdHIiLCJzbGljZSIsInJlcGxhY2UiLCJwb3MiLCJwYWRTdGFydCIsIm1heCIsIm1ha2VTbmlwcGV0Iiwib3B0aW9ucyIsIm1heExlbmd0aCIsImluZGVudCIsImxpbmVzQmVmb3JlIiwibGluZXNBZnRlciIsInJlIiwibGluZVN0YXJ0cyIsImxpbmVFbmRzIiwibWF0Y2giLCJmb3VuZExpbmVObyIsImV4ZWMiLCJwdXNoIiwiaSIsImxpbmVOb0xlbmd0aCIsIm1pbiIsIlRZUEVfQ09OU1RSVUNUT1JfT1BUSU9OUyIsIllBTUxfTk9ERV9LSU5EUyIsImNvbXBpbGVTdHlsZUFsaWFzZXMiLCJtYXAiLCJmb3JFYWNoIiwic3R5bGUiLCJhbGlhcyIsIlN0cmluZyIsIlR5cGUkMSIsInRhZyIsImluZGV4T2YiLCJraW5kIiwicmVzb2x2ZSIsImNvbnN0cnVjdCIsImRhdGEiLCJpbnN0YW5jZU9mIiwicHJlZGljYXRlIiwicmVwcmVzZW50IiwicmVwcmVzZW50TmFtZSIsImRlZmF1bHRTdHlsZSIsIm11bHRpIiwic3R5bGVBbGlhc2VzIiwidHlwZSIsImNvbXBpbGVMaXN0Iiwic2NoZW1hIiwiY3VycmVudFR5cGUiLCJuZXdJbmRleCIsInByZXZpb3VzVHlwZSIsInByZXZpb3VzSW5kZXgiLCJjb21waWxlTWFwIiwic2NhbGFyIiwibWFwcGluZyIsImZhbGxiYWNrIiwiY29sbGVjdFR5cGUiLCJhcmd1bWVudHMiLCJTY2hlbWEkMSIsImRlZmluaXRpb24iLCJpbXBsaWNpdCIsImV4cGxpY2l0IiwiY29uY2F0IiwidHlwZSQxIiwibG9hZEtpbmQiLCJjb21waWxlZEltcGxpY2l0IiwiY29tcGlsZWRFeHBsaWNpdCIsImNvbXBpbGVkVHlwZU1hcCIsInNlcSIsImZhaWxzYWZlIiwicmVzb2x2ZVlhbWxOdWxsIiwiY29uc3RydWN0WWFtbE51bGwiLCJpc051bGwiLCJvYmplY3QiLCJfbnVsbCIsImNhbm9uaWNhbCIsImxvd2VyY2FzZSIsInVwcGVyY2FzZSIsImNhbWVsY2FzZSIsImVtcHR5IiwicmVzb2x2ZVlhbWxCb29sZWFuIiwiY29uc3RydWN0WWFtbEJvb2xlYW4iLCJpc0Jvb2xlYW4iLCJib29sIiwiaXNIZXhDb2RlIiwiYyIsImlzT2N0Q29kZSIsImlzRGVjQ29kZSIsInJlc29sdmVZYW1sSW50ZWdlciIsImhhc0RpZ2l0cyIsImNoIiwiY2hhckNvZGVBdCIsImNvbnN0cnVjdFlhbWxJbnRlZ2VyIiwidmFsdWUiLCJzaWduIiwicGFyc2VJbnQiLCJpc0ludGVnZXIiLCJpbnQiLCJiaW5hcnkiLCJvYmoiLCJvY3RhbCIsImRlY2ltYWwiLCJoZXhhZGVjaW1hbCIsInRvVXBwZXJDYXNlIiwiWUFNTF9GTE9BVF9QQVRURVJOIiwiUmVnRXhwIiwicmVzb2x2ZVlhbWxGbG9hdCIsInRlc3QiLCJjb25zdHJ1Y3RZYW1sRmxvYXQiLCJ0b0xvd2VyQ2FzZSIsIlBPU0lUSVZFX0lORklOSVRZIiwiTmFOIiwicGFyc2VGbG9hdCIsIlNDSUVOVElGSUNfV0lUSE9VVF9ET1QiLCJyZXByZXNlbnRZYW1sRmxvYXQiLCJyZXMiLCJpc05hTiIsImlzRmxvYXQiLCJmbG9hdCIsImpzb24iLCJjb3JlIiwiWUFNTF9EQVRFX1JFR0VYUCIsIllBTUxfVElNRVNUQU1QX1JFR0VYUCIsInJlc29sdmVZYW1sVGltZXN0YW1wIiwiY29uc3RydWN0WWFtbFRpbWVzdGFtcCIsInllYXIiLCJtb250aCIsImRheSIsImhvdXIiLCJtaW51dGUiLCJzZWNvbmQiLCJmcmFjdGlvbiIsImRlbHRhIiwidHpfaG91ciIsInR6X21pbnV0ZSIsImRhdGUiLCJEYXRlIiwiVVRDIiwic2V0VGltZSIsImdldFRpbWUiLCJyZXByZXNlbnRZYW1sVGltZXN0YW1wIiwidG9JU09TdHJpbmciLCJ0aW1lc3RhbXAiLCJyZXNvbHZlWWFtbE1lcmdlIiwibWVyZ2UiLCJCQVNFNjRfTUFQIiwicmVzb2x2ZVlhbWxCaW5hcnkiLCJjb2RlIiwiaWR4IiwiYml0bGVuIiwiY2hhckF0IiwiY29uc3RydWN0WWFtbEJpbmFyeSIsInRhaWxiaXRzIiwiaW5wdXQiLCJiaXRzIiwiVWludDhBcnJheSIsInJlcHJlc2VudFlhbWxCaW5hcnkiLCJpc0JpbmFyeSIsIl9oYXNPd25Qcm9wZXJ0eSQzIiwiaGFzT3duUHJvcGVydHkiLCJfdG9TdHJpbmckMiIsInJlc29sdmVZYW1sT21hcCIsIm9iamVjdEtleXMiLCJwYWlyIiwicGFpcktleSIsInBhaXJIYXNLZXkiLCJjb25zdHJ1Y3RZYW1sT21hcCIsIm9tYXAiLCJfdG9TdHJpbmckMSIsInJlc29sdmVZYW1sUGFpcnMiLCJjb25zdHJ1Y3RZYW1sUGFpcnMiLCJwYWlycyIsIl9oYXNPd25Qcm9wZXJ0eSQyIiwicmVzb2x2ZVlhbWxTZXQiLCJjb25zdHJ1Y3RZYW1sU2V0Iiwic2V0IiwiX2RlZmF1bHQiLCJfaGFzT3duUHJvcGVydHkkMSIsIkNPTlRFWFRfRkxPV19JTiIsIkNPTlRFWFRfRkxPV19PVVQiLCJDT05URVhUX0JMT0NLX0lOIiwiQ09OVEVYVF9CTE9DS19PVVQiLCJDSE9NUElOR19DTElQIiwiQ0hPTVBJTkdfU1RSSVAiLCJDSE9NUElOR19LRUVQIiwiUEFUVEVSTl9OT05fUFJJTlRBQkxFIiwiUEFUVEVSTl9OT05fQVNDSUlfTElORV9CUkVBS1MiLCJQQVRURVJOX0ZMT1dfSU5ESUNBVE9SUyIsIlBBVFRFUk5fVEFHX0hBTkRMRSIsIlBBVFRFUk5fVEFHX1VSSSIsIl9jbGFzcyIsImlzX0VPTCIsImlzX1dISVRFX1NQQUNFIiwiaXNfV1NfT1JfRU9MIiwiaXNfRkxPV19JTkRJQ0FUT1IiLCJmcm9tSGV4Q29kZSIsImxjIiwiZXNjYXBlZEhleExlbiIsImZyb21EZWNpbWFsQ29kZSIsInNpbXBsZUVzY2FwZVNlcXVlbmNlIiwiY2hhckZyb21Db2RlcG9pbnQiLCJmcm9tQ2hhckNvZGUiLCJzaW1wbGVFc2NhcGVDaGVjayIsInNpbXBsZUVzY2FwZU1hcCIsIlN0YXRlJDEiLCJmaWxlbmFtZSIsIm9uV2FybmluZyIsImxlZ2FjeSIsImxpc3RlbmVyIiwiaW1wbGljaXRUeXBlcyIsInR5cGVNYXAiLCJsaW5lSW5kZW50IiwiZmlyc3RUYWJJbkxpbmUiLCJkb2N1bWVudHMiLCJnZW5lcmF0ZUVycm9yIiwic3RhdGUiLCJ0aHJvd0Vycm9yIiwidGhyb3dXYXJuaW5nIiwiZGlyZWN0aXZlSGFuZGxlcnMiLCJZQU1MIiwiaGFuZGxlWWFtbERpcmVjdGl2ZSIsImFyZ3MiLCJtYWpvciIsIm1pbm9yIiwidmVyc2lvbiIsImNoZWNrTGluZUJyZWFrcyIsIlRBRyIsImhhbmRsZVRhZ0RpcmVjdGl2ZSIsImhhbmRsZSIsInByZWZpeCIsInRhZ01hcCIsImRlY29kZVVSSUNvbXBvbmVudCIsImVyciIsImNhcHR1cmVTZWdtZW50Iiwic3RhcnQiLCJlbmQiLCJjaGVja0pzb24iLCJfcG9zaXRpb24iLCJfbGVuZ3RoIiwiX2NoYXJhY3RlciIsIl9yZXN1bHQiLCJtZXJnZU1hcHBpbmdzIiwiZGVzdGluYXRpb24iLCJvdmVycmlkYWJsZUtleXMiLCJxdWFudGl0eSIsInN0b3JlTWFwcGluZ1BhaXIiLCJrZXlUYWciLCJrZXlOb2RlIiwidmFsdWVOb2RlIiwic3RhcnRMaW5lIiwic3RhcnRMaW5lU3RhcnQiLCJzdGFydFBvcyIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwicmVhZExpbmVCcmVhayIsInNraXBTZXBhcmF0aW9uU3BhY2UiLCJhbGxvd0NvbW1lbnRzIiwiY2hlY2tJbmRlbnQiLCJsaW5lQnJlYWtzIiwidGVzdERvY3VtZW50U2VwYXJhdG9yIiwid3JpdGVGb2xkZWRMaW5lcyIsInJlYWRQbGFpblNjYWxhciIsIm5vZGVJbmRlbnQiLCJ3aXRoaW5GbG93Q29sbGVjdGlvbiIsInByZWNlZGluZyIsImZvbGxvd2luZyIsImNhcHR1cmVTdGFydCIsImNhcHR1cmVFbmQiLCJoYXNQZW5kaW5nQ29udGVudCIsIl9saW5lIiwiX2xpbmVTdGFydCIsIl9saW5lSW5kZW50IiwiX2tpbmQiLCJyZWFkU2luZ2xlUXVvdGVkU2NhbGFyIiwicmVhZERvdWJsZVF1b3RlZFNjYWxhciIsImhleExlbmd0aCIsImhleFJlc3VsdCIsInRtcCIsInJlYWRGbG93Q29sbGVjdGlvbiIsInJlYWROZXh0IiwiX3BvcyIsIl90YWciLCJfYW5jaG9yIiwiYW5jaG9yIiwidGVybWluYXRvciIsImlzUGFpciIsImlzRXhwbGljaXRQYWlyIiwiaXNNYXBwaW5nIiwiYW5jaG9yTWFwIiwiY29tcG9zZU5vZGUiLCJyZWFkQmxvY2tTY2FsYXIiLCJmb2xkaW5nIiwiY2hvbXBpbmciLCJkaWRSZWFkQ29udGVudCIsImRldGVjdGVkSW5kZW50IiwidGV4dEluZGVudCIsImVtcHR5TGluZXMiLCJhdE1vcmVJbmRlbnRlZCIsInJlYWRCbG9ja1NlcXVlbmNlIiwiZGV0ZWN0ZWQiLCJyZWFkQmxvY2tNYXBwaW5nIiwiZmxvd0luZGVudCIsImFsbG93Q29tcGFjdCIsIl9rZXlMaW5lIiwiX2tleUxpbmVTdGFydCIsIl9rZXlQb3MiLCJhdEV4cGxpY2l0S2V5IiwicmVhZFRhZ1Byb3BlcnR5IiwiaXNWZXJiYXRpbSIsImlzTmFtZWQiLCJ0YWdIYW5kbGUiLCJ0YWdOYW1lIiwicmVhZEFuY2hvclByb3BlcnR5IiwicmVhZEFsaWFzIiwicGFyZW50SW5kZW50Iiwibm9kZUNvbnRleHQiLCJhbGxvd1RvU2VlayIsImFsbG93QmxvY2tTdHlsZXMiLCJhbGxvd0Jsb2NrU2NhbGFycyIsImFsbG93QmxvY2tDb2xsZWN0aW9ucyIsImluZGVudFN0YXR1cyIsImF0TmV3TGluZSIsImhhc0NvbnRlbnQiLCJ0eXBlSW5kZXgiLCJ0eXBlUXVhbnRpdHkiLCJ0eXBlTGlzdCIsImJsb2NrSW5kZW50IiwicmVhZERvY3VtZW50IiwiZG9jdW1lbnRTdGFydCIsImRpcmVjdGl2ZU5hbWUiLCJkaXJlY3RpdmVBcmdzIiwiaGFzRGlyZWN0aXZlcyIsImxvYWREb2N1bWVudHMiLCJudWxscG9zIiwibG9hZEFsbCQxIiwiaXRlcmF0b3IiLCJsb2FkJDEiLCJ1bmRlZmluZWQiLCJsb2FkQWxsXzEiLCJsb2FkXzEiLCJsb2FkZXIiLCJsb2FkQWxsIiwibG9hZCIsIl90b1N0cmluZyIsIl9oYXNPd25Qcm9wZXJ0eSIsIkNIQVJfQk9NIiwiQ0hBUl9UQUIiLCJDSEFSX0xJTkVfRkVFRCIsIkNIQVJfQ0FSUklBR0VfUkVUVVJOIiwiQ0hBUl9TUEFDRSIsIkNIQVJfRVhDTEFNQVRJT04iLCJDSEFSX0RPVUJMRV9RVU9URSIsIkNIQVJfU0hBUlAiLCJDSEFSX1BFUkNFTlQiLCJDSEFSX0FNUEVSU0FORCIsIkNIQVJfU0lOR0xFX1FVT1RFIiwiQ0hBUl9BU1RFUklTSyIsIkNIQVJfQ09NTUEiLCJDSEFSX01JTlVTIiwiQ0hBUl9DT0xPTiIsIkNIQVJfRVFVQUxTIiwiQ0hBUl9HUkVBVEVSX1RIQU4iLCJDSEFSX1FVRVNUSU9OIiwiQ0hBUl9DT01NRVJDSUFMX0FUIiwiQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUIiwiQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCIsIkNIQVJfR1JBVkVfQUNDRU5UIiwiQ0hBUl9MRUZUX0NVUkxZX0JSQUNLRVQiLCJDSEFSX1ZFUlRJQ0FMX0xJTkUiLCJDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVQiLCJFU0NBUEVfU0VRVUVOQ0VTIiwiREVQUkVDQVRFRF9CT09MRUFOU19TWU5UQVgiLCJERVBSRUNBVEVEX0JBU0U2MF9TWU5UQVgiLCJjb21waWxlU3R5bGVNYXAiLCJlbmNvZGVIZXgiLCJjaGFyYWN0ZXIiLCJRVU9USU5HX1RZUEVfU0lOR0xFIiwiUVVPVElOR19UWVBFX0RPVUJMRSIsIlN0YXRlIiwibm9BcnJheUluZGVudCIsInNraXBJbnZhbGlkIiwiZmxvd0xldmVsIiwic3R5bGVNYXAiLCJzb3J0S2V5cyIsImxpbmVXaWR0aCIsIm5vUmVmcyIsIm5vQ29tcGF0TW9kZSIsImNvbmRlbnNlRmxvdyIsInF1b3RpbmdUeXBlIiwiZm9yY2VRdW90ZXMiLCJyZXBsYWNlciIsImV4cGxpY2l0VHlwZXMiLCJkdXBsaWNhdGVzIiwidXNlZER1cGxpY2F0ZXMiLCJpbmRlbnRTdHJpbmciLCJzcGFjZXMiLCJpbmQiLCJuZXh0IiwiZ2VuZXJhdGVOZXh0TGluZSIsImxldmVsIiwidGVzdEltcGxpY2l0UmVzb2x2aW5nIiwiaXNXaGl0ZXNwYWNlIiwiaXNQcmludGFibGUiLCJpc05zQ2hhck9yV2hpdGVzcGFjZSIsImlzUGxhaW5TYWZlIiwicHJldiIsImluYmxvY2siLCJjSXNOc0NoYXJPcldoaXRlc3BhY2UiLCJjSXNOc0NoYXIiLCJpc1BsYWluU2FmZUZpcnN0IiwiaXNQbGFpblNhZmVMYXN0IiwiY29kZVBvaW50QXQiLCJmaXJzdCIsIm5lZWRJbmRlbnRJbmRpY2F0b3IiLCJsZWFkaW5nU3BhY2VSZSIsIlNUWUxFX1BMQUlOIiwiU1RZTEVfU0lOR0xFIiwiU1RZTEVfTElURVJBTCIsIlNUWUxFX0ZPTERFRCIsIlNUWUxFX0RPVUJMRSIsImNob29zZVNjYWxhclN0eWxlIiwic2luZ2xlTGluZU9ubHkiLCJpbmRlbnRQZXJMZXZlbCIsInRlc3RBbWJpZ3VvdXNUeXBlIiwiY2hhciIsInByZXZDaGFyIiwiaGFzTGluZUJyZWFrIiwiaGFzRm9sZGFibGVMaW5lIiwic2hvdWxkVHJhY2tXaWR0aCIsInByZXZpb3VzTGluZUJyZWFrIiwicGxhaW4iLCJ3cml0ZVNjYWxhciIsImlza2V5IiwiZHVtcCIsInRlc3RBbWJpZ3VpdHkiLCJibG9ja0hlYWRlciIsImRyb3BFbmRpbmdOZXdsaW5lIiwiZm9sZFN0cmluZyIsImVzY2FwZVN0cmluZyIsImluZGVudEluZGljYXRvciIsImNsaXAiLCJrZWVwIiwiY2hvbXAiLCJ3aWR0aCIsImxpbmVSZSIsIm5leHRMRiIsImxhc3RJbmRleCIsImZvbGRMaW5lIiwicHJldk1vcmVJbmRlbnRlZCIsIm1vcmVJbmRlbnRlZCIsImJyZWFrUmUiLCJjdXJyIiwiZXNjYXBlU2VxIiwid3JpdGVGbG93U2VxdWVuY2UiLCJ3cml0ZU5vZGUiLCJ3cml0ZUJsb2NrU2VxdWVuY2UiLCJ3cml0ZUZsb3dNYXBwaW5nIiwib2JqZWN0S2V5TGlzdCIsIm9iamVjdEtleSIsIm9iamVjdFZhbHVlIiwicGFpckJ1ZmZlciIsIndyaXRlQmxvY2tNYXBwaW5nIiwiZXhwbGljaXRQYWlyIiwic29ydCIsImRldGVjdFR5cGUiLCJibG9jayIsImlzYmxvY2tzZXEiLCJ0YWdTdHIiLCJvYmplY3RPckFycmF5IiwiZHVwbGljYXRlSW5kZXgiLCJkdXBsaWNhdGUiLCJlbmNvZGVVUkkiLCJnZXREdXBsaWNhdGVSZWZlcmVuY2VzIiwib2JqZWN0cyIsImR1cGxpY2F0ZXNJbmRleGVzIiwiaW5zcGVjdE5vZGUiLCJkdW1wJDEiLCJkdW1wXzEiLCJkdW1wZXIiLCJyZW5hbWVkIiwiZnJvbSIsInRvIiwiVHlwZSIsIlNjaGVtYSIsIkZBSUxTQUZFX1NDSEVNQSIsIkpTT05fU0NIRU1BIiwiQ09SRV9TQ0hFTUEiLCJERUZBVUxUX1NDSEVNQSIsIllBTUxFeGNlcHRpb24iLCJ0eXBlcyIsIm51bGwiLCJzYWZlTG9hZCIsInNhZmVMb2FkQWxsIiwic2FmZUR1bXAiLCJqc1lhbWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/dist/js-yaml.mjs\n");

/***/ })

};
;