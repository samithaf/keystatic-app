"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/immer@9.0.21";
exports.ids = ["vendor-chunks/immer@9.0.21"];
exports.modules = {

/***/ "(rsc)/../../node_modules/.pnpm/immer@9.0.21/node_modules/immer/dist/immer.cjs.development.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/immer@9.0.21/node_modules/immer/dist/immer.cjs.development.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _ref;\n// Should be no imports here!\n// Some things that should be evaluated before all else...\n// We only want to know if non-polyfilled symbols are available\nvar hasSymbol = typeof Symbol !== \"undefined\" && typeof /*#__PURE__*/ Symbol(\"x\") === \"symbol\";\nvar hasMap = typeof Map !== \"undefined\";\nvar hasSet = typeof Set !== \"undefined\";\nvar hasProxies = typeof Proxy !== \"undefined\" && typeof Proxy.revocable !== \"undefined\" && typeof Reflect !== \"undefined\";\n/**\r\n * The sentinel value returned by producers to replace the draft with undefined.\r\n */ var NOTHING = hasSymbol ? /*#__PURE__*/ Symbol.for(\"immer-nothing\") : (_ref = {}, _ref[\"immer-nothing\"] = true, _ref);\n/**\r\n * To let Immer treat your class instances as plain immutable objects\r\n * (albeit with a custom prototype), you must define either an instance property\r\n * or a static property on each of your custom classes.\r\n *\r\n * Otherwise, your class instance will never be drafted, which means it won't be\r\n * safe to mutate in a produce callback.\r\n */ var DRAFTABLE = hasSymbol ? /*#__PURE__*/ Symbol.for(\"immer-draftable\") : \"__$immer_draftable\";\nvar DRAFT_STATE = hasSymbol ? /*#__PURE__*/ Symbol.for(\"immer-state\") : \"__$immer_state\"; // Even a polyfilled Symbol might provide Symbol.iterator\nvar iteratorSymbol = typeof Symbol != \"undefined\" && Symbol.iterator || \"@@iterator\";\nvar errors = {\n    0: \"Illegal state\",\n    1: \"Immer drafts cannot have computed properties\",\n    2: \"This object has been frozen and should not be mutated\",\n    3: function _(data) {\n        return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + data;\n    },\n    4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n    5: \"Immer forbids circular references\",\n    6: \"The first or second argument to `produce` must be a function\",\n    7: \"The third argument to `produce` must be a function or undefined\",\n    8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n    9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n    10: \"The given draft is already finalized\",\n    11: \"Object.defineProperty() cannot be used on an Immer draft\",\n    12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n    13: \"Immer only supports deleting array indices\",\n    14: \"Immer only supports setting array indices and the 'length' property\",\n    15: function _(path) {\n        return \"Cannot apply patch, path doesn't resolve: \" + path;\n    },\n    16: 'Sets cannot have \"replace\" patches.',\n    17: function _(op) {\n        return \"Unsupported patch operation: \" + op;\n    },\n    18: function _(plugin) {\n        return \"The plugin for '\" + plugin + \"' has not been loaded into Immer. To enable the plugin, import and call `enable\" + plugin + \"()` when initializing your application.\";\n    },\n    20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n    21: function _(thing) {\n        return \"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '\" + thing + \"'\";\n    },\n    22: function _(thing) {\n        return \"'current' expects a draft, got: \" + thing;\n    },\n    23: function _(thing) {\n        return \"'original' expects a draft, got: \" + thing;\n    },\n    24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n};\nfunction die(error) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    {\n        var e = errors[error];\n        var msg = !e ? \"unknown error nr: \" + error : typeof e === \"function\" ? e.apply(null, args) : e;\n        throw new Error(\"[Immer] \" + msg);\n    }\n}\n/** Returns true if the given value is an Immer draft */ /*#__PURE__*/ function isDraft(value) {\n    return !!value && !!value[DRAFT_STATE];\n}\n/** Returns true if the given value can be drafted by Immer */ /*#__PURE__*/ function isDraftable(value) {\n    var _value$constructor;\n    if (!value) return false;\n    return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor[DRAFTABLE]) || isMap(value) || isSet(value);\n}\nvar objectCtorString = /*#__PURE__*/ Object.prototype.constructor.toString();\n/*#__PURE__*/ function isPlainObject(value) {\n    if (!value || typeof value !== \"object\") return false;\n    var proto = Object.getPrototypeOf(value);\n    if (proto === null) {\n        return true;\n    }\n    var Ctor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n    if (Ctor === Object) return true;\n    return typeof Ctor == \"function\" && Function.toString.call(Ctor) === objectCtorString;\n}\nfunction original(value) {\n    if (!isDraft(value)) die(23, value);\n    return value[DRAFT_STATE].base_;\n}\n/*#__PURE__*/ var ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== \"undefined\" ? function(obj) {\n    return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));\n} : /* istanbul ignore next */ Object.getOwnPropertyNames;\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(target) {\n    // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n    var res = {};\n    ownKeys(target).forEach(function(key) {\n        res[key] = Object.getOwnPropertyDescriptor(target, key);\n    });\n    return res;\n};\nfunction each(obj, iter, enumerableOnly) {\n    if (enumerableOnly === void 0) {\n        enumerableOnly = false;\n    }\n    if (getArchtype(obj) === 0) {\n        (enumerableOnly ? Object.keys : ownKeys)(obj).forEach(function(key) {\n            if (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj);\n        });\n    } else {\n        obj.forEach(function(entry, index) {\n            return iter(index, entry, obj);\n        });\n    }\n}\n/*#__PURE__*/ function getArchtype(thing) {\n    /* istanbul ignore next */ var state = thing[DRAFT_STATE];\n    return state ? state.type_ > 3 ? state.type_ - 4 // cause Object and Array map back from 4 and 5\n     : state.type_ // others are the same\n     : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0 /* Object */ ;\n}\n/*#__PURE__*/ function has(thing, prop) {\n    return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\n/*#__PURE__*/ function get(thing, prop) {\n    // @ts-ignore\n    return getArchtype(thing) === 2 ? thing.get(prop) : thing[prop];\n}\n/*#__PURE__*/ function set(thing, propOrOldValue, value) {\n    var t = getArchtype(thing);\n    if (t === 2) thing.set(propOrOldValue, value);\n    else if (t === 3) {\n        thing.add(value);\n    } else thing[propOrOldValue] = value;\n}\n/*#__PURE__*/ function is(x, y) {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y;\n    } else {\n        return x !== x && y !== y;\n    }\n}\n/*#__PURE__*/ function isMap(target) {\n    return hasMap && target instanceof Map;\n}\n/*#__PURE__*/ function isSet(target) {\n    return hasSet && target instanceof Set;\n}\n/*#__PURE__*/ function latest(state) {\n    return state.copy_ || state.base_;\n}\n/*#__PURE__*/ function shallowCopy(base) {\n    if (Array.isArray(base)) return Array.prototype.slice.call(base);\n    var descriptors = getOwnPropertyDescriptors(base);\n    delete descriptors[DRAFT_STATE];\n    var keys = ownKeys(descriptors);\n    for(var i = 0; i < keys.length; i++){\n        var key = keys[i];\n        var desc = descriptors[key];\n        if (desc.writable === false) {\n            desc.writable = true;\n            desc.configurable = true;\n        } // like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n        // with libraries that trap values, like mobx or vue\n        // unlike object.assign, non-enumerables will be copied as well\n        if (desc.get || desc.set) descriptors[key] = {\n            configurable: true,\n            writable: true,\n            enumerable: desc.enumerable,\n            value: base[key]\n        };\n    }\n    return Object.create(Object.getPrototypeOf(base), descriptors);\n}\nfunction freeze(obj, deep) {\n    if (deep === void 0) {\n        deep = false;\n    }\n    if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;\n    if (getArchtype(obj) > 1) {\n        obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\n    }\n    Object.freeze(obj);\n    if (deep) each(obj, function(key, value) {\n        return freeze(value, true);\n    }, true);\n    return obj;\n}\nfunction dontMutateFrozenCollections() {\n    die(2);\n}\nfunction isFrozen(obj) {\n    if (obj == null || typeof obj !== \"object\") return true; // See #600, IE dies on non-objects in Object.isFrozen\n    return Object.isFrozen(obj);\n}\n/** Plugin utilities */ var plugins = {};\nfunction getPlugin(pluginKey) {\n    var plugin = plugins[pluginKey];\n    if (!plugin) {\n        die(18, pluginKey);\n    } // @ts-ignore\n    return plugin;\n}\nfunction loadPlugin(pluginKey, implementation) {\n    if (!plugins[pluginKey]) plugins[pluginKey] = implementation;\n}\nvar currentScope;\nfunction getCurrentScope() {\n    if (!currentScope) die(0);\n    return currentScope;\n}\nfunction createScope(parent_, immer_) {\n    return {\n        drafts_: [],\n        parent_: parent_,\n        immer_: immer_,\n        // Whenever the modified draft contains a draft from another scope, we\n        // need to prevent auto-freezing so the unowned draft can be finalized.\n        canAutoFreeze_: true,\n        unfinalizedDrafts_: 0\n    };\n}\nfunction usePatchesInScope(scope, patchListener) {\n    if (patchListener) {\n        getPlugin(\"Patches\"); // assert we have the plugin\n        scope.patches_ = [];\n        scope.inversePatches_ = [];\n        scope.patchListener_ = patchListener;\n    }\n}\nfunction revokeScope(scope) {\n    leaveScope(scope);\n    scope.drafts_.forEach(revokeDraft); // @ts-ignore\n    scope.drafts_ = null;\n}\nfunction leaveScope(scope) {\n    if (scope === currentScope) {\n        currentScope = scope.parent_;\n    }\n}\nfunction enterScope(immer) {\n    return currentScope = createScope(currentScope, immer);\n}\nfunction revokeDraft(draft) {\n    var state = draft[DRAFT_STATE];\n    if (state.type_ === 0 || state.type_ === 1) state.revoke_();\n    else state.revoked_ = true;\n}\nfunction processResult(result, scope) {\n    scope.unfinalizedDrafts_ = scope.drafts_.length;\n    var baseDraft = scope.drafts_[0];\n    var isReplaced = result !== undefined && result !== baseDraft;\n    if (!scope.immer_.useProxies_) getPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced);\n    if (isReplaced) {\n        if (baseDraft[DRAFT_STATE].modified_) {\n            revokeScope(scope);\n            die(4);\n        }\n        if (isDraftable(result)) {\n            // Finalize the result in case it contains (or is) a subset of the draft.\n            result = finalize(scope, result);\n            if (!scope.parent_) maybeFreeze(scope, result);\n        }\n        if (scope.patches_) {\n            getPlugin(\"Patches\").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);\n        }\n    } else {\n        // Finalize the base draft.\n        result = finalize(scope, baseDraft, []);\n    }\n    revokeScope(scope);\n    if (scope.patches_) {\n        scope.patchListener_(scope.patches_, scope.inversePatches_);\n    }\n    return result !== NOTHING ? result : undefined;\n}\nfunction finalize(rootScope, value, path) {\n    // Don't recurse in tho recursive data structures\n    if (isFrozen(value)) return value;\n    var state = value[DRAFT_STATE]; // A plain object, might need freezing, might contain drafts\n    if (!state) {\n        each(value, function(key, childValue) {\n            return finalizeProperty(rootScope, state, value, key, childValue, path);\n        }, true // See #590, don't recurse into non-enumerable of non drafted objects\n        );\n        return value;\n    } // Never finalize drafts owned by another scope.\n    if (state.scope_ !== rootScope) return value; // Unmodified draft, return the (frozen) original\n    if (!state.modified_) {\n        maybeFreeze(rootScope, state.base_, true);\n        return state.base_;\n    } // Not finalized yet, let's do that now\n    if (!state.finalized_) {\n        state.finalized_ = true;\n        state.scope_.unfinalizedDrafts_--;\n        var result = state.type_ === 4 || state.type_ === 5 ? state.copy_ = shallowCopy(state.draft_) : state.copy_; // Finalize all children of the copy\n        // For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n        // To preserve insertion order in all cases we then clear the set\n        // And we let finalizeProperty know it needs to re-add non-draft children back to the target\n        var resultEach = result;\n        var isSet = false;\n        if (state.type_ === 3) {\n            resultEach = new Set(result);\n            result.clear();\n            isSet = true;\n        }\n        each(resultEach, function(key, childValue) {\n            return finalizeProperty(rootScope, state, result, key, childValue, path, isSet);\n        }); // everything inside is frozen, we can freeze here\n        maybeFreeze(rootScope, result, false); // first time finalizing, let's create those patches\n        if (path && rootScope.patches_) {\n            getPlugin(\"Patches\").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);\n        }\n    }\n    return state.copy_;\n}\nfunction finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {\n    if (childValue === targetObject) die(5);\n    if (isDraft(childValue)) {\n        var path = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.\n        !has(parentState.assigned_, prop) // Skip deep patches for assigned keys.\n         ? rootPath.concat(prop) : undefined; // Drafts owned by `scope` are finalized here.\n        var res = finalize(rootScope, childValue, path);\n        set(targetObject, prop, res); // Drafts from another scope must prevented to be frozen\n        // if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n        if (isDraft(res)) {\n            rootScope.canAutoFreeze_ = false;\n        } else return;\n    } else if (targetIsSet) {\n        targetObject.add(childValue);\n    } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n    if (isDraftable(childValue) && !isFrozen(childValue)) {\n        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n            // optimization: if an object is not a draft, and we don't have to\n            // deepfreeze everything, and we are sure that no drafts are left in the remaining object\n            // cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n            // This benefits especially adding large data tree's without further processing.\n            // See add-data.js perf test\n            return;\n        }\n        finalize(rootScope, childValue); // immer deep freezes plain objects, so if there is no parent state, we freeze as well\n        if (!parentState || !parentState.scope_.parent_) maybeFreeze(rootScope, childValue);\n    }\n}\nfunction maybeFreeze(scope, value, deep) {\n    if (deep === void 0) {\n        deep = false;\n    }\n    // we never freeze for a non-root scope; as it would prevent pruning for drafts inside wrapping objects\n    if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n        freeze(value, deep);\n    }\n}\n/**\r\n * Returns a new draft of the `base` object.\r\n *\r\n * The second argument is the parent draft-state (used internally).\r\n */ function createProxyProxy(base, parent) {\n    var isArray = Array.isArray(base);\n    var state = {\n        type_: isArray ? 1 : 0,\n        // Track which produce call this is associated with.\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        // True for both shallow and deep changes.\n        modified_: false,\n        // Used during finalization.\n        finalized_: false,\n        // Track which properties have been assigned (true) or deleted (false).\n        assigned_: {},\n        // The parent draft state.\n        parent_: parent,\n        // The base state.\n        base_: base,\n        // The base proxy.\n        draft_: null,\n        // The base copy with any updated values.\n        copy_: null,\n        // Called by the `produce` function.\n        revoke_: null,\n        isManual_: false\n    }; // the traps must target something, a bit like the 'real' base.\n    // but also, we need to be able to determine from the target what the relevant state is\n    // (to avoid creating traps per instance to capture the state in closure,\n    // and to avoid creating weird hidden properties as well)\n    // So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n    // Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n    var target = state;\n    var traps = objectTraps;\n    if (isArray) {\n        target = [\n            state\n        ];\n        traps = arrayTraps;\n    }\n    var _Proxy$revocable = Proxy.revocable(target, traps), revoke = _Proxy$revocable.revoke, proxy = _Proxy$revocable.proxy;\n    state.draft_ = proxy;\n    state.revoke_ = revoke;\n    return proxy;\n}\n/**\r\n * Object drafts\r\n */ var objectTraps = {\n    get: function get(state, prop) {\n        if (prop === DRAFT_STATE) return state;\n        var source = latest(state);\n        if (!has(source, prop)) {\n            // non-existing or non-own property...\n            return readPropFromProto(state, source, prop);\n        }\n        var value = source[prop];\n        if (state.finalized_ || !isDraftable(value)) {\n            return value;\n        } // Check for existing draft in modified state.\n        // Assigned values are never drafted. This catches any drafts we created, too.\n        if (value === peek(state.base_, prop)) {\n            prepareCopy(state);\n            return state.copy_[prop] = createProxy(state.scope_.immer_, value, state);\n        }\n        return value;\n    },\n    has: function has(state, prop) {\n        return prop in latest(state);\n    },\n    ownKeys: function ownKeys(state) {\n        return Reflect.ownKeys(latest(state));\n    },\n    set: function set(state, prop, value) {\n        var desc = getDescriptorFromProto(latest(state), prop);\n        if (desc === null || desc === void 0 ? void 0 : desc.set) {\n            // special case: if this write is captured by a setter, we have\n            // to trigger it with the correct context\n            desc.set.call(state.draft_, value);\n            return true;\n        }\n        if (!state.modified_) {\n            // the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n            // from setting an existing property with value undefined to undefined (which is not a change)\n            var current = peek(latest(state), prop); // special case, if we assigning the original value to a draft, we can ignore the assignment\n            var currentState = current === null || current === void 0 ? void 0 : current[DRAFT_STATE];\n            if (currentState && currentState.base_ === value) {\n                state.copy_[prop] = value;\n                state.assigned_[prop] = false;\n                return true;\n            }\n            if (is(value, current) && (value !== undefined || has(state.base_, prop))) return true;\n            prepareCopy(state);\n            markChanged(state);\n        }\n        if (state.copy_[prop] === value && (value !== undefined || prop in state.copy_) || // special case: NaN\n        Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true; // @ts-ignore\n        state.copy_[prop] = value;\n        state.assigned_[prop] = true;\n        return true;\n    },\n    deleteProperty: function deleteProperty(state, prop) {\n        // The `undefined` check is a fast path for pre-existing keys.\n        if (peek(state.base_, prop) !== undefined || prop in state.base_) {\n            state.assigned_[prop] = false;\n            prepareCopy(state);\n            markChanged(state);\n        } else {\n            // if an originally not assigned property was deleted\n            delete state.assigned_[prop];\n        } // @ts-ignore\n        if (state.copy_) delete state.copy_[prop];\n        return true;\n    },\n    // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n    // the same guarantee in ES5 mode.\n    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {\n        var owner = latest(state);\n        var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n        if (!desc) return desc;\n        return {\n            writable: true,\n            configurable: state.type_ !== 1 || prop !== \"length\",\n            enumerable: desc.enumerable,\n            value: owner[prop]\n        };\n    },\n    defineProperty: function defineProperty() {\n        die(11);\n    },\n    getPrototypeOf: function getPrototypeOf(state) {\n        return Object.getPrototypeOf(state.base_);\n    },\n    setPrototypeOf: function setPrototypeOf() {\n        die(12);\n    }\n};\n/**\r\n * Array drafts\r\n */ var arrayTraps = {};\neach(objectTraps, function(key, fn) {\n    // @ts-ignore\n    arrayTraps[key] = function() {\n        arguments[0] = arguments[0][0];\n        return fn.apply(this, arguments);\n    };\n});\narrayTraps.deleteProperty = function(state, prop) {\n    if (isNaN(parseInt(prop))) die(13); // @ts-ignore\n    return arrayTraps.set.call(this, state, prop, undefined);\n};\narrayTraps.set = function(state, prop, value) {\n    if (prop !== \"length\" && isNaN(parseInt(prop))) die(14);\n    return objectTraps.set.call(this, state[0], prop, value, state[0]);\n}; // Access a property without creating an Immer draft.\nfunction peek(draft, prop) {\n    var state = draft[DRAFT_STATE];\n    var source = state ? latest(state) : draft;\n    return source[prop];\n}\nfunction readPropFromProto(state, source, prop) {\n    var _desc$get;\n    var desc = getDescriptorFromProto(source, prop);\n    return desc ? \"value\" in desc ? desc.value : // prototype, we should invoke it with the draft as context!\n    (_desc$get = desc.get) === null || _desc$get === void 0 ? void 0 : _desc$get.call(state.draft_) : undefined;\n}\nfunction getDescriptorFromProto(source, prop) {\n    // 'in' checks proto!\n    if (!(prop in source)) return undefined;\n    var proto = Object.getPrototypeOf(source);\n    while(proto){\n        var desc = Object.getOwnPropertyDescriptor(proto, prop);\n        if (desc) return desc;\n        proto = Object.getPrototypeOf(proto);\n    }\n    return undefined;\n}\nfunction markChanged(state) {\n    if (!state.modified_) {\n        state.modified_ = true;\n        if (state.parent_) {\n            markChanged(state.parent_);\n        }\n    }\n}\nfunction prepareCopy(state) {\n    if (!state.copy_) {\n        state.copy_ = shallowCopy(state.base_);\n    }\n}\nvar Immer = /*#__PURE__*/ function() {\n    function Immer(config) {\n        var _this = this;\n        this.useProxies_ = hasProxies;\n        this.autoFreeze_ = true;\n        /**\r\n     * The `produce` function takes a value and a \"recipe function\" (whose\r\n     * return value often depends on the base state). The recipe function is\r\n     * free to mutate its first argument however it wants. All mutations are\r\n     * only ever applied to a __copy__ of the base state.\r\n     *\r\n     * Pass only a function to create a \"curried producer\" which relieves you\r\n     * from passing the recipe function every time.\r\n     *\r\n     * Only plain objects and arrays are made mutable. All other objects are\r\n     * considered uncopyable.\r\n     *\r\n     * Note: This function is __bound__ to its `Immer` instance.\r\n     *\r\n     * @param {any} base - the initial state\r\n     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\r\n     * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n     * @returns {any} a new state, or the initial state if nothing was modified\r\n     */ this.produce = function(base, recipe, patchListener) {\n            // curried invocation\n            if (typeof base === \"function\" && typeof recipe !== \"function\") {\n                var defaultBase = recipe;\n                recipe = base;\n                var self = _this;\n                return function curriedProduce(base) {\n                    var _this2 = this;\n                    if (base === void 0) {\n                        base = defaultBase;\n                    }\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    return self.produce(base, function(draft) {\n                        var _recipe;\n                        return (_recipe = recipe).call.apply(_recipe, [\n                            _this2,\n                            draft\n                        ].concat(args));\n                    }); // prettier-ignore\n                };\n            }\n            if (typeof recipe !== \"function\") die(6);\n            if (patchListener !== undefined && typeof patchListener !== \"function\") die(7);\n            var result; // Only plain objects, arrays, and \"immerable classes\" are drafted.\n            if (isDraftable(base)) {\n                var scope = enterScope(_this);\n                var proxy = createProxy(_this, base, undefined);\n                var hasError = true;\n                try {\n                    result = recipe(proxy);\n                    hasError = false;\n                } finally{\n                    // finally instead of catch + rethrow better preserves original stack\n                    if (hasError) revokeScope(scope);\n                    else leaveScope(scope);\n                }\n                if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                    return result.then(function(result) {\n                        usePatchesInScope(scope, patchListener);\n                        return processResult(result, scope);\n                    }, function(error) {\n                        revokeScope(scope);\n                        throw error;\n                    });\n                }\n                usePatchesInScope(scope, patchListener);\n                return processResult(result, scope);\n            } else if (!base || typeof base !== \"object\") {\n                result = recipe(base);\n                if (result === undefined) result = base;\n                if (result === NOTHING) result = undefined;\n                if (_this.autoFreeze_) freeze(result, true);\n                if (patchListener) {\n                    var p = [];\n                    var ip = [];\n                    getPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip);\n                    patchListener(p, ip);\n                }\n                return result;\n            } else die(21, base);\n        };\n        this.produceWithPatches = function(base, recipe) {\n            // curried invocation\n            if (typeof base === \"function\") {\n                return function(state) {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    return _this.produceWithPatches(state, function(draft) {\n                        return base.apply(void 0, [\n                            draft\n                        ].concat(args));\n                    });\n                };\n            }\n            var patches, inversePatches;\n            var result = _this.produce(base, recipe, function(p, ip) {\n                patches = p;\n                inversePatches = ip;\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then(function(nextState) {\n                    return [\n                        nextState,\n                        patches,\n                        inversePatches\n                    ];\n                });\n            }\n            return [\n                result,\n                patches,\n                inversePatches\n            ];\n        };\n        if (typeof (config === null || config === void 0 ? void 0 : config.useProxies) === \"boolean\") this.setUseProxies(config.useProxies);\n        if (typeof (config === null || config === void 0 ? void 0 : config.autoFreeze) === \"boolean\") this.setAutoFreeze(config.autoFreeze);\n    }\n    var _proto = Immer.prototype;\n    _proto.createDraft = function createDraft(base) {\n        if (!isDraftable(base)) die(8);\n        if (isDraft(base)) base = current(base);\n        var scope = enterScope(this);\n        var proxy = createProxy(this, base, undefined);\n        proxy[DRAFT_STATE].isManual_ = true;\n        leaveScope(scope);\n        return proxy;\n    };\n    _proto.finishDraft = function finishDraft(draft, patchListener) {\n        var state = draft && draft[DRAFT_STATE];\n        {\n            if (!state || !state.isManual_) die(9);\n            if (state.finalized_) die(10);\n        }\n        var scope = state.scope_;\n        usePatchesInScope(scope, patchListener);\n        return processResult(undefined, scope);\n    } /**\r\n   * Pass true to automatically freeze all copies created by Immer.\r\n   *\r\n   * By default, auto-freezing is enabled.\r\n   */ ;\n    _proto.setAutoFreeze = function setAutoFreeze(value) {\n        this.autoFreeze_ = value;\n    } /**\r\n   * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n   * always faster than using ES5 proxies.\r\n   *\r\n   * By default, feature detection is used, so calling this is rarely necessary.\r\n   */ ;\n    _proto.setUseProxies = function setUseProxies(value) {\n        if (value && !hasProxies) {\n            die(20);\n        }\n        this.useProxies_ = value;\n    };\n    _proto.applyPatches = function applyPatches(base, patches) {\n        // If a patch replaces the entire state, take that replacement as base\n        // before applying patches\n        var i;\n        for(i = patches.length - 1; i >= 0; i--){\n            var patch = patches[i];\n            if (patch.path.length === 0 && patch.op === \"replace\") {\n                base = patch.value;\n                break;\n            }\n        } // If there was a patch that replaced the entire state, start from the\n        // patch after that.\n        if (i > -1) {\n            patches = patches.slice(i + 1);\n        }\n        var applyPatchesImpl = getPlugin(\"Patches\").applyPatches_;\n        if (isDraft(base)) {\n            // N.B: never hits if some patch a replacement, patches are never drafts\n            return applyPatchesImpl(base, patches);\n        } // Otherwise, produce a copy of the base state.\n        return this.produce(base, function(draft) {\n            return applyPatchesImpl(draft, patches);\n        });\n    };\n    return Immer;\n}();\nfunction createProxy(immer, value, parent) {\n    // precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n    var draft = isMap(value) ? getPlugin(\"MapSet\").proxyMap_(value, parent) : isSet(value) ? getPlugin(\"MapSet\").proxySet_(value, parent) : immer.useProxies_ ? createProxyProxy(value, parent) : getPlugin(\"ES5\").createES5Proxy_(value, parent);\n    var scope = parent ? parent.scope_ : getCurrentScope();\n    scope.drafts_.push(draft);\n    return draft;\n}\nfunction current(value) {\n    if (!isDraft(value)) die(22, value);\n    return currentImpl(value);\n}\nfunction currentImpl(value) {\n    if (!isDraftable(value)) return value;\n    var state = value[DRAFT_STATE];\n    var copy;\n    var archType = getArchtype(value);\n    if (state) {\n        if (!state.modified_ && (state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state))) return state.base_; // Optimization: avoid generating new drafts during copying\n        state.finalized_ = true;\n        copy = copyHelper(value, archType);\n        state.finalized_ = false;\n    } else {\n        copy = copyHelper(value, archType);\n    }\n    each(copy, function(key, childValue) {\n        if (state && get(state.base_, key) === childValue) return; // no need to copy or search in something that didn't change\n        set(copy, key, currentImpl(childValue));\n    }); // In the future, we might consider freezing here, based on the current settings\n    return archType === 3 ? new Set(copy) : copy;\n}\nfunction copyHelper(value, archType) {\n    // creates a shallow copy, even if it is a map or set\n    switch(archType){\n        case 2:\n            return new Map(value);\n        case 3:\n            // Set will be cloned as array temporarily, so that we can replace individual items\n            return Array.from(value);\n    }\n    return shallowCopy(value);\n}\nfunction enableES5() {\n    function willFinalizeES5_(scope, result, isReplaced) {\n        if (!isReplaced) {\n            if (scope.patches_) {\n                markChangesRecursively(scope.drafts_[0]);\n            } // This is faster when we don't care about which attributes changed.\n            markChangesSweep(scope.drafts_);\n        } else if (isDraft(result) && result[DRAFT_STATE].scope_ === scope) {\n            markChangesSweep(scope.drafts_);\n        }\n    }\n    function createES5Draft(isArray, base) {\n        if (isArray) {\n            var draft = new Array(base.length);\n            for(var i = 0; i < base.length; i++){\n                Object.defineProperty(draft, \"\" + i, proxyProperty(i, true));\n            }\n            return draft;\n        } else {\n            var _descriptors = getOwnPropertyDescriptors(base);\n            delete _descriptors[DRAFT_STATE];\n            var keys = ownKeys(_descriptors);\n            for(var _i = 0; _i < keys.length; _i++){\n                var key = keys[_i];\n                _descriptors[key] = proxyProperty(key, isArray || !!_descriptors[key].enumerable);\n            }\n            return Object.create(Object.getPrototypeOf(base), _descriptors);\n        }\n    }\n    function createES5Proxy_(base, parent) {\n        var isArray = Array.isArray(base);\n        var draft = createES5Draft(isArray, base);\n        var state = {\n            type_: isArray ? 5 : 4,\n            scope_: parent ? parent.scope_ : getCurrentScope(),\n            modified_: false,\n            finalized_: false,\n            assigned_: {},\n            parent_: parent,\n            // base is the object we are drafting\n            base_: base,\n            // draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\n            draft_: draft,\n            copy_: null,\n            revoked_: false,\n            isManual_: false\n        };\n        Object.defineProperty(draft, DRAFT_STATE, {\n            value: state,\n            // enumerable: false <- the default\n            writable: true\n        });\n        return draft;\n    } // property descriptors are recycled to make sure we don't create a get and set closure per property,\n    // but share them all instead\n    var descriptors = {};\n    function proxyProperty(prop, enumerable) {\n        var desc = descriptors[prop];\n        if (desc) {\n            desc.enumerable = enumerable;\n        } else {\n            descriptors[prop] = desc = {\n                configurable: true,\n                enumerable: enumerable,\n                get: function get() {\n                    var state = this[DRAFT_STATE];\n                    assertUnrevoked(state); // @ts-ignore\n                    return objectTraps.get(state, prop);\n                },\n                set: function set(value) {\n                    var state = this[DRAFT_STATE];\n                    assertUnrevoked(state); // @ts-ignore\n                    objectTraps.set(state, prop, value);\n                }\n            };\n        }\n        return desc;\n    } // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n    function markChangesSweep(drafts) {\n        // The natural order of drafts in the `scope` array is based on when they\n        // were accessed. By processing drafts in reverse natural order, we have a\n        // better chance of processing leaf nodes first. When a leaf node is known to\n        // have changed, we can avoid any traversal of its ancestor nodes.\n        for(var i = drafts.length - 1; i >= 0; i--){\n            var state = drafts[i][DRAFT_STATE];\n            if (!state.modified_) {\n                switch(state.type_){\n                    case 5:\n                        if (hasArrayChanges(state)) markChanged(state);\n                        break;\n                    case 4:\n                        if (hasObjectChanges(state)) markChanged(state);\n                        break;\n                }\n            }\n        }\n    }\n    function markChangesRecursively(object) {\n        if (!object || typeof object !== \"object\") return;\n        var state = object[DRAFT_STATE];\n        if (!state) return;\n        var base_ = state.base_, draft_ = state.draft_, assigned_ = state.assigned_, type_ = state.type_;\n        if (type_ === 4) {\n            // Look for added keys.\n            // probably there is a faster way to detect changes, as sweep + recurse seems to do some\n            // unnecessary work.\n            // also: probably we can store the information we detect here, to speed up tree finalization!\n            each(draft_, function(key) {\n                if (key === DRAFT_STATE) return; // The `undefined` check is a fast path for pre-existing keys.\n                if (base_[key] === undefined && !has(base_, key)) {\n                    assigned_[key] = true;\n                    markChanged(state);\n                } else if (!assigned_[key]) {\n                    // Only untouched properties trigger recursion.\n                    markChangesRecursively(draft_[key]);\n                }\n            }); // Look for removed keys.\n            each(base_, function(key) {\n                // The `undefined` check is a fast path for pre-existing keys.\n                if (draft_[key] === undefined && !has(draft_, key)) {\n                    assigned_[key] = false;\n                    markChanged(state);\n                }\n            });\n        } else if (type_ === 5) {\n            if (hasArrayChanges(state)) {\n                markChanged(state);\n                assigned_.length = true;\n            }\n            if (draft_.length < base_.length) {\n                for(var i = draft_.length; i < base_.length; i++){\n                    assigned_[i] = false;\n                }\n            } else {\n                for(var _i2 = base_.length; _i2 < draft_.length; _i2++){\n                    assigned_[_i2] = true;\n                }\n            } // Minimum count is enough, the other parts has been processed.\n            var min = Math.min(draft_.length, base_.length);\n            for(var _i3 = 0; _i3 < min; _i3++){\n                // Only untouched indices trigger recursion.\n                if (!draft_.hasOwnProperty(_i3)) {\n                    assigned_[_i3] = true;\n                }\n                if (assigned_[_i3] === undefined) markChangesRecursively(draft_[_i3]);\n            }\n        }\n    }\n    function hasObjectChanges(state) {\n        var base_ = state.base_, draft_ = state.draft_; // Search for added keys and changed keys. Start at the back, because\n        // non-numeric keys are ordered by time of definition on the object.\n        var keys = ownKeys(draft_);\n        for(var i = keys.length - 1; i >= 0; i--){\n            var key = keys[i];\n            if (key === DRAFT_STATE) continue;\n            var baseValue = base_[key]; // The `undefined` check is a fast path for pre-existing keys.\n            if (baseValue === undefined && !has(base_, key)) {\n                return true;\n            } else {\n                var value = draft_[key];\n                var _state = value && value[DRAFT_STATE];\n                if (_state ? _state.base_ !== baseValue : !is(value, baseValue)) {\n                    return true;\n                }\n            }\n        } // At this point, no keys were added or changed.\n        // Compare key count to determine if keys were deleted.\n        var baseIsDraft = !!base_[DRAFT_STATE];\n        return keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1); // + 1 to correct for DRAFT_STATE\n    }\n    function hasArrayChanges(state) {\n        var draft_ = state.draft_;\n        if (draft_.length !== state.base_.length) return true; // See #116\n        // If we first shorten the length, our array interceptors will be removed.\n        // If after that new items are added, result in the same original length,\n        // those last items will have no intercepting property.\n        // So if there is no own descriptor on the last position, we know that items were removed and added\n        // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n        // the last one\n        // last descriptor can be not a trap, if the array was extended\n        var descriptor = Object.getOwnPropertyDescriptor(draft_, draft_.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n        if (descriptor && !descriptor.get) return true; // if we miss a property, it has been deleted, so array probobaly changed\n        for(var i = 0; i < draft_.length; i++){\n            if (!draft_.hasOwnProperty(i)) return true;\n        } // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n        return false;\n    }\n    function hasChanges_(state) {\n        return state.type_ === 4 ? hasObjectChanges(state) : hasArrayChanges(state);\n    }\n    function assertUnrevoked(state) {\n        if (state.revoked_) die(3, JSON.stringify(latest(state)));\n    }\n    loadPlugin(\"ES5\", {\n        createES5Proxy_: createES5Proxy_,\n        willFinalizeES5_: willFinalizeES5_,\n        hasChanges_: hasChanges_\n    });\n}\nfunction enablePatches() {\n    var REPLACE = \"replace\";\n    var ADD = \"add\";\n    var REMOVE = \"remove\";\n    function generatePatches_(state, basePath, patches, inversePatches) {\n        switch(state.type_){\n            case 0:\n            case 4:\n            case 2:\n                return generatePatchesFromAssigned(state, basePath, patches, inversePatches);\n            case 5:\n            case 1:\n                return generateArrayPatches(state, basePath, patches, inversePatches);\n            case 3:\n                return generateSetPatches(state, basePath, patches, inversePatches);\n        }\n    }\n    function generateArrayPatches(state, basePath, patches, inversePatches) {\n        var base_ = state.base_, assigned_ = state.assigned_;\n        var copy_ = state.copy_; // Reduce complexity by ensuring `base` is never longer.\n        if (copy_.length < base_.length) {\n            var _ref = [\n                copy_,\n                base_\n            ];\n            base_ = _ref[0];\n            copy_ = _ref[1];\n            var _ref2 = [\n                inversePatches,\n                patches\n            ];\n            patches = _ref2[0];\n            inversePatches = _ref2[1];\n        } // Process replaced indices.\n        for(var i = 0; i < base_.length; i++){\n            if (assigned_[i] && copy_[i] !== base_[i]) {\n                var path = basePath.concat([\n                    i\n                ]);\n                patches.push({\n                    op: REPLACE,\n                    path: path,\n                    // Need to maybe clone it, as it can in fact be the original value\n                    // due to the base/copy inversion at the start of this function\n                    value: clonePatchValueIfNeeded(copy_[i])\n                });\n                inversePatches.push({\n                    op: REPLACE,\n                    path: path,\n                    value: clonePatchValueIfNeeded(base_[i])\n                });\n            }\n        } // Process added indices.\n        for(var _i = base_.length; _i < copy_.length; _i++){\n            var _path = basePath.concat([\n                _i\n            ]);\n            patches.push({\n                op: ADD,\n                path: _path,\n                // Need to maybe clone it, as it can in fact be the original value\n                // due to the base/copy inversion at the start of this function\n                value: clonePatchValueIfNeeded(copy_[_i])\n            });\n        }\n        if (base_.length < copy_.length) {\n            inversePatches.push({\n                op: REPLACE,\n                path: basePath.concat([\n                    \"length\"\n                ]),\n                value: base_.length\n            });\n        }\n    } // This is used for both Map objects and normal objects.\n    function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n        var base_ = state.base_, copy_ = state.copy_;\n        each(state.assigned_, function(key, assignedValue) {\n            var origValue = get(base_, key);\n            var value = get(copy_, key);\n            var op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\n            if (origValue === value && op === REPLACE) return;\n            var path = basePath.concat(key);\n            patches.push(op === REMOVE ? {\n                op: op,\n                path: path\n            } : {\n                op: op,\n                path: path,\n                value: value\n            });\n            inversePatches.push(op === ADD ? {\n                op: REMOVE,\n                path: path\n            } : op === REMOVE ? {\n                op: ADD,\n                path: path,\n                value: clonePatchValueIfNeeded(origValue)\n            } : {\n                op: REPLACE,\n                path: path,\n                value: clonePatchValueIfNeeded(origValue)\n            });\n        });\n    }\n    function generateSetPatches(state, basePath, patches, inversePatches) {\n        var base_ = state.base_, copy_ = state.copy_;\n        var i = 0;\n        base_.forEach(function(value) {\n            if (!copy_.has(value)) {\n                var path = basePath.concat([\n                    i\n                ]);\n                patches.push({\n                    op: REMOVE,\n                    path: path,\n                    value: value\n                });\n                inversePatches.unshift({\n                    op: ADD,\n                    path: path,\n                    value: value\n                });\n            }\n            i++;\n        });\n        i = 0;\n        copy_.forEach(function(value) {\n            if (!base_.has(value)) {\n                var path = basePath.concat([\n                    i\n                ]);\n                patches.push({\n                    op: ADD,\n                    path: path,\n                    value: value\n                });\n                inversePatches.unshift({\n                    op: REMOVE,\n                    path: path,\n                    value: value\n                });\n            }\n            i++;\n        });\n    }\n    function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {\n        patches.push({\n            op: REPLACE,\n            path: [],\n            value: replacement === NOTHING ? undefined : replacement\n        });\n        inversePatches.push({\n            op: REPLACE,\n            path: [],\n            value: baseValue\n        });\n    }\n    function applyPatches_(draft, patches) {\n        patches.forEach(function(patch) {\n            var path = patch.path, op = patch.op;\n            var base = draft;\n            for(var i = 0; i < path.length - 1; i++){\n                var parentType = getArchtype(base);\n                var p = path[i];\n                if (typeof p !== \"string\" && typeof p !== \"number\") {\n                    p = \"\" + p;\n                } // See #738, avoid prototype pollution\n                if ((parentType === 0 || parentType === 1) && (p === \"__proto__\" || p === \"constructor\")) die(24);\n                if (typeof base === \"function\" && p === \"prototype\") die(24);\n                base = get(base, p);\n                if (typeof base !== \"object\") die(15, path.join(\"/\"));\n            }\n            var type = getArchtype(base);\n            var value = deepClonePatchValue(patch.value); // used to clone patch to ensure original patch is not modified, see #411\n            var key = path[path.length - 1];\n            switch(op){\n                case REPLACE:\n                    switch(type){\n                        case 2:\n                            return base.set(key, value);\n                        /* istanbul ignore next */ case 3:\n                            die(16);\n                        default:\n                            // if value is an object, then it's assigned by reference\n                            // in the following add or remove ops, the value field inside the patch will also be modifyed\n                            // so we use value from the cloned patch\n                            // @ts-ignore\n                            return base[key] = value;\n                    }\n                case ADD:\n                    switch(type){\n                        case 1:\n                            return key === \"-\" ? base.push(value) : base.splice(key, 0, value);\n                        case 2:\n                            return base.set(key, value);\n                        case 3:\n                            return base.add(value);\n                        default:\n                            return base[key] = value;\n                    }\n                case REMOVE:\n                    switch(type){\n                        case 1:\n                            return base.splice(key, 1);\n                        case 2:\n                            return base.delete(key);\n                        case 3:\n                            return base.delete(patch.value);\n                        default:\n                            return delete base[key];\n                    }\n                default:\n                    die(17, op);\n            }\n        });\n        return draft;\n    }\n    function deepClonePatchValue(obj) {\n        if (!isDraftable(obj)) return obj;\n        if (Array.isArray(obj)) return obj.map(deepClonePatchValue);\n        if (isMap(obj)) return new Map(Array.from(obj.entries()).map(function(_ref3) {\n            var k = _ref3[0], v = _ref3[1];\n            return [\n                k,\n                deepClonePatchValue(v)\n            ];\n        }));\n        if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));\n        var cloned = Object.create(Object.getPrototypeOf(obj));\n        for(var key in obj){\n            cloned[key] = deepClonePatchValue(obj[key]);\n        }\n        if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];\n        return cloned;\n    }\n    function clonePatchValueIfNeeded(obj) {\n        if (isDraft(obj)) {\n            return deepClonePatchValue(obj);\n        } else return obj;\n    }\n    loadPlugin(\"Patches\", {\n        applyPatches_: applyPatches_,\n        generatePatches_: generatePatches_,\n        generateReplacementPatches_: generateReplacementPatches_\n    });\n}\n// types only!\nfunction enableMapSet() {\n    /* istanbul ignore next */ var _extendStatics = function extendStatics(d, b) {\n        _extendStatics = Object.setPrototypeOf || ({\n            __proto__: []\n        }) instanceof Array && function(d, b) {\n            d.__proto__ = b;\n        } || function(d, b) {\n            for(var p in b){\n                if (b.hasOwnProperty(p)) d[p] = b[p];\n            }\n        };\n        return _extendStatics(d, b);\n    }; // Ugly hack to resolve #502 and inherit built in Map / Set\n    function __extends(d, b) {\n        _extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = (__.prototype = b.prototype, new __());\n    }\n    var DraftMap = function(_super) {\n        __extends(DraftMap, _super); // Create class manually, cause #502\n        function DraftMap(target, parent) {\n            this[DRAFT_STATE] = {\n                type_: 2,\n                parent_: parent,\n                scope_: parent ? parent.scope_ : getCurrentScope(),\n                modified_: false,\n                finalized_: false,\n                copy_: undefined,\n                assigned_: undefined,\n                base_: target,\n                draft_: this,\n                isManual_: false,\n                revoked_: false\n            };\n            return this;\n        }\n        var p = DraftMap.prototype;\n        Object.defineProperty(p, \"size\", {\n            get: function get() {\n                return latest(this[DRAFT_STATE]).size;\n            } // enumerable: false,\n        });\n        p.has = function(key) {\n            return latest(this[DRAFT_STATE]).has(key);\n        };\n        p.set = function(key, value) {\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (!latest(state).has(key) || latest(state).get(key) !== value) {\n                prepareMapCopy(state);\n                markChanged(state);\n                state.assigned_.set(key, true);\n                state.copy_.set(key, value);\n                state.assigned_.set(key, true);\n            }\n            return this;\n        };\n        p.delete = function(key) {\n            if (!this.has(key)) {\n                return false;\n            }\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareMapCopy(state);\n            markChanged(state);\n            if (state.base_.has(key)) {\n                state.assigned_.set(key, false);\n            } else {\n                state.assigned_.delete(key);\n            }\n            state.copy_.delete(key);\n            return true;\n        };\n        p.clear = function() {\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (latest(state).size) {\n                prepareMapCopy(state);\n                markChanged(state);\n                state.assigned_ = new Map();\n                each(state.base_, function(key) {\n                    state.assigned_.set(key, false);\n                });\n                state.copy_.clear();\n            }\n        };\n        p.forEach = function(cb, thisArg) {\n            var _this = this;\n            var state = this[DRAFT_STATE];\n            latest(state).forEach(function(_value, key, _map) {\n                cb.call(thisArg, _this.get(key), key, _this);\n            });\n        };\n        p.get = function(key) {\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            var value = latest(state).get(key);\n            if (state.finalized_ || !isDraftable(value)) {\n                return value;\n            }\n            if (value !== state.base_.get(key)) {\n                return value; // either already drafted or reassigned\n            } // despite what it looks, this creates a draft only once, see above condition\n            var draft = createProxy(state.scope_.immer_, value, state);\n            prepareMapCopy(state);\n            state.copy_.set(key, draft);\n            return draft;\n        };\n        p.keys = function() {\n            return latest(this[DRAFT_STATE]).keys();\n        };\n        p.values = function() {\n            var _this2 = this, _ref;\n            var iterator = this.keys();\n            return _ref = {}, _ref[iteratorSymbol] = function() {\n                return _this2.values();\n            }, _ref.next = function next() {\n                var r = iterator.next();\n                /* istanbul ignore next */ if (r.done) return r;\n                var value = _this2.get(r.value);\n                return {\n                    done: false,\n                    value: value\n                };\n            }, _ref;\n        };\n        p.entries = function() {\n            var _this3 = this, _ref2;\n            var iterator = this.keys();\n            return _ref2 = {}, _ref2[iteratorSymbol] = function() {\n                return _this3.entries();\n            }, _ref2.next = function next() {\n                var r = iterator.next();\n                /* istanbul ignore next */ if (r.done) return r;\n                var value = _this3.get(r.value);\n                return {\n                    done: false,\n                    value: [\n                        r.value,\n                        value\n                    ]\n                };\n            }, _ref2;\n        };\n        p[iteratorSymbol] = function() {\n            return this.entries();\n        };\n        return DraftMap;\n    }(Map);\n    function proxyMap_(target, parent) {\n        // @ts-ignore\n        return new DraftMap(target, parent);\n    }\n    function prepareMapCopy(state) {\n        if (!state.copy_) {\n            state.assigned_ = new Map();\n            state.copy_ = new Map(state.base_);\n        }\n    }\n    var DraftSet = function(_super) {\n        __extends(DraftSet, _super); // Create class manually, cause #502\n        function DraftSet(target, parent) {\n            this[DRAFT_STATE] = {\n                type_: 3,\n                parent_: parent,\n                scope_: parent ? parent.scope_ : getCurrentScope(),\n                modified_: false,\n                finalized_: false,\n                copy_: undefined,\n                base_: target,\n                draft_: this,\n                drafts_: new Map(),\n                revoked_: false,\n                isManual_: false\n            };\n            return this;\n        }\n        var p = DraftSet.prototype;\n        Object.defineProperty(p, \"size\", {\n            get: function get() {\n                return latest(this[DRAFT_STATE]).size;\n            } // enumerable: true,\n        });\n        p.has = function(value) {\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state); // bit of trickery here, to be able to recognize both the value, and the draft of its value\n            if (!state.copy_) {\n                return state.base_.has(value);\n            }\n            if (state.copy_.has(value)) return true;\n            if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;\n            return false;\n        };\n        p.add = function(value) {\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (!this.has(value)) {\n                prepareSetCopy(state);\n                markChanged(state);\n                state.copy_.add(value);\n            }\n            return this;\n        };\n        p.delete = function(value) {\n            if (!this.has(value)) {\n                return false;\n            }\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareSetCopy(state);\n            markChanged(state);\n            return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : /* istanbul ignore next */ false);\n        };\n        p.clear = function() {\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            if (latest(state).size) {\n                prepareSetCopy(state);\n                markChanged(state);\n                state.copy_.clear();\n            }\n        };\n        p.values = function() {\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareSetCopy(state);\n            return state.copy_.values();\n        };\n        p.entries = function entries() {\n            var state = this[DRAFT_STATE];\n            assertUnrevoked(state);\n            prepareSetCopy(state);\n            return state.copy_.entries();\n        };\n        p.keys = function() {\n            return this.values();\n        };\n        p[iteratorSymbol] = function() {\n            return this.values();\n        };\n        p.forEach = function forEach(cb, thisArg) {\n            var iterator = this.values();\n            var result = iterator.next();\n            while(!result.done){\n                cb.call(thisArg, result.value, result.value, this);\n                result = iterator.next();\n            }\n        };\n        return DraftSet;\n    }(Set);\n    function proxySet_(target, parent) {\n        // @ts-ignore\n        return new DraftSet(target, parent);\n    }\n    function prepareSetCopy(state) {\n        if (!state.copy_) {\n            // create drafts for all entries to preserve insertion order\n            state.copy_ = new Set();\n            state.base_.forEach(function(value) {\n                if (isDraftable(value)) {\n                    var draft = createProxy(state.scope_.immer_, value, state);\n                    state.drafts_.set(value, draft);\n                    state.copy_.add(draft);\n                } else {\n                    state.copy_.add(value);\n                }\n            });\n        }\n    }\n    function assertUnrevoked(state) {\n        if (state.revoked_) die(3, JSON.stringify(latest(state)));\n    }\n    loadPlugin(\"MapSet\", {\n        proxyMap_: proxyMap_,\n        proxySet_: proxySet_\n    });\n}\nfunction enableAllPlugins() {\n    enableES5();\n    enableMapSet();\n    enablePatches();\n}\nvar immer = /*#__PURE__*/ new Immer();\n/**\r\n * The `produce` function takes a value and a \"recipe function\" (whose\r\n * return value often depends on the base state). The recipe function is\r\n * free to mutate its first argument however it wants. All mutations are\r\n * only ever applied to a __copy__ of the base state.\r\n *\r\n * Pass only a function to create a \"curried producer\" which relieves you\r\n * from passing the recipe function every time.\r\n *\r\n * Only plain objects and arrays are made mutable. All other objects are\r\n * considered uncopyable.\r\n *\r\n * Note: This function is __bound__ to its `Immer` instance.\r\n *\r\n * @param {any} base - the initial state\r\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\r\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n * @returns {any} a new state, or the initial state if nothing was modified\r\n */ var produce = immer.produce;\n/**\r\n * Like `produce`, but `produceWithPatches` always returns a tuple\r\n * [nextState, patches, inversePatches] (instead of just the next state)\r\n */ var produceWithPatches = /*#__PURE__*/ immer.produceWithPatches.bind(immer);\n/**\r\n * Pass true to automatically freeze all copies created by Immer.\r\n *\r\n * Always freeze by default, even in production mode\r\n */ var setAutoFreeze = /*#__PURE__*/ immer.setAutoFreeze.bind(immer);\n/**\r\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n * always faster than using ES5 proxies.\r\n *\r\n * By default, feature detection is used, so calling this is rarely necessary.\r\n */ var setUseProxies = /*#__PURE__*/ immer.setUseProxies.bind(immer);\n/**\r\n * Apply an array of Immer patches to the first argument.\r\n *\r\n * This function is a producer, which means copy-on-write is in effect.\r\n */ var applyPatches = /*#__PURE__*/ immer.applyPatches.bind(immer);\n/**\r\n * Create an Immer draft from the given base state, which may be a draft itself.\r\n * The draft can be modified until you finalize it with the `finishDraft` function.\r\n */ var createDraft = /*#__PURE__*/ immer.createDraft.bind(immer);\n/**\r\n * Finalize an Immer draft from a `createDraft` call, returning the base state\r\n * (if no changes were made) or a modified copy. The draft must *not* be\r\n * mutated afterwards.\r\n *\r\n * Pass a function as the 2nd argument to generate Immer patches based on the\r\n * changes that were made.\r\n */ var finishDraft = /*#__PURE__*/ immer.finishDraft.bind(immer);\n/**\r\n * This function is actually a no-op, but can be used to cast an immutable type\r\n * to an draft type and make TypeScript happy\r\n *\r\n * @param value\r\n */ function castDraft(value) {\n    return value;\n}\n/**\r\n * This function is actually a no-op, but can be used to cast a mutable type\r\n * to an immutable type and make TypeScript happy\r\n * @param value\r\n */ function castImmutable(value) {\n    return value;\n}\nexports.Immer = Immer;\nexports.applyPatches = applyPatches;\nexports.castDraft = castDraft;\nexports.castImmutable = castImmutable;\nexports.createDraft = createDraft;\nexports.current = current;\nexports[\"default\"] = produce;\nexports.enableAllPlugins = enableAllPlugins;\nexports.enableES5 = enableES5;\nexports.enableMapSet = enableMapSet;\nexports.enablePatches = enablePatches;\nexports.finishDraft = finishDraft;\nexports.freeze = freeze;\nexports.immerable = DRAFTABLE;\nexports.isDraft = isDraft;\nexports.isDraftable = isDraftable;\nexports.nothing = NOTHING;\nexports.original = original;\nexports.produce = produce;\nexports.produceWithPatches = produceWithPatches;\nexports.setAutoFreeze = setAutoFreeze;\nexports.setUseProxies = setUseProxies; //# sourceMappingURL=immer.cjs.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ltbWVyQDkuMC4yMS9ub2RlX21vZHVsZXMvaW1tZXIvZGlzdC9pbW1lci5janMuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFFN0QsSUFBSUM7QUFFSiw2QkFBNkI7QUFDN0IsMERBQTBEO0FBQzFELCtEQUErRDtBQUMvRCxJQUFJQyxZQUFZLE9BQU9DLFdBQVcsZUFBZSxPQUNqRCxXQUFXLEdBQ1hBLE9BQU8sU0FBUztBQUNoQixJQUFJQyxTQUFTLE9BQU9DLFFBQVE7QUFDNUIsSUFBSUMsU0FBUyxPQUFPQyxRQUFRO0FBQzVCLElBQUlDLGFBQWEsT0FBT0MsVUFBVSxlQUFlLE9BQU9BLE1BQU1DLFNBQVMsS0FBSyxlQUFlLE9BQU9DLFlBQVk7QUFDOUc7O0NBRUMsR0FFRCxJQUFJQyxVQUFVVixZQUNkLFdBQVcsR0FDWEMsT0FBT1UsR0FBRyxDQUFDLG1CQUFvQlosQ0FBQUEsT0FBTyxDQUFDLEdBQUdBLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxNQUFNQSxJQUFHO0FBQzNFOzs7Ozs7O0NBT0MsR0FFRCxJQUFJYSxZQUFZWixZQUNoQixXQUFXLEdBQ1hDLE9BQU9VLEdBQUcsQ0FBQyxxQkFBcUI7QUFDaEMsSUFBSUUsY0FBY2IsWUFDbEIsV0FBVyxHQUNYQyxPQUFPVSxHQUFHLENBQUMsaUJBQWlCLGtCQUFrQix5REFBeUQ7QUFFdkcsSUFBSUcsaUJBQWlCLE9BQU9iLFVBQVUsZUFBZUEsT0FBT2MsUUFBUSxJQUFJO0FBRXhFLElBQUlDLFNBQVM7SUFDWCxHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUc7SUFDSCxHQUFHLFNBQVNDLEVBQUVDLElBQUk7UUFDaEIsT0FBTyx5SEFBeUhBO0lBQ2xJO0lBQ0EsR0FBRztJQUNILEdBQUc7SUFDSCxHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUc7SUFDSCxHQUFHO0lBQ0gsSUFBSTtJ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QmpOLGVBQWUsR0FBRzRLO0FBQ2xCNUssa0JBQWUsR0FBRzBMO0FBQ2xCMUwsd0JBQXdCLEdBQUd3UztBQUMzQnhTLGlCQUFpQixHQUFHaU87QUFDcEJqTyxvQkFBb0IsR0FBR2lSO0FBQ3ZCalIscUJBQXFCLEdBQUd1UDtBQUN4QnZQLG1CQUFtQixHQUFHa047QUFDdEJsTixjQUFjLEdBQUdtRztBQUNqQm5HLGlCQUFpQixHQUFHZTtBQUNwQmYsZUFBZSxHQUFHc0M7QUFDbEJ0QyxtQkFBbUIsR0FBR3VDO0FBQ3RCdkMsZUFBZSxHQUFHYTtBQUNsQmIsZ0JBQWdCLEdBQUd1RDtBQUNuQnZELGVBQWUsR0FBRzBMO0FBQ2xCMUwsMEJBQTBCLEdBQUdzTTtBQUM3QnRNLHFCQUFxQixHQUFHK007QUFDeEIvTSxxQkFBcUIsR0FBRzZNLGVBQ3hCLGlEQUFpRCIsInNvdXJjZXMiOlsid2VicGFjazovL2tleXN0YXRpYy1zdGFydGVyLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pbW1lckA5LjAuMjEvbm9kZV9tb2R1bGVzL2ltbWVyL2Rpc3QvaW1tZXIuY2pzLmRldmVsb3BtZW50LmpzP2Y4YTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgX3JlZjtcblxuLy8gU2hvdWxkIGJlIG5vIGltcG9ydHMgaGVyZSFcbi8vIFNvbWUgdGhpbmdzIHRoYXQgc2hvdWxkIGJlIGV2YWx1YXRlZCBiZWZvcmUgYWxsIGVsc2UuLi5cbi8vIFdlIG9ubHkgd2FudCB0byBrbm93IGlmIG5vbi1wb2x5ZmlsbGVkIHN5bWJvbHMgYXJlIGF2YWlsYWJsZVxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mXG4vKiNfX1BVUkVfXyovXG5TeW1ib2woXCJ4XCIpID09PSBcInN5bWJvbFwiO1xudmFyIGhhc01hcCA9IHR5cGVvZiBNYXAgIT09IFwidW5kZWZpbmVkXCI7XG52YXIgaGFzU2V0ID0gdHlwZW9mIFNldCAhPT0gXCJ1bmRlZmluZWRcIjtcbnZhciBoYXNQcm94aWVzID0gdHlwZW9mIFByb3h5ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBQcm94eS5yZXZvY2FibGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCI7XG4vKipcclxuICogVGhlIHNlbnRpbmVsIHZhbHVlIHJldHVybmVkIGJ5IHByb2R1Y2VycyB0byByZXBsYWNlIHRoZSBkcmFmdCB3aXRoIHVuZGVmaW5lZC5cclxuICovXG5cbnZhciBOT1RISU5HID0gaGFzU3ltYm9sID9cbi8qI19fUFVSRV9fKi9cblN5bWJvbC5mb3IoXCJpbW1lci1ub3RoaW5nXCIpIDogKF9yZWYgPSB7fSwgX3JlZltcImltbWVyLW5vdGhpbmdcIl0gPSB0cnVlLCBfcmVmKTtcbi8qKlxyXG4gKiBUbyBsZXQgSW1tZXIgdHJlYXQgeW91ciBjbGFzcyBpbnN0YW5jZXMgYXMgcGxhaW4gaW1tdXRhYmxlIG9iamVjdHNcclxuICogKGFsYmVpdCB3aXRoIGEgY3VzdG9tIHByb3RvdHlwZSksIHlvdSBtdXN0IGRlZmluZSBlaXRoZXIgYW4gaW5zdGFuY2UgcHJvcGVydHlcclxuICogb3IgYSBzdGF0aWMgcHJvcGVydHkgb24gZWFjaCBvZiB5b3VyIGN1c3RvbSBjbGFzc2VzLlxyXG4gKlxyXG4gKiBPdGhlcndpc2UsIHlvdXIgY2xhc3MgaW5zdGFuY2Ugd2lsbCBuZXZlciBiZSBkcmFmdGVkLCB3aGljaCBtZWFucyBpdCB3b24ndCBiZVxyXG4gKiBzYWZlIHRvIG11dGF0ZSBpbiBhIHByb2R1Y2UgY2FsbGJhY2suXHJcbiAqL1xuXG52YXIgRFJBRlRBQkxFID0gaGFzU3ltYm9sID9cbi8qI19fUFVSRV9fKi9cblN5bWJvbC5mb3IoXCJpbW1lci1kcmFmdGFibGVcIikgOiBcIl9fJGltbWVyX2RyYWZ0YWJsZVwiO1xudmFyIERSQUZUX1NUQVRFID0gaGFzU3ltYm9sID9cbi8qI19fUFVSRV9fKi9cblN5bWJvbC5mb3IoXCJpbW1lci1zdGF0ZVwiKSA6IFwiX18kaW1tZXJfc3RhdGVcIjsgLy8gRXZlbiBhIHBvbHlmaWxsZWQgU3ltYm9sIG1pZ2h0IHByb3ZpZGUgU3ltYm9sLml0ZXJhdG9yXG5cbnZhciBpdGVyYXRvclN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG5cbnZhciBlcnJvcnMgPSB7XG4gIDA6IFwiSWxsZWdhbCBzdGF0ZVwiLFxuICAxOiBcIkltbWVyIGRyYWZ0cyBjYW5ub3QgaGF2ZSBjb21wdXRlZCBwcm9wZXJ0aWVzXCIsXG4gIDI6IFwiVGhpcyBvYmplY3QgaGFzIGJlZW4gZnJvemVuIGFuZCBzaG91bGQgbm90IGJlIG11dGF0ZWRcIixcbiAgMzogZnVuY3Rpb24gXyhkYXRhKSB7XG4gICAgcmV0dXJuIFwiQ2Fubm90IHVzZSBhIHByb3h5IHRoYXQgaGFzIGJlZW4gcmV2b2tlZC4gRGlkIHlvdSBwYXNzIGFuIG9iamVjdCBmcm9tIGluc2lkZSBhbiBpbW1lciBmdW5jdGlvbiB0byBhbiBhc3luYyBwcm9jZXNzPyBcIiArIGRhdGE7XG4gIH0sXG4gIDQ6IFwiQW4gaW1tZXIgcHJvZHVjZXIgcmV0dXJuZWQgYSBuZXcgdmFsdWUgKmFuZCogbW9kaWZpZWQgaXRzIGRyYWZ0LiBFaXRoZXIgcmV0dXJuIGEgbmV3IHZhbHVlICpvciogbW9kaWZ5IHRoZSBkcmFmdC5cIixcbiAgNTogXCJJbW1lciBmb3JiaWRzIGNpcmN1bGFyIHJlZmVyZW5jZXNcIixcbiAgNjogXCJUaGUgZmlyc3Qgb3Igc2Vjb25kIGFyZ3VtZW50IHRvIGBwcm9kdWNlYCBtdXN0IGJlIGEgZnVuY3Rpb25cIixcbiAgNzogXCJUaGUgdGhpcmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvbiBvciB1bmRlZmluZWRcIixcbiAgODogXCJGaXJzdCBhcmd1bWVudCB0byBgY3JlYXRlRHJhZnRgIG11c3QgYmUgYSBwbGFpbiBvYmplY3QsIGFuIGFycmF5LCBvciBhbiBpbW1lcmFibGUgb2JqZWN0XCIsXG4gIDk6IFwiRmlyc3QgYXJndW1lbnQgdG8gYGZpbmlzaERyYWZ0YCBtdXN0IGJlIGEgZHJhZnQgcmV0dXJuZWQgYnkgYGNyZWF0ZURyYWZ0YFwiLFxuICAxMDogXCJUaGUgZ2l2ZW4gZHJhZnQgaXMgYWxyZWFkeSBmaW5hbGl6ZWRcIixcbiAgMTE6IFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KCkgY2Fubm90IGJlIHVzZWQgb24gYW4gSW1tZXIgZHJhZnRcIixcbiAgMTI6IFwiT2JqZWN0LnNldFByb3RvdHlwZU9mKCkgY2Fubm90IGJlIHVzZWQgb24gYW4gSW1tZXIgZHJhZnRcIixcbiAgMTM6IFwiSW1tZXIgb25seSBzdXBwb3J0cyBkZWxldGluZyBhcnJheSBpbmRpY2VzXCIsXG4gIDE0OiBcIkltbWVyIG9ubHkgc3VwcG9ydHMgc2V0dGluZyBhcnJheSBpbmRpY2VzIGFuZCB0aGUgJ2xlbmd0aCcgcHJvcGVydHlcIixcbiAgMTU6IGZ1bmN0aW9uIF8ocGF0aCkge1xuICAgIHJldHVybiBcIkNhbm5vdCBhcHBseSBwYXRjaCwgcGF0aCBkb2Vzbid0IHJlc29sdmU6IFwiICsgcGF0aDtcbiAgfSxcbiAgMTY6ICdTZXRzIGNhbm5vdCBoYXZlIFwicmVwbGFjZVwiIHBhdGNoZXMuJyxcbiAgMTc6IGZ1bmN0aW9uIF8ob3ApIHtcbiAgICByZXR1cm4gXCJVbnN1cHBvcnRlZCBwYXRjaCBvcGVyYXRpb246IFwiICsgb3A7XG4gIH0sXG4gIDE4OiBmdW5jdGlvbiBfKHBsdWdpbikge1xuICAgIHJldHVybiBcIlRoZSBwbHVnaW4gZm9yICdcIiArIHBsdWdpbiArIFwiJyBoYXMgbm90IGJlZW4gbG9hZGVkIGludG8gSW1tZXIuIFRvIGVuYWJsZSB0aGUgcGx1Z2luLCBpbXBvcnQgYW5kIGNhbGwgYGVuYWJsZVwiICsgcGx1Z2luICsgXCIoKWAgd2hlbiBpbml0aWFsaXppbmcgeW91ciBhcHBsaWNhdGlvbi5cIjtcbiAgfSxcbiAgMjA6IFwiQ2Fubm90IHVzZSBwcm94aWVzIGlmIFByb3h5LCBQcm94eS5yZXZvY2FibGUgb3IgUmVmbGVjdCBhcmUgbm90IGF2YWlsYWJsZVwiLFxuICAyMTogZnVuY3Rpb24gXyh0aGluZykge1xuICAgIHJldHVybiBcInByb2R1Y2UgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoaW5ncyB0aGF0IGFyZSBkcmFmdGFibGU6IHBsYWluIG9iamVjdHMsIGFycmF5cywgTWFwLCBTZXQgb3IgY2xhc3NlcyB0aGF0IGFyZSBtYXJrZWQgd2l0aCAnW2ltbWVyYWJsZV06IHRydWUnLiBHb3QgJ1wiICsgdGhpbmcgKyBcIidcIjtcbiAgfSxcbiAgMjI6IGZ1bmN0aW9uIF8odGhpbmcpIHtcbiAgICByZXR1cm4gXCInY3VycmVudCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6IFwiICsgdGhpbmc7XG4gIH0sXG4gIDIzOiBmdW5jdGlvbiBfKHRoaW5nKSB7XG4gICAgcmV0dXJuIFwiJ29yaWdpbmFsJyBleHBlY3RzIGEgZHJhZnQsIGdvdDogXCIgKyB0aGluZztcbiAgfSxcbiAgMjQ6IFwiUGF0Y2hpbmcgcmVzZXJ2ZWQgYXR0cmlidXRlcyBsaWtlIF9fcHJvdG9fXywgcHJvdG90eXBlIGFuZCBjb25zdHJ1Y3RvciBpcyBub3QgYWxsb3dlZFwiXG59O1xuZnVuY3Rpb24gZGllKGVycm9yKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHtcbiAgICB2YXIgZSA9IGVycm9yc1tlcnJvcl07XG4gICAgdmFyIG1zZyA9ICFlID8gXCJ1bmtub3duIGVycm9yIG5yOiBcIiArIGVycm9yIDogdHlwZW9mIGUgPT09IFwiZnVuY3Rpb25cIiA/IGUuYXBwbHkobnVsbCwgYXJncykgOiBlO1xuICAgIHRocm93IG5ldyBFcnJvcihcIltJbW1lcl0gXCIgKyBtc2cpO1xuICB9XG59XG5cbi8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIEltbWVyIGRyYWZ0ICovXG5cbi8qI19fUFVSRV9fKi9cblxuZnVuY3Rpb24gaXNEcmFmdCh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiAhIXZhbHVlW0RSQUZUX1NUQVRFXTtcbn1cbi8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGNhbiBiZSBkcmFmdGVkIGJ5IEltbWVyICovXG5cbi8qI19fUFVSRV9fKi9cblxuZnVuY3Rpb24gaXNEcmFmdGFibGUodmFsdWUpIHtcbiAgdmFyIF92YWx1ZSRjb25zdHJ1Y3RvcjtcblxuICBpZiAoIXZhbHVlKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCAhIXZhbHVlW0RSQUZUQUJMRV0gfHwgISEoKF92YWx1ZSRjb25zdHJ1Y3RvciA9IHZhbHVlLmNvbnN0cnVjdG9yKSA9PT0gbnVsbCB8fCBfdmFsdWUkY29uc3RydWN0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF92YWx1ZSRjb25zdHJ1Y3RvcltEUkFGVEFCTEVdKSB8fCBpc01hcCh2YWx1ZSkgfHwgaXNTZXQodmFsdWUpO1xufVxudmFyIG9iamVjdEN0b3JTdHJpbmcgPVxuLyojX19QVVJFX18qL1xuT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci50b1N0cmluZygpO1xuLyojX19QVVJFX18qL1xuXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSByZXR1cm4gZmFsc2U7XG4gIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG5cbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgQ3RvciA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCBcImNvbnN0cnVjdG9yXCIpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICBpZiAoQ3RvciA9PT0gT2JqZWN0KSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09IFwiZnVuY3Rpb25cIiAmJiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKEN0b3IpID09PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuZnVuY3Rpb24gb3JpZ2luYWwodmFsdWUpIHtcbiAgaWYgKCFpc0RyYWZ0KHZhbHVlKSkgZGllKDIzLCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZVtEUkFGVF9TVEFURV0uYmFzZV87XG59XG4vKiNfX1BVUkVfXyovXG5cbnZhciBvd25LZXlzID0gdHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5vd25LZXlzID8gUmVmbGVjdC5vd25LZXlzIDogdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09IFwidW5kZWZpbmVkXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaikpO1xufSA6XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnModGFyZ2V0KSB7XG4gIC8vIFBvbHlmaWxsIG5lZWRlZCBmb3IgSGVybWVzIGFuZCBJRSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9oZXJtZXMvaXNzdWVzLzI3NFxuICB2YXIgcmVzID0ge307XG4gIG93bktleXModGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXNba2V5XSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICB9KTtcbiAgcmV0dXJuIHJlcztcbn07XG5mdW5jdGlvbiBlYWNoKG9iaiwgaXRlciwgZW51bWVyYWJsZU9ubHkpIHtcbiAgaWYgKGVudW1lcmFibGVPbmx5ID09PSB2b2lkIDApIHtcbiAgICBlbnVtZXJhYmxlT25seSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKGdldEFyY2h0eXBlKG9iaikgPT09IDBcbiAgLyogT2JqZWN0ICovXG4gICkge1xuICAgICAgKGVudW1lcmFibGVPbmx5ID8gT2JqZWN0LmtleXMgOiBvd25LZXlzKShvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIWVudW1lcmFibGVPbmx5IHx8IHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIpIGl0ZXIoa2V5LCBvYmpba2V5XSwgb2JqKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgb2JqLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xuICAgICAgcmV0dXJuIGl0ZXIoaW5kZXgsIGVudHJ5LCBvYmopO1xuICAgIH0pO1xuICB9XG59XG4vKiNfX1BVUkVfXyovXG5cbmZ1bmN0aW9uIGdldEFyY2h0eXBlKHRoaW5nKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHZhciBzdGF0ZSA9IHRoaW5nW0RSQUZUX1NUQVRFXTtcbiAgcmV0dXJuIHN0YXRlID8gc3RhdGUudHlwZV8gPiAzID8gc3RhdGUudHlwZV8gLSA0IC8vIGNhdXNlIE9iamVjdCBhbmQgQXJyYXkgbWFwIGJhY2sgZnJvbSA0IGFuZCA1XG4gIDogc3RhdGUudHlwZV8gLy8gb3RoZXJzIGFyZSB0aGUgc2FtZVxuICA6IEFycmF5LmlzQXJyYXkodGhpbmcpID8gMVxuICAvKiBBcnJheSAqL1xuICA6IGlzTWFwKHRoaW5nKSA/IDJcbiAgLyogTWFwICovXG4gIDogaXNTZXQodGhpbmcpID8gM1xuICAvKiBTZXQgKi9cbiAgOiAwXG4gIC8qIE9iamVjdCAqL1xuICA7XG59XG4vKiNfX1BVUkVfXyovXG5cbmZ1bmN0aW9uIGhhcyh0aGluZywgcHJvcCkge1xuICByZXR1cm4gZ2V0QXJjaHR5cGUodGhpbmcpID09PSAyXG4gIC8qIE1hcCAqL1xuICA/IHRoaW5nLmhhcyhwcm9wKSA6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGluZywgcHJvcCk7XG59XG4vKiNfX1BVUkVfXyovXG5cbmZ1bmN0aW9uIGdldCh0aGluZywgcHJvcCkge1xuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiBnZXRBcmNodHlwZSh0aGluZykgPT09IDJcbiAgLyogTWFwICovXG4gID8gdGhpbmcuZ2V0KHByb3ApIDogdGhpbmdbcHJvcF07XG59XG4vKiNfX1BVUkVfXyovXG5cbmZ1bmN0aW9uIHNldCh0aGluZywgcHJvcE9yT2xkVmFsdWUsIHZhbHVlKSB7XG4gIHZhciB0ID0gZ2V0QXJjaHR5cGUodGhpbmcpO1xuICBpZiAodCA9PT0gMlxuICAvKiBNYXAgKi9cbiAgKSB0aGluZy5zZXQocHJvcE9yT2xkVmFsdWUsIHZhbHVlKTtlbHNlIGlmICh0ID09PSAzXG4gIC8qIFNldCAqL1xuICApIHtcbiAgICAgIHRoaW5nLmFkZCh2YWx1ZSk7XG4gICAgfSBlbHNlIHRoaW5nW3Byb3BPck9sZFZhbHVlXSA9IHZhbHVlO1xufVxuLyojX19QVVJFX18qL1xuXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIEZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvYzY5OTA0YTUxMWI5MDAyNjY5MzUxNjgyMjMwNjNkZDg3NzJkZmM0MC9wYWNrYWdlcy9mYmpzL3NyYy9jb3JlL3NoYWxsb3dFcXVhbC5qc1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG4vKiNfX1BVUkVfXyovXG5cbmZ1bmN0aW9uIGlzTWFwKHRhcmdldCkge1xuICByZXR1cm4gaGFzTWFwICYmIHRhcmdldCBpbnN0YW5jZW9mIE1hcDtcbn1cbi8qI19fUFVSRV9fKi9cblxuZnVuY3Rpb24gaXNTZXQodGFyZ2V0KSB7XG4gIHJldHVybiBoYXNTZXQgJiYgdGFyZ2V0IGluc3RhbmNlb2YgU2V0O1xufVxuLyojX19QVVJFX18qL1xuXG5mdW5jdGlvbiBsYXRlc3Qoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmNvcHlfIHx8IHN0YXRlLmJhc2VfO1xufVxuLyojX19QVVJFX18qL1xuXG5mdW5jdGlvbiBzaGFsbG93Q29weShiYXNlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJhc2UpKSByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYmFzZSk7XG4gIHZhciBkZXNjcmlwdG9ycyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoYmFzZSk7XG4gIGRlbGV0ZSBkZXNjcmlwdG9yc1tEUkFGVF9TVEFURV07XG4gIHZhciBrZXlzID0gb3duS2V5cyhkZXNjcmlwdG9ycyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgdmFyIGRlc2MgPSBkZXNjcmlwdG9yc1trZXldO1xuXG4gICAgaWYgKGRlc2Mud3JpdGFibGUgPT09IGZhbHNlKSB7XG4gICAgICBkZXNjLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIGRlc2MuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICB9IC8vIGxpa2Ugb2JqZWN0LmFzc2lnbiwgd2Ugd2lsbCByZWFkIGFueSBfb3duXywgZ2V0L3NldCBhY2Nlc3NvcnMuIFRoaXMgaGVscHMgaW4gZGVhbGluZ1xuICAgIC8vIHdpdGggbGlicmFyaWVzIHRoYXQgdHJhcCB2YWx1ZXMsIGxpa2UgbW9ieCBvciB2dWVcbiAgICAvLyB1bmxpa2Ugb2JqZWN0LmFzc2lnbiwgbm9uLWVudW1lcmFibGVzIHdpbGwgYmUgY29waWVkIGFzIHdlbGxcblxuXG4gICAgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSBkZXNjcmlwdG9yc1trZXldID0ge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBkZXNjLmVudW1lcmFibGUsXG4gICAgICB2YWx1ZTogYmFzZVtrZXldXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihiYXNlKSwgZGVzY3JpcHRvcnMpO1xufVxuZnVuY3Rpb24gZnJlZXplKG9iaiwgZGVlcCkge1xuICBpZiAoZGVlcCA9PT0gdm9pZCAwKSB7XG4gICAgZGVlcCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzRnJvemVuKG9iaikgfHwgaXNEcmFmdChvYmopIHx8ICFpc0RyYWZ0YWJsZShvYmopKSByZXR1cm4gb2JqO1xuXG4gIGlmIChnZXRBcmNodHlwZShvYmopID4gMVxuICAvKiBNYXAgb3IgU2V0ICovXG4gICkge1xuICAgICAgb2JqLnNldCA9IG9iai5hZGQgPSBvYmouY2xlYXIgPSBvYmouZGVsZXRlID0gZG9udE11dGF0ZUZyb3plbkNvbGxlY3Rpb25zO1xuICAgIH1cblxuICBPYmplY3QuZnJlZXplKG9iaik7XG4gIGlmIChkZWVwKSBlYWNoKG9iaiwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gZnJlZXplKHZhbHVlLCB0cnVlKTtcbiAgfSwgdHJ1ZSk7XG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGRvbnRNdXRhdGVGcm96ZW5Db2xsZWN0aW9ucygpIHtcbiAgZGllKDIpO1xufVxuXG5mdW5jdGlvbiBpc0Zyb3plbihvYmopIHtcbiAgaWYgKG9iaiA9PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHJldHVybiB0cnVlOyAvLyBTZWUgIzYwMCwgSUUgZGllcyBvbiBub24tb2JqZWN0cyBpbiBPYmplY3QuaXNGcm96ZW5cblxuICByZXR1cm4gT2JqZWN0LmlzRnJvemVuKG9iaik7XG59XG5cbi8qKiBQbHVnaW4gdXRpbGl0aWVzICovXG5cbnZhciBwbHVnaW5zID0ge307XG5mdW5jdGlvbiBnZXRQbHVnaW4ocGx1Z2luS2V5KSB7XG4gIHZhciBwbHVnaW4gPSBwbHVnaW5zW3BsdWdpbktleV07XG5cbiAgaWYgKCFwbHVnaW4pIHtcbiAgICBkaWUoMTgsIHBsdWdpbktleSk7XG4gIH0gLy8gQHRzLWlnbm9yZVxuXG5cbiAgcmV0dXJuIHBsdWdpbjtcbn1cbmZ1bmN0aW9uIGxvYWRQbHVnaW4ocGx1Z2luS2V5LCBpbXBsZW1lbnRhdGlvbikge1xuICBpZiAoIXBsdWdpbnNbcGx1Z2luS2V5XSkgcGx1Z2luc1twbHVnaW5LZXldID0gaW1wbGVtZW50YXRpb247XG59XG5cbnZhciBjdXJyZW50U2NvcGU7XG5mdW5jdGlvbiBnZXRDdXJyZW50U2NvcGUoKSB7XG4gIGlmICggIWN1cnJlbnRTY29wZSkgZGllKDApO1xuICByZXR1cm4gY3VycmVudFNjb3BlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTY29wZShwYXJlbnRfLCBpbW1lcl8pIHtcbiAgcmV0dXJuIHtcbiAgICBkcmFmdHNfOiBbXSxcbiAgICBwYXJlbnRfOiBwYXJlbnRfLFxuICAgIGltbWVyXzogaW1tZXJfLFxuICAgIC8vIFdoZW5ldmVyIHRoZSBtb2RpZmllZCBkcmFmdCBjb250YWlucyBhIGRyYWZ0IGZyb20gYW5vdGhlciBzY29wZSwgd2VcbiAgICAvLyBuZWVkIHRvIHByZXZlbnQgYXV0by1mcmVlemluZyBzbyB0aGUgdW5vd25lZCBkcmFmdCBjYW4gYmUgZmluYWxpemVkLlxuICAgIGNhbkF1dG9GcmVlemVfOiB0cnVlLFxuICAgIHVuZmluYWxpemVkRHJhZnRzXzogMFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcikge1xuICBpZiAocGF0Y2hMaXN0ZW5lcikge1xuICAgIGdldFBsdWdpbihcIlBhdGNoZXNcIik7IC8vIGFzc2VydCB3ZSBoYXZlIHRoZSBwbHVnaW5cblxuICAgIHNjb3BlLnBhdGNoZXNfID0gW107XG4gICAgc2NvcGUuaW52ZXJzZVBhdGNoZXNfID0gW107XG4gICAgc2NvcGUucGF0Y2hMaXN0ZW5lcl8gPSBwYXRjaExpc3RlbmVyO1xuICB9XG59XG5mdW5jdGlvbiByZXZva2VTY29wZShzY29wZSkge1xuICBsZWF2ZVNjb3BlKHNjb3BlKTtcbiAgc2NvcGUuZHJhZnRzXy5mb3JFYWNoKHJldm9rZURyYWZ0KTsgLy8gQHRzLWlnbm9yZVxuXG4gIHNjb3BlLmRyYWZ0c18gPSBudWxsO1xufVxuZnVuY3Rpb24gbGVhdmVTY29wZShzY29wZSkge1xuICBpZiAoc2NvcGUgPT09IGN1cnJlbnRTY29wZSkge1xuICAgIGN1cnJlbnRTY29wZSA9IHNjb3BlLnBhcmVudF87XG4gIH1cbn1cbmZ1bmN0aW9uIGVudGVyU2NvcGUoaW1tZXIpIHtcbiAgcmV0dXJuIGN1cnJlbnRTY29wZSA9IGNyZWF0ZVNjb3BlKGN1cnJlbnRTY29wZSwgaW1tZXIpO1xufVxuXG5mdW5jdGlvbiByZXZva2VEcmFmdChkcmFmdCkge1xuICB2YXIgc3RhdGUgPSBkcmFmdFtEUkFGVF9TVEFURV07XG4gIGlmIChzdGF0ZS50eXBlXyA9PT0gMFxuICAvKiBQcm94eU9iamVjdCAqL1xuICB8fCBzdGF0ZS50eXBlXyA9PT0gMVxuICAvKiBQcm94eUFycmF5ICovXG4gICkgc3RhdGUucmV2b2tlXygpO2Vsc2Ugc3RhdGUucmV2b2tlZF8gPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmVzdWx0KHJlc3VsdCwgc2NvcGUpIHtcbiAgc2NvcGUudW5maW5hbGl6ZWREcmFmdHNfID0gc2NvcGUuZHJhZnRzXy5sZW5ndGg7XG4gIHZhciBiYXNlRHJhZnQgPSBzY29wZS5kcmFmdHNfWzBdO1xuICB2YXIgaXNSZXBsYWNlZCA9IHJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIHJlc3VsdCAhPT0gYmFzZURyYWZ0O1xuICBpZiAoIXNjb3BlLmltbWVyXy51c2VQcm94aWVzXykgZ2V0UGx1Z2luKFwiRVM1XCIpLndpbGxGaW5hbGl6ZUVTNV8oc2NvcGUsIHJlc3VsdCwgaXNSZXBsYWNlZCk7XG5cbiAgaWYgKGlzUmVwbGFjZWQpIHtcbiAgICBpZiAoYmFzZURyYWZ0W0RSQUZUX1NUQVRFXS5tb2RpZmllZF8pIHtcbiAgICAgIHJldm9rZVNjb3BlKHNjb3BlKTtcbiAgICAgIGRpZSg0KTtcbiAgICB9XG5cbiAgICBpZiAoaXNEcmFmdGFibGUocmVzdWx0KSkge1xuICAgICAgLy8gRmluYWxpemUgdGhlIHJlc3VsdCBpbiBjYXNlIGl0IGNvbnRhaW5zIChvciBpcykgYSBzdWJzZXQgb2YgdGhlIGRyYWZ0LlxuICAgICAgcmVzdWx0ID0gZmluYWxpemUoc2NvcGUsIHJlc3VsdCk7XG4gICAgICBpZiAoIXNjb3BlLnBhcmVudF8pIG1heWJlRnJlZXplKHNjb3BlLCByZXN1bHQpO1xuICAgIH1cblxuICAgIGlmIChzY29wZS5wYXRjaGVzXykge1xuICAgICAgZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5nZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oYmFzZURyYWZ0W0RSQUZUX1NUQVRFXS5iYXNlXywgcmVzdWx0LCBzY29wZS5wYXRjaGVzXywgc2NvcGUuaW52ZXJzZVBhdGNoZXNfKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRmluYWxpemUgdGhlIGJhc2UgZHJhZnQuXG4gICAgcmVzdWx0ID0gZmluYWxpemUoc2NvcGUsIGJhc2VEcmFmdCwgW10pO1xuICB9XG5cbiAgcmV2b2tlU2NvcGUoc2NvcGUpO1xuXG4gIGlmIChzY29wZS5wYXRjaGVzXykge1xuICAgIHNjb3BlLnBhdGNoTGlzdGVuZXJfKHNjb3BlLnBhdGNoZXNfLCBzY29wZS5pbnZlcnNlUGF0Y2hlc18pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdCAhPT0gTk9USElORyA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZmluYWxpemUocm9vdFNjb3BlLCB2YWx1ZSwgcGF0aCkge1xuICAvLyBEb24ndCByZWN1cnNlIGluIHRobyByZWN1cnNpdmUgZGF0YSBzdHJ1Y3R1cmVzXG4gIGlmIChpc0Zyb3plbih2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgdmFyIHN0YXRlID0gdmFsdWVbRFJBRlRfU1RBVEVdOyAvLyBBIHBsYWluIG9iamVjdCwgbWlnaHQgbmVlZCBmcmVlemluZywgbWlnaHQgY29udGFpbiBkcmFmdHNcblxuICBpZiAoIXN0YXRlKSB7XG4gICAgZWFjaCh2YWx1ZSwgZnVuY3Rpb24gKGtleSwgY2hpbGRWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZpbmFsaXplUHJvcGVydHkocm9vdFNjb3BlLCBzdGF0ZSwgdmFsdWUsIGtleSwgY2hpbGRWYWx1ZSwgcGF0aCk7XG4gICAgfSwgdHJ1ZSAvLyBTZWUgIzU5MCwgZG9uJ3QgcmVjdXJzZSBpbnRvIG5vbi1lbnVtZXJhYmxlIG9mIG5vbiBkcmFmdGVkIG9iamVjdHNcbiAgICApO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSAvLyBOZXZlciBmaW5hbGl6ZSBkcmFmdHMgb3duZWQgYnkgYW5vdGhlciBzY29wZS5cblxuXG4gIGlmIChzdGF0ZS5zY29wZV8gIT09IHJvb3RTY29wZSkgcmV0dXJuIHZhbHVlOyAvLyBVbm1vZGlmaWVkIGRyYWZ0LCByZXR1cm4gdGhlIChmcm96ZW4pIG9yaWdpbmFsXG5cbiAgaWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcbiAgICBtYXliZUZyZWV6ZShyb290U2NvcGUsIHN0YXRlLmJhc2VfLCB0cnVlKTtcbiAgICByZXR1cm4gc3RhdGUuYmFzZV87XG4gIH0gLy8gTm90IGZpbmFsaXplZCB5ZXQsIGxldCdzIGRvIHRoYXQgbm93XG5cblxuICBpZiAoIXN0YXRlLmZpbmFsaXplZF8pIHtcbiAgICBzdGF0ZS5maW5hbGl6ZWRfID0gdHJ1ZTtcbiAgICBzdGF0ZS5zY29wZV8udW5maW5hbGl6ZWREcmFmdHNfLS07XG4gICAgdmFyIHJlc3VsdCA9IC8vIEZvciBFUzUsIGNyZWF0ZSBhIGdvb2QgY29weSBmcm9tIHRoZSBkcmFmdCBmaXJzdCwgd2l0aCBhZGRlZCBrZXlzIGFuZCB3aXRob3V0IGRlbGV0ZWQga2V5cy5cbiAgICBzdGF0ZS50eXBlXyA9PT0gNFxuICAgIC8qIEVTNU9iamVjdCAqL1xuICAgIHx8IHN0YXRlLnR5cGVfID09PSA1XG4gICAgLyogRVM1QXJyYXkgKi9cbiAgICA/IHN0YXRlLmNvcHlfID0gc2hhbGxvd0NvcHkoc3RhdGUuZHJhZnRfKSA6IHN0YXRlLmNvcHlfOyAvLyBGaW5hbGl6ZSBhbGwgY2hpbGRyZW4gb2YgdGhlIGNvcHlcbiAgICAvLyBGb3Igc2V0cyB3ZSBjbG9uZSBiZWZvcmUgaXRlcmF0aW5nLCBvdGhlcndpc2Ugd2UgY2FuIGdldCBpbiBlbmRsZXNzIGxvb3AgZHVlIHRvIG1vZGlmeWluZyBkdXJpbmcgaXRlcmF0aW9uLCBzZWUgIzYyOFxuICAgIC8vIFRvIHByZXNlcnZlIGluc2VydGlvbiBvcmRlciBpbiBhbGwgY2FzZXMgd2UgdGhlbiBjbGVhciB0aGUgc2V0XG4gICAgLy8gQW5kIHdlIGxldCBmaW5hbGl6ZVByb3BlcnR5IGtub3cgaXQgbmVlZHMgdG8gcmUtYWRkIG5vbi1kcmFmdCBjaGlsZHJlbiBiYWNrIHRvIHRoZSB0YXJnZXRcblxuICAgIHZhciByZXN1bHRFYWNoID0gcmVzdWx0O1xuICAgIHZhciBpc1NldCA9IGZhbHNlO1xuXG4gICAgaWYgKHN0YXRlLnR5cGVfID09PSAzXG4gICAgLyogU2V0ICovXG4gICAgKSB7XG4gICAgICAgIHJlc3VsdEVhY2ggPSBuZXcgU2V0KHJlc3VsdCk7XG4gICAgICAgIHJlc3VsdC5jbGVhcigpO1xuICAgICAgICBpc1NldCA9IHRydWU7XG4gICAgICB9XG5cbiAgICBlYWNoKHJlc3VsdEVhY2gsIGZ1bmN0aW9uIChrZXksIGNoaWxkVmFsdWUpIHtcbiAgICAgIHJldHVybiBmaW5hbGl6ZVByb3BlcnR5KHJvb3RTY29wZSwgc3RhdGUsIHJlc3VsdCwga2V5LCBjaGlsZFZhbHVlLCBwYXRoLCBpc1NldCk7XG4gICAgfSk7IC8vIGV2ZXJ5dGhpbmcgaW5zaWRlIGlzIGZyb3plbiwgd2UgY2FuIGZyZWV6ZSBoZXJlXG5cbiAgICBtYXliZUZyZWV6ZShyb290U2NvcGUsIHJlc3VsdCwgZmFsc2UpOyAvLyBmaXJzdCB0aW1lIGZpbmFsaXppbmcsIGxldCdzIGNyZWF0ZSB0aG9zZSBwYXRjaGVzXG5cbiAgICBpZiAocGF0aCAmJiByb290U2NvcGUucGF0Y2hlc18pIHtcbiAgICAgIGdldFBsdWdpbihcIlBhdGNoZXNcIikuZ2VuZXJhdGVQYXRjaGVzXyhzdGF0ZSwgcGF0aCwgcm9vdFNjb3BlLnBhdGNoZXNfLCByb290U2NvcGUuaW52ZXJzZVBhdGNoZXNfKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RhdGUuY29weV87XG59XG5cbmZ1bmN0aW9uIGZpbmFsaXplUHJvcGVydHkocm9vdFNjb3BlLCBwYXJlbnRTdGF0ZSwgdGFyZ2V0T2JqZWN0LCBwcm9wLCBjaGlsZFZhbHVlLCByb290UGF0aCwgdGFyZ2V0SXNTZXQpIHtcbiAgaWYgKCBjaGlsZFZhbHVlID09PSB0YXJnZXRPYmplY3QpIGRpZSg1KTtcblxuICBpZiAoaXNEcmFmdChjaGlsZFZhbHVlKSkge1xuICAgIHZhciBwYXRoID0gcm9vdFBhdGggJiYgcGFyZW50U3RhdGUgJiYgcGFyZW50U3RhdGUudHlwZV8gIT09IDNcbiAgICAvKiBTZXQgKi9cbiAgICAmJiAvLyBTZXQgb2JqZWN0cyBhcmUgYXRvbWljIHNpbmNlIHRoZXkgaGF2ZSBubyBrZXlzLlxuICAgICFoYXMocGFyZW50U3RhdGUuYXNzaWduZWRfLCBwcm9wKSAvLyBTa2lwIGRlZXAgcGF0Y2hlcyBmb3IgYXNzaWduZWQga2V5cy5cbiAgICA/IHJvb3RQYXRoLmNvbmNhdChwcm9wKSA6IHVuZGVmaW5lZDsgLy8gRHJhZnRzIG93bmVkIGJ5IGBzY29wZWAgYXJlIGZpbmFsaXplZCBoZXJlLlxuXG4gICAgdmFyIHJlcyA9IGZpbmFsaXplKHJvb3RTY29wZSwgY2hpbGRWYWx1ZSwgcGF0aCk7XG4gICAgc2V0KHRhcmdldE9iamVjdCwgcHJvcCwgcmVzKTsgLy8gRHJhZnRzIGZyb20gYW5vdGhlciBzY29wZSBtdXN0IHByZXZlbnRlZCB0byBiZSBmcm96ZW5cbiAgICAvLyBpZiB3ZSBnb3QgYSBkcmFmdCBiYWNrIGZyb20gZmluYWxpemUsIHdlJ3JlIGluIGEgbmVzdGVkIHByb2R1Y2UgYW5kIHNob3VsZG4ndCBmcmVlemVcblxuICAgIGlmIChpc0RyYWZ0KHJlcykpIHtcbiAgICAgIHJvb3RTY29wZS5jYW5BdXRvRnJlZXplXyA9IGZhbHNlO1xuICAgIH0gZWxzZSByZXR1cm47XG4gIH0gZWxzZSBpZiAodGFyZ2V0SXNTZXQpIHtcbiAgICB0YXJnZXRPYmplY3QuYWRkKGNoaWxkVmFsdWUpO1xuICB9IC8vIFNlYXJjaCBuZXcgb2JqZWN0cyBmb3IgdW5maW5hbGl6ZWQgZHJhZnRzLiBGcm96ZW4gb2JqZWN0cyBzaG91bGQgbmV2ZXIgY29udGFpbiBkcmFmdHMuXG5cblxuICBpZiAoaXNEcmFmdGFibGUoY2hpbGRWYWx1ZSkgJiYgIWlzRnJvemVuKGNoaWxkVmFsdWUpKSB7XG4gICAgaWYgKCFyb290U2NvcGUuaW1tZXJfLmF1dG9GcmVlemVfICYmIHJvb3RTY29wZS51bmZpbmFsaXplZERyYWZ0c18gPCAxKSB7XG4gICAgICAvLyBvcHRpbWl6YXRpb246IGlmIGFuIG9iamVjdCBpcyBub3QgYSBkcmFmdCwgYW5kIHdlIGRvbid0IGhhdmUgdG9cbiAgICAgIC8vIGRlZXBmcmVlemUgZXZlcnl0aGluZywgYW5kIHdlIGFyZSBzdXJlIHRoYXQgbm8gZHJhZnRzIGFyZSBsZWZ0IGluIHRoZSByZW1haW5pbmcgb2JqZWN0XG4gICAgICAvLyBjYXVzZSB3ZSBzYXcgYW5kIGZpbmFsaXplZCBhbGwgZHJhZnRzIGFscmVhZHk7IHdlIGNhbiBzdG9wIHZpc2l0aW5nIHRoZSByZXN0IG9mIHRoZSB0cmVlLlxuICAgICAgLy8gVGhpcyBiZW5lZml0cyBlc3BlY2lhbGx5IGFkZGluZyBsYXJnZSBkYXRhIHRyZWUncyB3aXRob3V0IGZ1cnRoZXIgcHJvY2Vzc2luZy5cbiAgICAgIC8vIFNlZSBhZGQtZGF0YS5qcyBwZXJmIHRlc3RcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmaW5hbGl6ZShyb290U2NvcGUsIGNoaWxkVmFsdWUpOyAvLyBpbW1lciBkZWVwIGZyZWV6ZXMgcGxhaW4gb2JqZWN0cywgc28gaWYgdGhlcmUgaXMgbm8gcGFyZW50IHN0YXRlLCB3ZSBmcmVlemUgYXMgd2VsbFxuXG4gICAgaWYgKCFwYXJlbnRTdGF0ZSB8fCAhcGFyZW50U3RhdGUuc2NvcGVfLnBhcmVudF8pIG1heWJlRnJlZXplKHJvb3RTY29wZSwgY2hpbGRWYWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVGcmVlemUoc2NvcGUsIHZhbHVlLCBkZWVwKSB7XG4gIGlmIChkZWVwID09PSB2b2lkIDApIHtcbiAgICBkZWVwID0gZmFsc2U7XG4gIH1cblxuICAvLyB3ZSBuZXZlciBmcmVlemUgZm9yIGEgbm9uLXJvb3Qgc2NvcGU7IGFzIGl0IHdvdWxkIHByZXZlbnQgcHJ1bmluZyBmb3IgZHJhZnRzIGluc2lkZSB3cmFwcGluZyBvYmplY3RzXG4gIGlmICghc2NvcGUucGFyZW50XyAmJiBzY29wZS5pbW1lcl8uYXV0b0ZyZWV6ZV8gJiYgc2NvcGUuY2FuQXV0b0ZyZWV6ZV8pIHtcbiAgICBmcmVlemUodmFsdWUsIGRlZXApO1xuICB9XG59XG5cbi8qKlxyXG4gKiBSZXR1cm5zIGEgbmV3IGRyYWZ0IG9mIHRoZSBgYmFzZWAgb2JqZWN0LlxyXG4gKlxyXG4gKiBUaGUgc2Vjb25kIGFyZ3VtZW50IGlzIHRoZSBwYXJlbnQgZHJhZnQtc3RhdGUgKHVzZWQgaW50ZXJuYWxseSkuXHJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVQcm94eVByb3h5KGJhc2UsIHBhcmVudCkge1xuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoYmFzZSk7XG4gIHZhciBzdGF0ZSA9IHtcbiAgICB0eXBlXzogaXNBcnJheSA/IDFcbiAgICAvKiBQcm94eUFycmF5ICovXG4gICAgOiAwXG4gICAgLyogUHJveHlPYmplY3QgKi9cbiAgICAsXG4gICAgLy8gVHJhY2sgd2hpY2ggcHJvZHVjZSBjYWxsIHRoaXMgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgIHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpLFxuICAgIC8vIFRydWUgZm9yIGJvdGggc2hhbGxvdyBhbmQgZGVlcCBjaGFuZ2VzLlxuICAgIG1vZGlmaWVkXzogZmFsc2UsXG4gICAgLy8gVXNlZCBkdXJpbmcgZmluYWxpemF0aW9uLlxuICAgIGZpbmFsaXplZF86IGZhbHNlLFxuICAgIC8vIFRyYWNrIHdoaWNoIHByb3BlcnRpZXMgaGF2ZSBiZWVuIGFzc2lnbmVkICh0cnVlKSBvciBkZWxldGVkIChmYWxzZSkuXG4gICAgYXNzaWduZWRfOiB7fSxcbiAgICAvLyBUaGUgcGFyZW50IGRyYWZ0IHN0YXRlLlxuICAgIHBhcmVudF86IHBhcmVudCxcbiAgICAvLyBUaGUgYmFzZSBzdGF0ZS5cbiAgICBiYXNlXzogYmFzZSxcbiAgICAvLyBUaGUgYmFzZSBwcm94eS5cbiAgICBkcmFmdF86IG51bGwsXG4gICAgLy8gVGhlIGJhc2UgY29weSB3aXRoIGFueSB1cGRhdGVkIHZhbHVlcy5cbiAgICBjb3B5XzogbnVsbCxcbiAgICAvLyBDYWxsZWQgYnkgdGhlIGBwcm9kdWNlYCBmdW5jdGlvbi5cbiAgICByZXZva2VfOiBudWxsLFxuICAgIGlzTWFudWFsXzogZmFsc2VcbiAgfTsgLy8gdGhlIHRyYXBzIG11c3QgdGFyZ2V0IHNvbWV0aGluZywgYSBiaXQgbGlrZSB0aGUgJ3JlYWwnIGJhc2UuXG4gIC8vIGJ1dCBhbHNvLCB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gZGV0ZXJtaW5lIGZyb20gdGhlIHRhcmdldCB3aGF0IHRoZSByZWxldmFudCBzdGF0ZSBpc1xuICAvLyAodG8gYXZvaWQgY3JlYXRpbmcgdHJhcHMgcGVyIGluc3RhbmNlIHRvIGNhcHR1cmUgdGhlIHN0YXRlIGluIGNsb3N1cmUsXG4gIC8vIGFuZCB0byBhdm9pZCBjcmVhdGluZyB3ZWlyZCBoaWRkZW4gcHJvcGVydGllcyBhcyB3ZWxsKVxuICAvLyBTbyB0aGUgdHJpY2sgaXMgdG8gdXNlICdzdGF0ZScgYXMgdGhlIGFjdHVhbCAndGFyZ2V0JyEgKGFuZCBtYWtlIHN1cmUgd2UgaW50ZXJjZXB0IGV2ZXJ5dGhpbmcpXG4gIC8vIE5vdGUgdGhhdCBpbiB0aGUgY2FzZSBvZiBhbiBhcnJheSwgd2UgcHV0IHRoZSBzdGF0ZSBpbiBhbiBhcnJheSB0byBoYXZlIGJldHRlciBSZWZsZWN0IGRlZmF1bHRzIG9vdGJcblxuICB2YXIgdGFyZ2V0ID0gc3RhdGU7XG4gIHZhciB0cmFwcyA9IG9iamVjdFRyYXBzO1xuXG4gIGlmIChpc0FycmF5KSB7XG4gICAgdGFyZ2V0ID0gW3N0YXRlXTtcbiAgICB0cmFwcyA9IGFycmF5VHJhcHM7XG4gIH1cblxuICB2YXIgX1Byb3h5JHJldm9jYWJsZSA9IFByb3h5LnJldm9jYWJsZSh0YXJnZXQsIHRyYXBzKSxcbiAgICAgIHJldm9rZSA9IF9Qcm94eSRyZXZvY2FibGUucmV2b2tlLFxuICAgICAgcHJveHkgPSBfUHJveHkkcmV2b2NhYmxlLnByb3h5O1xuXG4gIHN0YXRlLmRyYWZ0XyA9IHByb3h5O1xuICBzdGF0ZS5yZXZva2VfID0gcmV2b2tlO1xuICByZXR1cm4gcHJveHk7XG59XG4vKipcclxuICogT2JqZWN0IGRyYWZ0c1xyXG4gKi9cblxudmFyIG9iamVjdFRyYXBzID0ge1xuICBnZXQ6IGZ1bmN0aW9uIGdldChzdGF0ZSwgcHJvcCkge1xuICAgIGlmIChwcm9wID09PSBEUkFGVF9TVEFURSkgcmV0dXJuIHN0YXRlO1xuICAgIHZhciBzb3VyY2UgPSBsYXRlc3Qoc3RhdGUpO1xuXG4gICAgaWYgKCFoYXMoc291cmNlLCBwcm9wKSkge1xuICAgICAgLy8gbm9uLWV4aXN0aW5nIG9yIG5vbi1vd24gcHJvcGVydHkuLi5cbiAgICAgIHJldHVybiByZWFkUHJvcEZyb21Qcm90byhzdGF0ZSwgc291cmNlLCBwcm9wKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBzb3VyY2VbcHJvcF07XG5cbiAgICBpZiAoc3RhdGUuZmluYWxpemVkXyB8fCAhaXNEcmFmdGFibGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSAvLyBDaGVjayBmb3IgZXhpc3RpbmcgZHJhZnQgaW4gbW9kaWZpZWQgc3RhdGUuXG4gICAgLy8gQXNzaWduZWQgdmFsdWVzIGFyZSBuZXZlciBkcmFmdGVkLiBUaGlzIGNhdGNoZXMgYW55IGRyYWZ0cyB3ZSBjcmVhdGVkLCB0b28uXG5cblxuICAgIGlmICh2YWx1ZSA9PT0gcGVlayhzdGF0ZS5iYXNlXywgcHJvcCkpIHtcbiAgICAgIHByZXBhcmVDb3B5KHN0YXRlKTtcbiAgICAgIHJldHVybiBzdGF0ZS5jb3B5X1twcm9wXSA9IGNyZWF0ZVByb3h5KHN0YXRlLnNjb3BlXy5pbW1lcl8sIHZhbHVlLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBoYXM6IGZ1bmN0aW9uIGhhcyhzdGF0ZSwgcHJvcCkge1xuICAgIHJldHVybiBwcm9wIGluIGxhdGVzdChzdGF0ZSk7XG4gIH0sXG4gIG93bktleXM6IGZ1bmN0aW9uIG93bktleXMoc3RhdGUpIHtcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKGxhdGVzdChzdGF0ZSkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldChzdGF0ZSwgcHJvcFxuICAvKiBzdHJpY3RseSBub3QsIGJ1dCBoZWxwcyBUUyAqL1xuICAsIHZhbHVlKSB7XG4gICAgdmFyIGRlc2MgPSBnZXREZXNjcmlwdG9yRnJvbVByb3RvKGxhdGVzdChzdGF0ZSksIHByb3ApO1xuXG4gICAgaWYgKGRlc2MgPT09IG51bGwgfHwgZGVzYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVzYy5zZXQpIHtcbiAgICAgIC8vIHNwZWNpYWwgY2FzZTogaWYgdGhpcyB3cml0ZSBpcyBjYXB0dXJlZCBieSBhIHNldHRlciwgd2UgaGF2ZVxuICAgICAgLy8gdG8gdHJpZ2dlciBpdCB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbiAgICAgIGRlc2Muc2V0LmNhbGwoc3RhdGUuZHJhZnRfLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIXN0YXRlLm1vZGlmaWVkXykge1xuICAgICAgLy8gdGhlIGxhc3QgY2hlY2sgaXMgYmVjYXVzZSB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gZGlzdGluZ3Vpc2ggc2V0dGluZyBhIG5vbi1leGlzdGluZyB0byB1bmRlZmluZWQgKHdoaWNoIGlzIGEgY2hhbmdlKVxuICAgICAgLy8gZnJvbSBzZXR0aW5nIGFuIGV4aXN0aW5nIHByb3BlcnR5IHdpdGggdmFsdWUgdW5kZWZpbmVkIHRvIHVuZGVmaW5lZCAod2hpY2ggaXMgbm90IGEgY2hhbmdlKVxuICAgICAgdmFyIGN1cnJlbnQgPSBwZWVrKGxhdGVzdChzdGF0ZSksIHByb3ApOyAvLyBzcGVjaWFsIGNhc2UsIGlmIHdlIGFzc2lnbmluZyB0aGUgb3JpZ2luYWwgdmFsdWUgdG8gYSBkcmFmdCwgd2UgY2FuIGlnbm9yZSB0aGUgYXNzaWdubWVudFxuXG4gICAgICB2YXIgY3VycmVudFN0YXRlID0gY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50W0RSQUZUX1NUQVRFXTtcblxuICAgICAgaWYgKGN1cnJlbnRTdGF0ZSAmJiBjdXJyZW50U3RhdGUuYmFzZV8gPT09IHZhbHVlKSB7XG4gICAgICAgIHN0YXRlLmNvcHlfW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIHN0YXRlLmFzc2lnbmVkX1twcm9wXSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzKHZhbHVlLCBjdXJyZW50KSAmJiAodmFsdWUgIT09IHVuZGVmaW5lZCB8fCBoYXMoc3RhdGUuYmFzZV8sIHByb3ApKSkgcmV0dXJuIHRydWU7XG4gICAgICBwcmVwYXJlQ29weShzdGF0ZSk7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmNvcHlfW3Byb3BdID09PSB2YWx1ZSAmJiAoIC8vIHNwZWNpYWwgY2FzZTogaGFuZGxlIG5ldyBwcm9wcyB3aXRoIHZhbHVlICd1bmRlZmluZWQnXG4gICAgdmFsdWUgIT09IHVuZGVmaW5lZCB8fCBwcm9wIGluIHN0YXRlLmNvcHlfKSB8fCAvLyBzcGVjaWFsIGNhc2U6IE5hTlxuICAgIE51bWJlci5pc05hTih2YWx1ZSkgJiYgTnVtYmVyLmlzTmFOKHN0YXRlLmNvcHlfW3Byb3BdKSkgcmV0dXJuIHRydWU7IC8vIEB0cy1pZ25vcmVcblxuICAgIHN0YXRlLmNvcHlfW3Byb3BdID0gdmFsdWU7XG4gICAgc3RhdGUuYXNzaWduZWRfW3Byb3BdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHN0YXRlLCBwcm9wKSB7XG4gICAgLy8gVGhlIGB1bmRlZmluZWRgIGNoZWNrIGlzIGEgZmFzdCBwYXRoIGZvciBwcmUtZXhpc3Rpbmcga2V5cy5cbiAgICBpZiAocGVlayhzdGF0ZS5iYXNlXywgcHJvcCkgIT09IHVuZGVmaW5lZCB8fCBwcm9wIGluIHN0YXRlLmJhc2VfKSB7XG4gICAgICBzdGF0ZS5hc3NpZ25lZF9bcHJvcF0gPSBmYWxzZTtcbiAgICAgIHByZXBhcmVDb3B5KHN0YXRlKTtcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgYW4gb3JpZ2luYWxseSBub3QgYXNzaWduZWQgcHJvcGVydHkgd2FzIGRlbGV0ZWRcbiAgICAgIGRlbGV0ZSBzdGF0ZS5hc3NpZ25lZF9bcHJvcF07XG4gICAgfSAvLyBAdHMtaWdub3JlXG5cblxuICAgIGlmIChzdGF0ZS5jb3B5XykgZGVsZXRlIHN0YXRlLmNvcHlfW3Byb3BdO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyBOb3RlOiBXZSBuZXZlciBjb2VyY2UgYGRlc2MudmFsdWVgIGludG8gYW4gSW1tZXIgZHJhZnQsIGJlY2F1c2Ugd2UgY2FuJ3QgbWFrZVxuICAvLyB0aGUgc2FtZSBndWFyYW50ZWUgaW4gRVM1IG1vZGUuXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHN0YXRlLCBwcm9wKSB7XG4gICAgdmFyIG93bmVyID0gbGF0ZXN0KHN0YXRlKTtcbiAgICB2YXIgZGVzYyA9IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG93bmVyLCBwcm9wKTtcbiAgICBpZiAoIWRlc2MpIHJldHVybiBkZXNjO1xuICAgIHJldHVybiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogc3RhdGUudHlwZV8gIT09IDFcbiAgICAgIC8qIFByb3h5QXJyYXkgKi9cbiAgICAgIHx8IHByb3AgIT09IFwibGVuZ3RoXCIsXG4gICAgICBlbnVtZXJhYmxlOiBkZXNjLmVudW1lcmFibGUsXG4gICAgICB2YWx1ZTogb3duZXJbcHJvcF1cbiAgICB9O1xuICB9LFxuICBkZWZpbmVQcm9wZXJ0eTogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoKSB7XG4gICAgZGllKDExKTtcbiAgfSxcbiAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKHN0YXRlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihzdGF0ZS5iYXNlXyk7XG4gIH0sXG4gIHNldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZigpIHtcbiAgICBkaWUoMTIpO1xuICB9XG59O1xuLyoqXHJcbiAqIEFycmF5IGRyYWZ0c1xyXG4gKi9cblxudmFyIGFycmF5VHJhcHMgPSB7fTtcbmVhY2gob2JqZWN0VHJhcHMsIGZ1bmN0aW9uIChrZXksIGZuKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgYXJyYXlUcmFwc1trZXldID0gZnVuY3Rpb24gKCkge1xuICAgIGFyZ3VtZW50c1swXSA9IGFyZ3VtZW50c1swXVswXTtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn0pO1xuXG5hcnJheVRyYXBzLmRlbGV0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKHN0YXRlLCBwcm9wKSB7XG4gIGlmICggaXNOYU4ocGFyc2VJbnQocHJvcCkpKSBkaWUoMTMpOyAvLyBAdHMtaWdub3JlXG5cbiAgcmV0dXJuIGFycmF5VHJhcHMuc2V0LmNhbGwodGhpcywgc3RhdGUsIHByb3AsIHVuZGVmaW5lZCk7XG59O1xuXG5hcnJheVRyYXBzLnNldCA9IGZ1bmN0aW9uIChzdGF0ZSwgcHJvcCwgdmFsdWUpIHtcbiAgaWYgKCBwcm9wICE9PSBcImxlbmd0aFwiICYmIGlzTmFOKHBhcnNlSW50KHByb3ApKSkgZGllKDE0KTtcbiAgcmV0dXJuIG9iamVjdFRyYXBzLnNldC5jYWxsKHRoaXMsIHN0YXRlWzBdLCBwcm9wLCB2YWx1ZSwgc3RhdGVbMF0pO1xufTsgLy8gQWNjZXNzIGEgcHJvcGVydHkgd2l0aG91dCBjcmVhdGluZyBhbiBJbW1lciBkcmFmdC5cblxuXG5mdW5jdGlvbiBwZWVrKGRyYWZ0LCBwcm9wKSB7XG4gIHZhciBzdGF0ZSA9IGRyYWZ0W0RSQUZUX1NUQVRFXTtcbiAgdmFyIHNvdXJjZSA9IHN0YXRlID8gbGF0ZXN0KHN0YXRlKSA6IGRyYWZ0O1xuICByZXR1cm4gc291cmNlW3Byb3BdO1xufVxuXG5mdW5jdGlvbiByZWFkUHJvcEZyb21Qcm90byhzdGF0ZSwgc291cmNlLCBwcm9wKSB7XG4gIHZhciBfZGVzYyRnZXQ7XG5cbiAgdmFyIGRlc2MgPSBnZXREZXNjcmlwdG9yRnJvbVByb3RvKHNvdXJjZSwgcHJvcCk7XG4gIHJldHVybiBkZXNjID8gXCJ2YWx1ZVwiIGluIGRlc2MgPyBkZXNjLnZhbHVlIDogLy8gVGhpcyBpcyBhIHZlcnkgc3BlY2lhbCBjYXNlLCBpZiB0aGUgcHJvcCBpcyBhIGdldHRlciBkZWZpbmVkIGJ5IHRoZVxuICAvLyBwcm90b3R5cGUsIHdlIHNob3VsZCBpbnZva2UgaXQgd2l0aCB0aGUgZHJhZnQgYXMgY29udGV4dCFcbiAgKF9kZXNjJGdldCA9IGRlc2MuZ2V0KSA9PT0gbnVsbCB8fCBfZGVzYyRnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kZXNjJGdldC5jYWxsKHN0YXRlLmRyYWZ0XykgOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGdldERlc2NyaXB0b3JGcm9tUHJvdG8oc291cmNlLCBwcm9wKSB7XG4gIC8vICdpbicgY2hlY2tzIHByb3RvIVxuICBpZiAoIShwcm9wIGluIHNvdXJjZSkpIHJldHVybiB1bmRlZmluZWQ7XG4gIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihzb3VyY2UpO1xuXG4gIHdoaWxlIChwcm90bykge1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgcHJvcCk7XG4gICAgaWYgKGRlc2MpIHJldHVybiBkZXNjO1xuICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIG1hcmtDaGFuZ2VkKHN0YXRlKSB7XG4gIGlmICghc3RhdGUubW9kaWZpZWRfKSB7XG4gICAgc3RhdGUubW9kaWZpZWRfID0gdHJ1ZTtcblxuICAgIGlmIChzdGF0ZS5wYXJlbnRfKSB7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZS5wYXJlbnRfKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHByZXBhcmVDb3B5KHN0YXRlKSB7XG4gIGlmICghc3RhdGUuY29weV8pIHtcbiAgICBzdGF0ZS5jb3B5XyA9IHNoYWxsb3dDb3B5KHN0YXRlLmJhc2VfKTtcbiAgfVxufVxuXG52YXIgSW1tZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbW1lcihjb25maWcpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy51c2VQcm94aWVzXyA9IGhhc1Byb3hpZXM7XG4gICAgdGhpcy5hdXRvRnJlZXplXyA9IHRydWU7XG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYHByb2R1Y2VgIGZ1bmN0aW9uIHRha2VzIGEgdmFsdWUgYW5kIGEgXCJyZWNpcGUgZnVuY3Rpb25cIiAod2hvc2VcclxuICAgICAqIHJldHVybiB2YWx1ZSBvZnRlbiBkZXBlbmRzIG9uIHRoZSBiYXNlIHN0YXRlKS4gVGhlIHJlY2lwZSBmdW5jdGlvbiBpc1xyXG4gICAgICogZnJlZSB0byBtdXRhdGUgaXRzIGZpcnN0IGFyZ3VtZW50IGhvd2V2ZXIgaXQgd2FudHMuIEFsbCBtdXRhdGlvbnMgYXJlXHJcbiAgICAgKiBvbmx5IGV2ZXIgYXBwbGllZCB0byBhIF9fY29weV9fIG9mIHRoZSBiYXNlIHN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIFBhc3Mgb25seSBhIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIFwiY3VycmllZCBwcm9kdWNlclwiIHdoaWNoIHJlbGlldmVzIHlvdVxyXG4gICAgICogZnJvbSBwYXNzaW5nIHRoZSByZWNpcGUgZnVuY3Rpb24gZXZlcnkgdGltZS5cclxuICAgICAqXHJcbiAgICAgKiBPbmx5IHBsYWluIG9iamVjdHMgYW5kIGFycmF5cyBhcmUgbWFkZSBtdXRhYmxlLiBBbGwgb3RoZXIgb2JqZWN0cyBhcmVcclxuICAgICAqIGNvbnNpZGVyZWQgdW5jb3B5YWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIF9fYm91bmRfXyB0byBpdHMgYEltbWVyYCBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gYmFzZSAtIHRoZSBpbml0aWFsIHN0YXRlXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWNpcGUgLSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEgcHJveHkgb2YgdGhlIGJhc2Ugc3RhdGUgYXMgZmlyc3QgYXJndW1lbnQgYW5kIHdoaWNoIGNhbiBiZSBmcmVlbHkgbW9kaWZpZWRcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHBhdGNoTGlzdGVuZXIgLSBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggYWxsIHRoZSBwYXRjaGVzIHByb2R1Y2VkIGhlcmVcclxuICAgICAqIEByZXR1cm5zIHthbnl9IGEgbmV3IHN0YXRlLCBvciB0aGUgaW5pdGlhbCBzdGF0ZSBpZiBub3RoaW5nIHdhcyBtb2RpZmllZFxyXG4gICAgICovXG5cbiAgICB0aGlzLnByb2R1Y2UgPSBmdW5jdGlvbiAoYmFzZSwgcmVjaXBlLCBwYXRjaExpc3RlbmVyKSB7XG4gICAgICAvLyBjdXJyaWVkIGludm9jYXRpb25cbiAgICAgIGlmICh0eXBlb2YgYmFzZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiByZWNpcGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgZGVmYXVsdEJhc2UgPSByZWNpcGU7XG4gICAgICAgIHJlY2lwZSA9IGJhc2U7XG4gICAgICAgIHZhciBzZWxmID0gX3RoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjdXJyaWVkUHJvZHVjZShiYXNlKSB7XG4gICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICBpZiAoYmFzZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBiYXNlID0gZGVmYXVsdEJhc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNlbGYucHJvZHVjZShiYXNlLCBmdW5jdGlvbiAoZHJhZnQpIHtcbiAgICAgICAgICAgIHZhciBfcmVjaXBlO1xuXG4gICAgICAgICAgICByZXR1cm4gKF9yZWNpcGUgPSByZWNpcGUpLmNhbGwuYXBwbHkoX3JlY2lwZSwgW190aGlzMiwgZHJhZnRdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgfSk7IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHJlY2lwZSAhPT0gXCJmdW5jdGlvblwiKSBkaWUoNik7XG4gICAgICBpZiAocGF0Y2hMaXN0ZW5lciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBwYXRjaExpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpIGRpZSg3KTtcbiAgICAgIHZhciByZXN1bHQ7IC8vIE9ubHkgcGxhaW4gb2JqZWN0cywgYXJyYXlzLCBhbmQgXCJpbW1lcmFibGUgY2xhc3Nlc1wiIGFyZSBkcmFmdGVkLlxuXG4gICAgICBpZiAoaXNEcmFmdGFibGUoYmFzZSkpIHtcbiAgICAgICAgdmFyIHNjb3BlID0gZW50ZXJTY29wZShfdGhpcyk7XG4gICAgICAgIHZhciBwcm94eSA9IGNyZWF0ZVByb3h5KF90aGlzLCBiYXNlLCB1bmRlZmluZWQpO1xuICAgICAgICB2YXIgaGFzRXJyb3IgPSB0cnVlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVjaXBlKHByb3h5KTtcbiAgICAgICAgICBoYXNFcnJvciA9IGZhbHNlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIC8vIGZpbmFsbHkgaW5zdGVhZCBvZiBjYXRjaCArIHJldGhyb3cgYmV0dGVyIHByZXNlcnZlcyBvcmlnaW5hbCBzdGFja1xuICAgICAgICAgIGlmIChoYXNFcnJvcikgcmV2b2tlU2NvcGUoc2NvcGUpO2Vsc2UgbGVhdmVTY29wZShzY29wZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICB1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcik7XG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzc1Jlc3VsdChyZXN1bHQsIHNjb3BlKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldm9rZVNjb3BlKHNjb3BlKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdXNlUGF0Y2hlc0luU2NvcGUoc2NvcGUsIHBhdGNoTGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gcHJvY2Vzc1Jlc3VsdChyZXN1bHQsIHNjb3BlKTtcbiAgICAgIH0gZWxzZSBpZiAoIWJhc2UgfHwgdHlwZW9mIGJhc2UgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVjaXBlKGJhc2UpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHJlc3VsdCA9IGJhc2U7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IE5PVEhJTkcpIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKF90aGlzLmF1dG9GcmVlemVfKSBmcmVlemUocmVzdWx0LCB0cnVlKTtcblxuICAgICAgICBpZiAocGF0Y2hMaXN0ZW5lcikge1xuICAgICAgICAgIHZhciBwID0gW107XG4gICAgICAgICAgdmFyIGlwID0gW107XG4gICAgICAgICAgZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5nZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oYmFzZSwgcmVzdWx0LCBwLCBpcCk7XG4gICAgICAgICAgcGF0Y2hMaXN0ZW5lcihwLCBpcCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlIGRpZSgyMSwgYmFzZSk7XG4gICAgfTtcblxuICAgIHRoaXMucHJvZHVjZVdpdGhQYXRjaGVzID0gZnVuY3Rpb24gKGJhc2UsIHJlY2lwZSkge1xuICAgICAgLy8gY3VycmllZCBpbnZvY2F0aW9uXG4gICAgICBpZiAodHlwZW9mIGJhc2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIF90aGlzLnByb2R1Y2VXaXRoUGF0Y2hlcyhzdGF0ZSwgZnVuY3Rpb24gKGRyYWZ0KSB7XG4gICAgICAgICAgICByZXR1cm4gYmFzZS5hcHBseSh2b2lkIDAsIFtkcmFmdF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gX3RoaXMucHJvZHVjZShiYXNlLCByZWNpcGUsIGZ1bmN0aW9uIChwLCBpcCkge1xuICAgICAgICBwYXRjaGVzID0gcDtcbiAgICAgICAgaW52ZXJzZVBhdGNoZXMgPSBpcDtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oZnVuY3Rpb24gKG5leHRTdGF0ZSkge1xuICAgICAgICAgIHJldHVybiBbbmV4dFN0YXRlLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlc107XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3Jlc3VsdCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcudXNlUHJveGllcykgPT09IFwiYm9vbGVhblwiKSB0aGlzLnNldFVzZVByb3hpZXMoY29uZmlnLnVzZVByb3hpZXMpO1xuICAgIGlmICh0eXBlb2YgKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5hdXRvRnJlZXplKSA9PT0gXCJib29sZWFuXCIpIHRoaXMuc2V0QXV0b0ZyZWV6ZShjb25maWcuYXV0b0ZyZWV6ZSk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gSW1tZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5jcmVhdGVEcmFmdCA9IGZ1bmN0aW9uIGNyZWF0ZURyYWZ0KGJhc2UpIHtcbiAgICBpZiAoIWlzRHJhZnRhYmxlKGJhc2UpKSBkaWUoOCk7XG4gICAgaWYgKGlzRHJhZnQoYmFzZSkpIGJhc2UgPSBjdXJyZW50KGJhc2UpO1xuICAgIHZhciBzY29wZSA9IGVudGVyU2NvcGUodGhpcyk7XG4gICAgdmFyIHByb3h5ID0gY3JlYXRlUHJveHkodGhpcywgYmFzZSwgdW5kZWZpbmVkKTtcbiAgICBwcm94eVtEUkFGVF9TVEFURV0uaXNNYW51YWxfID0gdHJ1ZTtcbiAgICBsZWF2ZVNjb3BlKHNjb3BlKTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH07XG5cbiAgX3Byb3RvLmZpbmlzaERyYWZ0ID0gZnVuY3Rpb24gZmluaXNoRHJhZnQoZHJhZnQsIHBhdGNoTGlzdGVuZXIpIHtcbiAgICB2YXIgc3RhdGUgPSBkcmFmdCAmJiBkcmFmdFtEUkFGVF9TVEFURV07XG5cbiAgICB7XG4gICAgICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5pc01hbnVhbF8pIGRpZSg5KTtcbiAgICAgIGlmIChzdGF0ZS5maW5hbGl6ZWRfKSBkaWUoMTApO1xuICAgIH1cblxuICAgIHZhciBzY29wZSA9IHN0YXRlLnNjb3BlXztcbiAgICB1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcik7XG4gICAgcmV0dXJuIHByb2Nlc3NSZXN1bHQodW5kZWZpbmVkLCBzY29wZSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUGFzcyB0cnVlIHRvIGF1dG9tYXRpY2FsbHkgZnJlZXplIGFsbCBjb3BpZXMgY3JlYXRlZCBieSBJbW1lci5cclxuICAgKlxyXG4gICAqIEJ5IGRlZmF1bHQsIGF1dG8tZnJlZXppbmcgaXMgZW5hYmxlZC5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zZXRBdXRvRnJlZXplID0gZnVuY3Rpb24gc2V0QXV0b0ZyZWV6ZSh2YWx1ZSkge1xuICAgIHRoaXMuYXV0b0ZyZWV6ZV8gPSB2YWx1ZTtcbiAgfVxuICAvKipcclxuICAgKiBQYXNzIHRydWUgdG8gdXNlIHRoZSBFUzIwMTUgYFByb3h5YCBjbGFzcyB3aGVuIGNyZWF0aW5nIGRyYWZ0cywgd2hpY2ggaXNcclxuICAgKiBhbHdheXMgZmFzdGVyIHRoYW4gdXNpbmcgRVM1IHByb3hpZXMuXHJcbiAgICpcclxuICAgKiBCeSBkZWZhdWx0LCBmZWF0dXJlIGRldGVjdGlvbiBpcyB1c2VkLCBzbyBjYWxsaW5nIHRoaXMgaXMgcmFyZWx5IG5lY2Vzc2FyeS5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zZXRVc2VQcm94aWVzID0gZnVuY3Rpb24gc2V0VXNlUHJveGllcyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiAhaGFzUHJveGllcykge1xuICAgICAgZGllKDIwKTtcbiAgICB9XG5cbiAgICB0aGlzLnVzZVByb3hpZXNfID0gdmFsdWU7XG4gIH07XG5cbiAgX3Byb3RvLmFwcGx5UGF0Y2hlcyA9IGZ1bmN0aW9uIGFwcGx5UGF0Y2hlcyhiYXNlLCBwYXRjaGVzKSB7XG4gICAgLy8gSWYgYSBwYXRjaCByZXBsYWNlcyB0aGUgZW50aXJlIHN0YXRlLCB0YWtlIHRoYXQgcmVwbGFjZW1lbnQgYXMgYmFzZVxuICAgIC8vIGJlZm9yZSBhcHBseWluZyBwYXRjaGVzXG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSBwYXRjaGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgcGF0Y2ggPSBwYXRjaGVzW2ldO1xuXG4gICAgICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPT09IDAgJiYgcGF0Y2gub3AgPT09IFwicmVwbGFjZVwiKSB7XG4gICAgICAgIGJhc2UgPSBwYXRjaC52YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSAvLyBJZiB0aGVyZSB3YXMgYSBwYXRjaCB0aGF0IHJlcGxhY2VkIHRoZSBlbnRpcmUgc3RhdGUsIHN0YXJ0IGZyb20gdGhlXG4gICAgLy8gcGF0Y2ggYWZ0ZXIgdGhhdC5cblxuXG4gICAgaWYgKGkgPiAtMSkge1xuICAgICAgcGF0Y2hlcyA9IHBhdGNoZXMuc2xpY2UoaSArIDEpO1xuICAgIH1cblxuICAgIHZhciBhcHBseVBhdGNoZXNJbXBsID0gZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5hcHBseVBhdGNoZXNfO1xuXG4gICAgaWYgKGlzRHJhZnQoYmFzZSkpIHtcbiAgICAgIC8vIE4uQjogbmV2ZXIgaGl0cyBpZiBzb21lIHBhdGNoIGEgcmVwbGFjZW1lbnQsIHBhdGNoZXMgYXJlIG5ldmVyIGRyYWZ0c1xuICAgICAgcmV0dXJuIGFwcGx5UGF0Y2hlc0ltcGwoYmFzZSwgcGF0Y2hlcyk7XG4gICAgfSAvLyBPdGhlcndpc2UsIHByb2R1Y2UgYSBjb3B5IG9mIHRoZSBiYXNlIHN0YXRlLlxuXG5cbiAgICByZXR1cm4gdGhpcy5wcm9kdWNlKGJhc2UsIGZ1bmN0aW9uIChkcmFmdCkge1xuICAgICAgcmV0dXJuIGFwcGx5UGF0Y2hlc0ltcGwoZHJhZnQsIHBhdGNoZXMpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBJbW1lcjtcbn0oKTtcbmZ1bmN0aW9uIGNyZWF0ZVByb3h5KGltbWVyLCB2YWx1ZSwgcGFyZW50KSB7XG4gIC8vIHByZWNvbmRpdGlvbjogY3JlYXRlUHJveHkgc2hvdWxkIGJlIGd1YXJkZWQgYnkgaXNEcmFmdGFibGUsIHNvIHdlIGtub3cgd2UgY2FuIHNhZmVseSBkcmFmdFxuICB2YXIgZHJhZnQgPSBpc01hcCh2YWx1ZSkgPyBnZXRQbHVnaW4oXCJNYXBTZXRcIikucHJveHlNYXBfKHZhbHVlLCBwYXJlbnQpIDogaXNTZXQodmFsdWUpID8gZ2V0UGx1Z2luKFwiTWFwU2V0XCIpLnByb3h5U2V0Xyh2YWx1ZSwgcGFyZW50KSA6IGltbWVyLnVzZVByb3hpZXNfID8gY3JlYXRlUHJveHlQcm94eSh2YWx1ZSwgcGFyZW50KSA6IGdldFBsdWdpbihcIkVTNVwiKS5jcmVhdGVFUzVQcm94eV8odmFsdWUsIHBhcmVudCk7XG4gIHZhciBzY29wZSA9IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKTtcbiAgc2NvcGUuZHJhZnRzXy5wdXNoKGRyYWZ0KTtcbiAgcmV0dXJuIGRyYWZ0O1xufVxuXG5mdW5jdGlvbiBjdXJyZW50KHZhbHVlKSB7XG4gIGlmICghaXNEcmFmdCh2YWx1ZSkpIGRpZSgyMiwgdmFsdWUpO1xuICByZXR1cm4gY3VycmVudEltcGwodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBjdXJyZW50SW1wbCh2YWx1ZSkge1xuICBpZiAoIWlzRHJhZnRhYmxlKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICB2YXIgc3RhdGUgPSB2YWx1ZVtEUkFGVF9TVEFURV07XG4gIHZhciBjb3B5O1xuICB2YXIgYXJjaFR5cGUgPSBnZXRBcmNodHlwZSh2YWx1ZSk7XG5cbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5tb2RpZmllZF8gJiYgKHN0YXRlLnR5cGVfIDwgNCB8fCAhZ2V0UGx1Z2luKFwiRVM1XCIpLmhhc0NoYW5nZXNfKHN0YXRlKSkpIHJldHVybiBzdGF0ZS5iYXNlXzsgLy8gT3B0aW1pemF0aW9uOiBhdm9pZCBnZW5lcmF0aW5nIG5ldyBkcmFmdHMgZHVyaW5nIGNvcHlpbmdcblxuICAgIHN0YXRlLmZpbmFsaXplZF8gPSB0cnVlO1xuICAgIGNvcHkgPSBjb3B5SGVscGVyKHZhbHVlLCBhcmNoVHlwZSk7XG4gICAgc3RhdGUuZmluYWxpemVkXyA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGNvcHkgPSBjb3B5SGVscGVyKHZhbHVlLCBhcmNoVHlwZSk7XG4gIH1cblxuICBlYWNoKGNvcHksIGZ1bmN0aW9uIChrZXksIGNoaWxkVmFsdWUpIHtcbiAgICBpZiAoc3RhdGUgJiYgZ2V0KHN0YXRlLmJhc2VfLCBrZXkpID09PSBjaGlsZFZhbHVlKSByZXR1cm47IC8vIG5vIG5lZWQgdG8gY29weSBvciBzZWFyY2ggaW4gc29tZXRoaW5nIHRoYXQgZGlkbid0IGNoYW5nZVxuXG4gICAgc2V0KGNvcHksIGtleSwgY3VycmVudEltcGwoY2hpbGRWYWx1ZSkpO1xuICB9KTsgLy8gSW4gdGhlIGZ1dHVyZSwgd2UgbWlnaHQgY29uc2lkZXIgZnJlZXppbmcgaGVyZSwgYmFzZWQgb24gdGhlIGN1cnJlbnQgc2V0dGluZ3NcblxuICByZXR1cm4gYXJjaFR5cGUgPT09IDNcbiAgLyogU2V0ICovXG4gID8gbmV3IFNldChjb3B5KSA6IGNvcHk7XG59XG5cbmZ1bmN0aW9uIGNvcHlIZWxwZXIodmFsdWUsIGFyY2hUeXBlKSB7XG4gIC8vIGNyZWF0ZXMgYSBzaGFsbG93IGNvcHksIGV2ZW4gaWYgaXQgaXMgYSBtYXAgb3Igc2V0XG4gIHN3aXRjaCAoYXJjaFR5cGUpIHtcbiAgICBjYXNlIDJcbiAgICAvKiBNYXAgKi9cbiAgICA6XG4gICAgICByZXR1cm4gbmV3IE1hcCh2YWx1ZSk7XG5cbiAgICBjYXNlIDNcbiAgICAvKiBTZXQgKi9cbiAgICA6XG4gICAgICAvLyBTZXQgd2lsbCBiZSBjbG9uZWQgYXMgYXJyYXkgdGVtcG9yYXJpbHksIHNvIHRoYXQgd2UgY2FuIHJlcGxhY2UgaW5kaXZpZHVhbCBpdGVtc1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20odmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHNoYWxsb3dDb3B5KHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlRVM1KCkge1xuICBmdW5jdGlvbiB3aWxsRmluYWxpemVFUzVfKHNjb3BlLCByZXN1bHQsIGlzUmVwbGFjZWQpIHtcbiAgICBpZiAoIWlzUmVwbGFjZWQpIHtcbiAgICAgIGlmIChzY29wZS5wYXRjaGVzXykge1xuICAgICAgICBtYXJrQ2hhbmdlc1JlY3Vyc2l2ZWx5KHNjb3BlLmRyYWZ0c19bMF0pO1xuICAgICAgfSAvLyBUaGlzIGlzIGZhc3RlciB3aGVuIHdlIGRvbid0IGNhcmUgYWJvdXQgd2hpY2ggYXR0cmlidXRlcyBjaGFuZ2VkLlxuXG5cbiAgICAgIG1hcmtDaGFuZ2VzU3dlZXAoc2NvcGUuZHJhZnRzXyk7XG4gICAgfSAvLyBXaGVuIGEgY2hpbGQgZHJhZnQgaXMgcmV0dXJuZWQsIGxvb2sgZm9yIGNoYW5nZXMuXG4gICAgZWxzZSBpZiAoaXNEcmFmdChyZXN1bHQpICYmIHJlc3VsdFtEUkFGVF9TVEFURV0uc2NvcGVfID09PSBzY29wZSkge1xuICAgICAgICBtYXJrQ2hhbmdlc1N3ZWVwKHNjb3BlLmRyYWZ0c18pO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRVM1RHJhZnQoaXNBcnJheSwgYmFzZSkge1xuICAgIGlmIChpc0FycmF5KSB7XG4gICAgICB2YXIgZHJhZnQgPSBuZXcgQXJyYXkoYmFzZS5sZW5ndGgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRyYWZ0LCBcIlwiICsgaSwgcHJveHlQcm9wZXJ0eShpLCB0cnVlKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkcmFmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9kZXNjcmlwdG9ycyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoYmFzZSk7XG5cbiAgICAgIGRlbGV0ZSBfZGVzY3JpcHRvcnNbRFJBRlRfU1RBVEVdO1xuICAgICAgdmFyIGtleXMgPSBvd25LZXlzKF9kZXNjcmlwdG9ycyk7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBrZXlzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tfaV07XG4gICAgICAgIF9kZXNjcmlwdG9yc1trZXldID0gcHJveHlQcm9wZXJ0eShrZXksIGlzQXJyYXkgfHwgISFfZGVzY3JpcHRvcnNba2V5XS5lbnVtZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2UpLCBfZGVzY3JpcHRvcnMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVTNVByb3h5XyhiYXNlLCBwYXJlbnQpIHtcbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoYmFzZSk7XG4gICAgdmFyIGRyYWZ0ID0gY3JlYXRlRVM1RHJhZnQoaXNBcnJheSwgYmFzZSk7XG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgdHlwZV86IGlzQXJyYXkgPyA1XG4gICAgICAvKiBFUzVBcnJheSAqL1xuICAgICAgOiA0XG4gICAgICAvKiBFUzVPYmplY3QgKi9cbiAgICAgICxcbiAgICAgIHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpLFxuICAgICAgbW9kaWZpZWRfOiBmYWxzZSxcbiAgICAgIGZpbmFsaXplZF86IGZhbHNlLFxuICAgICAgYXNzaWduZWRfOiB7fSxcbiAgICAgIHBhcmVudF86IHBhcmVudCxcbiAgICAgIC8vIGJhc2UgaXMgdGhlIG9iamVjdCB3ZSBhcmUgZHJhZnRpbmdcbiAgICAgIGJhc2VfOiBiYXNlLFxuICAgICAgLy8gZHJhZnQgaXMgdGhlIGRyYWZ0IG9iamVjdCBpdHNlbGYsIHRoYXQgdHJhcHMgYWxsIHJlYWRzIGFuZCByZWFkcyBmcm9tIGVpdGhlciB0aGUgYmFzZSAoaWYgdW5tb2RpZmllZCkgb3IgY29weSAoaWYgbW9kaWZpZWQpXG4gICAgICBkcmFmdF86IGRyYWZ0LFxuICAgICAgY29weV86IG51bGwsXG4gICAgICByZXZva2VkXzogZmFsc2UsXG4gICAgICBpc01hbnVhbF86IGZhbHNlXG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZHJhZnQsIERSQUZUX1NUQVRFLCB7XG4gICAgICB2YWx1ZTogc3RhdGUsXG4gICAgICAvLyBlbnVtZXJhYmxlOiBmYWxzZSA8LSB0aGUgZGVmYXVsdFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZHJhZnQ7XG4gIH0gLy8gcHJvcGVydHkgZGVzY3JpcHRvcnMgYXJlIHJlY3ljbGVkIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCBjcmVhdGUgYSBnZXQgYW5kIHNldCBjbG9zdXJlIHBlciBwcm9wZXJ0eSxcbiAgLy8gYnV0IHNoYXJlIHRoZW0gYWxsIGluc3RlYWRcblxuXG4gIHZhciBkZXNjcmlwdG9ycyA9IHt9O1xuXG4gIGZ1bmN0aW9uIHByb3h5UHJvcGVydHkocHJvcCwgZW51bWVyYWJsZSkge1xuICAgIHZhciBkZXNjID0gZGVzY3JpcHRvcnNbcHJvcF07XG5cbiAgICBpZiAoZGVzYykge1xuICAgICAgZGVzYy5lbnVtZXJhYmxlID0gZW51bWVyYWJsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVzY3JpcHRvcnNbcHJvcF0gPSBkZXNjID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGVudW1lcmFibGUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7IC8vIEB0cy1pZ25vcmVcblxuICAgICAgICAgIHJldHVybiBvYmplY3RUcmFwcy5nZXQoc3RhdGUsIHByb3ApO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7IC8vIEB0cy1pZ25vcmVcblxuICAgICAgICAgIG9iamVjdFRyYXBzLnNldChzdGF0ZSwgcHJvcCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBkZXNjO1xuICB9IC8vIFRoaXMgbG9va3MgZXhwZW5zaXZlLCBidXQgb25seSBwcm94aWVzIGFyZSB2aXNpdGVkLCBhbmQgb25seSBvYmplY3RzIHdpdGhvdXQga25vd24gY2hhbmdlcyBhcmUgc2Nhbm5lZC5cblxuXG4gIGZ1bmN0aW9uIG1hcmtDaGFuZ2VzU3dlZXAoZHJhZnRzKSB7XG4gICAgLy8gVGhlIG5hdHVyYWwgb3JkZXIgb2YgZHJhZnRzIGluIHRoZSBgc2NvcGVgIGFycmF5IGlzIGJhc2VkIG9uIHdoZW4gdGhleVxuICAgIC8vIHdlcmUgYWNjZXNzZWQuIEJ5IHByb2Nlc3NpbmcgZHJhZnRzIGluIHJldmVyc2UgbmF0dXJhbCBvcmRlciwgd2UgaGF2ZSBhXG4gICAgLy8gYmV0dGVyIGNoYW5jZSBvZiBwcm9jZXNzaW5nIGxlYWYgbm9kZXMgZmlyc3QuIFdoZW4gYSBsZWFmIG5vZGUgaXMga25vd24gdG9cbiAgICAvLyBoYXZlIGNoYW5nZWQsIHdlIGNhbiBhdm9pZCBhbnkgdHJhdmVyc2FsIG9mIGl0cyBhbmNlc3RvciBub2Rlcy5cbiAgICBmb3IgKHZhciBpID0gZHJhZnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgc3RhdGUgPSBkcmFmdHNbaV1bRFJBRlRfU1RBVEVdO1xuXG4gICAgICBpZiAoIXN0YXRlLm1vZGlmaWVkXykge1xuICAgICAgICBzd2l0Y2ggKHN0YXRlLnR5cGVfKSB7XG4gICAgICAgICAgY2FzZSA1XG4gICAgICAgICAgLyogRVM1QXJyYXkgKi9cbiAgICAgICAgICA6XG4gICAgICAgICAgICBpZiAoaGFzQXJyYXlDaGFuZ2VzKHN0YXRlKSkgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDRcbiAgICAgICAgICAvKiBFUzVPYmplY3QgKi9cbiAgICAgICAgICA6XG4gICAgICAgICAgICBpZiAoaGFzT2JqZWN0Q2hhbmdlcyhzdGF0ZSkpIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya0NoYW5nZXNSZWN1cnNpdmVseShvYmplY3QpIHtcbiAgICBpZiAoIW9iamVjdCB8fCB0eXBlb2Ygb2JqZWN0ICE9PSBcIm9iamVjdFwiKSByZXR1cm47XG4gICAgdmFyIHN0YXRlID0gb2JqZWN0W0RSQUZUX1NUQVRFXTtcbiAgICBpZiAoIXN0YXRlKSByZXR1cm47XG4gICAgdmFyIGJhc2VfID0gc3RhdGUuYmFzZV8sXG4gICAgICAgIGRyYWZ0XyA9IHN0YXRlLmRyYWZ0XyxcbiAgICAgICAgYXNzaWduZWRfID0gc3RhdGUuYXNzaWduZWRfLFxuICAgICAgICB0eXBlXyA9IHN0YXRlLnR5cGVfO1xuXG4gICAgaWYgKHR5cGVfID09PSA0XG4gICAgLyogRVM1T2JqZWN0ICovXG4gICAgKSB7XG4gICAgICAgIC8vIExvb2sgZm9yIGFkZGVkIGtleXMuXG4gICAgICAgIC8vIHByb2JhYmx5IHRoZXJlIGlzIGEgZmFzdGVyIHdheSB0byBkZXRlY3QgY2hhbmdlcywgYXMgc3dlZXAgKyByZWN1cnNlIHNlZW1zIHRvIGRvIHNvbWVcbiAgICAgICAgLy8gdW5uZWNlc3Nhcnkgd29yay5cbiAgICAgICAgLy8gYWxzbzogcHJvYmFibHkgd2UgY2FuIHN0b3JlIHRoZSBpbmZvcm1hdGlvbiB3ZSBkZXRlY3QgaGVyZSwgdG8gc3BlZWQgdXAgdHJlZSBmaW5hbGl6YXRpb24hXG4gICAgICAgIGVhY2goZHJhZnRfLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgaWYgKGtleSA9PT0gRFJBRlRfU1RBVEUpIHJldHVybjsgLy8gVGhlIGB1bmRlZmluZWRgIGNoZWNrIGlzIGEgZmFzdCBwYXRoIGZvciBwcmUtZXhpc3Rpbmcga2V5cy5cblxuICAgICAgICAgIGlmIChiYXNlX1trZXldID09PSB1bmRlZmluZWQgJiYgIWhhcyhiYXNlXywga2V5KSkge1xuICAgICAgICAgICAgYXNzaWduZWRfW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWFzc2lnbmVkX1trZXldKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHVudG91Y2hlZCBwcm9wZXJ0aWVzIHRyaWdnZXIgcmVjdXJzaW9uLlxuICAgICAgICAgICAgbWFya0NoYW5nZXNSZWN1cnNpdmVseShkcmFmdF9ba2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTsgLy8gTG9vayBmb3IgcmVtb3ZlZCBrZXlzLlxuXG4gICAgICAgIGVhY2goYmFzZV8sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAvLyBUaGUgYHVuZGVmaW5lZGAgY2hlY2sgaXMgYSBmYXN0IHBhdGggZm9yIHByZS1leGlzdGluZyBrZXlzLlxuICAgICAgICAgIGlmIChkcmFmdF9ba2V5XSA9PT0gdW5kZWZpbmVkICYmICFoYXMoZHJhZnRfLCBrZXkpKSB7XG4gICAgICAgICAgICBhc3NpZ25lZF9ba2V5XSA9IGZhbHNlO1xuICAgICAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVfID09PSA1XG4gICAgLyogRVM1QXJyYXkgKi9cbiAgICApIHtcbiAgICAgICAgaWYgKGhhc0FycmF5Q2hhbmdlcyhzdGF0ZSkpIHtcbiAgICAgICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICAgICAgYXNzaWduZWRfLmxlbmd0aCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHJhZnRfLmxlbmd0aCA8IGJhc2VfLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSBkcmFmdF8ubGVuZ3RoOyBpIDwgYmFzZV8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFzc2lnbmVkX1tpXSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSBiYXNlXy5sZW5ndGg7IF9pMiA8IGRyYWZ0Xy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICBhc3NpZ25lZF9bX2kyXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIE1pbmltdW0gY291bnQgaXMgZW5vdWdoLCB0aGUgb3RoZXIgcGFydHMgaGFzIGJlZW4gcHJvY2Vzc2VkLlxuXG5cbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKGRyYWZ0Xy5sZW5ndGgsIGJhc2VfLmxlbmd0aCk7XG5cbiAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbWluOyBfaTMrKykge1xuICAgICAgICAgIC8vIE9ubHkgdW50b3VjaGVkIGluZGljZXMgdHJpZ2dlciByZWN1cnNpb24uXG4gICAgICAgICAgaWYgKCFkcmFmdF8uaGFzT3duUHJvcGVydHkoX2kzKSkge1xuICAgICAgICAgICAgYXNzaWduZWRfW19pM10gPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhc3NpZ25lZF9bX2kzXSA9PT0gdW5kZWZpbmVkKSBtYXJrQ2hhbmdlc1JlY3Vyc2l2ZWx5KGRyYWZ0X1tfaTNdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFzT2JqZWN0Q2hhbmdlcyhzdGF0ZSkge1xuICAgIHZhciBiYXNlXyA9IHN0YXRlLmJhc2VfLFxuICAgICAgICBkcmFmdF8gPSBzdGF0ZS5kcmFmdF87IC8vIFNlYXJjaCBmb3IgYWRkZWQga2V5cyBhbmQgY2hhbmdlZCBrZXlzLiBTdGFydCBhdCB0aGUgYmFjaywgYmVjYXVzZVxuICAgIC8vIG5vbi1udW1lcmljIGtleXMgYXJlIG9yZGVyZWQgYnkgdGltZSBvZiBkZWZpbml0aW9uIG9uIHRoZSBvYmplY3QuXG5cbiAgICB2YXIga2V5cyA9IG93bktleXMoZHJhZnRfKTtcblxuICAgIGZvciAodmFyIGkgPSBrZXlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChrZXkgPT09IERSQUZUX1NUQVRFKSBjb250aW51ZTtcbiAgICAgIHZhciBiYXNlVmFsdWUgPSBiYXNlX1trZXldOyAvLyBUaGUgYHVuZGVmaW5lZGAgY2hlY2sgaXMgYSBmYXN0IHBhdGggZm9yIHByZS1leGlzdGluZyBrZXlzLlxuXG4gICAgICBpZiAoYmFzZVZhbHVlID09PSB1bmRlZmluZWQgJiYgIWhhcyhiYXNlXywga2V5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gT25jZSBhIGJhc2Uga2V5IGlzIGRlbGV0ZWQsIGZ1dHVyZSBjaGFuZ2VzIGdvIHVuZGV0ZWN0ZWQsIGJlY2F1c2UgaXRzXG4gICAgICAvLyBkZXNjcmlwdG9yIGlzIGVyYXNlZC4gVGhpcyBicmFuY2ggZGV0ZWN0cyBhbnkgbWlzc2VkIGNoYW5nZXMuXG4gICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBkcmFmdF9ba2V5XTtcblxuICAgICAgICAgIHZhciBfc3RhdGUgPSB2YWx1ZSAmJiB2YWx1ZVtEUkFGVF9TVEFURV07XG5cbiAgICAgICAgICBpZiAoX3N0YXRlID8gX3N0YXRlLmJhc2VfICE9PSBiYXNlVmFsdWUgOiAhaXModmFsdWUsIGJhc2VWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gLy8gQXQgdGhpcyBwb2ludCwgbm8ga2V5cyB3ZXJlIGFkZGVkIG9yIGNoYW5nZWQuXG4gICAgLy8gQ29tcGFyZSBrZXkgY291bnQgdG8gZGV0ZXJtaW5lIGlmIGtleXMgd2VyZSBkZWxldGVkLlxuXG5cbiAgICB2YXIgYmFzZUlzRHJhZnQgPSAhIWJhc2VfW0RSQUZUX1NUQVRFXTtcbiAgICByZXR1cm4ga2V5cy5sZW5ndGggIT09IG93bktleXMoYmFzZV8pLmxlbmd0aCArIChiYXNlSXNEcmFmdCA/IDAgOiAxKTsgLy8gKyAxIHRvIGNvcnJlY3QgZm9yIERSQUZUX1NUQVRFXG4gIH1cblxuICBmdW5jdGlvbiBoYXNBcnJheUNoYW5nZXMoc3RhdGUpIHtcbiAgICB2YXIgZHJhZnRfID0gc3RhdGUuZHJhZnRfO1xuICAgIGlmIChkcmFmdF8ubGVuZ3RoICE9PSBzdGF0ZS5iYXNlXy5sZW5ndGgpIHJldHVybiB0cnVlOyAvLyBTZWUgIzExNlxuICAgIC8vIElmIHdlIGZpcnN0IHNob3J0ZW4gdGhlIGxlbmd0aCwgb3VyIGFycmF5IGludGVyY2VwdG9ycyB3aWxsIGJlIHJlbW92ZWQuXG4gICAgLy8gSWYgYWZ0ZXIgdGhhdCBuZXcgaXRlbXMgYXJlIGFkZGVkLCByZXN1bHQgaW4gdGhlIHNhbWUgb3JpZ2luYWwgbGVuZ3RoLFxuICAgIC8vIHRob3NlIGxhc3QgaXRlbXMgd2lsbCBoYXZlIG5vIGludGVyY2VwdGluZyBwcm9wZXJ0eS5cbiAgICAvLyBTbyBpZiB0aGVyZSBpcyBubyBvd24gZGVzY3JpcHRvciBvbiB0aGUgbGFzdCBwb3NpdGlvbiwgd2Uga25vdyB0aGF0IGl0ZW1zIHdlcmUgcmVtb3ZlZCBhbmQgYWRkZWRcbiAgICAvLyBOLkIuOiBzcGxpY2UsIHVuc2hpZnQsIGV0YyBvbmx5IHNoaWZ0IHZhbHVlcyBhcm91bmQsIGJ1dCBub3QgcHJvcCBkZXNjcmlwdG9ycywgc28gd2Ugb25seSBoYXZlIHRvIGNoZWNrXG4gICAgLy8gdGhlIGxhc3Qgb25lXG4gICAgLy8gbGFzdCBkZXNjcmlwdG9yIGNhbiBiZSBub3QgYSB0cmFwLCBpZiB0aGUgYXJyYXkgd2FzIGV4dGVuZGVkXG5cbiAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZHJhZnRfLCBkcmFmdF8ubGVuZ3RoIC0gMSk7IC8vIGRlc2NyaXB0b3IgY2FuIGJlIG51bGwsIGJ1dCBvbmx5IGZvciBuZXdseSBjcmVhdGVkIHNwYXJzZSBhcnJheXMsIGVnLiBuZXcgQXJyYXkoMTApXG5cbiAgICBpZiAoZGVzY3JpcHRvciAmJiAhZGVzY3JpcHRvci5nZXQpIHJldHVybiB0cnVlOyAvLyBpZiB3ZSBtaXNzIGEgcHJvcGVydHksIGl0IGhhcyBiZWVuIGRlbGV0ZWQsIHNvIGFycmF5IHByb2JvYmFseSBjaGFuZ2VkXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRyYWZ0Xy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFkcmFmdF8uaGFzT3duUHJvcGVydHkoaSkpIHJldHVybiB0cnVlO1xuICAgIH0gLy8gRm9yIGFsbCBvdGhlciBjYXNlcywgd2UgZG9uJ3QgaGF2ZSB0byBjb21wYXJlLCBhcyB0aGV5IHdvdWxkIGhhdmUgYmVlbiBwaWNrZWQgdXAgYnkgdGhlIGluZGV4IHNldHRlcnNcblxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzQ2hhbmdlc18oc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUudHlwZV8gPT09IDRcbiAgICAvKiBFUzVPYmplY3QgKi9cbiAgICA/IGhhc09iamVjdENoYW5nZXMoc3RhdGUpIDogaGFzQXJyYXlDaGFuZ2VzKHN0YXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydFVucmV2b2tlZChzdGF0ZVxuICAvKkVTNVN0YXRlIHwgTWFwU3RhdGUgfCBTZXRTdGF0ZSovXG4gICkge1xuICAgIGlmIChzdGF0ZS5yZXZva2VkXykgZGllKDMsIEpTT04uc3RyaW5naWZ5KGxhdGVzdChzdGF0ZSkpKTtcbiAgfVxuXG4gIGxvYWRQbHVnaW4oXCJFUzVcIiwge1xuICAgIGNyZWF0ZUVTNVByb3h5XzogY3JlYXRlRVM1UHJveHlfLFxuICAgIHdpbGxGaW5hbGl6ZUVTNV86IHdpbGxGaW5hbGl6ZUVTNV8sXG4gICAgaGFzQ2hhbmdlc186IGhhc0NoYW5nZXNfXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlbmFibGVQYXRjaGVzKCkge1xuICB2YXIgUkVQTEFDRSA9IFwicmVwbGFjZVwiO1xuICB2YXIgQUREID0gXCJhZGRcIjtcbiAgdmFyIFJFTU9WRSA9IFwicmVtb3ZlXCI7XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVQYXRjaGVzXyhzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XG4gICAgc3dpdGNoIChzdGF0ZS50eXBlXykge1xuICAgICAgY2FzZSAwXG4gICAgICAvKiBQcm94eU9iamVjdCAqL1xuICAgICAgOlxuICAgICAgY2FzZSA0XG4gICAgICAvKiBFUzVPYmplY3QgKi9cbiAgICAgIDpcbiAgICAgIGNhc2UgMlxuICAgICAgLyogTWFwICovXG4gICAgICA6XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZVBhdGNoZXNGcm9tQXNzaWduZWQoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcyk7XG5cbiAgICAgIGNhc2UgNVxuICAgICAgLyogRVM1QXJyYXkgKi9cbiAgICAgIDpcbiAgICAgIGNhc2UgMVxuICAgICAgLyogUHJveHlBcnJheSAqL1xuICAgICAgOlxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVBcnJheVBhdGNoZXMoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcyk7XG5cbiAgICAgIGNhc2UgM1xuICAgICAgLyogU2V0ICovXG4gICAgICA6XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZVNldFBhdGNoZXMoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVBcnJheVBhdGNoZXMoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICAgIHZhciBiYXNlXyA9IHN0YXRlLmJhc2VfLFxuICAgICAgICBhc3NpZ25lZF8gPSBzdGF0ZS5hc3NpZ25lZF87XG4gICAgdmFyIGNvcHlfID0gc3RhdGUuY29weV87IC8vIFJlZHVjZSBjb21wbGV4aXR5IGJ5IGVuc3VyaW5nIGBiYXNlYCBpcyBuZXZlciBsb25nZXIuXG5cbiAgICBpZiAoY29weV8ubGVuZ3RoIDwgYmFzZV8ubGVuZ3RoKSB7XG4gICAgICB2YXIgX3JlZiA9IFtjb3B5XywgYmFzZV9dO1xuICAgICAgYmFzZV8gPSBfcmVmWzBdO1xuICAgICAgY29weV8gPSBfcmVmWzFdO1xuICAgICAgdmFyIF9yZWYyID0gW2ludmVyc2VQYXRjaGVzLCBwYXRjaGVzXTtcbiAgICAgIHBhdGNoZXMgPSBfcmVmMlswXTtcbiAgICAgIGludmVyc2VQYXRjaGVzID0gX3JlZjJbMV07XG4gICAgfSAvLyBQcm9jZXNzIHJlcGxhY2VkIGluZGljZXMuXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFzZV8ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhc3NpZ25lZF9baV0gJiYgY29weV9baV0gIT09IGJhc2VfW2ldKSB7XG4gICAgICAgIHZhciBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSk7XG4gICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgb3A6IFJFUExBQ0UsXG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAvLyBOZWVkIHRvIG1heWJlIGNsb25lIGl0LCBhcyBpdCBjYW4gaW4gZmFjdCBiZSB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgICAgICAgICAvLyBkdWUgdG8gdGhlIGJhc2UvY29weSBpbnZlcnNpb24gYXQgdGhlIHN0YXJ0IG9mIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQoY29weV9baV0pXG4gICAgICAgIH0pO1xuICAgICAgICBpbnZlcnNlUGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogUkVQTEFDRSxcbiAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChiYXNlX1tpXSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSAvLyBQcm9jZXNzIGFkZGVkIGluZGljZXMuXG5cblxuICAgIGZvciAodmFyIF9pID0gYmFzZV8ubGVuZ3RoOyBfaSA8IGNvcHlfLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9wYXRoID0gYmFzZVBhdGguY29uY2F0KFtfaV0pO1xuXG4gICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICBvcDogQURELFxuICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgLy8gTmVlZCB0byBtYXliZSBjbG9uZSBpdCwgYXMgaXQgY2FuIGluIGZhY3QgYmUgdGhlIG9yaWdpbmFsIHZhbHVlXG4gICAgICAgIC8vIGR1ZSB0byB0aGUgYmFzZS9jb3B5IGludmVyc2lvbiBhdCB0aGUgc3RhcnQgb2YgdGhpcyBmdW5jdGlvblxuICAgICAgICB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQoY29weV9bX2ldKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGJhc2VfLmxlbmd0aCA8IGNvcHlfLmxlbmd0aCkge1xuICAgICAgaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICAgIG9wOiBSRVBMQUNFLFxuICAgICAgICBwYXRoOiBiYXNlUGF0aC5jb25jYXQoW1wibGVuZ3RoXCJdKSxcbiAgICAgICAgdmFsdWU6IGJhc2VfLmxlbmd0aFxuICAgICAgfSk7XG4gICAgfVxuICB9IC8vIFRoaXMgaXMgdXNlZCBmb3IgYm90aCBNYXAgb2JqZWN0cyBhbmQgbm9ybWFsIG9iamVjdHMuXG5cblxuICBmdW5jdGlvbiBnZW5lcmF0ZVBhdGNoZXNGcm9tQXNzaWduZWQoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICAgIHZhciBiYXNlXyA9IHN0YXRlLmJhc2VfLFxuICAgICAgICBjb3B5XyA9IHN0YXRlLmNvcHlfO1xuICAgIGVhY2goc3RhdGUuYXNzaWduZWRfLCBmdW5jdGlvbiAoa2V5LCBhc3NpZ25lZFZhbHVlKSB7XG4gICAgICB2YXIgb3JpZ1ZhbHVlID0gZ2V0KGJhc2VfLCBrZXkpO1xuICAgICAgdmFyIHZhbHVlID0gZ2V0KGNvcHlfLCBrZXkpO1xuICAgICAgdmFyIG9wID0gIWFzc2lnbmVkVmFsdWUgPyBSRU1PVkUgOiBoYXMoYmFzZV8sIGtleSkgPyBSRVBMQUNFIDogQUREO1xuICAgICAgaWYgKG9yaWdWYWx1ZSA9PT0gdmFsdWUgJiYgb3AgPT09IFJFUExBQ0UpIHJldHVybjtcbiAgICAgIHZhciBwYXRoID0gYmFzZVBhdGguY29uY2F0KGtleSk7XG4gICAgICBwYXRjaGVzLnB1c2gob3AgPT09IFJFTU9WRSA/IHtcbiAgICAgICAgb3A6IG9wLFxuICAgICAgICBwYXRoOiBwYXRoXG4gICAgICB9IDoge1xuICAgICAgICBvcDogb3AsXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgICBpbnZlcnNlUGF0Y2hlcy5wdXNoKG9wID09PSBBREQgPyB7XG4gICAgICAgIG9wOiBSRU1PVkUsXG4gICAgICAgIHBhdGg6IHBhdGhcbiAgICAgIH0gOiBvcCA9PT0gUkVNT1ZFID8ge1xuICAgICAgICBvcDogQURELFxuICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQob3JpZ1ZhbHVlKVxuICAgICAgfSA6IHtcbiAgICAgICAgb3A6IFJFUExBQ0UsXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChvcmlnVmFsdWUpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlU2V0UGF0Y2hlcyhzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XG4gICAgdmFyIGJhc2VfID0gc3RhdGUuYmFzZV8sXG4gICAgICAgIGNvcHlfID0gc3RhdGUuY29weV87XG4gICAgdmFyIGkgPSAwO1xuICAgIGJhc2VfLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoIWNvcHlfLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogUkVNT1ZFLFxuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBpbnZlcnNlUGF0Y2hlcy51bnNoaWZ0KHtcbiAgICAgICAgICBvcDogQURELFxuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpKys7XG4gICAgfSk7XG4gICAgaSA9IDA7XG4gICAgY29weV8uZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICghYmFzZV8uaGFzKHZhbHVlKSkge1xuICAgICAgICB2YXIgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xuICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgIG9wOiBBREQsXG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGludmVyc2VQYXRjaGVzLnVuc2hpZnQoe1xuICAgICAgICAgIG9wOiBSRU1PVkUsXG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyhiYXNlVmFsdWUsIHJlcGxhY2VtZW50LCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICBvcDogUkVQTEFDRSxcbiAgICAgIHBhdGg6IFtdLFxuICAgICAgdmFsdWU6IHJlcGxhY2VtZW50ID09PSBOT1RISU5HID8gdW5kZWZpbmVkIDogcmVwbGFjZW1lbnRcbiAgICB9KTtcbiAgICBpbnZlcnNlUGF0Y2hlcy5wdXNoKHtcbiAgICAgIG9wOiBSRVBMQUNFLFxuICAgICAgcGF0aDogW10sXG4gICAgICB2YWx1ZTogYmFzZVZhbHVlXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseVBhdGNoZXNfKGRyYWZ0LCBwYXRjaGVzKSB7XG4gICAgcGF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXRjaCkge1xuICAgICAgdmFyIHBhdGggPSBwYXRjaC5wYXRoLFxuICAgICAgICAgIG9wID0gcGF0Y2gub3A7XG4gICAgICB2YXIgYmFzZSA9IGRyYWZ0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJlbnRUeXBlID0gZ2V0QXJjaHR5cGUoYmFzZSk7XG4gICAgICAgIHZhciBwID0gcGF0aFtpXTtcblxuICAgICAgICBpZiAodHlwZW9mIHAgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHAgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBwID0gXCJcIiArIHA7XG4gICAgICAgIH0gLy8gU2VlICM3MzgsIGF2b2lkIHByb3RvdHlwZSBwb2xsdXRpb25cblxuXG4gICAgICAgIGlmICgocGFyZW50VHlwZSA9PT0gMFxuICAgICAgICAvKiBPYmplY3QgKi9cbiAgICAgICAgfHwgcGFyZW50VHlwZSA9PT0gMVxuICAgICAgICAvKiBBcnJheSAqL1xuICAgICAgICApICYmIChwID09PSBcIl9fcHJvdG9fX1wiIHx8IHAgPT09IFwiY29uc3RydWN0b3JcIikpIGRpZSgyNCk7XG4gICAgICAgIGlmICh0eXBlb2YgYmFzZSA9PT0gXCJmdW5jdGlvblwiICYmIHAgPT09IFwicHJvdG90eXBlXCIpIGRpZSgyNCk7XG4gICAgICAgIGJhc2UgPSBnZXQoYmFzZSwgcCk7XG4gICAgICAgIGlmICh0eXBlb2YgYmFzZSAhPT0gXCJvYmplY3RcIikgZGllKDE1LCBwYXRoLmpvaW4oXCIvXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGUgPSBnZXRBcmNodHlwZShiYXNlKTtcbiAgICAgIHZhciB2YWx1ZSA9IGRlZXBDbG9uZVBhdGNoVmFsdWUocGF0Y2gudmFsdWUpOyAvLyB1c2VkIHRvIGNsb25lIHBhdGNoIHRvIGVuc3VyZSBvcmlnaW5hbCBwYXRjaCBpcyBub3QgbW9kaWZpZWQsIHNlZSAjNDExXG5cbiAgICAgIHZhciBrZXkgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG5cbiAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgY2FzZSBSRVBMQUNFOlxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAyXG4gICAgICAgICAgICAvKiBNYXAgKi9cbiAgICAgICAgICAgIDpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Uuc2V0KGtleSwgdmFsdWUpO1xuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gICAgICAgICAgICBjYXNlIDNcbiAgICAgICAgICAgIC8qIFNldCAqL1xuICAgICAgICAgICAgOlxuICAgICAgICAgICAgICBkaWUoMTYpO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBpZiB2YWx1ZSBpcyBhbiBvYmplY3QsIHRoZW4gaXQncyBhc3NpZ25lZCBieSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgLy8gaW4gdGhlIGZvbGxvd2luZyBhZGQgb3IgcmVtb3ZlIG9wcywgdGhlIHZhbHVlIGZpZWxkIGluc2lkZSB0aGUgcGF0Y2ggd2lsbCBhbHNvIGJlIG1vZGlmeWVkXG4gICAgICAgICAgICAgIC8vIHNvIHdlIHVzZSB2YWx1ZSBmcm9tIHRoZSBjbG9uZWQgcGF0Y2hcbiAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICByZXR1cm4gYmFzZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgQUREOlxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAxXG4gICAgICAgICAgICAvKiBBcnJheSAqL1xuICAgICAgICAgICAgOlxuICAgICAgICAgICAgICByZXR1cm4ga2V5ID09PSBcIi1cIiA/IGJhc2UucHVzaCh2YWx1ZSkgOiBiYXNlLnNwbGljZShrZXksIDAsIHZhbHVlKTtcblxuICAgICAgICAgICAgY2FzZSAyXG4gICAgICAgICAgICAvKiBNYXAgKi9cbiAgICAgICAgICAgIDpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Uuc2V0KGtleSwgdmFsdWUpO1xuXG4gICAgICAgICAgICBjYXNlIDNcbiAgICAgICAgICAgIC8qIFNldCAqL1xuICAgICAgICAgICAgOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5hZGQodmFsdWUpO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVNT1ZFOlxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAxXG4gICAgICAgICAgICAvKiBBcnJheSAqL1xuICAgICAgICAgICAgOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5zcGxpY2Uoa2V5LCAxKTtcblxuICAgICAgICAgICAgY2FzZSAyXG4gICAgICAgICAgICAvKiBNYXAgKi9cbiAgICAgICAgICAgIDpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2UuZGVsZXRlKGtleSk7XG5cbiAgICAgICAgICAgIGNhc2UgM1xuICAgICAgICAgICAgLyogU2V0ICovXG4gICAgICAgICAgICA6XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLmRlbGV0ZShwYXRjaC52YWx1ZSk7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBkZWxldGUgYmFzZVtrZXldO1xuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRpZSgxNywgb3ApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkcmFmdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZXBDbG9uZVBhdGNoVmFsdWUob2JqKSB7XG4gICAgaWYgKCFpc0RyYWZ0YWJsZShvYmopKSByZXR1cm4gb2JqO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHJldHVybiBvYmoubWFwKGRlZXBDbG9uZVBhdGNoVmFsdWUpO1xuICAgIGlmIChpc01hcChvYmopKSByZXR1cm4gbmV3IE1hcChBcnJheS5mcm9tKG9iai5lbnRyaWVzKCkpLm1hcChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgIHZhciBrID0gX3JlZjNbMF0sXG4gICAgICAgICAgdiA9IF9yZWYzWzFdO1xuICAgICAgcmV0dXJuIFtrLCBkZWVwQ2xvbmVQYXRjaFZhbHVlKHYpXTtcbiAgICB9KSk7XG4gICAgaWYgKGlzU2V0KG9iaikpIHJldHVybiBuZXcgU2V0KEFycmF5LmZyb20ob2JqKS5tYXAoZGVlcENsb25lUGF0Y2hWYWx1ZSkpO1xuICAgIHZhciBjbG9uZWQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKTtcblxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGNsb25lZFtrZXldID0gZGVlcENsb25lUGF0Y2hWYWx1ZShvYmpba2V5XSk7XG4gICAgfVxuXG4gICAgaWYgKGhhcyhvYmosIERSQUZUQUJMRSkpIGNsb25lZFtEUkFGVEFCTEVdID0gb2JqW0RSQUZUQUJMRV07XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKG9iaikge1xuICAgIGlmIChpc0RyYWZ0KG9iaikpIHtcbiAgICAgIHJldHVybiBkZWVwQ2xvbmVQYXRjaFZhbHVlKG9iaik7XG4gICAgfSBlbHNlIHJldHVybiBvYmo7XG4gIH1cblxuICBsb2FkUGx1Z2luKFwiUGF0Y2hlc1wiLCB7XG4gICAgYXBwbHlQYXRjaGVzXzogYXBwbHlQYXRjaGVzXyxcbiAgICBnZW5lcmF0ZVBhdGNoZXNfOiBnZW5lcmF0ZVBhdGNoZXNfLFxuICAgIGdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXzogZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfXG4gIH0pO1xufVxuXG4vLyB0eXBlcyBvbmx5IVxuZnVuY3Rpb24gZW5hYmxlTWFwU2V0KCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB2YXIgX2V4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiBleHRlbmRTdGF0aWNzKGQsIGIpIHtcbiAgICBfZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgICBfX3Byb3RvX186IFtdXG4gICAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBkLl9fcHJvdG9fXyA9IGI7XG4gICAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSB7XG4gICAgICAgIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIF9leHRlbmRTdGF0aWNzKGQsIGIpO1xuICB9OyAvLyBVZ2x5IGhhY2sgdG8gcmVzb2x2ZSAjNTAyIGFuZCBpbmhlcml0IGJ1aWx0IGluIE1hcCAvIFNldFxuXG5cbiAgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgICBfZXh0ZW5kU3RhdGljcyhkLCBiKTtcblxuICAgIGZ1bmN0aW9uIF9fKCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gICAgfVxuXG4gICAgZC5wcm90b3R5cGUgPSAoIC8vIEB0cy1pZ25vcmVcbiAgICBfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9XG5cbiAgdmFyIERyYWZ0TWFwID0gZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEcmFmdE1hcCwgX3N1cGVyKTsgLy8gQ3JlYXRlIGNsYXNzIG1hbnVhbGx5LCBjYXVzZSAjNTAyXG5cblxuICAgIGZ1bmN0aW9uIERyYWZ0TWFwKHRhcmdldCwgcGFyZW50KSB7XG4gICAgICB0aGlzW0RSQUZUX1NUQVRFXSA9IHtcbiAgICAgICAgdHlwZV86IDJcbiAgICAgICAgLyogTWFwICovXG4gICAgICAgICxcbiAgICAgICAgcGFyZW50XzogcGFyZW50LFxuICAgICAgICBzY29wZV86IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKSxcbiAgICAgICAgbW9kaWZpZWRfOiBmYWxzZSxcbiAgICAgICAgZmluYWxpemVkXzogZmFsc2UsXG4gICAgICAgIGNvcHlfOiB1bmRlZmluZWQsXG4gICAgICAgIGFzc2lnbmVkXzogdW5kZWZpbmVkLFxuICAgICAgICBiYXNlXzogdGFyZ2V0LFxuICAgICAgICBkcmFmdF86IHRoaXMsXG4gICAgICAgIGlzTWFudWFsXzogZmFsc2UsXG4gICAgICAgIHJldm9rZWRfOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBwID0gRHJhZnRNYXAucHJvdG90eXBlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcInNpemVcIiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLnNpemU7XG4gICAgICB9IC8vIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgLy8gY29uZmlndXJhYmxlOiB0cnVlXG5cbiAgICB9KTtcblxuICAgIHAuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkuaGFzKGtleSk7XG4gICAgfTtcblxuICAgIHAuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcblxuICAgICAgaWYgKCFsYXRlc3Qoc3RhdGUpLmhhcyhrZXkpIHx8IGxhdGVzdChzdGF0ZSkuZ2V0KGtleSkgIT09IHZhbHVlKSB7XG4gICAgICAgIHByZXBhcmVNYXBDb3B5KHN0YXRlKTtcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgIHN0YXRlLmNvcHlfLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfLnNldChrZXksIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgcC5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoIXRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBwcmVwYXJlTWFwQ29weShzdGF0ZSk7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG5cbiAgICAgIGlmIChzdGF0ZS5iYXNlXy5oYXMoa2V5KSkge1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5jb3B5Xy5kZWxldGUoa2V5KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBwLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuXG4gICAgICBpZiAobGF0ZXN0KHN0YXRlKS5zaXplKSB7XG4gICAgICAgIHByZXBhcmVNYXBDb3B5KHN0YXRlKTtcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8gPSBuZXcgTWFwKCk7XG4gICAgICAgIGVhY2goc3RhdGUuYmFzZV8sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RhdGUuY29weV8uY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcC5mb3JFYWNoID0gZnVuY3Rpb24gKGNiLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGxhdGVzdChzdGF0ZSkuZm9yRWFjaChmdW5jdGlvbiAoX3ZhbHVlLCBrZXksIF9tYXApIHtcbiAgICAgICAgY2IuY2FsbCh0aGlzQXJnLCBfdGhpcy5nZXQoa2V5KSwga2V5LCBfdGhpcyk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcC5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICB2YXIgdmFsdWUgPSBsYXRlc3Qoc3RhdGUpLmdldChrZXkpO1xuXG4gICAgICBpZiAoc3RhdGUuZmluYWxpemVkXyB8fCAhaXNEcmFmdGFibGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlICE9PSBzdGF0ZS5iYXNlXy5nZXQoa2V5KSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7IC8vIGVpdGhlciBhbHJlYWR5IGRyYWZ0ZWQgb3IgcmVhc3NpZ25lZFxuICAgICAgfSAvLyBkZXNwaXRlIHdoYXQgaXQgbG9va3MsIHRoaXMgY3JlYXRlcyBhIGRyYWZ0IG9ubHkgb25jZSwgc2VlIGFib3ZlIGNvbmRpdGlvblxuXG5cbiAgICAgIHZhciBkcmFmdCA9IGNyZWF0ZVByb3h5KHN0YXRlLnNjb3BlXy5pbW1lcl8sIHZhbHVlLCBzdGF0ZSk7XG4gICAgICBwcmVwYXJlTWFwQ29weShzdGF0ZSk7XG4gICAgICBzdGF0ZS5jb3B5Xy5zZXQoa2V5LCBkcmFmdCk7XG4gICAgICByZXR1cm4gZHJhZnQ7XG4gICAgfTtcblxuICAgIHAua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLmtleXMoKTtcbiAgICB9O1xuXG4gICAgcC52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcyxcbiAgICAgICAgICBfcmVmO1xuXG4gICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLmtleXMoKTtcbiAgICAgIHJldHVybiBfcmVmID0ge30sIF9yZWZbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLnZhbHVlcygpO1xuICAgICAgfSwgX3JlZi5uZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgdmFyIHIgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICAgICAgaWYgKHIuZG9uZSkgcmV0dXJuIHI7XG5cbiAgICAgICAgdmFyIHZhbHVlID0gX3RoaXMyLmdldChyLnZhbHVlKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSwgX3JlZjtcbiAgICB9O1xuXG4gICAgcC5lbnRyaWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXMsXG4gICAgICAgICAgX3JlZjI7XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMua2V5cygpO1xuICAgICAgcmV0dXJuIF9yZWYyID0ge30sIF9yZWYyW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5lbnRyaWVzKCk7XG4gICAgICB9LCBfcmVmMi5uZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgdmFyIHIgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICAgICAgaWYgKHIuZG9uZSkgcmV0dXJuIHI7XG5cbiAgICAgICAgdmFyIHZhbHVlID0gX3RoaXMzLmdldChyLnZhbHVlKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiBbci52YWx1ZSwgdmFsdWVdXG4gICAgICAgIH07XG4gICAgICB9LCBfcmVmMjtcbiAgICB9O1xuXG4gICAgcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBEcmFmdE1hcDtcbiAgfShNYXApO1xuXG4gIGZ1bmN0aW9uIHByb3h5TWFwXyh0YXJnZXQsIHBhcmVudCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gbmV3IERyYWZ0TWFwKHRhcmdldCwgcGFyZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVNYXBDb3B5KHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5jb3B5Xykge1xuICAgICAgc3RhdGUuYXNzaWduZWRfID0gbmV3IE1hcCgpO1xuICAgICAgc3RhdGUuY29weV8gPSBuZXcgTWFwKHN0YXRlLmJhc2VfKTtcbiAgICB9XG4gIH1cblxuICB2YXIgRHJhZnRTZXQgPSBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERyYWZ0U2V0LCBfc3VwZXIpOyAvLyBDcmVhdGUgY2xhc3MgbWFudWFsbHksIGNhdXNlICM1MDJcblxuXG4gICAgZnVuY3Rpb24gRHJhZnRTZXQodGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAgIHRoaXNbRFJBRlRfU1RBVEVdID0ge1xuICAgICAgICB0eXBlXzogM1xuICAgICAgICAvKiBTZXQgKi9cbiAgICAgICAgLFxuICAgICAgICBwYXJlbnRfOiBwYXJlbnQsXG4gICAgICAgIHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpLFxuICAgICAgICBtb2RpZmllZF86IGZhbHNlLFxuICAgICAgICBmaW5hbGl6ZWRfOiBmYWxzZSxcbiAgICAgICAgY29weV86IHVuZGVmaW5lZCxcbiAgICAgICAgYmFzZV86IHRhcmdldCxcbiAgICAgICAgZHJhZnRfOiB0aGlzLFxuICAgICAgICBkcmFmdHNfOiBuZXcgTWFwKCksXG4gICAgICAgIHJldm9rZWRfOiBmYWxzZSxcbiAgICAgICAgaXNNYW51YWxfOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBwID0gRHJhZnRTZXQucHJvdG90eXBlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcInNpemVcIiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLnNpemU7XG4gICAgICB9IC8vIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICB9KTtcblxuICAgIHAuaGFzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7IC8vIGJpdCBvZiB0cmlja2VyeSBoZXJlLCB0byBiZSBhYmxlIHRvIHJlY29nbml6ZSBib3RoIHRoZSB2YWx1ZSwgYW5kIHRoZSBkcmFmdCBvZiBpdHMgdmFsdWVcblxuICAgICAgaWYgKCFzdGF0ZS5jb3B5Xykge1xuICAgICAgICByZXR1cm4gc3RhdGUuYmFzZV8uaGFzKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLmNvcHlfLmhhcyh2YWx1ZSkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHN0YXRlLmRyYWZ0c18uaGFzKHZhbHVlKSAmJiBzdGF0ZS5jb3B5Xy5oYXMoc3RhdGUuZHJhZnRzXy5nZXQodmFsdWUpKSkgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHAuYWRkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG5cbiAgICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB7XG4gICAgICAgIHByZXBhcmVTZXRDb3B5KHN0YXRlKTtcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5jb3B5Xy5hZGQodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgcC5kZWxldGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvcHlfLmRlbGV0ZSh2YWx1ZSkgfHwgKHN0YXRlLmRyYWZ0c18uaGFzKHZhbHVlKSA/IHN0YXRlLmNvcHlfLmRlbGV0ZShzdGF0ZS5kcmFmdHNfLmdldCh2YWx1ZSkpIDpcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBmYWxzZSk7XG4gICAgfTtcblxuICAgIHAuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG5cbiAgICAgIGlmIChsYXRlc3Qoc3RhdGUpLnNpemUpIHtcbiAgICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICAgIHN0YXRlLmNvcHlfLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHAudmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvcHlfLnZhbHVlcygpO1xuICAgIH07XG5cbiAgICBwLmVudHJpZXMgPSBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvcHlfLmVudHJpZXMoKTtcbiAgICB9O1xuXG4gICAgcC5rZXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG4gICAgfTtcblxuICAgIHBbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG4gICAgfTtcblxuICAgIHAuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goY2IsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMudmFsdWVzKCk7XG4gICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuXG4gICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIGNiLmNhbGwodGhpc0FyZywgcmVzdWx0LnZhbHVlLCByZXN1bHQudmFsdWUsIHRoaXMpO1xuICAgICAgICByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBEcmFmdFNldDtcbiAgfShTZXQpO1xuXG4gIGZ1bmN0aW9uIHByb3h5U2V0Xyh0YXJnZXQsIHBhcmVudCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gbmV3IERyYWZ0U2V0KHRhcmdldCwgcGFyZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVTZXRDb3B5KHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5jb3B5Xykge1xuICAgICAgLy8gY3JlYXRlIGRyYWZ0cyBmb3IgYWxsIGVudHJpZXMgdG8gcHJlc2VydmUgaW5zZXJ0aW9uIG9yZGVyXG4gICAgICBzdGF0ZS5jb3B5XyA9IG5ldyBTZXQoKTtcbiAgICAgIHN0YXRlLmJhc2VfLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICB2YXIgZHJhZnQgPSBjcmVhdGVQcm94eShzdGF0ZS5zY29wZV8uaW1tZXJfLCB2YWx1ZSwgc3RhdGUpO1xuICAgICAgICAgIHN0YXRlLmRyYWZ0c18uc2V0KHZhbHVlLCBkcmFmdCk7XG4gICAgICAgICAgc3RhdGUuY29weV8uYWRkKGRyYWZ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5jb3B5Xy5hZGQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRVbnJldm9rZWQoc3RhdGVcbiAgLypFUzVTdGF0ZSB8IE1hcFN0YXRlIHwgU2V0U3RhdGUqL1xuICApIHtcbiAgICBpZiAoc3RhdGUucmV2b2tlZF8pIGRpZSgzLCBKU09OLnN0cmluZ2lmeShsYXRlc3Qoc3RhdGUpKSk7XG4gIH1cblxuICBsb2FkUGx1Z2luKFwiTWFwU2V0XCIsIHtcbiAgICBwcm94eU1hcF86IHByb3h5TWFwXyxcbiAgICBwcm94eVNldF86IHByb3h5U2V0X1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlQWxsUGx1Z2lucygpIHtcbiAgZW5hYmxlRVM1KCk7XG4gIGVuYWJsZU1hcFNldCgpO1xuICBlbmFibGVQYXRjaGVzKCk7XG59XG5cbnZhciBpbW1lciA9XG4vKiNfX1BVUkVfXyovXG5uZXcgSW1tZXIoKTtcbi8qKlxyXG4gKiBUaGUgYHByb2R1Y2VgIGZ1bmN0aW9uIHRha2VzIGEgdmFsdWUgYW5kIGEgXCJyZWNpcGUgZnVuY3Rpb25cIiAod2hvc2VcclxuICogcmV0dXJuIHZhbHVlIG9mdGVuIGRlcGVuZHMgb24gdGhlIGJhc2Ugc3RhdGUpLiBUaGUgcmVjaXBlIGZ1bmN0aW9uIGlzXHJcbiAqIGZyZWUgdG8gbXV0YXRlIGl0cyBmaXJzdCBhcmd1bWVudCBob3dldmVyIGl0IHdhbnRzLiBBbGwgbXV0YXRpb25zIGFyZVxyXG4gKiBvbmx5IGV2ZXIgYXBwbGllZCB0byBhIF9fY29weV9fIG9mIHRoZSBiYXNlIHN0YXRlLlxyXG4gKlxyXG4gKiBQYXNzIG9ubHkgYSBmdW5jdGlvbiB0byBjcmVhdGUgYSBcImN1cnJpZWQgcHJvZHVjZXJcIiB3aGljaCByZWxpZXZlcyB5b3VcclxuICogZnJvbSBwYXNzaW5nIHRoZSByZWNpcGUgZnVuY3Rpb24gZXZlcnkgdGltZS5cclxuICpcclxuICogT25seSBwbGFpbiBvYmplY3RzIGFuZCBhcnJheXMgYXJlIG1hZGUgbXV0YWJsZS4gQWxsIG90aGVyIG9iamVjdHMgYXJlXHJcbiAqIGNvbnNpZGVyZWQgdW5jb3B5YWJsZS5cclxuICpcclxuICogTm90ZTogVGhpcyBmdW5jdGlvbiBpcyBfX2JvdW5kX18gdG8gaXRzIGBJbW1lcmAgaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB7YW55fSBiYXNlIC0gdGhlIGluaXRpYWwgc3RhdGVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvZHVjZXIgLSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEgcHJveHkgb2YgdGhlIGJhc2Ugc3RhdGUgYXMgZmlyc3QgYXJndW1lbnQgYW5kIHdoaWNoIGNhbiBiZSBmcmVlbHkgbW9kaWZpZWRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gcGF0Y2hMaXN0ZW5lciAtIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhbGwgdGhlIHBhdGNoZXMgcHJvZHVjZWQgaGVyZVxyXG4gKiBAcmV0dXJucyB7YW55fSBhIG5ldyBzdGF0ZSwgb3IgdGhlIGluaXRpYWwgc3RhdGUgaWYgbm90aGluZyB3YXMgbW9kaWZpZWRcclxuICovXG5cbnZhciBwcm9kdWNlID0gaW1tZXIucHJvZHVjZTtcbi8qKlxyXG4gKiBMaWtlIGBwcm9kdWNlYCwgYnV0IGBwcm9kdWNlV2l0aFBhdGNoZXNgIGFsd2F5cyByZXR1cm5zIGEgdHVwbGVcclxuICogW25leHRTdGF0ZSwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdIChpbnN0ZWFkIG9mIGp1c3QgdGhlIG5leHQgc3RhdGUpXHJcbiAqL1xuXG52YXIgcHJvZHVjZVdpdGhQYXRjaGVzID1cbi8qI19fUFVSRV9fKi9cbmltbWVyLnByb2R1Y2VXaXRoUGF0Y2hlcy5iaW5kKGltbWVyKTtcbi8qKlxyXG4gKiBQYXNzIHRydWUgdG8gYXV0b21hdGljYWxseSBmcmVlemUgYWxsIGNvcGllcyBjcmVhdGVkIGJ5IEltbWVyLlxyXG4gKlxyXG4gKiBBbHdheXMgZnJlZXplIGJ5IGRlZmF1bHQsIGV2ZW4gaW4gcHJvZHVjdGlvbiBtb2RlXHJcbiAqL1xuXG52YXIgc2V0QXV0b0ZyZWV6ZSA9XG4vKiNfX1BVUkVfXyovXG5pbW1lci5zZXRBdXRvRnJlZXplLmJpbmQoaW1tZXIpO1xuLyoqXHJcbiAqIFBhc3MgdHJ1ZSB0byB1c2UgdGhlIEVTMjAxNSBgUHJveHlgIGNsYXNzIHdoZW4gY3JlYXRpbmcgZHJhZnRzLCB3aGljaCBpc1xyXG4gKiBhbHdheXMgZmFzdGVyIHRoYW4gdXNpbmcgRVM1IHByb3hpZXMuXHJcbiAqXHJcbiAqIEJ5IGRlZmF1bHQsIGZlYXR1cmUgZGV0ZWN0aW9uIGlzIHVzZWQsIHNvIGNhbGxpbmcgdGhpcyBpcyByYXJlbHkgbmVjZXNzYXJ5LlxyXG4gKi9cblxudmFyIHNldFVzZVByb3hpZXMgPVxuLyojX19QVVJFX18qL1xuaW1tZXIuc2V0VXNlUHJveGllcy5iaW5kKGltbWVyKTtcbi8qKlxyXG4gKiBBcHBseSBhbiBhcnJheSBvZiBJbW1lciBwYXRjaGVzIHRvIHRoZSBmaXJzdCBhcmd1bWVudC5cclxuICpcclxuICogVGhpcyBmdW5jdGlvbiBpcyBhIHByb2R1Y2VyLCB3aGljaCBtZWFucyBjb3B5LW9uLXdyaXRlIGlzIGluIGVmZmVjdC5cclxuICovXG5cbnZhciBhcHBseVBhdGNoZXMgPVxuLyojX19QVVJFX18qL1xuaW1tZXIuYXBwbHlQYXRjaGVzLmJpbmQoaW1tZXIpO1xuLyoqXHJcbiAqIENyZWF0ZSBhbiBJbW1lciBkcmFmdCBmcm9tIHRoZSBnaXZlbiBiYXNlIHN0YXRlLCB3aGljaCBtYXkgYmUgYSBkcmFmdCBpdHNlbGYuXHJcbiAqIFRoZSBkcmFmdCBjYW4gYmUgbW9kaWZpZWQgdW50aWwgeW91IGZpbmFsaXplIGl0IHdpdGggdGhlIGBmaW5pc2hEcmFmdGAgZnVuY3Rpb24uXHJcbiAqL1xuXG52YXIgY3JlYXRlRHJhZnQgPVxuLyojX19QVVJFX18qL1xuaW1tZXIuY3JlYXRlRHJhZnQuYmluZChpbW1lcik7XG4vKipcclxuICogRmluYWxpemUgYW4gSW1tZXIgZHJhZnQgZnJvbSBhIGBjcmVhdGVEcmFmdGAgY2FsbCwgcmV0dXJuaW5nIHRoZSBiYXNlIHN0YXRlXHJcbiAqIChpZiBubyBjaGFuZ2VzIHdlcmUgbWFkZSkgb3IgYSBtb2RpZmllZCBjb3B5LiBUaGUgZHJhZnQgbXVzdCAqbm90KiBiZVxyXG4gKiBtdXRhdGVkIGFmdGVyd2FyZHMuXHJcbiAqXHJcbiAqIFBhc3MgYSBmdW5jdGlvbiBhcyB0aGUgMm5kIGFyZ3VtZW50IHRvIGdlbmVyYXRlIEltbWVyIHBhdGNoZXMgYmFzZWQgb24gdGhlXHJcbiAqIGNoYW5nZXMgdGhhdCB3ZXJlIG1hZGUuXHJcbiAqL1xuXG52YXIgZmluaXNoRHJhZnQgPVxuLyojX19QVVJFX18qL1xuaW1tZXIuZmluaXNoRHJhZnQuYmluZChpbW1lcik7XG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBpcyBhY3R1YWxseSBhIG5vLW9wLCBidXQgY2FuIGJlIHVzZWQgdG8gY2FzdCBhbiBpbW11dGFibGUgdHlwZVxyXG4gKiB0byBhbiBkcmFmdCB0eXBlIGFuZCBtYWtlIFR5cGVTY3JpcHQgaGFwcHlcclxuICpcclxuICogQHBhcmFtIHZhbHVlXHJcbiAqL1xuXG5mdW5jdGlvbiBjYXN0RHJhZnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYWN0dWFsbHkgYSBuby1vcCwgYnV0IGNhbiBiZSB1c2VkIHRvIGNhc3QgYSBtdXRhYmxlIHR5cGVcclxuICogdG8gYW4gaW1tdXRhYmxlIHR5cGUgYW5kIG1ha2UgVHlwZVNjcmlwdCBoYXBweVxyXG4gKiBAcGFyYW0gdmFsdWVcclxuICovXG5cbmZ1bmN0aW9uIGNhc3RJbW11dGFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnRzLkltbWVyID0gSW1tZXI7XG5leHBvcnRzLmFwcGx5UGF0Y2hlcyA9IGFwcGx5UGF0Y2hlcztcbmV4cG9ydHMuY2FzdERyYWZ0ID0gY2FzdERyYWZ0O1xuZXhwb3J0cy5jYXN0SW1tdXRhYmxlID0gY2FzdEltbXV0YWJsZTtcbmV4cG9ydHMuY3JlYXRlRHJhZnQgPSBjcmVhdGVEcmFmdDtcbmV4cG9ydHMuY3VycmVudCA9IGN1cnJlbnQ7XG5leHBvcnRzLmRlZmF1bHQgPSBwcm9kdWNlO1xuZXhwb3J0cy5lbmFibGVBbGxQbHVnaW5zID0gZW5hYmxlQWxsUGx1Z2lucztcbmV4cG9ydHMuZW5hYmxlRVM1ID0gZW5hYmxlRVM1O1xuZXhwb3J0cy5lbmFibGVNYXBTZXQgPSBlbmFibGVNYXBTZXQ7XG5leHBvcnRzLmVuYWJsZVBhdGNoZXMgPSBlbmFibGVQYXRjaGVzO1xuZXhwb3J0cy5maW5pc2hEcmFmdCA9IGZpbmlzaERyYWZ0O1xuZXhwb3J0cy5mcmVlemUgPSBmcmVlemU7XG5leHBvcnRzLmltbWVyYWJsZSA9IERSQUZUQUJMRTtcbmV4cG9ydHMuaXNEcmFmdCA9IGlzRHJhZnQ7XG5leHBvcnRzLmlzRHJhZnRhYmxlID0gaXNEcmFmdGFibGU7XG5leHBvcnRzLm5vdGhpbmcgPSBOT1RISU5HO1xuZXhwb3J0cy5vcmlnaW5hbCA9IG9yaWdpbmFsO1xuZXhwb3J0cy5wcm9kdWNlID0gcHJvZHVjZTtcbmV4cG9ydHMucHJvZHVjZVdpdGhQYXRjaGVzID0gcHJvZHVjZVdpdGhQYXRjaGVzO1xuZXhwb3J0cy5zZXRBdXRvRnJlZXplID0gc2V0QXV0b0ZyZWV6ZTtcbmV4cG9ydHMuc2V0VXNlUHJveGllcyA9IHNldFVzZVByb3hpZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbW1lci5janMuZGV2ZWxvcG1lbnQuanMubWFwXG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJfcmVmIiwiaGFzU3ltYm9sIiwiU3ltYm9sIiwiaGFzTWFwIiwiTWFwIiwiaGFzU2V0IiwiU2V0IiwiaGFzUHJveGllcyIsIlByb3h5IiwicmV2b2NhYmxlIiwiUmVmbGVjdCIsIk5PVEhJTkciLCJmb3IiLCJEUkFGVEFCTEUiLCJEUkFGVF9TVEFURSIsIml0ZXJhdG9yU3ltYm9sIiwiaXRlcmF0b3IiLCJlcnJvcnMiLCJfIiwiZGF0YSIsInBhdGgiLCJvcCIsInBsdWdpbiIsInRoaW5nIiwiZGllIiwiZXJyb3IiLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJncyIsIkFycmF5IiwiX2tleSIsImUiLCJtc2ciLCJhcHBseSIsIkVycm9yIiwiaXNEcmFmdCIsImlzRHJhZnRhYmxlIiwiX3ZhbHVlJGNvbnN0cnVjdG9yIiwiaXNQbGFpbk9iamVjdCIsImlzQXJyYXkiLCJjb25zdHJ1Y3RvciIsImlzTWFwIiwiaXNTZXQiLCJvYmplY3RDdG9yU3RyaW5nIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwiQ3RvciIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIkZ1bmN0aW9uIiwib3JpZ2luYWwiLCJiYXNlXyIsIm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJvYmoiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiY29uY2F0IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsInRhcmdldCIsInJlcyIsImZvckVhY2giLCJrZXkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlYWNoIiwiaXRlciIsImVudW1lcmFibGVPbmx5IiwiZ2V0QXJjaHR5cGUiLCJrZXlzIiwiZW50cnkiLCJpbmRleCIsInN0YXRlIiwidHlwZV8iLCJoYXMiLCJwcm9wIiwiZ2V0Iiwic2V0IiwicHJvcE9yT2xkVmFsdWUiLCJ0IiwiYWRkIiwiaXMiLCJ4IiwieSIsImxhdGVzdCIsImNvcHlfIiwic2hhbGxvd0NvcHkiLCJiYXNlIiwic2xpY2UiLCJkZXNjcmlwdG9ycyIsImkiLCJkZXNjIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiY3JlYXRlIiwiZnJlZXplIiwiZGVlcCIsImlzRnJvemVuIiwiY2xlYXIiLCJkZWxldGUiLCJkb250TXV0YXRlRnJvemVuQ29sbGVjdGlvbnMiLCJwbHVnaW5zIiwiZ2V0UGx1Z2luIiwicGx1Z2luS2V5IiwibG9hZFBsdWdpbiIsImltcGxlbWVudGF0aW9uIiwiY3VycmVudFNjb3BlIiwiZ2V0Q3VycmVudFNjb3BlIiwiY3JlYXRlU2NvcGUiLCJwYXJlbnRfIiwiaW1tZXJfIiwiZHJhZnRzXyIsImNhbkF1dG9GcmVlemVfIiwidW5maW5hbGl6ZWREcmFmdHNfIiwidXNlUGF0Y2hlc0luU2NvcGUiLCJzY29wZSIsInBhdGNoTGlzdGVuZXIiLCJwYXRjaGVzXyIsImludmVyc2VQYXRjaGVzXyIsInBhdGNoTGlzdGVuZXJfIiwicmV2b2tlU2NvcGUiLCJsZWF2ZVNjb3BlIiwicmV2b2tlRHJhZnQiLCJlbnRlclNjb3BlIiwiaW1tZXIiLCJkcmFmdCIsInJldm9rZV8iLCJyZXZva2VkXyIsInByb2Nlc3NSZXN1bHQiLCJyZXN1bHQiLCJiYXNlRHJhZnQiLCJpc1JlcGxhY2VkIiwidW5kZWZpbmVkIiwidXNlUHJveGllc18iLCJ3aWxsRmluYWxpemVFUzVfIiwibW9kaWZpZWRfIiwiZmluYWxpemUiLCJtYXliZUZyZWV6ZSIsImdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyIsInJvb3RTY29wZSIsImNoaWxkVmFsdWUiLCJmaW5hbGl6ZVByb3BlcnR5Iiwic2NvcGVfIiwiZmluYWxpemVkXyIsImRyYWZ0XyIsInJlc3VsdEVhY2giLCJnZW5lcmF0ZVBhdGNoZXNfIiwicGFyZW50U3RhdGUiLCJ0YXJnZXRPYmplY3QiLCJyb290UGF0aCIsInRhcmdldElzU2V0IiwiYXNzaWduZWRfIiwiYXV0b0ZyZWV6ZV8iLCJjcmVhdGVQcm94eVByb3h5IiwicGFyZW50IiwiaXNNYW51YWxfIiwidHJhcHMiLCJvYmplY3RUcmFwcyIsImFycmF5VHJhcHMiLCJfUHJveHkkcmV2b2NhYmxlIiwicmV2b2tlIiwicHJveHkiLCJzb3VyY2UiLCJyZWFkUHJvcEZyb21Qcm90byIsInBlZWsiLCJwcmVwYXJlQ29weSIsImNyZWF0ZVByb3h5IiwiZ2V0RGVzY3JpcHRvckZyb21Qcm90byIsImN1cnJlbnQiLCJjdXJyZW50U3RhdGUiLCJtYXJrQ2hhbmdlZCIsIk51bWJlciIsImlzTmFOIiwiZGVsZXRlUHJvcGVydHkiLCJvd25lciIsInNldFByb3RvdHlwZU9mIiwiZm4iLCJwYXJzZUludCIsIl9kZXNjJGdldCIsIkltbWVyIiwiY29uZmlnIiwiX3RoaXMiLCJwcm9kdWNlIiwicmVjaXBlIiwiZGVmYXVsdEJhc2UiLCJzZWxmIiwiY3VycmllZFByb2R1Y2UiLCJfdGhpczIiLCJfcmVjaXBlIiwiaGFzRXJyb3IiLCJQcm9taXNlIiwidGhlbiIsInAiLCJpcCIsInByb2R1Y2VXaXRoUGF0Y2hlcyIsIl9sZW4yIiwiX2tleTIiLCJwYXRjaGVzIiwiaW52ZXJzZVBhdGNoZXMiLCJuZXh0U3RhdGUiLCJ1c2VQcm94aWVzIiwic2V0VXNlUHJveGllcyIsImF1dG9GcmVlemUiLCJzZXRBdXRvRnJlZXplIiwiX3Byb3RvIiwiY3JlYXRlRHJhZnQiLCJmaW5pc2hEcmFmdCIsImFwcGx5UGF0Y2hlcyIsInBhdGNoIiwiYXBwbHlQYXRjaGVzSW1wbCIsImFwcGx5UGF0Y2hlc18iLCJwcm94eU1hcF8iLCJwcm94eVNldF8iLCJjcmVhdGVFUzVQcm94eV8iLCJwdXNoIiwiY3VycmVudEltcGwiLCJjb3B5IiwiYXJjaFR5cGUiLCJoYXNDaGFuZ2VzXyIsImNvcHlIZWxwZXIiLCJmcm9tIiwiZW5hYmxlRVM1IiwibWFya0NoYW5nZXNSZWN1cnNpdmVseSIsIm1hcmtDaGFuZ2VzU3dlZXAiLCJjcmVhdGVFUzVEcmFmdCIsInByb3h5UHJvcGVydHkiLCJfZGVzY3JpcHRvcnMiLCJfaSIsImFzc2VydFVucmV2b2tlZCIsImRyYWZ0cyIsImhhc0FycmF5Q2hhbmdlcyIsImhhc09iamVjdENoYW5nZXMiLCJvYmplY3QiLCJfaTIiLCJtaW4iLCJNYXRoIiwiX2kzIiwiYmFzZVZhbHVlIiwiX3N0YXRlIiwiYmFzZUlzRHJhZnQiLCJkZXNjcmlwdG9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImVuYWJsZVBhdGNoZXMiLCJSRVBMQUNFIiwiQUREIiwiUkVNT1ZFIiwiYmFzZVBhdGgiLCJnZW5lcmF0ZVBhdGNoZXNGcm9tQXNzaWduZWQiLCJnZW5lcmF0ZUFycmF5UGF0Y2hlcyIsImdlbmVyYXRlU2V0UGF0Y2hlcyIsIl9yZWYyIiwiY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQiLCJfcGF0aCIsImFzc2lnbmVkVmFsdWUiLCJvcmlnVmFsdWUiLCJ1bnNoaWZ0IiwicmVwbGFjZW1lbnQiLCJwYXJlbnRUeXBlIiwiam9pbiIsInR5cGUiLCJkZWVwQ2xvbmVQYXRjaFZhbHVlIiwic3BsaWNlIiwibWFwIiwiZW50cmllcyIsIl9yZWYzIiwiayIsInYiLCJjbG9uZWQiLCJlbmFibGVNYXBTZXQiLCJfZXh0ZW5kU3RhdGljcyIsImV4dGVuZFN0YXRpY3MiLCJkIiwiYiIsIl9fcHJvdG9fXyIsIl9fZXh0ZW5kcyIsIl9fIiwiRHJhZnRNYXAiLCJfc3VwZXIiLCJzaXplIiwicHJlcGFyZU1hcENvcHkiLCJjYiIsInRoaXNBcmciLCJfdmFsdWUiLCJfbWFwIiwidmFsdWVzIiwibmV4dCIsInIiLCJkb25lIiwiX3RoaXMzIiwiRHJhZnRTZXQiLCJwcmVwYXJlU2V0Q29weSIsImVuYWJsZUFsbFBsdWdpbnMiLCJiaW5kIiwiY2FzdERyYWZ0IiwiY2FzdEltbXV0YWJsZSIsImRlZmF1bHQiLCJpbW1lcmFibGUiLCJub3RoaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/immer@9.0.21/node_modules/immer/dist/immer.cjs.development.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/immer@9.0.21/node_modules/immer/dist/index.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/.pnpm/immer@9.0.21/node_modules/immer/dist/index.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./immer.cjs.development.js */ \"(rsc)/../../node_modules/.pnpm/immer@9.0.21/node_modules/immer/dist/immer.cjs.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ltbWVyQDkuMC4yMS9ub2RlX21vZHVsZXMvaW1tZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFDQTtBQUVBLElBQUlBLEtBQXlCLEVBQWMsRUFFMUMsTUFBTTtJQUNMQyxzS0FBeUI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rZXlzdGF0aWMtc3RhcnRlci8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaW1tZXJAOS4wLjIxL25vZGVfbW9kdWxlcy9pbW1lci9kaXN0L2luZGV4LmpzP2QxY2IiXSwic291cmNlc0NvbnRlbnQiOlsiXG4ndXNlIHN0cmljdCdcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ltbWVyLmNqcy5wcm9kdWN0aW9uLm1pbi5qcycpXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaW1tZXIuY2pzLmRldmVsb3BtZW50LmpzJylcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/immer@9.0.21/node_modules/immer/dist/index.js\n");

/***/ })

};
;